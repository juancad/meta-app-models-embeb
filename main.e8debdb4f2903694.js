(self.webpackChunkmeta_app_models=self.webpackChunkmeta_app_models||[]).push([[179],{106:(jt,q,ne)=>{"use strict";var X={};ne.r(X),ne.d(X,{assertParamsValid:()=>g1,computeFlatOffset:()=>b1,computeOutShape:()=>y1,getNormalizedAxes:()=>NQ,isSliceContinous:()=>v1,maskToAxes:()=>EQ,parseSliceParams:()=>nv,sliceInfo:()=>x1,startForAxis:()=>KP,startIndicesWithElidedDims:()=>HP,stopForAxis:()=>XP,stopIndicesWithElidedDims:()=>jP,stridesForAxis:()=>qP,stridesWithElidedDims:()=>UP});var U={};ne.r(U),ne.d(U,{collectGatherOpShapeInfo:()=>bS,computeOutShape:()=>QM,segOpComputeOptimalWindowSize:()=>ZM});var M={};ne.r(M),ne.d(M,{ERF_A1:()=>oS,ERF_A2:()=>iS,ERF_A3:()=>aS,ERF_A4:()=>lS,ERF_A5:()=>uS,ERF_P:()=>sS,PARALLELIZE_THRESHOLD:()=>J1,RowPartitionType:()=>Mo,SELU_SCALE:()=>wv,SELU_SCALEALPHA:()=>xv,applyActivation:()=>fv,assertAndGetBroadcastShape:()=>Vt,assertAxesAreInnerMostDims:()=>Hr,assertParamsConsistent:()=>Q1,assignToTypedArray:()=>PM,axesAreInnerMostDims:()=>N1,calculateShapes:()=>ru,checkEinsumDimSizes:()=>fS,checkPadOnDimRoundingMode:()=>gs,combineLocations:()=>sM,combineRaggedTensorToTensorShapes:()=>TM,complexWithEvenIndex:()=>FM,complexWithOddIndex:()=>OM,computeConv2DInfo:()=>Mr,computeConv3DInfo:()=>ja,computeDefaultPad:()=>_1,computeDilation2DInfo:()=>Vp,computeOptimalWindowSize:()=>bv,computeOutAndReduceShapes:()=>$r,computeOutShape:()=>Ai,computePool2DInfo:()=>Ro,computePool3DInfo:()=>ca,convertConv2DDataFormat:()=>da,decodeEinsumEquation:()=>hS,eitherStridesOrDilationsAreOne:()=>Gr,expandShapeToKeepDim:()=>pr,exponent:()=>$M,exponents:()=>MM,fromStringArrayToUint8:()=>JM,fromUint8ToStringArray:()=>ga,getAxesPermutation:()=>Qn,getBroadcastDims:()=>Mc,getComplexWithIndex:()=>cS,getEinsumComputePath:()=>mS,getEinsumPermutation:()=>pS,getFusedBiasGradient:()=>pv,getFusedDyActivation:()=>hv,getImageCenter:()=>eS,getInnerMostAxes:()=>fr,getPermuted:()=>Xp,getRaggedRank:()=>EM,getReductionAxes:()=>Dr,getReshaped:()=>Kp,getReshapedPermuted:()=>Yp,getRowPartitionTypesHelper:()=>kM,getSliceBeginCoords:()=>tS,getSliceSize:()=>nS,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>BM,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>zM,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>UM,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>HM,getSparseReshapeInputOutputMismatchErrorMessage:()=>qM,getSparseReshapeInputOutputMultipleErrorMessage:()=>jM,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>WM,getSparseReshapeNegativeOutputDimErrorMessage:()=>GM,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>YM,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>vS,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>KM,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>XM,getUndoAxesPermutation:()=>Ka,isIdentityPermutation:()=>gS,log:()=>qY,mergeRealAndImagArrays:()=>ma,prepareAndValidate:()=>rS,prepareSplitSize:()=>yS,segment_util:()=>U,shouldFuse:()=>mv,slice_util:()=>X,splitRealAndImagArrays:()=>RM,stridesOrDilationsArePositive:()=>Ql,tupleValuesAreOne:()=>qa,upcastType:()=>Ws,validateDefaultValueShape:()=>NM,validateInput:()=>Tne,validateUpdateShape:()=>AM,warn:()=>lo});var F={};function P(t){return"function"==typeof t}function G(t){const e=t(r=>{Error.call(r),r.stack=(new Error).stack});return e.prototype=Object.create(Error.prototype),e.prototype.constructor=e,e}ne.r(F),ne.d(F,{addImpl:()=>DV,bincountImpl:()=>II,bincountReduceImpl:()=>RV,castImpl:()=>IV,ceilImpl:()=>FV,concatImpl:()=>OV,equalImpl:()=>$V,expImpl:()=>VV,expm1Impl:()=>zV,floorDivImpl:()=>HV,floorImpl:()=>GV,gatherNdImpl:()=>jV,gatherV2Impl:()=>qV,greaterEqualImpl:()=>XV,greaterImpl:()=>KV,lessEqualImpl:()=>ZV,lessImpl:()=>YV,linSpaceImpl:()=>QV,logImpl:()=>JV,maxImpl:()=>e3,maximumImpl:()=>n3,minimumImpl:()=>r3,multiplyImpl:()=>DI,negImpl:()=>o3,notEqualImpl:()=>i3,prodImpl:()=>c3,raggedGatherImpl:()=>h3,raggedRangeImpl:()=>f3,raggedTensorToTensorImpl:()=>y3,rangeImpl:()=>v3,rsqrtImpl:()=>b3,scatterImpl:()=>pu,sigmoidImpl:()=>qle,simpleAbsImpl:()=>kV,sliceImpl:()=>AV,sparseFillEmptyRowsImpl:()=>w3,sparseReshapeImpl:()=>_3,sparseSegmentReductionImpl:()=>RI,sqrtImpl:()=>mfe,squaredDifferenceImpl:()=>C3,staticRegexReplaceImpl:()=>S3,stridedSliceImpl:()=>I3,stringNGramsImpl:()=>D3,stringSplitImpl:()=>T3,stringToHashBucketFastImpl:()=>k3,subImpl:()=>UV,tileImpl:()=>E3,topKImpl:()=>A3,transposeImpl:()=>CI,uniqueImpl:()=>F3});const j=G(t=>function(e){t(this),this.message=e?`${e.length} errors occurred during unsubscription:\n${e.map((r,s)=>`${s+1}) ${r.toString()}`).join("\n  ")}`:"",this.name="UnsubscriptionError",this.errors=e});function B(t,n){if(t){const e=t.indexOf(n);0<=e&&t.splice(e,1)}}class T{constructor(n){this.initialTeardown=n,this.closed=!1,this._parentage=null,this._finalizers=null}unsubscribe(){let n;if(!this.closed){this.closed=!0;const{_parentage:e}=this;if(e)if(this._parentage=null,Array.isArray(e))for(const o of e)o.remove(this);else e.remove(this);const{initialTeardown:r}=this;if(P(r))try{r()}catch(o){n=o instanceof j?o.errors:[o]}const{_finalizers:s}=this;if(s){this._finalizers=null;for(const o of s)try{S(o)}catch(i){n=n??[],i instanceof j?n=[...n,...i.errors]:n.push(i)}}if(n)throw new j(n)}}add(n){var e;if(n&&n!==this)if(this.closed)S(n);else{if(n instanceof T){if(n.closed||n._hasParent(this))return;n._addParent(this)}(this._finalizers=null!==(e=this._finalizers)&&void 0!==e?e:[]).push(n)}}_hasParent(n){const{_parentage:e}=this;return e===n||Array.isArray(e)&&e.includes(n)}_addParent(n){const{_parentage:e}=this;this._parentage=Array.isArray(e)?(e.push(n),e):e?[e,n]:n}_removeParent(n){const{_parentage:e}=this;e===n?this._parentage=null:Array.isArray(e)&&B(e,n)}remove(n){const{_finalizers:e}=this;e&&B(e,n),n instanceof T&&n._removeParent(this)}}T.EMPTY=(()=>{const t=new T;return t.closed=!0,t})();const I=T.EMPTY;function A(t){return t instanceof T||t&&"closed"in t&&P(t.remove)&&P(t.add)&&P(t.unsubscribe)}function S(t){P(t)?t():t.unsubscribe()}const D={onUnhandledError:null,onStoppedNotification:null,Promise:void 0,useDeprecatedSynchronousErrorHandling:!1,useDeprecatedNextContext:!1},N={setTimeout(t,n,...e){const{delegate:r}=N;return r?.setTimeout?r.setTimeout(t,n,...e):setTimeout(t,n,...e)},clearTimeout(t){const{delegate:n}=N;return(n?.clearTimeout||clearTimeout)(t)},delegate:void 0};function L(t){N.setTimeout(()=>{const{onUnhandledError:n}=D;if(!n)throw t;n(t)})}function Z(){}const ie=Se("C",void 0,void 0);function Se(t,n,e){return{kind:t,value:n,error:e}}let Te=null;function de(t){if(D.useDeprecatedSynchronousErrorHandling){const n=!Te;if(n&&(Te={errorThrown:!1,error:null}),t(),n){const{errorThrown:e,error:r}=Te;if(Te=null,e)throw r}}else t()}class me extends T{constructor(n){super(),this.isStopped=!1,n?(this.destination=n,A(n)&&n.add(this)):this.destination=Me}static create(n,e,r){return new ue(n,e,r)}next(n){this.isStopped?ut(function Fe(t){return Se("N",t,void 0)}(n),this):this._next(n)}error(n){this.isStopped?ut(function oe(t){return Se("E",void 0,t)}(n),this):(this.isStopped=!0,this._error(n))}complete(){this.isStopped?ut(ie,this):(this.isStopped=!0,this._complete())}unsubscribe(){this.closed||(this.isStopped=!0,super.unsubscribe(),this.destination=null)}_next(n){this.destination.next(n)}_error(n){try{this.destination.error(n)}finally{this.unsubscribe()}}_complete(){try{this.destination.complete()}finally{this.unsubscribe()}}}const O=Function.prototype.bind;function E(t,n){return O.call(t,n)}class _{constructor(n){this.partialObserver=n}next(n){const{partialObserver:e}=this;if(e.next)try{e.next(n)}catch(r){et(r)}}error(n){const{partialObserver:e}=this;if(e.error)try{e.error(n)}catch(r){et(r)}else et(n)}complete(){const{partialObserver:n}=this;if(n.complete)try{n.complete()}catch(e){et(e)}}}class ue extends me{constructor(n,e,r){let s;if(super(),P(n)||!n)s={next:n??void 0,error:e??void 0,complete:r??void 0};else{let o;this&&D.useDeprecatedNextContext?(o=Object.create(n),o.unsubscribe=()=>this.unsubscribe(),s={next:n.next&&E(n.next,o),error:n.error&&E(n.error,o),complete:n.complete&&E(n.complete,o)}):s=n}this.destination=new _(s)}}function et(t){D.useDeprecatedSynchronousErrorHandling?function Oe(t){D.useDeprecatedSynchronousErrorHandling&&Te&&(Te.errorThrown=!0,Te.error=t)}(t):L(t)}function ut(t,n){const{onStoppedNotification:e}=D;e&&N.setTimeout(()=>e(t,n))}const Me={closed:!0,next:Z,error:function ke(t){throw t},complete:Z},dt="function"==typeof Symbol&&Symbol.observable||"@@observable";function ce(t){return t}function ft(t){return 0===t.length?ce:1===t.length?t[0]:function(e){return t.reduce((r,s)=>s(r),e)}}let Ve=(()=>{class t{constructor(e){e&&(this._subscribe=e)}lift(e){const r=new t;return r.source=this,r.operator=e,r}subscribe(e,r,s){const o=function Ur(t){return t&&t instanceof me||function Nn(t){return t&&P(t.next)&&P(t.error)&&P(t.complete)}(t)&&A(t)}(e)?e:new ue(e,r,s);return de(()=>{const{operator:i,source:a}=this;o.add(i?i.call(o,a):a?this._subscribe(o):this._trySubscribe(o))}),o}_trySubscribe(e){try{return this._subscribe(e)}catch(r){e.error(r)}}forEach(e,r){return new(r=qe(r))((s,o)=>{const i=new ue({next:a=>{try{e(a)}catch(l){o(l),i.unsubscribe()}},error:o,complete:s});this.subscribe(i)})}_subscribe(e){var r;return null===(r=this.source)||void 0===r?void 0:r.subscribe(e)}[dt](){return this}pipe(...e){return ft(e)(this)}toPromise(e){return new(e=qe(e))((r,s)=>{let o;this.subscribe(i=>o=i,i=>s(i),()=>r(o))})}}return t.create=n=>new t(n),t})();function qe(t){var n;return null!==(n=t??D.Promise)&&void 0!==n?n:Promise}const an=G(t=>function(){t(this),this.name="ObjectUnsubscribedError",this.message="object unsubscribed"});let Zt=(()=>{class t extends Ve{constructor(){super(),this.closed=!1,this.currentObservers=null,this.observers=[],this.isStopped=!1,this.hasError=!1,this.thrownError=null}lift(e){const r=new gr(this,this);return r.operator=e,r}_throwIfClosed(){if(this.closed)throw new an}next(e){de(()=>{if(this._throwIfClosed(),!this.isStopped){this.currentObservers||(this.currentObservers=Array.from(this.observers));for(const r of this.currentObservers)r.next(e)}})}error(e){de(()=>{if(this._throwIfClosed(),!this.isStopped){this.hasError=this.isStopped=!0,this.thrownError=e;const{observers:r}=this;for(;r.length;)r.shift().error(e)}})}complete(){de(()=>{if(this._throwIfClosed(),!this.isStopped){this.isStopped=!0;const{observers:e}=this;for(;e.length;)e.shift().complete()}})}unsubscribe(){this.isStopped=this.closed=!0,this.observers=this.currentObservers=null}get observed(){var e;return(null===(e=this.observers)||void 0===e?void 0:e.length)>0}_trySubscribe(e){return this._throwIfClosed(),super._trySubscribe(e)}_subscribe(e){return this._throwIfClosed(),this._checkFinalizedStatuses(e),this._innerSubscribe(e)}_innerSubscribe(e){const{hasError:r,isStopped:s,observers:o}=this;return r||s?I:(this.currentObservers=null,o.push(e),new T(()=>{this.currentObservers=null,B(o,e)}))}_checkFinalizedStatuses(e){const{hasError:r,thrownError:s,isStopped:o}=this;r?e.error(s):o&&e.complete()}asObservable(){const e=new Ve;return e.source=this,e}}return t.create=(n,e)=>new gr(n,e),t})();class gr extends Zt{constructor(n,e){super(),this.destination=n,this.source=e}next(n){var e,r;null===(r=null===(e=this.destination)||void 0===e?void 0:e.next)||void 0===r||r.call(e,n)}error(n){var e,r;null===(r=null===(e=this.destination)||void 0===e?void 0:e.error)||void 0===r||r.call(e,n)}complete(){var n,e;null===(e=null===(n=this.destination)||void 0===n?void 0:n.complete)||void 0===e||e.call(n)}_subscribe(n){var e,r;return null!==(r=null===(e=this.source)||void 0===e?void 0:e.subscribe(n))&&void 0!==r?r:I}}function Xn(t){return P(t?.lift)}function In(t){return n=>{if(Xn(n))return n.lift(function(e){try{return t(e,this)}catch(r){this.error(r)}});throw new TypeError("Unable to lift unknown Observable type")}}function vn(t,n,e,r,s){return new C(t,n,e,r,s)}class C extends me{constructor(n,e,r,s,o,i){super(n),this.onFinalize=o,this.shouldUnsubscribe=i,this._next=e?function(a){try{e(a)}catch(l){n.error(l)}}:super._next,this._error=s?function(a){try{s(a)}catch(l){n.error(l)}finally{this.unsubscribe()}}:super._error,this._complete=r?function(){try{r()}catch(a){n.error(a)}finally{this.unsubscribe()}}:super._complete}unsubscribe(){var n;if(!this.shouldUnsubscribe||this.shouldUnsubscribe()){const{closed:e}=this;super.unsubscribe(),!e&&(null===(n=this.onFinalize)||void 0===n||n.call(this))}}}function ye(t,n){return In((e,r)=>{let s=0;e.subscribe(vn(r,o=>{r.next(t.call(n,o,s++))}))})}function Kr(t){return this instanceof Kr?(this.v=t,this):new Kr(t)}function Ib(t){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var e,n=t[Symbol.asyncIterator];return n?n.call(t):(t=function Xs(t){var n="function"==typeof Symbol&&Symbol.iterator,e=n&&t[n],r=0;if(e)return e.call(t);if(t&&"number"==typeof t.length)return{next:function(){return t&&r>=t.length&&(t=void 0),{value:t&&t[r++],done:!t}}};throw new TypeError(n?"Object is not iterable.":"Symbol.iterator is not defined.")}(t),e={},r("next"),r("throw"),r("return"),e[Symbol.asyncIterator]=function(){return this},e);function r(o){e[o]=t[o]&&function(i){return new Promise(function(a,l){!function s(o,i,a,l){Promise.resolve(l).then(function(u){o({value:u,done:a})},i)}(a,l,(i=t[o](i)).done,i.value)})}}}const eD=t=>t&&"number"==typeof t.length&&"function"!=typeof t;function tD(t){return P(t?.then)}function nD(t){return P(t[dt])}function rD(t){return Symbol.asyncIterator&&P(t?.[Symbol.asyncIterator])}function sD(t){return new TypeError(`You provided ${null!==t&&"object"==typeof t?"an invalid object":`'${t}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`)}const oD=function nz(){return"function"==typeof Symbol&&Symbol.iterator?Symbol.iterator:"@@iterator"}();function iD(t){return P(t?.[oD])}function aD(t){return function kf(t,n,e){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var s,r=e.apply(t,n||[]),o=[];return s={},i("next"),i("throw"),i("return"),s[Symbol.asyncIterator]=function(){return this},s;function i(h){r[h]&&(s[h]=function(p){return new Promise(function(f,g){o.push([h,p,f,g])>1||a(h,p)})})}function a(h,p){try{!function l(h){h.value instanceof Kr?Promise.resolve(h.value.v).then(u,c):d(o[0][2],h)}(r[h](p))}catch(f){d(o[0][3],f)}}function u(h){a("next",h)}function c(h){a("throw",h)}function d(h,p){h(p),o.shift(),o.length&&a(o[0][0],o[0][1])}}(this,arguments,function*(){const e=t.getReader();try{for(;;){const{value:r,done:s}=yield Kr(e.read());if(s)return yield Kr(void 0);yield yield Kr(r)}}finally{e.releaseLock()}})}function lD(t){return P(t?.getReader)}function vo(t){if(t instanceof Ve)return t;if(null!=t){if(nD(t))return function rz(t){return new Ve(n=>{const e=t[dt]();if(P(e.subscribe))return e.subscribe(n);throw new TypeError("Provided object does not correctly implement Symbol.observable")})}(t);if(eD(t))return function sz(t){return new Ve(n=>{for(let e=0;e<t.length&&!n.closed;e++)n.next(t[e]);n.complete()})}(t);if(tD(t))return function oz(t){return new Ve(n=>{t.then(e=>{n.closed||(n.next(e),n.complete())},e=>n.error(e)).then(null,L)})}(t);if(rD(t))return uD(t);if(iD(t))return function iz(t){return new Ve(n=>{for(const e of t)if(n.next(e),n.closed)return;n.complete()})}(t);if(lD(t))return function az(t){return uD(aD(t))}(t)}throw sD(t)}function uD(t){return new Ve(n=>{(function lz(t,n){var e,r,s,o;return function An(t,n,e,r){return new(e||(e=Promise))(function(o,i){function a(c){try{u(r.next(c))}catch(d){i(d)}}function l(c){try{u(r.throw(c))}catch(d){i(d)}}function u(c){c.done?o(c.value):function s(o){return o instanceof e?o:new e(function(i){i(o)})}(c.value).then(a,l)}u((r=r.apply(t,n||[])).next())})}(this,void 0,void 0,function*(){try{for(e=Ib(t);!(r=yield e.next()).done;)if(n.next(r.value),n.closed)return}catch(i){s={error:i}}finally{try{r&&!r.done&&(o=e.return)&&(yield o.call(e))}finally{if(s)throw s.error}}n.complete()})})(t,n).catch(e=>n.error(e))})}function Ui(t,n,e,r=0,s=!1){const o=n.schedule(function(){e(),s?t.add(this.schedule(null,r)):this.unsubscribe()},r);if(t.add(o),!s)return o}function Xr(t,n,e=1/0){return P(n)?Xr((r,s)=>ye((o,i)=>n(r,o,s,i))(vo(t(r,s))),e):("number"==typeof n&&(e=n),In((r,s)=>function uz(t,n,e,r,s,o,i,a){const l=[];let u=0,c=0,d=!1;const h=()=>{d&&!l.length&&!u&&n.complete()},p=g=>u<r?f(g):l.push(g),f=g=>{o&&n.next(g),u++;let m=!1;vo(e(g,c++)).subscribe(vn(n,y=>{s?.(y),o?p(y):n.next(y)},()=>{m=!0},void 0,()=>{if(m)try{for(u--;l.length&&u<r;){const y=l.shift();i?Ui(n,i,()=>f(y)):f(y)}h()}catch(y){n.error(y)}}))};return t.subscribe(vn(n,p,()=>{d=!0,h()})),()=>{a?.()}}(r,s,t,e)))}function _u(t=1/0){return Xr(ce,t)}const di=new Ve(t=>t.complete());function Db(t){return t[t.length-1]}function cD(t){return P(Db(t))?t.pop():void 0}function pd(t){return function dz(t){return t&&P(t.schedule)}(Db(t))?t.pop():void 0}function dD(t,n=0){return In((e,r)=>{e.subscribe(vn(r,s=>Ui(r,t,()=>r.next(s),n),()=>Ui(r,t,()=>r.complete(),n),s=>Ui(r,t,()=>r.error(s),n)))})}function hD(t,n=0){return In((e,r)=>{r.add(t.schedule(()=>e.subscribe(r),n))})}function pD(t,n){if(!t)throw new Error("Iterable cannot be null");return new Ve(e=>{Ui(e,n,()=>{const r=t[Symbol.asyncIterator]();Ui(e,n,()=>{r.next().then(s=>{s.done?e.complete():e.next(s.value)})},0,!0)})})}function _r(t,n){return n?function vz(t,n){if(null!=t){if(nD(t))return function pz(t,n){return vo(t).pipe(hD(n),dD(n))}(t,n);if(eD(t))return function mz(t,n){return new Ve(e=>{let r=0;return n.schedule(function(){r===t.length?e.complete():(e.next(t[r++]),e.closed||this.schedule())})})}(t,n);if(tD(t))return function fz(t,n){return vo(t).pipe(hD(n),dD(n))}(t,n);if(rD(t))return pD(t,n);if(iD(t))return function gz(t,n){return new Ve(e=>{let r;return Ui(e,n,()=>{r=t[oD](),Ui(e,n,()=>{let s,o;try{({value:s,done:o}=r.next())}catch(i){return void e.error(i)}o?e.complete():e.next(s)},0,!0)}),()=>P(r?.return)&&r.return()})}(t,n);if(lD(t))return function yz(t,n){return pD(aD(t),n)}(t,n)}throw sD(t)}(t,n):vo(t)}function Tb(t,n,...e){if(!0===n)return void t();if(!1===n)return;const r=new ue({next:()=>{r.unsubscribe(),t()}});return vo(n(...e)).subscribe(r)}function Fn(t){for(let n in t)if(t[n]===Fn)return n;throw Error("Could not find renamed property on target object.")}function kb(t,n){for(const e in n)n.hasOwnProperty(e)&&!t.hasOwnProperty(e)&&(t[e]=n[e])}function Bn(t){if("string"==typeof t)return t;if(Array.isArray(t))return"["+t.map(Bn).join(", ")+"]";if(null==t)return""+t;if(t.overriddenName)return`${t.overriddenName}`;if(t.name)return`${t.name}`;const n=t.toString();if(null==n)return""+n;const e=n.indexOf("\n");return-1===e?n:n.substring(0,e)}function Eb(t,n){return null==t||""===t?null===n?"":n:null==n||""===n?t:t+" "+n}const wz=Fn({__forward_ref__:Fn});function zn(t){return t.__forward_ref__=zn,t.toString=function(){return Bn(this())},t}function Ft(t){return Nb(t)?t():t}function Nb(t){return"function"==typeof t&&t.hasOwnProperty(wz)&&t.__forward_ref__===zn}function Ab(t){return t&&!!t.\u0275providers}class Xe extends Error{constructor(n,e){super(Nf(n,e)),this.code=n}}function Nf(t,n){return`NG0${Math.abs(t)}${n?": "+n.trim():""}`}function Bt(t){return"string"==typeof t?t:null==t?"":String(t)}function Af(t,n){throw new Xe(-201,!1)}function bo(t,n){null==t&&function wn(t,n,e,r){throw new Error(`ASSERTION ERROR: ${t}`+(null==r?"":` [Expected=> ${e} ${r} ${n} <=Actual]`))}(n,t,null,"!=")}function kt(t){return{token:t.token,providedIn:t.providedIn||null,factory:t.factory,value:void 0}}function Zs(t){return{providers:t.providers||[],imports:t.imports||[]}}function Rf(t){return mD(t,Ff)||mD(t,yD)}function mD(t,n){return t.hasOwnProperty(n)?t[n]:null}function gD(t){return t&&(t.hasOwnProperty(Rb)||t.hasOwnProperty(Nz))?t[Rb]:null}const Ff=Fn({\u0275prov:Fn}),Rb=Fn({\u0275inj:Fn}),yD=Fn({ngInjectableDef:Fn}),Nz=Fn({ngInjectorDef:Fn});var Ot=(()=>((Ot=Ot||{})[Ot.Default=0]="Default",Ot[Ot.Host=1]="Host",Ot[Ot.Self=2]="Self",Ot[Ot.SkipSelf=4]="SkipSelf",Ot[Ot.Optional=8]="Optional",Ot))();let Fb;function xo(t){const n=Fb;return Fb=t,n}function vD(t,n,e){const r=Rf(t);return r&&"root"==r.providedIn?void 0===r.value?r.value=r.factory():r.value:e&Ot.Optional?null:void 0!==n?n:void Af(Bn(t))}const Wn=(()=>typeof globalThis<"u"&&globalThis||typeof global<"u"&&global||typeof window<"u"&&window||typeof self<"u"&&typeof WorkerGlobalScope<"u"&&self instanceof WorkerGlobalScope&&self)(),fd={},Ob="__NG_DI_FLAG__",Of="ngTempTokenPath",Rz="ngTokenPath",Fz=/\n/gm,Oz="\u0275",bD="__source";let md;function Cu(t){const n=md;return md=t,n}function Pz(t,n=Ot.Default){if(void 0===md)throw new Xe(-203,!1);return null===md?vD(t,void 0,n):md.get(t,n&Ot.Optional?null:void 0,n)}function Et(t,n=Ot.Default){return(function Az(){return Fb}()||Pz)(Ft(t),n)}function cn(t,n=Ot.Default){return Et(t,Pf(n))}function Pf(t){return typeof t>"u"||"number"==typeof t?t:0|(t.optional&&8)|(t.host&&1)|(t.self&&2)|(t.skipSelf&&4)}function Pb(t){const n=[];for(let e=0;e<t.length;e++){const r=Ft(t[e]);if(Array.isArray(r)){if(0===r.length)throw new Xe(900,!1);let s,o=Ot.Default;for(let i=0;i<r.length;i++){const a=r[i],l=Mz(a);"number"==typeof l?-1===l?s=a.token:o|=l:s=a}n.push(Et(s,o))}else n.push(Et(r))}return n}function gd(t,n){return t[Ob]=n,t.prototype[Ob]=n,t}function Mz(t){return t[Ob]}function Wi(t){return{toString:t}.toString()}var hi=(()=>((hi=hi||{})[hi.OnPush=0]="OnPush",hi[hi.Default=1]="Default",hi))(),pi=(()=>{return(t=pi||(pi={}))[t.Emulated=0]="Emulated",t[t.None=2]="None",t[t.ShadowDom=3]="ShadowDom",pi;var t})();const Gi={},bn=[],Mf=Fn({\u0275cmp:Fn}),Mb=Fn({\u0275dir:Fn}),$b=Fn({\u0275pipe:Fn}),wD=Fn({\u0275mod:Fn}),Hi=Fn({\u0275fac:Fn}),yd=Fn({__NG_ELEMENT_ID__:Fn});let Vz=0;function yl(t){return Wi(()=>{const n=CD(t),e={...n,decls:t.decls,vars:t.vars,template:t.template,consts:t.consts||null,ngContentSelectors:t.ngContentSelectors,onPush:t.changeDetection===hi.OnPush,directiveDefs:null,pipeDefs:null,dependencies:n.standalone&&t.dependencies||null,getStandaloneInjector:null,data:t.data||{},encapsulation:t.encapsulation||pi.Emulated,id:"c"+Vz++,styles:t.styles||bn,_:null,schemas:t.schemas||null,tView:null};SD(e);const r=t.dependencies;return e.directiveDefs=$f(r,!1),e.pipeDefs=$f(r,!0),e})}function zz(t){return _n(t)||os(t)}function Uz(t){return null!==t}function wo(t){return Wi(()=>({type:t.type,bootstrap:t.bootstrap||bn,declarations:t.declarations||bn,imports:t.imports||bn,exports:t.exports||bn,transitiveCompileScopes:null,schemas:t.schemas||null,id:t.id||null}))}function _D(t,n){if(null==t)return Gi;const e={};for(const r in t)if(t.hasOwnProperty(r)){let s=t[r],o=s;Array.isArray(s)&&(o=s[1],s=s[0]),e[s]=r,n&&(n[s]=o)}return e}function Pt(t){return Wi(()=>{const n=CD(t);return SD(n),n})}function _n(t){return t[Mf]||null}function os(t){return t[Mb]||null}function Ls(t){return t[$b]||null}function Qs(t,n){const e=t[wD]||null;if(!e&&!0===n)throw new Error(`Type ${Bn(t)} does not have '\u0275mod' property.`);return e}function CD(t){const n={};return{type:t.type,providersResolver:null,factory:null,hostBindings:t.hostBindings||null,hostVars:t.hostVars||0,hostAttrs:t.hostAttrs||null,contentQueries:t.contentQueries||null,declaredInputs:n,exportAs:t.exportAs||null,standalone:!0===t.standalone,selectors:t.selectors||bn,viewQuery:t.viewQuery||null,features:t.features||null,setInput:null,findHostDirectiveDefs:null,hostDirectives:null,inputs:_D(t.inputs,n),outputs:_D(t.outputs)}}function SD(t){t.features?.forEach(n=>n(t))}function $f(t,n){if(!t)return null;const e=n?Ls:zz;return()=>("function"==typeof t?t():t).map(r=>e(r)).filter(Uz)}const ji=0,ht=1,qt=2,ir=3,Uo=4,vl=5,is=6,Iu=7,yr=8,Lf=9,Vf=10,Qt=11,Lb=12,vd=13,ID=14,Du=15,as=16,bd=17,Tu=18,fi=19,xd=20,DD=21,Gn=22,Vb=1,TD=2,Bf=7,zf=8,ku=9,Cs=10;function Js(t){return Array.isArray(t)&&"object"==typeof t[Vb]}function Wo(t){return Array.isArray(t)&&!0===t[Vb]}function Bb(t){return 0!=(4&t.flags)}function wd(t){return t.componentOffset>-1}function Uf(t){return 1==(1&t.flags)}function Go(t){return!!t.template}function Gz(t){return 0!=(256&t[qt])}function bl(t,n){return t.hasOwnProperty(Hi)?t[Hi]:null}class qz{constructor(n,e,r){this.previousValue=n,this.currentValue=e,this.firstChange=r}isFirstChange(){return this.firstChange}}function eo(){return ND}function ND(t){return t.type.prototype.ngOnChanges&&(t.setInput=Xz),Kz}function Kz(){const t=RD(this),n=t?.current;if(n){const e=t.previous;if(e===Gi)t.previous=n;else for(let r in n)e[r]=n[r];t.current=null,this.ngOnChanges(n)}}function Xz(t,n,e,r){const s=this.declaredInputs[e],o=RD(t)||function Yz(t,n){return t[AD]=n}(t,{previous:Gi,current:null}),i=o.current||(o.current={}),a=o.previous,l=a[s];i[s]=new qz(l&&l.currentValue,n,a===Gi),t[r]=n}eo.ngInherit=!0;const AD="__ngSimpleChanges__";function RD(t){return t[AD]||null}const _o=function(t,n,e){},FD="svg";function Yr(t){for(;Array.isArray(t);)t=t[ji];return t}function Wf(t,n){return Yr(n[t])}function to(t,n){return Yr(n[t.index])}function PD(t,n){return t.data[n]}function no(t,n){const e=n[t];return Js(e)?e:e[ji]}function Gf(t){return 64==(64&t[qt])}function _a(t,n){return null==n?null:t[n]}function MD(t){t[Tu]=0}function Ub(t,n){t[vl]+=n;let e=t,r=t[ir];for(;null!==r&&(1===n&&1===e[vl]||-1===n&&0===e[vl]);)r[vl]+=n,e=r,r=r[ir]}const zt={lFrame:jD(null),bindingsEnabled:!0};function LD(){return zt.bindingsEnabled}function Le(){return zt.lFrame.lView}function fn(){return zt.lFrame.tView}function St(t){return zt.lFrame.contextLView=t,t[yr]}function It(t){return zt.lFrame.contextLView=null,t}function Zr(){let t=VD();for(;null!==t&&64===t.type;)t=t.parent;return t}function VD(){return zt.lFrame.currentTNode}function mi(t,n){const e=zt.lFrame;e.currentTNode=t,e.isParent=n}function Wb(){return zt.lFrame.isParent}function Gb(){zt.lFrame.isParent=!1}function Ss(){const t=zt.lFrame;let n=t.bindingRootIndex;return-1===n&&(n=t.bindingRootIndex=t.tView.bindingStartIndex),n}function Nu(){return zt.lFrame.bindingIndex++}function Ki(t){const n=zt.lFrame,e=n.bindingIndex;return n.bindingIndex=n.bindingIndex+t,e}function uU(t,n){const e=zt.lFrame;e.bindingIndex=e.bindingRootIndex=t,Hb(n)}function Hb(t){zt.lFrame.currentDirectiveIndex=t}function WD(){return zt.lFrame.currentQueryIndex}function qb(t){zt.lFrame.currentQueryIndex=t}function dU(t){const n=t[ht];return 2===n.type?n.declTNode:1===n.type?t[is]:null}function GD(t,n,e){if(e&Ot.SkipSelf){let s=n,o=t;for(;!(s=s.parent,null!==s||e&Ot.Host||(s=dU(o),null===s||(o=o[Du],10&s.type))););if(null===s)return!1;n=s,t=o}const r=zt.lFrame=HD();return r.currentTNode=n,r.lView=t,!0}function Kb(t){const n=HD(),e=t[ht];zt.lFrame=n,n.currentTNode=e.firstChild,n.lView=t,n.tView=e,n.contextLView=t,n.bindingIndex=e.bindingStartIndex,n.inI18n=!1}function HD(){const t=zt.lFrame,n=null===t?null:t.child;return null===n?jD(t):n}function jD(t){const n={currentTNode:null,isParent:!0,lView:null,tView:null,selectedIndex:-1,contextLView:null,elementDepthCount:0,currentNamespace:null,currentDirectiveIndex:-1,bindingRootIndex:-1,bindingIndex:-1,currentQueryIndex:0,parent:t,child:null,inI18n:!1};return null!==t&&(t.child=n),n}function qD(){const t=zt.lFrame;return zt.lFrame=t.parent,t.currentTNode=null,t.lView=null,t}const KD=qD;function Xb(){const t=qD();t.isParent=!0,t.tView=null,t.selectedIndex=-1,t.contextLView=null,t.elementDepthCount=0,t.currentDirectiveIndex=-1,t.currentNamespace=null,t.bindingRootIndex=-1,t.bindingIndex=-1,t.currentQueryIndex=0}function Is(){return zt.lFrame.selectedIndex}function xl(t){zt.lFrame.selectedIndex=t}function Hf(t,n){for(let e=n.directiveStart,r=n.directiveEnd;e<r;e++){const o=t.data[e].type.prototype,{ngAfterContentInit:i,ngAfterContentChecked:a,ngAfterViewInit:l,ngAfterViewChecked:u,ngOnDestroy:c}=o;i&&(t.contentHooks||(t.contentHooks=[])).push(-e,i),a&&((t.contentHooks||(t.contentHooks=[])).push(e,a),(t.contentCheckHooks||(t.contentCheckHooks=[])).push(e,a)),l&&(t.viewHooks||(t.viewHooks=[])).push(-e,l),u&&((t.viewHooks||(t.viewHooks=[])).push(e,u),(t.viewCheckHooks||(t.viewCheckHooks=[])).push(e,u)),null!=c&&(t.destroyHooks||(t.destroyHooks=[])).push(e,c)}}function jf(t,n,e){YD(t,n,3,e)}function qf(t,n,e,r){(3&t[qt])===e&&YD(t,n,e,r)}function Yb(t,n){let e=t[qt];(3&e)===n&&(e&=2047,e+=1,t[qt]=e)}function YD(t,n,e,r){const o=r??-1,i=n.length-1;let a=0;for(let l=void 0!==r?65535&t[Tu]:0;l<i;l++)if("number"==typeof n[l+1]){if(a=n[l],null!=r&&a>=r)break}else n[l]<0&&(t[Tu]+=65536),(a<o||-1==o)&&(bU(t,e,n,l),t[Tu]=(4294901760&t[Tu])+l+2),l++}function bU(t,n,e,r){const s=e[r]<0,o=e[r+1],a=t[s?-e[r]:e[r]];if(s){if(t[qt]>>11<t[Tu]>>16&&(3&t[qt])===n){t[qt]+=2048,_o(4,a,o);try{o.call(a)}finally{_o(5,a,o)}}}else{_o(4,a,o);try{o.call(a)}finally{_o(5,a,o)}}}const Au=-1;class Cd{constructor(n,e,r){this.factory=n,this.resolving=!1,this.canSeeViewProviders=e,this.injectImpl=r}}function Qb(t,n,e){let r=0;for(;r<e.length;){const s=e[r];if("number"==typeof s){if(0!==s)break;r++;const o=e[r++],i=e[r++],a=e[r++];t.setAttribute(n,i,a,o)}else{const o=s,i=e[++r];QD(o)?t.setProperty(n,o,i):t.setAttribute(n,o,i),r++}}return r}function ZD(t){return 3===t||4===t||6===t}function QD(t){return 64===t.charCodeAt(0)}function Sd(t,n){if(null!==n&&0!==n.length)if(null===t||0===t.length)t=n.slice();else{let e=-1;for(let r=0;r<n.length;r++){const s=n[r];"number"==typeof s?e=s:0===e||JD(t,e,s,null,-1===e||2===e?n[++r]:null)}}return t}function JD(t,n,e,r,s){let o=0,i=t.length;if(-1===n)i=-1;else for(;o<t.length;){const a=t[o++];if("number"==typeof a){if(a===n){i=-1;break}if(a>n){i=o-1;break}}}for(;o<t.length;){const a=t[o];if("number"==typeof a)break;if(a===e){if(null===r)return void(null!==s&&(t[o+1]=s));if(r===t[o+1])return void(t[o+2]=s)}o++,null!==r&&o++,null!==s&&o++}-1!==i&&(t.splice(i,0,n),o=i+1),t.splice(o++,0,e),null!==r&&t.splice(o++,0,r),null!==s&&t.splice(o++,0,s)}function eT(t){return t!==Au}function Kf(t){return 32767&t}function Xf(t,n){let e=function CU(t){return t>>16}(t),r=n;for(;e>0;)r=r[Du],e--;return r}let Jb=!0;function Yf(t){const n=Jb;return Jb=t,n}const tT=255,nT=5;let SU=0;const gi={};function Zf(t,n){const e=rT(t,n);if(-1!==e)return e;const r=n[ht];r.firstCreatePass&&(t.injectorIndex=n.length,e0(r.data,t),e0(n,null),e0(r.blueprint,null));const s=t0(t,n),o=t.injectorIndex;if(eT(s)){const i=Kf(s),a=Xf(s,n),l=a[ht].data;for(let u=0;u<8;u++)n[o+u]=a[i+u]|l[i+u]}return n[o+8]=s,o}function e0(t,n){t.push(0,0,0,0,0,0,0,0,n)}function rT(t,n){return-1===t.injectorIndex||t.parent&&t.parent.injectorIndex===t.injectorIndex||null===n[t.injectorIndex+8]?-1:t.injectorIndex}function t0(t,n){if(t.parent&&-1!==t.parent.injectorIndex)return t.parent.injectorIndex;let e=0,r=null,s=n;for(;null!==s;){if(r=cT(s),null===r)return Au;if(e++,s=s[Du],-1!==r.injectorIndex)return r.injectorIndex|e<<16}return Au}function n0(t,n,e){!function IU(t,n,e){let r;"string"==typeof e?r=e.charCodeAt(0)||0:e.hasOwnProperty(yd)&&(r=e[yd]),null==r&&(r=e[yd]=SU++);const s=r&tT;n.data[t+(s>>nT)]|=1<<s}(t,n,e)}function sT(t,n,e){if(e&Ot.Optional||void 0!==t)return t;Af()}function oT(t,n,e,r){if(e&Ot.Optional&&void 0===r&&(r=null),!(e&(Ot.Self|Ot.Host))){const s=t[Lf],o=xo(void 0);try{return s?s.get(n,r,e&Ot.Optional):vD(n,r,e&Ot.Optional)}finally{xo(o)}}return sT(r,0,e)}function iT(t,n,e,r=Ot.Default,s){if(null!==t){if(1024&n[qt]){const i=function NU(t,n,e,r,s){let o=t,i=n;for(;null!==o&&null!==i&&1024&i[qt]&&!(256&i[qt]);){const a=aT(o,i,e,r|Ot.Self,gi);if(a!==gi)return a;let l=o.parent;if(!l){const u=i[DD];if(u){const c=u.get(e,gi,r);if(c!==gi)return c}l=cT(i),i=i[Du]}o=l}return s}(t,n,e,r,gi);if(i!==gi)return i}const o=aT(t,n,e,r,gi);if(o!==gi)return o}return oT(n,e,r,s)}function aT(t,n,e,r,s){const o=function kU(t){if("string"==typeof t)return t.charCodeAt(0)||0;const n=t.hasOwnProperty(yd)?t[yd]:void 0;return"number"==typeof n?n>=0?n&tT:EU:n}(e);if("function"==typeof o){if(!GD(n,t,r))return r&Ot.Host?sT(s,0,r):oT(n,e,r,s);try{const i=o(r);if(null!=i||r&Ot.Optional)return i;Af()}finally{KD()}}else if("number"==typeof o){let i=null,a=rT(t,n),l=Au,u=r&Ot.Host?n[as][is]:null;for((-1===a||r&Ot.SkipSelf)&&(l=-1===a?t0(t,n):n[a+8],l!==Au&&uT(r,!1)?(i=n[ht],a=Kf(l),n=Xf(l,n)):a=-1);-1!==a;){const c=n[ht];if(lT(o,a,c.data)){const d=TU(a,n,e,i,r,u);if(d!==gi)return d}l=n[a+8],l!==Au&&uT(r,n[ht].data[a+8]===u)&&lT(o,a,n)?(i=c,a=Kf(l),n=Xf(l,n)):a=-1}}return s}function TU(t,n,e,r,s,o){const i=n[ht],a=i.data[t+8],c=Qf(a,i,e,null==r?wd(a)&&Jb:r!=i&&0!=(3&a.type),s&Ot.Host&&o===a);return null!==c?wl(n,i,c,a):gi}function Qf(t,n,e,r,s){const o=t.providerIndexes,i=n.data,a=1048575&o,l=t.directiveStart,c=o>>20,h=s?a+c:t.directiveEnd;for(let p=r?a:a+c;p<h;p++){const f=i[p];if(p<l&&e===f||p>=l&&f.type===e)return p}if(s){const p=i[l];if(p&&Go(p)&&p.type===e)return l}return null}function wl(t,n,e,r){let s=t[e];const o=n.data;if(function xU(t){return t instanceof Cd}(s)){const i=s;i.resolving&&function _z(t,n){const e=n?`. Dependency path: ${n.join(" > ")} > ${t}`:"";throw new Xe(-200,`Circular dependency in DI detected for ${t}${e}`)}(function xn(t){return"function"==typeof t?t.name||t.toString():"object"==typeof t&&null!=t&&"function"==typeof t.type?t.type.name||t.type.toString():Bt(t)}(o[e]));const a=Yf(i.canSeeViewProviders);i.resolving=!0;const l=i.injectImpl?xo(i.injectImpl):null;GD(t,r,Ot.Default);try{s=t[e]=i.factory(void 0,o,t,r),n.firstCreatePass&&e>=r.directiveStart&&function vU(t,n,e){const{ngOnChanges:r,ngOnInit:s,ngDoCheck:o}=n.type.prototype;if(r){const i=ND(n);(e.preOrderHooks||(e.preOrderHooks=[])).push(t,i),(e.preOrderCheckHooks||(e.preOrderCheckHooks=[])).push(t,i)}s&&(e.preOrderHooks||(e.preOrderHooks=[])).push(0-t,s),o&&((e.preOrderHooks||(e.preOrderHooks=[])).push(t,o),(e.preOrderCheckHooks||(e.preOrderCheckHooks=[])).push(t,o))}(e,o[e],n)}finally{null!==l&&xo(l),Yf(a),i.resolving=!1,KD()}}return s}function lT(t,n,e){return!!(e[n+(t>>nT)]&1<<t)}function uT(t,n){return!(t&Ot.Self||t&Ot.Host&&n)}class Ru{constructor(n,e){this._tNode=n,this._lView=e}get(n,e,r){return iT(this._tNode,this._lView,n,Pf(r),e)}}function EU(){return new Ru(Zr(),Le())}function Qr(t){return Wi(()=>{const n=t.prototype.constructor,e=n[Hi]||r0(n),r=Object.prototype;let s=Object.getPrototypeOf(t.prototype).constructor;for(;s&&s!==r;){const o=s[Hi]||r0(s);if(o&&o!==e)return o;s=Object.getPrototypeOf(s)}return o=>new o})}function r0(t){return Nb(t)?()=>{const n=r0(Ft(t));return n&&n()}:bl(t)}function cT(t){const n=t[ht],e=n.type;return 2===e?n.declTNode:1===e?t[is]:null}const Ou="__parameters__";function Mu(t,n,e){return Wi(()=>{const r=function s0(t){return function(...e){if(t){const r=t(...e);for(const s in r)this[s]=r[s]}}}(n);function s(...o){if(this instanceof s)return r.apply(this,o),this;const i=new s(...o);return a.annotation=i,a;function a(l,u,c){const d=l.hasOwnProperty(Ou)?l[Ou]:Object.defineProperty(l,Ou,{value:[]})[Ou];for(;d.length<=c;)d.push(null);return(d[c]=d[c]||[]).push(i),l}}return e&&(s.prototype=Object.create(e.prototype)),s.prototype.ngMetadataName=t,s.annotationCls=s,s})}class Ct{constructor(n,e){this._desc=n,this.ngMetadataName="InjectionToken",this.\u0275prov=void 0,"number"==typeof e?this.__NG_ELEMENT_ID__=e:void 0!==e&&(this.\u0275prov=kt({token:this,providedIn:e.providedIn||"root",factory:e.factory}))}get multi(){return this}toString(){return`InjectionToken ${this._desc}`}}function _l(t,n){t.forEach(e=>Array.isArray(e)?_l(e,n):n(e))}function hT(t,n,e){n>=t.length?t.push(e):t.splice(n,0,e)}function em(t,n){return n>=t.length-1?t.pop():t.splice(n,1)[0]}function ro(t,n,e){let r=$u(t,n);return r>=0?t[1|r]=e:(r=~r,function OU(t,n,e,r){let s=t.length;if(s==n)t.push(e,r);else if(1===s)t.push(r,t[0]),t[0]=e;else{for(s--,t.push(t[s-1],t[s]);s>n;)t[s]=t[s-2],s--;t[n]=e,t[n+1]=r}}(t,r,n,e)),r}function a0(t,n){const e=$u(t,n);if(e>=0)return t[1|e]}function $u(t,n){return function pT(t,n,e){let r=0,s=t.length>>e;for(;s!==r;){const o=r+(s-r>>1),i=t[o<<e];if(n===i)return o<<e;i>n?s=o:r=o+1}return~(s<<e)}(t,n,1)}const kd=gd(Mu("Optional"),8),Ed=gd(Mu("SkipSelf"),4);var Vs=(()=>((Vs=Vs||{})[Vs.Important=1]="Important",Vs[Vs.DashCase=2]="DashCase",Vs))();const p0=new Map;let n4=0;const m0="__ngContext__";function ls(t,n){Js(n)?(t[m0]=n[xd],function s4(t){p0.set(t[xd],t)}(n)):t[m0]=n}let g0;function y0(t,n){return g0(t,n)}function Fd(t){const n=t[ir];return Wo(n)?n[ir]:n}function v0(t){return FT(t[vd])}function b0(t){return FT(t[Uo])}function FT(t){for(;null!==t&&!Wo(t);)t=t[Uo];return t}function Vu(t,n,e,r,s){if(null!=r){let o,i=!1;Wo(r)?o=r:Js(r)&&(i=!0,r=r[ji]);const a=Yr(r);0===t&&null!==e?null==s?VT(n,e,a):Cl(n,e,a,s||null,!0):1===t&&null!==e?Cl(n,e,a,s||null,!0):2===t?function D0(t,n,e){const r=sm(t,n);r&&function S4(t,n,e,r){t.removeChild(n,e,r)}(t,r,n,e)}(n,a,i):3===t&&n.destroyNode(a),null!=o&&function T4(t,n,e,r,s){const o=e[Bf];o!==Yr(e)&&Vu(n,t,r,o,s);for(let a=Cs;a<e.length;a++){const l=e[a];Od(l[ht],l,t,n,r,o)}}(n,t,o,e,s)}}function w0(t,n,e){return t.createElement(n,e)}function PT(t,n){const e=t[ku],r=e.indexOf(n),s=n[ir];512&n[qt]&&(n[qt]&=-513,Ub(s,-1)),e.splice(r,1)}function _0(t,n){if(t.length<=Cs)return;const e=Cs+n,r=t[e];if(r){const s=r[bd];null!==s&&s!==t&&PT(s,r),n>0&&(t[e-1][Uo]=r[Uo]);const o=em(t,Cs+n);!function g4(t,n){Od(t,n,n[Qt],2,null,null),n[ji]=null,n[is]=null}(r[ht],r);const i=o[fi];null!==i&&i.detachView(o[ht]),r[ir]=null,r[Uo]=null,r[qt]&=-65}return r}function MT(t,n){if(!(128&n[qt])){const e=n[Qt];e.destroyNode&&Od(t,n,e,3,null,null),function b4(t){let n=t[vd];if(!n)return C0(t[ht],t);for(;n;){let e=null;if(Js(n))e=n[vd];else{const r=n[Cs];r&&(e=r)}if(!e){for(;n&&!n[Uo]&&n!==t;)Js(n)&&C0(n[ht],n),n=n[ir];null===n&&(n=t),Js(n)&&C0(n[ht],n),e=n&&n[Uo]}n=e}}(n)}}function C0(t,n){if(!(128&n[qt])){n[qt]&=-65,n[qt]|=128,function C4(t,n){let e;if(null!=t&&null!=(e=t.destroyHooks))for(let r=0;r<e.length;r+=2){const s=n[e[r]];if(!(s instanceof Cd)){const o=e[r+1];if(Array.isArray(o))for(let i=0;i<o.length;i+=2){const a=s[o[i]],l=o[i+1];_o(4,a,l);try{l.call(a)}finally{_o(5,a,l)}}else{_o(4,s,o);try{o.call(s)}finally{_o(5,s,o)}}}}}(t,n),function _4(t,n){const e=t.cleanup,r=n[Iu];let s=-1;if(null!==e)for(let o=0;o<e.length-1;o+=2)if("string"==typeof e[o]){const i=e[o+3];i>=0?r[s=i]():r[s=-i].unsubscribe(),o+=2}else{const i=r[s=e[o+1]];e[o].call(i)}if(null!==r){for(let o=s+1;o<r.length;o++)(0,r[o])();n[Iu]=null}}(t,n),1===n[ht].type&&n[Qt].destroy();const e=n[bd];if(null!==e&&Wo(n[ir])){e!==n[ir]&&PT(e,n);const r=n[fi];null!==r&&r.detachView(t)}!function o4(t){p0.delete(t[xd])}(n)}}function $T(t,n,e){return function LT(t,n,e){let r=n;for(;null!==r&&40&r.type;)r=(n=r).parent;if(null===r)return e[ji];{const{componentOffset:s}=r;if(s>-1){const{encapsulation:o}=t.data[r.directiveStart+s];if(o===pi.None||o===pi.Emulated)return null}return to(r,e)}}(t,n.parent,e)}function Cl(t,n,e,r,s){t.insertBefore(n,e,r,s)}function VT(t,n,e){t.appendChild(n,e)}function BT(t,n,e,r,s){null!==r?Cl(t,n,e,r,s):VT(t,n,e)}function sm(t,n){return t.parentNode(n)}let S0,E0,WT=function UT(t,n,e){return 40&t.type?to(t,e):null};function om(t,n,e,r){const s=$T(t,r,n),o=n[Qt],a=function zT(t,n,e){return WT(t,n,e)}(r.parent||n[is],r,n);if(null!=s)if(Array.isArray(e))for(let l=0;l<e.length;l++)BT(o,s,e[l],a,!1);else BT(o,s,e,a,!1);void 0!==S0&&S0(o,r,n,e,s)}function im(t,n){if(null!==n){const e=n.type;if(3&e)return to(n,t);if(4&e)return I0(-1,t[n.index]);if(8&e){const r=n.child;if(null!==r)return im(t,r);{const s=t[n.index];return Wo(s)?I0(-1,s):Yr(s)}}if(32&e)return y0(n,t)()||Yr(t[n.index]);{const r=HT(t,n);return null!==r?Array.isArray(r)?r[0]:im(Fd(t[as]),r):im(t,n.next)}}return null}function HT(t,n){return null!==n?t[as][is].projection[n.projection]:null}function I0(t,n){const e=Cs+t+1;if(e<n.length){const r=n[e],s=r[ht].firstChild;if(null!==s)return im(r,s)}return n[Bf]}function T0(t,n,e,r,s,o,i){for(;null!=e;){const a=r[e.index],l=e.type;if(i&&0===n&&(a&&ls(Yr(a),r),e.flags|=2),32!=(32&e.flags))if(8&l)T0(t,n,e.child,r,s,o,!1),Vu(n,t,s,a,o);else if(32&l){const u=y0(e,r);let c;for(;c=u();)Vu(n,t,s,c,o);Vu(n,t,s,a,o)}else 16&l?jT(t,n,r,e,s,o):Vu(n,t,s,a,o);e=i?e.projectionNext:e.next}}function Od(t,n,e,r,s,o){T0(e,r,t.firstChild,n,s,o,!1)}function jT(t,n,e,r,s,o){const i=e[as],l=i[is].projection[r.projection];if(Array.isArray(l))for(let u=0;u<l.length;u++)Vu(n,t,s,l[u],o);else T0(t,n,l,i[ir],s,o,!0)}function qT(t,n,e){""===e?t.removeAttribute(n,"class"):t.setAttribute(n,"class",e)}function KT(t,n,e){const{mergedAttrs:r,classes:s,styles:o}=e;null!==r&&Qb(t,n,r),null!==s&&qT(t,n,s),null!==o&&function E4(t,n,e){t.setAttribute(n,"style",e)}(t,n,o)}class JT{constructor(n){this.changingThisBreaksApplicationSecurity=n}toString(){return`SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see https://g.co/ng/security#xss)`}}function Ca(t){return t instanceof JT?t.changingThisBreaksApplicationSecurity:t}const cm=new Ct("ENVIRONMENT_INITIALIZER"),uk=new Ct("INJECTOR",-1),ck=new Ct("INJECTOR_DEF_TYPES");class dk{get(n,e=fd){if(e===fd){const r=new Error(`NullInjectorError: No provider for ${Bn(n)}!`);throw r.name="NullInjectorError",r}return e}}function nW(...t){return{\u0275providers:hk(0,t),\u0275fromNgModule:!0}}function hk(t,...n){const e=[],r=new Set;let s;return _l(n,o=>{const i=o;P0(i,e,[],r)&&(s||(s=[]),s.push(i))}),void 0!==s&&pk(s,e),e}function pk(t,n){for(let e=0;e<t.length;e++){const{providers:s}=t[e];M0(s,o=>{n.push(o)})}}function P0(t,n,e,r){if(!(t=Ft(t)))return!1;let s=null,o=gD(t);const i=!o&&_n(t);if(o||i){if(i&&!i.standalone)return!1;s=t}else{const l=t.ngModule;if(o=gD(l),!o)return!1;s=l}const a=r.has(s);if(i){if(a)return!1;if(r.add(s),i.dependencies){const l="function"==typeof i.dependencies?i.dependencies():i.dependencies;for(const u of l)P0(u,n,e,r)}}else{if(!o)return!1;{if(null!=o.imports&&!a){let u;r.add(s);try{_l(o.imports,c=>{P0(c,n,e,r)&&(u||(u=[]),u.push(c))})}finally{}void 0!==u&&pk(u,n)}if(!a){const u=bl(s)||(()=>new s);n.push({provide:s,useFactory:u,deps:bn},{provide:ck,useValue:s,multi:!0},{provide:cm,useValue:()=>Et(s),multi:!0})}const l=o.providers;null==l||a||M0(l,c=>{n.push(c)})}}return s!==t&&void 0!==t.providers}function M0(t,n){for(let e of t)Ab(e)&&(e=e.\u0275providers),Array.isArray(e)?M0(e,n):n(e)}const rW=Fn({provide:String,useValue:Fn});function $0(t){return null!==t&&"object"==typeof t&&rW in t}function Sl(t){return"function"==typeof t}const L0=new Ct("Set Injector scope."),dm={},oW={};let V0;function hm(){return void 0===V0&&(V0=new dk),V0}class Yi{}class gk extends Yi{get destroyed(){return this._destroyed}constructor(n,e,r,s){super(),this.parent=e,this.source=r,this.scopes=s,this.records=new Map,this._ngOnDestroyHooks=new Set,this._onDestroyHooks=[],this._destroyed=!1,z0(n,i=>this.processProvider(i)),this.records.set(uk,zu(void 0,this)),s.has("environment")&&this.records.set(Yi,zu(void 0,this));const o=this.records.get(L0);null!=o&&"string"==typeof o.value&&this.scopes.add(o.value),this.injectorDefTypes=new Set(this.get(ck.multi,bn,Ot.Self))}destroy(){this.assertNotDestroyed(),this._destroyed=!0;try{for(const n of this._ngOnDestroyHooks)n.ngOnDestroy();for(const n of this._onDestroyHooks)n()}finally{this.records.clear(),this._ngOnDestroyHooks.clear(),this.injectorDefTypes.clear(),this._onDestroyHooks.length=0}}onDestroy(n){this._onDestroyHooks.push(n)}runInContext(n){this.assertNotDestroyed();const e=Cu(this),r=xo(void 0);try{return n()}finally{Cu(e),xo(r)}}get(n,e=fd,r=Ot.Default){this.assertNotDestroyed(),r=Pf(r);const s=Cu(this),o=xo(void 0);try{if(!(r&Ot.SkipSelf)){let a=this.records.get(n);if(void 0===a){const l=function cW(t){return"function"==typeof t||"object"==typeof t&&t instanceof Ct}(n)&&Rf(n);a=l&&this.injectableDefInScope(l)?zu(B0(n),dm):null,this.records.set(n,a)}if(null!=a)return this.hydrate(n,a)}return(r&Ot.Self?hm():this.parent).get(n,e=r&Ot.Optional&&e===fd?null:e)}catch(i){if("NullInjectorError"===i.name){if((i[Of]=i[Of]||[]).unshift(Bn(n)),s)throw i;return function $z(t,n,e,r){const s=t[Of];throw n[bD]&&s.unshift(n[bD]),t.message=function Lz(t,n,e,r=null){t=t&&"\n"===t.charAt(0)&&t.charAt(1)==Oz?t.slice(2):t;let s=Bn(n);if(Array.isArray(n))s=n.map(Bn).join(" -> ");else if("object"==typeof n){let o=[];for(let i in n)if(n.hasOwnProperty(i)){let a=n[i];o.push(i+":"+("string"==typeof a?JSON.stringify(a):Bn(a)))}s=`{${o.join(", ")}}`}return`${e}${r?"("+r+")":""}[${s}]: ${t.replace(Fz,"\n  ")}`}("\n"+t.message,s,e,r),t[Rz]=s,t[Of]=null,t}(i,n,"R3InjectorError",this.source)}throw i}finally{xo(o),Cu(s)}}resolveInjectorInitializers(){const n=Cu(this),e=xo(void 0);try{const r=this.get(cm.multi,bn,Ot.Self);for(const s of r)s()}finally{Cu(n),xo(e)}}toString(){const n=[],e=this.records;for(const r of e.keys())n.push(Bn(r));return`R3Injector[${n.join(", ")}]`}assertNotDestroyed(){if(this._destroyed)throw new Xe(205,!1)}processProvider(n){let e=Sl(n=Ft(n))?n:Ft(n&&n.provide);const r=function aW(t){return $0(t)?zu(void 0,t.useValue):zu(yk(t),dm)}(n);if(Sl(n)||!0!==n.multi)this.records.get(e);else{let s=this.records.get(e);s||(s=zu(void 0,dm,!0),s.factory=()=>Pb(s.multi),this.records.set(e,s)),e=n,s.multi.push(n)}this.records.set(e,r)}hydrate(n,e){return e.value===dm&&(e.value=oW,e.value=e.factory()),"object"==typeof e.value&&e.value&&function uW(t){return null!==t&&"object"==typeof t&&"function"==typeof t.ngOnDestroy}(e.value)&&this._ngOnDestroyHooks.add(e.value),e.value}injectableDefInScope(n){if(!n.providedIn)return!1;const e=Ft(n.providedIn);return"string"==typeof e?"any"===e||this.scopes.has(e):this.injectorDefTypes.has(e)}}function B0(t){const n=Rf(t),e=null!==n?n.factory:bl(t);if(null!==e)return e;if(t instanceof Ct)throw new Xe(204,!1);if(t instanceof Function)return function iW(t){const n=t.length;if(n>0)throw function Td(t,n){const e=[];for(let r=0;r<t;r++)e.push(n);return e}(n,"?"),new Xe(204,!1);const e=function kz(t){const n=t&&(t[Ff]||t[yD]);return n?(function Ez(t){if(t.hasOwnProperty("name"))return t.name;(""+t).match(/^function\s*([^\s(]+)/)}(t),n):null}(t);return null!==e?()=>e.factory(t):()=>new t}(t);throw new Xe(204,!1)}function yk(t,n,e){let r;if(Sl(t)){const s=Ft(t);return bl(s)||B0(s)}if($0(t))r=()=>Ft(t.useValue);else if(function mk(t){return!(!t||!t.useFactory)}(t))r=()=>t.useFactory(...Pb(t.deps||[]));else if(function fk(t){return!(!t||!t.useExisting)}(t))r=()=>Et(Ft(t.useExisting));else{const s=Ft(t&&(t.useClass||t.provide));if(!function lW(t){return!!t.deps}(t))return bl(s)||B0(s);r=()=>new s(...Pb(t.deps))}return r}function zu(t,n,e=!1){return{factory:t,value:n,multi:e?[]:void 0}}function z0(t,n){for(const e of t)Array.isArray(e)?z0(e,n):e&&Ab(e)?z0(e.\u0275providers,n):n(e)}class dW{}class vk{}class pW{resolveComponentFactory(n){throw function hW(t){const n=Error(`No component factory found for ${Bn(t)}. Did you add it to @NgModule.entryComponents?`);return n.ngComponent=t,n}(n)}}let Uu=(()=>{class t{}return t.NULL=new pW,t})();function fW(){return Wu(Zr(),Le())}function Wu(t,n){return new us(to(t,n))}let us=(()=>{class t{constructor(e){this.nativeElement=e}}return t.__NG_ELEMENT_ID__=fW,t})();function mW(t){return t instanceof us?t.nativeElement:t}class xk{}let Zi=(()=>{class t{}return t.__NG_ELEMENT_ID__=()=>function gW(){const t=Le(),e=no(Zr().index,t);return(Js(e)?e:t)[Qt]}(),t})(),yW=(()=>{class t{}return t.\u0275prov=kt({token:t,providedIn:"root",factory:()=>null}),t})();class Ld{constructor(n){this.full=n,this.major=n.split(".")[0],this.minor=n.split(".")[1],this.patch=n.split(".").slice(2).join(".")}}const vW=new Ld("15.2.3"),U0={},W0="ngOriginalError";function G0(t){return t[W0]}class Gu{constructor(){this._console=console}handleError(n){const e=this._findOriginalError(n);this._console.error("ERROR",n),e&&this._console.error("ORIGINAL ERROR",e)}_findOriginalError(n){let e=n&&G0(n);for(;e&&G0(e);)e=G0(e);return e||null}}function wk(t){return t.ownerDocument.defaultView}function H0(t){return t.ownerDocument}function Qi(t){return t instanceof Function?t():t}function Ck(t,n,e){let r=t.length;for(;;){const s=t.indexOf(n,e);if(-1===s)return s;if(0===s||t.charCodeAt(s-1)<=32){const o=n.length;if(s+o===r||t.charCodeAt(s+o)<=32)return s}e=s+1}}const Sk="ng-template";function TW(t,n,e){let r=0;for(;r<t.length;){let s=t[r++];if(e&&"class"===s){if(s=t[r],-1!==Ck(s.toLowerCase(),n,0))return!0}else if(1===s){for(;r<t.length&&"string"==typeof(s=t[r++]);)if(s.toLowerCase()===n)return!0;return!1}}return!1}function Ik(t){return 4===t.type&&t.value!==Sk}function kW(t,n,e){return n===(4!==t.type||e?t.value:Sk)}function EW(t,n,e){let r=4;const s=t.attrs||[],o=function RW(t){for(let n=0;n<t.length;n++)if(ZD(t[n]))return n;return t.length}(s);let i=!1;for(let a=0;a<n.length;a++){const l=n[a];if("number"!=typeof l){if(!i)if(4&r){if(r=2|1&r,""!==l&&!kW(t,l,e)||""===l&&1===n.length){if(Ho(r))return!1;i=!0}}else{const u=8&r?l:n[++a];if(8&r&&null!==t.attrs){if(!TW(t.attrs,u,e)){if(Ho(r))return!1;i=!0}continue}const d=NW(8&r?"class":l,s,Ik(t),e);if(-1===d){if(Ho(r))return!1;i=!0;continue}if(""!==u){let h;h=d>o?"":s[d+1].toLowerCase();const p=8&r?h:null;if(p&&-1!==Ck(p,u,0)||2&r&&u!==h){if(Ho(r))return!1;i=!0}}}}else{if(!i&&!Ho(r)&&!Ho(l))return!1;if(i&&Ho(l))continue;i=!1,r=l|1&r}}return Ho(r)||i}function Ho(t){return 0==(1&t)}function NW(t,n,e,r){if(null===n)return-1;let s=0;if(r||!e){let o=!1;for(;s<n.length;){const i=n[s];if(i===t)return s;if(3===i||6===i)o=!0;else{if(1===i||2===i){let a=n[++s];for(;"string"==typeof a;)a=n[++s];continue}if(4===i)break;if(0===i){s+=4;continue}}s+=o?1:2}return-1}return function FW(t,n){let e=t.indexOf(4);if(e>-1)for(e++;e<t.length;){const r=t[e];if("number"==typeof r)return-1;if(r===n)return e;e++}return-1}(n,t)}function Dk(t,n,e=!1){for(let r=0;r<n.length;r++)if(EW(t,n[r],e))return!0;return!1}function Tk(t,n){return t?":not("+n.trim()+")":n}function PW(t){let n=t[0],e=1,r=2,s="",o=!1;for(;e<t.length;){let i=t[e];if("string"==typeof i)if(2&r){const a=t[++e];s+="["+i+(a.length>0?'="'+a+'"':"")+"]"}else 8&r?s+="."+i:4&r&&(s+=" "+i);else""!==s&&!Ho(i)&&(n+=Tk(o,s),s=""),r=i,o=o||!Ho(r);e++}return""!==s&&(n+=Tk(o,s)),n}const Ut={};function Ke(t){kk(fn(),Le(),Is()+t,!1)}function kk(t,n,e,r){if(!r)if(3==(3&n[qt])){const o=t.preOrderCheckHooks;null!==o&&jf(n,o,e)}else{const o=t.preOrderHooks;null!==o&&qf(n,o,0,e)}xl(e)}function Rk(t,n=null,e=null,r){const s=Fk(t,n,e,r);return s.resolveInjectorInitializers(),s}function Fk(t,n=null,e=null,r,s=new Set){const o=[e||bn,nW(t)];return r=r||("object"==typeof t?void 0:Bn(t)),new gk(o,n||hm(),r||null,s)}let Ds=(()=>{class t{static create(e,r){if(Array.isArray(e))return Rk({name:""},r,e,"");{const s=e.name??"";return Rk({name:s},e.parent,e.providers,s)}}}return t.THROW_IF_NOT_FOUND=fd,t.NULL=new dk,t.\u0275prov=kt({token:t,providedIn:"any",factory:()=>Et(uk)}),t.__NG_ELEMENT_ID__=-1,t})();function Pe(t,n=Ot.Default){const e=Le();return null===e?Et(t,n):iT(Zr(),e,Ft(t),n)}function zk(t,n){const e=t.contentQueries;if(null!==e)for(let r=0;r<e.length;r+=2){const o=e[r+1];if(-1!==o){const i=t.data[o];qb(e[r]),i.contentQueries(2,n[o],o)}}}function fm(t,n,e,r,s,o,i,a,l,u,c){const d=n.blueprint.slice();return d[ji]=s,d[qt]=76|r,(null!==c||t&&1024&t[qt])&&(d[qt]|=1024),MD(d),d[ir]=d[Du]=t,d[yr]=e,d[Vf]=i||t&&t[Vf],d[Qt]=a||t&&t[Qt],d[Lb]=l||t&&t[Lb]||null,d[Lf]=u||t&&t[Lf]||null,d[is]=o,d[xd]=function r4(){return n4++}(),d[DD]=c,d[as]=2==n.type?t[as]:d,d}function qu(t,n,e,r,s){let o=t.data[n];if(null===o)o=function Y0(t,n,e,r,s){const o=VD(),i=Wb(),l=t.data[n]=function aG(t,n,e,r,s,o){return{type:e,index:r,insertBeforeIndex:null,injectorIndex:n?n.injectorIndex:-1,directiveStart:-1,directiveEnd:-1,directiveStylingLast:-1,componentOffset:-1,propertyBindings:null,flags:0,providerIndexes:0,value:s,attrs:o,mergedAttrs:null,localNames:null,initialInputs:void 0,inputs:null,outputs:null,tView:null,next:null,prev:null,projectionNext:null,child:null,parent:n,projection:null,styles:null,stylesWithoutHost:null,residualStyles:void 0,classes:null,classesWithoutHost:null,residualClasses:void 0,classBindings:0,styleBindings:0}}(0,i?o:o&&o.parent,e,n,r,s);return null===t.firstChild&&(t.firstChild=l),null!==o&&(i?null==o.child&&null!==l.parent&&(o.child=l):null===o.next&&(o.next=l,l.prev=o)),l}(t,n,e,r,s),function lU(){return zt.lFrame.inI18n}()&&(o.flags|=32);else if(64&o.type){o.type=e,o.value=r,o.attrs=s;const i=function _d(){const t=zt.lFrame,n=t.currentTNode;return t.isParent?n:n.parent}();o.injectorIndex=null===i?-1:i.injectorIndex}return mi(o,!0),o}function Vd(t,n,e,r){if(0===e)return-1;const s=n.length;for(let o=0;o<e;o++)n.push(r),t.blueprint.push(r),t.data.push(null);return s}function Z0(t,n,e){Kb(n);try{const r=t.viewQuery;null!==r&&ax(1,r,e);const s=t.template;null!==s&&Uk(t,n,s,1,e),t.firstCreatePass&&(t.firstCreatePass=!1),t.staticContentQueries&&zk(t,n),t.staticViewQueries&&ax(2,t.viewQuery,e);const o=t.components;null!==o&&function sG(t,n){for(let e=0;e<n.length;e++)DG(t,n[e])}(n,o)}catch(r){throw t.firstCreatePass&&(t.incompleteFirstPass=!0,t.firstCreatePass=!1),r}finally{n[qt]&=-5,Xb()}}function mm(t,n,e,r){const s=n[qt];if(128!=(128&s)){Kb(n);try{MD(n),function zD(t){return zt.lFrame.bindingIndex=t}(t.bindingStartIndex),null!==e&&Uk(t,n,e,2,r);const i=3==(3&s);if(i){const u=t.preOrderCheckHooks;null!==u&&jf(n,u,null)}else{const u=t.preOrderHooks;null!==u&&qf(n,u,0,null),Yb(n,0)}if(function SG(t){for(let n=v0(t);null!==n;n=b0(n)){if(!n[TD])continue;const e=n[ku];for(let r=0;r<e.length;r++){const s=e[r];512&s[qt]||Ub(s[ir],1),s[qt]|=512}}}(n),function CG(t){for(let n=v0(t);null!==n;n=b0(n))for(let e=Cs;e<n.length;e++){const r=n[e],s=r[ht];Gf(r)&&mm(s,r,s.template,r[yr])}}(n),null!==t.contentQueries&&zk(t,n),i){const u=t.contentCheckHooks;null!==u&&jf(n,u)}else{const u=t.contentHooks;null!==u&&qf(n,u,1),Yb(n,1)}!function nG(t,n){const e=t.hostBindingOpCodes;if(null!==e)try{for(let r=0;r<e.length;r++){const s=e[r];if(s<0)xl(~s);else{const o=s,i=e[++r],a=e[++r];uU(i,o),a(2,n[o])}}}finally{xl(-1)}}(t,n);const a=t.components;null!==a&&function rG(t,n){for(let e=0;e<n.length;e++)IG(t,n[e])}(n,a);const l=t.viewQuery;if(null!==l&&ax(2,l,r),i){const u=t.viewCheckHooks;null!==u&&jf(n,u)}else{const u=t.viewHooks;null!==u&&qf(n,u,2),Yb(n,2)}!0===t.firstUpdatePass&&(t.firstUpdatePass=!1),n[qt]&=-41,512&n[qt]&&(n[qt]&=-513,Ub(n[ir],-1))}finally{Xb()}}}function Uk(t,n,e,r,s){const o=Is(),i=2&r;try{xl(-1),i&&n.length>Gn&&kk(t,n,Gn,!1),_o(i?2:0,s),e(r,s)}finally{xl(o),_o(i?3:1,s)}}function Q0(t,n,e){if(Bb(n)){const s=n.directiveEnd;for(let o=n.directiveStart;o<s;o++){const i=t.data[o];i.contentQueries&&i.contentQueries(1,e[o],o)}}}function J0(t,n,e){LD()&&(function pG(t,n,e,r){const s=e.directiveStart,o=e.directiveEnd;wd(e)&&function xG(t,n,e){const r=to(n,t),s=Wk(e),o=t[Vf],i=gm(t,fm(t,s,null,e.onPush?32:16,r,n,o,o.createRenderer(r,e),null,null,null));t[n.index]=i}(n,e,t.data[s+e.componentOffset]),t.firstCreatePass||Zf(e,n),ls(r,n);const i=e.initialInputs;for(let a=s;a<o;a++){const l=t.data[a],u=wl(n,t,a,e);ls(u,n),null!==i&&wG(0,a-s,u,l,0,i),Go(l)&&(no(e.index,n)[yr]=wl(n,t,a,e))}}(t,n,e,to(e,n)),64==(64&e.flags)&&Xk(t,n,e))}function ex(t,n,e=to){const r=n.localNames;if(null!==r){let s=n.index+1;for(let o=0;o<r.length;o+=2){const i=r[o+1],a=-1===i?e(n,t):t[i];t[s++]=a}}}function Wk(t){const n=t.tView;return null===n||n.incompleteFirstPass?t.tView=tx(1,null,t.template,t.decls,t.vars,t.directiveDefs,t.pipeDefs,t.viewQuery,t.schemas,t.consts):n}function tx(t,n,e,r,s,o,i,a,l,u){const c=Gn+r,d=c+s,h=function oG(t,n){const e=[];for(let r=0;r<n;r++)e.push(r<t?null:Ut);return e}(c,d),p="function"==typeof u?u():u;return h[ht]={type:t,blueprint:h,template:e,queries:null,viewQuery:a,declTNode:n,data:h.slice().fill(null,c),bindingStartIndex:c,expandoStartIndex:d,hostBindingOpCodes:null,firstCreatePass:!0,firstUpdatePass:!0,staticViewQueries:!1,staticContentQueries:!1,preOrderHooks:null,preOrderCheckHooks:null,contentHooks:null,contentCheckHooks:null,viewHooks:null,viewCheckHooks:null,destroyHooks:null,cleanup:null,contentQueries:null,components:null,directiveRegistry:"function"==typeof o?o():o,pipeRegistry:"function"==typeof i?i():i,firstChild:null,schemas:l,consts:p,incompleteFirstPass:!1}}function Gk(t,n,e,r){const s=Zk(n);null===e?s.push(r):(s.push(e),t.firstCreatePass&&Qk(t).push(r,s.length-1))}function Hk(t,n,e,r){for(let s in t)if(t.hasOwnProperty(s)){e=null===e?{}:e;const o=t[s];null===r?jk(e,n,s,o):r.hasOwnProperty(s)&&jk(e,n,r[s],o)}return e}function jk(t,n,e,r){t.hasOwnProperty(e)?t[e].push(n,r):t[e]=[n,r]}function qk(t,n){const e=no(n,t);16&e[qt]||(e[qt]|=32)}function nx(t,n,e,r){if(LD()){const s=null===r?null:{"":-1},o=function mG(t,n){const e=t.directiveRegistry;let r=null,s=null;if(e)for(let o=0;o<e.length;o++){const i=e[o];if(Dk(n,i.selectors,!1))if(r||(r=[]),Go(i))if(null!==i.findHostDirectiveDefs){const a=[];s=s||new Map,i.findHostDirectiveDefs(i,a,s),r.unshift(...a,i),rx(t,n,a.length)}else r.unshift(i),rx(t,n,0);else s=s||new Map,i.findHostDirectiveDefs?.(i,r,s),r.push(i)}return null===r?null:[r,s]}(t,e);let i,a;null===o?i=a=null:[i,a]=o,null!==i&&Kk(t,n,e,i,s,a),s&&function gG(t,n,e){if(n){const r=t.localNames=[];for(let s=0;s<n.length;s+=2){const o=e[n[s+1]];if(null==o)throw new Xe(-301,!1);r.push(n[s],o)}}}(e,r,s)}e.mergedAttrs=Sd(e.mergedAttrs,e.attrs)}function Kk(t,n,e,r,s,o){for(let u=0;u<r.length;u++)n0(Zf(e,n),t,r[u].type);!function vG(t,n,e){t.flags|=1,t.directiveStart=n,t.directiveEnd=n+e,t.providerIndexes=n}(e,t.data.length,r.length);for(let u=0;u<r.length;u++){const c=r[u];c.providersResolver&&c.providersResolver(c)}let i=!1,a=!1,l=Vd(t,n,r.length,null);for(let u=0;u<r.length;u++){const c=r[u];e.mergedAttrs=Sd(e.mergedAttrs,c.hostAttrs),bG(t,e,n,l,c),yG(l,c,s),null!==c.contentQueries&&(e.flags|=4),(null!==c.hostBindings||null!==c.hostAttrs||0!==c.hostVars)&&(e.flags|=64);const d=c.type.prototype;!i&&(d.ngOnChanges||d.ngOnInit||d.ngDoCheck)&&((t.preOrderHooks||(t.preOrderHooks=[])).push(e.index),i=!0),!a&&(d.ngOnChanges||d.ngDoCheck)&&((t.preOrderCheckHooks||(t.preOrderCheckHooks=[])).push(e.index),a=!0),l++}!function lG(t,n,e){const s=n.directiveEnd,o=t.data,i=n.attrs,a=[];let l=null,u=null;for(let c=n.directiveStart;c<s;c++){const d=o[c],h=e?e.get(d):null,f=h?h.outputs:null;l=Hk(d.inputs,c,l,h?h.inputs:null),u=Hk(d.outputs,c,u,f);const g=null===l||null===i||Ik(n)?null:_G(l,c,i);a.push(g)}null!==l&&(l.hasOwnProperty("class")&&(n.flags|=8),l.hasOwnProperty("style")&&(n.flags|=16)),n.initialInputs=a,n.inputs=l,n.outputs=u}(t,e,o)}function Xk(t,n,e){const r=e.directiveStart,s=e.directiveEnd,o=e.index,i=function cU(){return zt.lFrame.currentDirectiveIndex}();try{xl(o);for(let a=r;a<s;a++){const l=t.data[a],u=n[a];Hb(a),(null!==l.hostBindings||0!==l.hostVars||null!==l.hostAttrs)&&fG(l,u)}}finally{xl(-1),Hb(i)}}function fG(t,n){null!==t.hostBindings&&t.hostBindings(1,n)}function rx(t,n,e){n.componentOffset=e,(t.components||(t.components=[])).push(n.index)}function yG(t,n,e){if(e){if(n.exportAs)for(let r=0;r<n.exportAs.length;r++)e[n.exportAs[r]]=t;Go(n)&&(e[""]=t)}}function bG(t,n,e,r,s){t.data[r]=s;const o=s.factory||(s.factory=bl(s.type)),i=new Cd(o,Go(s),Pe);t.blueprint[r]=i,e[r]=i,function dG(t,n,e,r,s){const o=s.hostBindings;if(o){let i=t.hostBindingOpCodes;null===i&&(i=t.hostBindingOpCodes=[]);const a=~n.index;(function hG(t){let n=t.length;for(;n>0;){const e=t[--n];if("number"==typeof e&&e<0)return e}return 0})(i)!=a&&i.push(a),i.push(e,r,o)}}(t,n,r,Vd(t,e,s.hostVars,Ut),s)}function wG(t,n,e,r,s,o){const i=o[n];if(null!==i){const a=r.setInput;for(let l=0;l<i.length;){const u=i[l++],c=i[l++],d=i[l++];null!==a?r.setInput(e,d,u,c):e[c]=d}}}function _G(t,n,e){let r=null,s=0;for(;s<e.length;){const o=e[s];if(0!==o)if(5!==o){if("number"==typeof o)break;if(t.hasOwnProperty(o)){null===r&&(r=[]);const i=t[o];for(let a=0;a<i.length;a+=2)if(i[a]===n){r.push(o,i[a+1],e[s+1]);break}}s+=2}else s+=2;else s+=4}return r}function Yk(t,n,e,r){return[t,!0,!1,n,null,0,r,e,null,null]}function IG(t,n){const e=no(n,t);if(Gf(e)){const r=e[ht];48&e[qt]?mm(r,e,r.template,e[yr]):e[vl]>0&&ox(e)}}function ox(t){for(let r=v0(t);null!==r;r=b0(r))for(let s=Cs;s<r.length;s++){const o=r[s];if(Gf(o))if(512&o[qt]){const i=o[ht];mm(i,o,i.template,o[yr])}else o[vl]>0&&ox(o)}const e=t[ht].components;if(null!==e)for(let r=0;r<e.length;r++){const s=no(e[r],t);Gf(s)&&s[vl]>0&&ox(s)}}function DG(t,n){const e=no(n,t),r=e[ht];(function TG(t,n){for(let e=n.length;e<t.blueprint.length;e++)n.push(t.blueprint[e])})(r,e),Z0(r,e,e[yr])}function gm(t,n){return t[vd]?t[ID][Uo]=n:t[vd]=n,t[ID]=n,n}function ix(t){for(;t;){t[qt]|=32;const n=Fd(t);if(Gz(t)&&!n)return t;t=n}return null}function ym(t,n,e,r=!0){const s=n[Vf];s.begin&&s.begin();try{mm(t,n,t.template,e)}catch(i){throw r&&eE(n,i),i}finally{s.end&&s.end()}}function ax(t,n,e){qb(0),n(t,e)}function Zk(t){return t[Iu]||(t[Iu]=[])}function Qk(t){return t.cleanup||(t.cleanup=[])}function eE(t,n){const e=t[Lf],r=e?e.get(Gu,null):null;r&&r.handleError(n)}function lx(t,n,e,r,s){for(let o=0;o<e.length;){const i=e[o++],a=e[o++],l=n[i],u=t.data[i];null!==u.setInput?u.setInput(l,s,r,a):l[a]=s}}function vm(t,n,e){let r=e?t.styles:null,s=e?t.classes:null,o=0;if(null!==n)for(let i=0;i<n.length;i++){const a=n[i];"number"==typeof a?o=a:1==o?s=Eb(s,a):2==o&&(r=Eb(r,a+": "+n[++i]+";"))}e?t.styles=r:t.stylesWithoutHost=r,e?t.classes=s:t.classesWithoutHost=s}function bm(t,n,e,r,s=!1){for(;null!==e;){const o=n[e.index];if(null!==o&&r.push(Yr(o)),Wo(o))for(let a=Cs;a<o.length;a++){const l=o[a],u=l[ht].firstChild;null!==u&&bm(l[ht],l,u,r)}const i=e.type;if(8&i)bm(t,n,e.child,r);else if(32&i){const a=y0(e,n);let l;for(;l=a();)r.push(l)}else if(16&i){const a=HT(n,e);if(Array.isArray(a))r.push(...a);else{const l=Fd(n[as]);bm(l[ht],l,a,r,!0)}}e=s?e.projectionNext:e.next}return r}class Bd{get rootNodes(){const n=this._lView,e=n[ht];return bm(e,n,e.firstChild,[])}constructor(n,e){this._lView=n,this._cdRefInjectingView=e,this._appRef=null,this._attachedToViewContainer=!1}get context(){return this._lView[yr]}set context(n){this._lView[yr]=n}get destroyed(){return 128==(128&this._lView[qt])}destroy(){if(this._appRef)this._appRef.detachView(this);else if(this._attachedToViewContainer){const n=this._lView[ir];if(Wo(n)){const e=n[zf],r=e?e.indexOf(this):-1;r>-1&&(_0(n,r),em(e,r))}this._attachedToViewContainer=!1}MT(this._lView[ht],this._lView)}onDestroy(n){Gk(this._lView[ht],this._lView,null,n)}markForCheck(){ix(this._cdRefInjectingView||this._lView)}detach(){this._lView[qt]&=-65}reattach(){this._lView[qt]|=64}detectChanges(){ym(this._lView[ht],this._lView,this.context)}checkNoChanges(){}attachToViewContainerRef(){if(this._appRef)throw new Xe(902,!1);this._attachedToViewContainer=!0}detachFromAppRef(){this._appRef=null,function v4(t,n){Od(t,n,n[Qt],2,null,null)}(this._lView[ht],this._lView)}attachToAppRef(n){if(this._attachedToViewContainer)throw new Xe(902,!1);this._appRef=n}}class kG extends Bd{constructor(n){super(n),this._view=n}detectChanges(){const n=this._view;ym(n[ht],n,n[yr],!1)}checkNoChanges(){}get context(){return null}}class tE extends Uu{constructor(n){super(),this.ngModule=n}resolveComponentFactory(n){const e=_n(n);return new zd(e,this.ngModule)}}function nE(t){const n=[];for(let e in t)t.hasOwnProperty(e)&&n.push({propName:t[e],templateName:e});return n}class NG{constructor(n,e){this.injector=n,this.parentInjector=e}get(n,e,r){r=Pf(r);const s=this.injector.get(n,U0,r);return s!==U0||e===U0?s:this.parentInjector.get(n,e,r)}}class zd extends vk{get inputs(){return nE(this.componentDef.inputs)}get outputs(){return nE(this.componentDef.outputs)}constructor(n,e){super(),this.componentDef=n,this.ngModule=e,this.componentType=n.type,this.selector=function MW(t){return t.map(PW).join(",")}(n.selectors),this.ngContentSelectors=n.ngContentSelectors?n.ngContentSelectors:[],this.isBoundToModule=!!e}create(n,e,r,s){let o=(s=s||this.ngModule)instanceof Yi?s:s?.injector;o&&null!==this.componentDef.getStandaloneInjector&&(o=this.componentDef.getStandaloneInjector(o)||o);const i=o?new NG(n,o):n,a=i.get(xk,null);if(null===a)throw new Xe(407,!1);const l=i.get(yW,null),u=a.createRenderer(null,this.componentDef),c=this.componentDef.selectors[0][0]||"div",d=r?function iG(t,n,e){return t.selectRootElement(n,e===pi.ShadowDom)}(u,r,this.componentDef.encapsulation):w0(u,c,function EG(t){const n=t.toLowerCase();return"svg"===n?FD:"math"===n?"math":null}(c)),h=this.componentDef.onPush?288:272,p=tx(0,null,null,1,0,null,null,null,null,null),f=fm(null,p,null,h,null,null,a,u,l,i,null);let g,m;Kb(f);try{const y=this.componentDef;let v,b=null;y.findHostDirectiveDefs?(v=[],b=new Map,y.findHostDirectiveDefs(y,v,b),v.push(y)):v=[y];const x=function RG(t,n){const e=t[ht],r=Gn;return t[r]=n,qu(e,r,2,"#host",null)}(f,d),w=function FG(t,n,e,r,s,o,i,a){const l=s[ht];!function OG(t,n,e,r){for(const s of t)n.mergedAttrs=Sd(n.mergedAttrs,s.hostAttrs);null!==n.mergedAttrs&&(vm(n,n.mergedAttrs,!0),null!==e&&KT(r,e,n))}(r,t,n,i);const u=o.createRenderer(n,e),c=fm(s,Wk(e),null,e.onPush?32:16,s[t.index],t,o,u,a||null,null,null);return l.firstCreatePass&&rx(l,t,r.length-1),gm(s,c),s[t.index]=c}(x,d,y,v,f,a,u);m=PD(p,Gn),d&&function MG(t,n,e,r){if(r)Qb(t,e,["ng-version",vW.full]);else{const{attrs:s,classes:o}=function $W(t){const n=[],e=[];let r=1,s=2;for(;r<t.length;){let o=t[r];if("string"==typeof o)2===s?""!==o&&n.push(o,t[++r]):8===s&&e.push(o);else{if(!Ho(s))break;s=o}r++}return{attrs:n,classes:e}}(n.selectors[0]);s&&Qb(t,e,s),o&&o.length>0&&qT(t,e,o.join(" "))}}(u,y,d,r),void 0!==e&&function $G(t,n,e){const r=t.projection=[];for(let s=0;s<n.length;s++){const o=e[s];r.push(null!=o?Array.from(o):null)}}(m,this.ngContentSelectors,e),g=function PG(t,n,e,r,s,o){const i=Zr(),a=s[ht],l=to(i,s);Kk(a,s,i,e,null,r);for(let c=0;c<e.length;c++)ls(wl(s,a,i.directiveStart+c,i),s);Xk(a,s,i),l&&ls(l,s);const u=wl(s,a,i.directiveStart+i.componentOffset,i);if(t[yr]=s[yr]=u,null!==o)for(const c of o)c(u,n);return Q0(a,i,t),u}(w,y,v,b,f,[LG]),Z0(p,f,null)}finally{Xb()}return new AG(this.componentType,g,Wu(m,f),f,m)}}class AG extends dW{constructor(n,e,r,s,o){super(),this.location=r,this._rootLView=s,this._tNode=o,this.instance=e,this.hostView=this.changeDetectorRef=new kG(s),this.componentType=n}setInput(n,e){const r=this._tNode.inputs;let s;if(null!==r&&(s=r[n])){const o=this._rootLView;lx(o[ht],o,s,n,e),qk(o,this._tNode.index)}}get injector(){return new Ru(this._tNode,this._rootLView)}destroy(){this.hostView.destroy()}onDestroy(n){this.hostView.onDestroy(n)}}function LG(){const t=Zr();Hf(Le()[ht],t)}function Dn(t){let n=function rE(t){return Object.getPrototypeOf(t.prototype).constructor}(t.type),e=!0;const r=[t];for(;n;){let s;if(Go(t))s=n.\u0275cmp||n.\u0275dir;else{if(n.\u0275cmp)throw new Xe(903,!1);s=n.\u0275dir}if(s){if(e){r.push(s);const i=t;i.inputs=ux(t.inputs),i.declaredInputs=ux(t.declaredInputs),i.outputs=ux(t.outputs);const a=s.hostBindings;a&&UG(t,a);const l=s.viewQuery,u=s.contentQueries;if(l&&BG(t,l),u&&zG(t,u),kb(t.inputs,s.inputs),kb(t.declaredInputs,s.declaredInputs),kb(t.outputs,s.outputs),Go(s)&&s.data.animation){const c=t.data;c.animation=(c.animation||[]).concat(s.data.animation)}}const o=s.features;if(o)for(let i=0;i<o.length;i++){const a=o[i];a&&a.ngInherit&&a(t),a===Dn&&(e=!1)}}n=Object.getPrototypeOf(n)}!function VG(t){let n=0,e=null;for(let r=t.length-1;r>=0;r--){const s=t[r];s.hostVars=n+=s.hostVars,s.hostAttrs=Sd(s.hostAttrs,e=Sd(e,s.hostAttrs))}}(r)}function ux(t){return t===Gi?{}:t===bn?[]:t}function BG(t,n){const e=t.viewQuery;t.viewQuery=e?(r,s)=>{n(r,s),e(r,s)}:n}function zG(t,n){const e=t.contentQueries;t.contentQueries=e?(r,s,o)=>{n(r,s,o),e(r,s,o)}:n}function UG(t,n){const e=t.hostBindings;t.hostBindings=e?(r,s)=>{n(r,s),e(r,s)}:n}function xm(t){return!!cx(t)&&(Array.isArray(t)||!(t instanceof Map)&&Symbol.iterator in t)}function cx(t){return null!==t&&("function"==typeof t||"object"==typeof t)}function vi(t,n,e){return t[n]=e}function cs(t,n,e){return!Object.is(t[n],e)&&(t[n]=e,!0)}function Il(t,n,e,r){const s=cs(t,n,e);return cs(t,n+1,r)||s}function Xu(t,n,e,r){return cs(t,Nu(),e)?n+Bt(e)+r:Ut}function ln(t,n,e,r,s,o,i,a){const l=Le(),u=fn(),c=t+Gn,d=u.firstCreatePass?function QG(t,n,e,r,s,o,i,a,l){const u=n.consts,c=qu(n,t,4,i||null,_a(u,a));nx(n,e,c,_a(u,l)),Hf(n,c);const d=c.tView=tx(2,c,r,s,o,n.directiveRegistry,n.pipeRegistry,null,n.schemas,u);return null!==n.queries&&(n.queries.template(n,c),d.queries=n.queries.embeddedTView(c)),c}(c,u,l,n,e,r,s,o,i):u.data[c];mi(d,!1);const h=l[Qt].createComment("");om(u,l,h,d),ls(h,l),gm(l,l[c]=Yk(h,l,h,d)),Uf(d)&&J0(u,l,d),null!=i&&ex(l,d,a)}function dx(t){return function Eu(t,n){return t[n]}(function aU(){return zt.lFrame.contextLView}(),Gn+t)}function nt(t,n,e){const r=Le();return cs(r,Nu(),n)&&function so(t,n,e,r,s,o,i,a){const l=to(n,e);let c,u=n.inputs;!a&&null!=u&&(c=u[r])?(lx(t,e,c,r,s),wd(n)&&qk(e,n.index)):3&n.type&&(r=function uG(t){return"class"===t?"className":"for"===t?"htmlFor":"formaction"===t?"formAction":"innerHtml"===t?"innerHTML":"readonly"===t?"readOnly":"tabindex"===t?"tabIndex":t}(r),s=null!=i?i(s,n.value||"",r):s,o.setProperty(l,r,s))}(fn(),function tr(){const t=zt.lFrame;return PD(t.tView,t.selectedIndex)}(),r,t,n,r[Qt],e,!1),nt}function hx(t,n,e,r,s){const i=s?"class":"style";lx(t,e,n.inputs[i],i,r)}function Re(t,n,e,r){const s=Le(),o=fn(),i=Gn+t,a=s[Qt],l=o.firstCreatePass?function eH(t,n,e,r,s,o){const i=n.consts,l=qu(n,t,2,r,_a(i,s));return nx(n,e,l,_a(i,o)),null!==l.attrs&&vm(l,l.attrs,!1),null!==l.mergedAttrs&&vm(l,l.mergedAttrs,!0),null!==n.queries&&n.queries.elementStart(n,l),l}(i,o,s,n,e,r):o.data[i],u=s[i]=w0(a,n,function yU(){return zt.lFrame.currentNamespace}()),c=Uf(l);return mi(l,!0),KT(a,u,l),32!=(32&l.flags)&&om(o,s,u,l),0===function nU(){return zt.lFrame.elementDepthCount}()&&ls(u,s),function rU(){zt.lFrame.elementDepthCount++}(),c&&(J0(o,s,l),Q0(o,l,s)),null!==r&&ex(s,l),Re}function Ee(){let t=Zr();Wb()?Gb():(t=t.parent,mi(t,!1));const n=t;!function sU(){zt.lFrame.elementDepthCount--}();const e=fn();return e.firstCreatePass&&(Hf(e,t),Bb(t)&&e.queries.elementEnd(t)),null!=n.classesWithoutHost&&function wU(t){return 0!=(8&t.flags)}(n)&&hx(e,n,Le(),n.classesWithoutHost,!0),null!=n.stylesWithoutHost&&function _U(t){return 0!=(16&t.flags)}(n)&&hx(e,n,Le(),n.stylesWithoutHost,!1),Ee}function sn(t,n,e,r){return Re(t,n,e,r),Ee(),sn}function px(t,n,e){const r=Le(),s=fn(),o=t+Gn,i=s.firstCreatePass?function tH(t,n,e,r,s){const o=n.consts,i=_a(o,r),a=qu(n,t,8,"ng-container",i);return null!==i&&vm(a,i,!0),nx(n,e,a,_a(o,s)),null!==n.queries&&n.queries.elementStart(n,a),a}(o,s,r,n,e):s.data[o];mi(i,!0);const a=r[o]=r[Qt].createComment("");return om(s,r,a,i),ls(a,r),Uf(i)&&(J0(s,r,i),Q0(s,i,r)),null!=e&&ex(r,i),px}function fx(){let t=Zr();const n=fn();return Wb()?Gb():(t=t.parent,mi(t,!1)),n.firstCreatePass&&(Hf(n,t),Bb(t)&&n.queries.elementEnd(t)),fx}function mx(t,n,e){return px(t,n,e),fx(),mx}function ar(){return Le()}function Wd(t){return!!t&&"function"==typeof t.then}const gx=function gE(t){return!!t&&"function"==typeof t.subscribe};function at(t,n,e,r){const s=Le(),o=fn(),i=Zr();return function vE(t,n,e,r,s,o,i){const a=Uf(r),u=t.firstCreatePass&&Qk(t),c=n[yr],d=Zk(n);let h=!0;if(3&r.type||i){const g=to(r,n),m=i?i(g):g,y=d.length,v=i?x=>i(Yr(x[r.index])):r.index;let b=null;if(!i&&a&&(b=function nH(t,n,e,r){const s=t.cleanup;if(null!=s)for(let o=0;o<s.length-1;o+=2){const i=s[o];if(i===e&&s[o+1]===r){const a=n[Iu],l=s[o+2];return a.length>l?a[l]:null}"string"==typeof i&&(o+=2)}return null}(t,n,s,r.index)),null!==b)(b.__ngLastListenerFn__||b).__ngNextListenerFn__=o,b.__ngLastListenerFn__=o,h=!1;else{o=xE(r,n,c,o,!1);const x=e.listen(m,s,o);d.push(o,x),u&&u.push(s,v,y,y+1)}}else o=xE(r,n,c,o,!1);const p=r.outputs;let f;if(h&&null!==p&&(f=p[s])){const g=f.length;if(g)for(let m=0;m<g;m+=2){const w=n[f[m]][f[m+1]].subscribe(o),k=d.length;d.push(o,w),u&&u.push(s,r.index,k,-(k+1))}}}(o,s,s[Qt],i,t,n,r),at}function bE(t,n,e,r){try{return _o(6,n,e),!1!==e(r)}catch(s){return eE(t,s),!1}finally{_o(7,n,e)}}function xE(t,n,e,r,s){return function o(i){if(i===Function)return r;ix(t.componentOffset>-1?no(t.index,n):n);let l=bE(n,e,r,i),u=o.__ngNextListenerFn__;for(;u;)l=bE(n,e,u,i)&&l,u=u.__ngNextListenerFn__;return s&&!1===l&&(i.preventDefault(),i.returnValue=!1),l}}function ot(t=1){return function hU(t){return(zt.lFrame.contextLView=function pU(t,n){for(;t>0;)n=n[Du],t--;return n}(t,zt.lFrame.contextLView))[yr]}(t)}function _m(t,n){return t<<17|n<<2}function Sa(t){return t>>17&32767}function vx(t){return 2|t}function Dl(t){return(131068&t)>>2}function bx(t,n){return-131069&t|n<<2}function xx(t){return 1|t}function NE(t,n,e,r,s){const o=t[e+1],i=null===n;let a=r?Sa(o):Dl(o),l=!1;for(;0!==a&&(!1===l||i);){const c=t[a+1];dH(t[a],n)&&(l=!0,t[a+1]=r?xx(c):vx(c)),a=r?Sa(c):Dl(c)}l&&(t[e+1]=r?vx(o):xx(o))}function dH(t,n){return null===t||null==n||(Array.isArray(t)?t[1]:t)===n||!(!Array.isArray(t)||"string"!=typeof n)&&$u(t,n)>=0}const Rr={textEnd:0,key:0,keyEnd:0,value:0,valueEnd:0};function AE(t){return t.substring(Rr.key,Rr.keyEnd)}function RE(t,n){const e=Rr.textEnd;return e===n?-1:(n=Rr.keyEnd=function mH(t,n,e){for(;n<e&&t.charCodeAt(n)>32;)n++;return n}(t,Rr.key=n,e),rc(t,n,e))}function rc(t,n,e){for(;n<e&&t.charCodeAt(n)<=32;)n++;return n}function vr(t,n,e){return jo(t,n,e,!1),vr}function Ts(t,n){return jo(t,n,null,!0),Ts}function Tl(t){qo(ro,wi,t,!0)}function wi(t,n){for(let e=function pH(t){return function OE(t){Rr.key=0,Rr.keyEnd=0,Rr.value=0,Rr.valueEnd=0,Rr.textEnd=t.length}(t),RE(t,rc(t,0,Rr.textEnd))}(n);e>=0;e=RE(n,e))ro(t,AE(n),!0)}function jo(t,n,e,r){const s=Le(),o=fn(),i=Ki(2);o.firstUpdatePass&&LE(o,t,i,r),n!==Ut&&cs(s,i,n)&&BE(o,o.data[Is()],s,s[Qt],t,s[i+1]=function IH(t,n){return null==t||("string"==typeof n?t+=n:"object"==typeof t&&(t=Bn(Ca(t)))),t}(n,e),r,i)}function qo(t,n,e,r){const s=fn(),o=Ki(2);s.firstUpdatePass&&LE(s,null,o,r);const i=Le();if(e!==Ut&&cs(i,o,e)){const a=s.data[Is()];if(UE(a,r)&&!$E(s,o)){let l=r?a.classesWithoutHost:a.stylesWithoutHost;null!==l&&(e=Eb(l,e||"")),hx(s,a,i,e,r)}else!function SH(t,n,e,r,s,o,i,a){s===Ut&&(s=bn);let l=0,u=0,c=0<s.length?s[0]:null,d=0<o.length?o[0]:null;for(;null!==c||null!==d;){const h=l<s.length?s[l+1]:void 0,p=u<o.length?o[u+1]:void 0;let g,f=null;c===d?(l+=2,u+=2,h!==p&&(f=d,g=p)):null===d||null!==c&&c<d?(l+=2,f=c):(u+=2,f=d,g=p),null!==f&&BE(t,n,e,r,f,g,i,a),c=l<s.length?s[l]:null,d=u<o.length?o[u]:null}}(s,a,i,i[Qt],i[o+1],i[o+1]=function CH(t,n,e){if(null==e||""===e)return bn;const r=[],s=Ca(e);if(Array.isArray(s))for(let o=0;o<s.length;o++)t(r,s[o],!0);else if("object"==typeof s)for(const o in s)s.hasOwnProperty(o)&&t(r,o,s[o]);else"string"==typeof s&&n(r,s);return r}(t,n,e),r,o)}}function $E(t,n){return n>=t.expandoStartIndex}function LE(t,n,e,r){const s=t.data;if(null===s[e+1]){const o=s[Is()],i=$E(t,e);UE(o,r)&&null===n&&!i&&(n=!1),n=function bH(t,n,e,r){const s=function jb(t){const n=zt.lFrame.currentDirectiveIndex;return-1===n?null:t[n]}(t);let o=r?n.residualClasses:n.residualStyles;if(null===s)0===(r?n.classBindings:n.styleBindings)&&(e=Gd(e=wx(null,t,n,e,r),n.attrs,r),o=null);else{const i=n.directiveStylingLast;if(-1===i||t[i]!==s)if(e=wx(s,t,n,e,r),null===o){let l=function xH(t,n,e){const r=e?n.classBindings:n.styleBindings;if(0!==Dl(r))return t[Sa(r)]}(t,n,r);void 0!==l&&Array.isArray(l)&&(l=wx(null,t,n,l[1],r),l=Gd(l,n.attrs,r),function wH(t,n,e,r){t[Sa(e?n.classBindings:n.styleBindings)]=r}(t,n,r,l))}else o=function _H(t,n,e){let r;const s=n.directiveEnd;for(let o=1+n.directiveStylingLast;o<s;o++)r=Gd(r,t[o].hostAttrs,e);return Gd(r,n.attrs,e)}(t,n,r)}return void 0!==o&&(r?n.residualClasses=o:n.residualStyles=o),e}(s,o,n,r),function uH(t,n,e,r,s,o){let i=o?n.classBindings:n.styleBindings,a=Sa(i),l=Dl(i);t[r]=e;let c,u=!1;if(Array.isArray(e)?(c=e[1],(null===c||$u(e,c)>0)&&(u=!0)):c=e,s)if(0!==l){const h=Sa(t[a+1]);t[r+1]=_m(h,a),0!==h&&(t[h+1]=bx(t[h+1],r)),t[a+1]=function aH(t,n){return 131071&t|n<<17}(t[a+1],r)}else t[r+1]=_m(a,0),0!==a&&(t[a+1]=bx(t[a+1],r)),a=r;else t[r+1]=_m(l,0),0===a?a=r:t[l+1]=bx(t[l+1],r),l=r;u&&(t[r+1]=vx(t[r+1])),NE(t,c,r,!0),NE(t,c,r,!1),function cH(t,n,e,r,s){const o=s?t.residualClasses:t.residualStyles;null!=o&&"string"==typeof n&&$u(o,n)>=0&&(e[r+1]=xx(e[r+1]))}(n,c,t,r,o),i=_m(a,l),o?n.classBindings=i:n.styleBindings=i}(s,o,n,e,i,r)}}function wx(t,n,e,r,s){let o=null;const i=e.directiveEnd;let a=e.directiveStylingLast;for(-1===a?a=e.directiveStart:a++;a<i&&(o=n[a],r=Gd(r,o.hostAttrs,s),o!==t);)a++;return null!==t&&(e.directiveStylingLast=a),r}function Gd(t,n,e){const r=e?1:2;let s=-1;if(null!==n)for(let o=0;o<n.length;o++){const i=n[o];"number"==typeof i?s=i:s===r&&(Array.isArray(t)||(t=void 0===t?[]:["",t]),ro(t,i,!!e||n[++o]))}return void 0===t?null:t}function BE(t,n,e,r,s,o,i,a){if(!(3&n.type))return;const l=t.data,u=l[a+1],c=function lH(t){return 1==(1&t)}(u)?zE(l,n,e,s,Dl(u),i):void 0;Cm(c)||(Cm(o)||function iH(t){return 2==(2&t)}(u)&&(o=zE(l,null,e,s,a,i)),function k4(t,n,e,r,s){if(n)s?t.addClass(e,r):t.removeClass(e,r);else{let o=-1===r.indexOf("-")?void 0:Vs.DashCase;null==s?t.removeStyle(e,r,o):("string"==typeof s&&s.endsWith("!important")&&(s=s.slice(0,-10),o|=Vs.Important),t.setStyle(e,r,s,o))}}(r,i,Wf(Is(),e),s,o))}function zE(t,n,e,r,s,o){const i=null===n;let a;for(;s>0;){const l=t[s],u=Array.isArray(l),c=u?l[1]:l,d=null===c;let h=e[s+1];h===Ut&&(h=d?bn:void 0);let p=d?a0(h,r):c===r?h:void 0;if(u&&!Cm(p)&&(p=a0(l,r)),Cm(p)&&(a=p,i))return a;const f=t[s+1];s=i?Sa(f):Dl(f)}if(null!==n){let l=o?n.residualClasses:n.residualStyles;null!=l&&(a=a0(l,r))}return a}function Cm(t){return void 0!==t}function UE(t,n){return 0!=(t.flags&(n?8:16))}function bt(t,n=""){const e=Le(),r=fn(),s=t+Gn,o=r.firstCreatePass?qu(r,s,1,n,null):r.data[s],i=e[s]=function x0(t,n){return t.createText(n)}(e[Qt],n);om(r,e,i,o),mi(o,!1)}function kl(t){return Io("",t,""),kl}function Io(t,n,e){const r=Le(),s=Xu(r,t,n,e);return s!==Ut&&function Ji(t,n,e){const r=Wf(n,t);!function OT(t,n,e){t.setValue(n,e)}(t[Qt],r,e)}(r,Is(),s),Io}const oc="en-US";let dN=oc;function Sx(t,n,e,r,s){if(t=Ft(t),Array.isArray(t))for(let o=0;o<t.length;o++)Sx(t[o],n,e,r,s);else{const o=fn(),i=Le();let a=Sl(t)?t:Ft(t.provide),l=yk(t);const u=Zr(),c=1048575&u.providerIndexes,d=u.directiveStart,h=u.providerIndexes>>20;if(Sl(t)||!t.multi){const p=new Cd(l,s,Pe),f=Dx(a,n,s?c:c+h,d);-1===f?(n0(Zf(u,i),o,a),Ix(o,t,n.length),n.push(a),u.directiveStart++,u.directiveEnd++,s&&(u.providerIndexes+=1048576),e.push(p),i.push(p)):(e[f]=p,i[f]=p)}else{const p=Dx(a,n,c+h,d),f=Dx(a,n,c,c+h),m=f>=0&&e[f];if(s&&!m||!s&&!(p>=0&&e[p])){n0(Zf(u,i),o,a);const y=function Uj(t,n,e,r,s){const o=new Cd(t,e,Pe);return o.multi=[],o.index=n,o.componentProviders=0,MN(o,s,r&&!e),o}(s?zj:Bj,e.length,s,r,l);!s&&m&&(e[f].providerFactory=y),Ix(o,t,n.length,0),n.push(a),u.directiveStart++,u.directiveEnd++,s&&(u.providerIndexes+=1048576),e.push(y),i.push(y)}else Ix(o,t,p>-1?p:f,MN(e[s?f:p],l,!s&&r));!s&&r&&m&&e[f].componentProviders++}}}function Ix(t,n,e,r){const s=Sl(n),o=function sW(t){return!!t.useClass}(n);if(s||o){const l=(o?Ft(n.useClass):n).prototype.ngOnDestroy;if(l){const u=t.destroyHooks||(t.destroyHooks=[]);if(!s&&n.multi){const c=u.indexOf(e);-1===c?u.push(e,[r,l]):u[c+1].push(r,l)}else u.push(e,l)}}}function MN(t,n,e){return e&&t.componentProviders++,t.multi.push(n)-1}function Dx(t,n,e,r){for(let s=e;s<r;s++)if(n[s]===t)return s;return-1}function Bj(t,n,e,r){return Tx(this.multi,[])}function zj(t,n,e,r){const s=this.multi;let o;if(this.providerFactory){const i=this.providerFactory.componentProviders,a=wl(e,e[ht],this.providerFactory.index,r);o=a.slice(0,i),Tx(s,o);for(let l=i;l<a.length;l++)o.push(a[l])}else o=[],Tx(s,o);return o}function Tx(t,n){for(let e=0;e<t.length;e++)n.push((0,t[e])());return n}function Yn(t,n=[]){return e=>{e.providersResolver=(r,s)=>function Vj(t,n,e){const r=fn();if(r.firstCreatePass){const s=Go(t);Sx(e,r.data,r.blueprint,s,!0),Sx(n,r.data,r.blueprint,s,!1)}}(r,s?s(t):t,n)}}class ic{}class $N{}class LN extends ic{constructor(n,e){super(),this._parent=e,this._bootstrapComponents=[],this.destroyCbs=[],this.componentFactoryResolver=new tE(this);const r=Qs(n);this._bootstrapComponents=Qi(r.bootstrap),this._r3Injector=Fk(n,e,[{provide:ic,useValue:this},{provide:Uu,useValue:this.componentFactoryResolver}],Bn(n),new Set(["environment"])),this._r3Injector.resolveInjectorInitializers(),this.instance=this._r3Injector.get(n)}get injector(){return this._r3Injector}destroy(){const n=this._r3Injector;!n.destroyed&&n.destroy(),this.destroyCbs.forEach(e=>e()),this.destroyCbs=null}onDestroy(n){this.destroyCbs.push(n)}}class kx extends $N{constructor(n){super(),this.moduleType=n}create(n){return new LN(this.moduleType,n)}}class Gj extends ic{constructor(n,e,r){super(),this.componentFactoryResolver=new tE(this),this.instance=null;const s=new gk([...n,{provide:ic,useValue:this},{provide:Uu,useValue:this.componentFactoryResolver}],e||hm(),r,new Set(["environment"]));this.injector=s,s.resolveInjectorInitializers()}destroy(){this.injector.destroy()}onDestroy(n){this.injector.onDestroy(n)}}function km(t,n,e=null){return new Gj(t,n,e).injector}let Hj=(()=>{class t{constructor(e){this._injector=e,this.cachedInjectors=new Map}getOrCreateStandaloneInjector(e){if(!e.standalone)return null;if(!this.cachedInjectors.has(e.id)){const r=hk(0,e.type),s=r.length>0?km([r],this._injector,`Standalone[${e.type.name}]`):null;this.cachedInjectors.set(e.id,s)}return this.cachedInjectors.get(e.id)}ngOnDestroy(){try{for(const e of this.cachedInjectors.values())null!==e&&e.destroy()}finally{this.cachedInjectors.clear()}}}return t.\u0275prov=kt({token:t,providedIn:"environment",factory:()=>new t(Et(Yi))}),t})();function VN(t){t.getStandaloneInjector=n=>n.get(Hj).getOrCreateStandaloneInjector(t)}function Em(t,n,e,r){return function qN(t,n,e,r,s,o){const i=n+e;return cs(t,i,s)?vi(t,i+1,o?r.call(o,s):r(s)):Yd(t,i+1)}(Le(),Ss(),t,n,e,r)}function Nm(t,n,e,r,s){return function KN(t,n,e,r,s,o,i){const a=n+e;return Il(t,a,s,o)?vi(t,a+2,i?r.call(i,s,o):r(s,o)):Yd(t,a+2)}(Le(),Ss(),t,n,e,r,s)}function jN(t,n,e,r,s,o,i){return function YN(t,n,e,r,s,o,i,a,l){const u=n+e;return function So(t,n,e,r,s,o){const i=Il(t,n,e,r);return Il(t,n+2,s,o)||i}(t,u,s,o,i,a)?vi(t,u+4,l?r.call(l,s,o,i,a):r(s,o,i,a)):Yd(t,u+4)}(Le(),Ss(),t,n,e,r,s,o,i)}function Yd(t,n){const e=t[n];return e===Ut?void 0:e}function Nx(t){return n=>{setTimeout(t,void 0,n)}}const nn=class f5 extends Zt{constructor(n=!1){super(),this.__isAsync=n}emit(n){super.next(n)}subscribe(n,e,r){let s=n,o=e||(()=>null),i=r;if(n&&"object"==typeof n){const l=n;s=l.next?.bind(l),o=l.error?.bind(l),i=l.complete?.bind(l)}this.__isAsync&&(o=Nx(o),s&&(s=Nx(s)),i&&(i=Nx(i)));const a=super.subscribe({next:s,error:o,complete:i});return n instanceof T&&n.add(a),a}};function m5(){return this._results[Symbol.iterator]()}class Ax{get changes(){return this._changes||(this._changes=new nn)}constructor(n=!1){this._emitDistinctChangesOnly=n,this.dirty=!0,this._results=[],this._changesDetected=!1,this._changes=null,this.length=0,this.first=void 0,this.last=void 0;const e=Ax.prototype;e[Symbol.iterator]||(e[Symbol.iterator]=m5)}get(n){return this._results[n]}map(n){return this._results.map(n)}filter(n){return this._results.filter(n)}find(n){return this._results.find(n)}reduce(n,e){return this._results.reduce(n,e)}forEach(n){this._results.forEach(n)}some(n){return this._results.some(n)}toArray(){return this._results.slice()}toString(){return this._results.toString()}reset(n,e){const r=this;r.dirty=!1;const s=function Co(t){return t.flat(Number.POSITIVE_INFINITY)}(n);(this._changesDetected=!function RU(t,n,e){if(t.length!==n.length)return!1;for(let r=0;r<t.length;r++){let s=t[r],o=n[r];if(e&&(s=e(s),o=e(o)),o!==s)return!1}return!0}(r._results,s,e))&&(r._results=s,r.length=s.length,r.last=s[this.length-1],r.first=s[0])}notifyOnChanges(){this._changes&&(this._changesDetected||!this._emitDistinctChangesOnly)&&this._changes.emit(this)}setDirty(){this.dirty=!0}destroy(){this.changes.complete(),this.changes.unsubscribe()}}let ea=(()=>{class t{}return t.__NG_ELEMENT_ID__=v5,t})();const g5=ea,y5=class extends g5{constructor(n,e,r){super(),this._declarationLView=n,this._declarationTContainer=e,this.elementRef=r}createEmbeddedView(n,e){const r=this._declarationTContainer.tView,s=fm(this._declarationLView,r,n,16,null,r.declTNode,null,null,null,null,e||null);s[bd]=this._declarationLView[this._declarationTContainer.index];const i=this._declarationLView[fi];return null!==i&&(s[fi]=i.createEmbeddedView(r)),Z0(r,s,n),new Bd(s)}};function v5(){return Am(Zr(),Le())}function Am(t,n){return 4&t.type?new y5(n,t,Wu(t,n)):null}let Do=(()=>{class t{}return t.__NG_ELEMENT_ID__=b5,t})();function b5(){return eA(Zr(),Le())}const x5=Do,QN=class extends x5{constructor(n,e,r){super(),this._lContainer=n,this._hostTNode=e,this._hostLView=r}get element(){return Wu(this._hostTNode,this._hostLView)}get injector(){return new Ru(this._hostTNode,this._hostLView)}get parentInjector(){const n=t0(this._hostTNode,this._hostLView);if(eT(n)){const e=Xf(n,this._hostLView),r=Kf(n);return new Ru(e[ht].data[r+8],e)}return new Ru(null,this._hostLView)}clear(){for(;this.length>0;)this.remove(this.length-1)}get(n){const e=JN(this._lContainer);return null!==e&&e[n]||null}get length(){return this._lContainer.length-Cs}createEmbeddedView(n,e,r){let s,o;"number"==typeof r?s=r:null!=r&&(s=r.index,o=r.injector);const i=n.createEmbeddedView(e||{},o);return this.insert(i,s),i}createComponent(n,e,r,s,o){const i=n&&!function Dd(t){return"function"==typeof t}(n);let a;if(i)a=e;else{const d=e||{};a=d.index,r=d.injector,s=d.projectableNodes,o=d.environmentInjector||d.ngModuleRef}const l=i?n:new zd(_n(n)),u=r||this.parentInjector;if(!o&&null==l.ngModule){const h=(i?u:this.parentInjector).get(Yi,null);h&&(o=h)}const c=l.create(u,s,void 0,o);return this.insert(c.hostView,a),c}insert(n,e){const r=n._lView,s=r[ht];if(function tU(t){return Wo(t[ir])}(r)){const c=this.indexOf(n);if(-1!==c)this.detach(c);else{const d=r[ir],h=new QN(d,d[is],d[ir]);h.detach(h.indexOf(n))}}const o=this._adjustIndex(e),i=this._lContainer;!function x4(t,n,e,r){const s=Cs+r,o=e.length;r>0&&(e[s-1][Uo]=n),r<o-Cs?(n[Uo]=e[s],hT(e,Cs+r,n)):(e.push(n),n[Uo]=null),n[ir]=e;const i=n[bd];null!==i&&e!==i&&function w4(t,n){const e=t[ku];n[as]!==n[ir][ir][as]&&(t[TD]=!0),null===e?t[ku]=[n]:e.push(n)}(i,n);const a=n[fi];null!==a&&a.insertView(t),n[qt]|=64}(s,r,i,o);const a=I0(o,i),l=r[Qt],u=sm(l,i[Bf]);return null!==u&&function y4(t,n,e,r,s,o){r[ji]=s,r[is]=n,Od(t,r,e,1,s,o)}(s,i[is],l,r,u,a),n.attachToViewContainerRef(),hT(Rx(i),o,n),n}move(n,e){return this.insert(n,e)}indexOf(n){const e=JN(this._lContainer);return null!==e?e.indexOf(n):-1}remove(n){const e=this._adjustIndex(n,-1),r=_0(this._lContainer,e);r&&(em(Rx(this._lContainer),e),MT(r[ht],r))}detach(n){const e=this._adjustIndex(n,-1),r=_0(this._lContainer,e);return r&&null!=em(Rx(this._lContainer),e)?new Bd(r):null}_adjustIndex(n,e=0){return n??this.length+e}};function JN(t){return t[zf]}function Rx(t){return t[zf]||(t[zf]=[])}function eA(t,n){let e;const r=n[t.index];if(Wo(r))e=r;else{let s;if(8&t.type)s=Yr(r);else{const o=n[Qt];s=o.createComment("");const i=to(t,n);Cl(o,sm(o,i),s,function I4(t,n){return t.nextSibling(n)}(o,i),!1)}n[t.index]=e=Yk(r,n,s,t),gm(n,e)}return new QN(e,t,n)}class Fx{constructor(n){this.queryList=n,this.matches=null}clone(){return new Fx(this.queryList)}setDirty(){this.queryList.setDirty()}}class Ox{constructor(n=[]){this.queries=n}createEmbeddedView(n){const e=n.queries;if(null!==e){const r=null!==n.contentQueries?n.contentQueries[0]:e.length,s=[];for(let o=0;o<r;o++){const i=e.getByIndex(o);s.push(this.queries[i.indexInDeclarationView].clone())}return new Ox(s)}return null}insertView(n){this.dirtyQueriesWithMatches(n)}detachView(n){this.dirtyQueriesWithMatches(n)}dirtyQueriesWithMatches(n){for(let e=0;e<this.queries.length;e++)null!==iA(n,e).matches&&this.queries[e].setDirty()}}class tA{constructor(n,e,r=null){this.predicate=n,this.flags=e,this.read=r}}class Px{constructor(n=[]){this.queries=n}elementStart(n,e){for(let r=0;r<this.queries.length;r++)this.queries[r].elementStart(n,e)}elementEnd(n){for(let e=0;e<this.queries.length;e++)this.queries[e].elementEnd(n)}embeddedTView(n){let e=null;for(let r=0;r<this.length;r++){const s=null!==e?e.length:0,o=this.getByIndex(r).embeddedTView(n,s);o&&(o.indexInDeclarationView=r,null!==e?e.push(o):e=[o])}return null!==e?new Px(e):null}template(n,e){for(let r=0;r<this.queries.length;r++)this.queries[r].template(n,e)}getByIndex(n){return this.queries[n]}get length(){return this.queries.length}track(n){this.queries.push(n)}}class Mx{constructor(n,e=-1){this.metadata=n,this.matches=null,this.indexInDeclarationView=-1,this.crossesNgTemplate=!1,this._appliesToNextNode=!0,this._declarationNodeIndex=e}elementStart(n,e){this.isApplyingToNode(e)&&this.matchTNode(n,e)}elementEnd(n){this._declarationNodeIndex===n.index&&(this._appliesToNextNode=!1)}template(n,e){this.elementStart(n,e)}embeddedTView(n,e){return this.isApplyingToNode(n)?(this.crossesNgTemplate=!0,this.addMatch(-n.index,e),new Mx(this.metadata)):null}isApplyingToNode(n){if(this._appliesToNextNode&&1!=(1&this.metadata.flags)){const e=this._declarationNodeIndex;let r=n.parent;for(;null!==r&&8&r.type&&r.index!==e;)r=r.parent;return e===(null!==r?r.index:-1)}return this._appliesToNextNode}matchTNode(n,e){const r=this.metadata.predicate;if(Array.isArray(r))for(let s=0;s<r.length;s++){const o=r[s];this.matchTNodeWithReadOption(n,e,w5(e,o)),this.matchTNodeWithReadOption(n,e,Qf(e,n,o,!1,!1))}else r===ea?4&e.type&&this.matchTNodeWithReadOption(n,e,-1):this.matchTNodeWithReadOption(n,e,Qf(e,n,r,!1,!1))}matchTNodeWithReadOption(n,e,r){if(null!==r){const s=this.metadata.read;if(null!==s)if(s===us||s===Do||s===ea&&4&e.type)this.addMatch(e.index,-2);else{const o=Qf(e,n,s,!1,!1);null!==o&&this.addMatch(e.index,o)}else this.addMatch(e.index,r)}}addMatch(n,e){null===this.matches?this.matches=[n,e]:this.matches.push(n,e)}}function w5(t,n){const e=t.localNames;if(null!==e)for(let r=0;r<e.length;r+=2)if(e[r]===n)return e[r+1];return null}function C5(t,n,e,r){return-1===e?function _5(t,n){return 11&t.type?Wu(t,n):4&t.type?Am(t,n):null}(n,t):-2===e?function S5(t,n,e){return e===us?Wu(n,t):e===ea?Am(n,t):e===Do?eA(n,t):void 0}(t,n,r):wl(t,t[ht],e,n)}function nA(t,n,e,r){const s=n[fi].queries[r];if(null===s.matches){const o=t.data,i=e.matches,a=[];for(let l=0;l<i.length;l+=2){const u=i[l];a.push(u<0?null:C5(n,o[u],i[l+1],e.metadata.read))}s.matches=a}return s.matches}function $x(t,n,e,r){const s=t.queries.getByIndex(e),o=s.matches;if(null!==o){const i=nA(t,n,s,e);for(let a=0;a<o.length;a+=2){const l=o[a];if(l>0)r.push(i[a/2]);else{const u=o[a+1],c=n[-l];for(let d=Cs;d<c.length;d++){const h=c[d];h[bd]===h[ir]&&$x(h[ht],h,u,r)}if(null!==c[ku]){const d=c[ku];for(let h=0;h<d.length;h++){const p=d[h];$x(p[ht],p,u,r)}}}}}return r}function Nl(t){const n=Le(),e=fn(),r=WD();qb(r+1);const s=iA(e,r);if(t.dirty&&function eU(t){return 4==(4&t[qt])}(n)===(2==(2&s.metadata.flags))){if(null===s.matches)t.reset([]);else{const o=s.crossesNgTemplate?$x(e,n,r,[]):nA(e,n,s,r);t.reset(o,mW),t.notifyOnChanges()}return!0}return!1}function ac(t,n,e){const r=fn();r.firstCreatePass&&(function oA(t,n,e){null===t.queries&&(t.queries=new Px),t.queries.track(new Mx(n,e))}(r,new tA(t,n,e),-1),2==(2&n)&&(r.staticViewQueries=!0)),function sA(t,n,e){const r=new Ax(4==(4&e));Gk(t,n,r,r.destroy),null===n[fi]&&(n[fi]=new Ox),n[fi].queries.push(new Fx(r))}(r,Le(),n)}function Al(){return function I5(t,n){return t[fi].queries[n].queryList}(Le(),WD())}function iA(t,n){return t.queries.getByIndex(n)}function Fm(...t){}const Om=new Ct("Application Initializer");let Pm=(()=>{class t{constructor(e){this.appInits=e,this.resolve=Fm,this.reject=Fm,this.initialized=!1,this.done=!1,this.donePromise=new Promise((r,s)=>{this.resolve=r,this.reject=s})}runInitializers(){if(this.initialized)return;const e=[],r=()=>{this.done=!0,this.resolve()};if(this.appInits)for(let s=0;s<this.appInits.length;s++){const o=this.appInits[s]();if(Wd(o))e.push(o);else if(gx(o)){const i=new Promise((a,l)=>{o.subscribe({complete:a,error:l})});e.push(i)}}Promise.all(e).then(()=>{r()}).catch(s=>{this.reject(s)}),0===e.length&&r(),this.initialized=!0}}return t.\u0275fac=function(e){return new(e||t)(Et(Om,8))},t.\u0275prov=kt({token:t,factory:t.\u0275fac,providedIn:"root"}),t})();const Jd=new Ct("AppId",{providedIn:"root",factory:function SA(){return`${Wx()}${Wx()}${Wx()}`}});function Wx(){return String.fromCharCode(97+Math.floor(25*Math.random()))}const IA=new Ct("Platform Initializer"),Gx=new Ct("Platform ID",{providedIn:"platform",factory:()=>"unknown"});let q5=(()=>{class t{log(e){console.log(e)}warn(e){console.warn(e)}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=kt({token:t,factory:t.\u0275fac,providedIn:"platform"}),t})();const ta=new Ct("LocaleId",{providedIn:"root",factory:()=>cn(ta,Ot.Optional|Ot.SkipSelf)||function K5(){return typeof $localize<"u"&&$localize.locale||oc}()});class Y5{constructor(n,e){this.ngModuleFactory=n,this.componentFactories=e}}let DA=(()=>{class t{compileModuleSync(e){return new kx(e)}compileModuleAsync(e){return Promise.resolve(this.compileModuleSync(e))}compileModuleAndAllComponentsSync(e){const r=this.compileModuleSync(e),o=Qi(Qs(e).declarations).reduce((i,a)=>{const l=_n(a);return l&&i.push(new zd(l)),i},[]);return new Y5(r,o)}compileModuleAndAllComponentsAsync(e){return Promise.resolve(this.compileModuleAndAllComponentsSync(e))}clearCache(){}clearCacheFor(e){}getModuleId(e){}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=kt({token:t,factory:t.\u0275fac,providedIn:"root"}),t})();const J5=(()=>Promise.resolve(0))();function Hx(t){typeof Zone>"u"?J5.then(()=>{t&&t.apply(null,null)}):Zone.current.scheduleMicroTask("scheduleMicrotask",t)}class ur{constructor({enableLongStackTrace:n=!1,shouldCoalesceEventChangeDetection:e=!1,shouldCoalesceRunChangeDetection:r=!1}){if(this.hasPendingMacrotasks=!1,this.hasPendingMicrotasks=!1,this.isStable=!0,this.onUnstable=new nn(!1),this.onMicrotaskEmpty=new nn(!1),this.onStable=new nn(!1),this.onError=new nn(!1),typeof Zone>"u")throw new Xe(908,!1);Zone.assertZonePatched();const s=this;s._nesting=0,s._outer=s._inner=Zone.current,Zone.TaskTrackingZoneSpec&&(s._inner=s._inner.fork(new Zone.TaskTrackingZoneSpec)),n&&Zone.longStackTraceZoneSpec&&(s._inner=s._inner.fork(Zone.longStackTraceZoneSpec)),s.shouldCoalesceEventChangeDetection=!r&&e,s.shouldCoalesceRunChangeDetection=r,s.lastRequestAnimationFrameId=-1,s.nativeRequestAnimationFrame=function e6(){let t=Wn.requestAnimationFrame,n=Wn.cancelAnimationFrame;if(typeof Zone<"u"&&t&&n){const e=t[Zone.__symbol__("OriginalDelegate")];e&&(t=e);const r=n[Zone.__symbol__("OriginalDelegate")];r&&(n=r)}return{nativeRequestAnimationFrame:t,nativeCancelAnimationFrame:n}}().nativeRequestAnimationFrame,function r6(t){const n=()=>{!function n6(t){t.isCheckStableRunning||-1!==t.lastRequestAnimationFrameId||(t.lastRequestAnimationFrameId=t.nativeRequestAnimationFrame.call(Wn,()=>{t.fakeTopEventTask||(t.fakeTopEventTask=Zone.root.scheduleEventTask("fakeTopEventTask",()=>{t.lastRequestAnimationFrameId=-1,qx(t),t.isCheckStableRunning=!0,jx(t),t.isCheckStableRunning=!1},void 0,()=>{},()=>{})),t.fakeTopEventTask.invoke()}),qx(t))}(t)};t._inner=t._inner.fork({name:"angular",properties:{isAngularZone:!0},onInvokeTask:(e,r,s,o,i,a)=>{try{return EA(t),e.invokeTask(s,o,i,a)}finally{(t.shouldCoalesceEventChangeDetection&&"eventTask"===o.type||t.shouldCoalesceRunChangeDetection)&&n(),NA(t)}},onInvoke:(e,r,s,o,i,a,l)=>{try{return EA(t),e.invoke(s,o,i,a,l)}finally{t.shouldCoalesceRunChangeDetection&&n(),NA(t)}},onHasTask:(e,r,s,o)=>{e.hasTask(s,o),r===s&&("microTask"==o.change?(t._hasPendingMicrotasks=o.microTask,qx(t),jx(t)):"macroTask"==o.change&&(t.hasPendingMacrotasks=o.macroTask))},onHandleError:(e,r,s,o)=>(e.handleError(s,o),t.runOutsideAngular(()=>t.onError.emit(o)),!1)})}(s)}static isInAngularZone(){return typeof Zone<"u"&&!0===Zone.current.get("isAngularZone")}static assertInAngularZone(){if(!ur.isInAngularZone())throw new Xe(909,!1)}static assertNotInAngularZone(){if(ur.isInAngularZone())throw new Xe(909,!1)}run(n,e,r){return this._inner.run(n,e,r)}runTask(n,e,r,s){const o=this._inner,i=o.scheduleEventTask("NgZoneEvent: "+s,n,t6,Fm,Fm);try{return o.runTask(i,e,r)}finally{o.cancelTask(i)}}runGuarded(n,e,r){return this._inner.runGuarded(n,e,r)}runOutsideAngular(n){return this._outer.run(n)}}const t6={};function jx(t){if(0==t._nesting&&!t.hasPendingMicrotasks&&!t.isStable)try{t._nesting++,t.onMicrotaskEmpty.emit(null)}finally{if(t._nesting--,!t.hasPendingMicrotasks)try{t.runOutsideAngular(()=>t.onStable.emit(null))}finally{t.isStable=!0}}}function qx(t){t.hasPendingMicrotasks=!!(t._hasPendingMicrotasks||(t.shouldCoalesceEventChangeDetection||t.shouldCoalesceRunChangeDetection)&&-1!==t.lastRequestAnimationFrameId)}function EA(t){t._nesting++,t.isStable&&(t.isStable=!1,t.onUnstable.emit(null))}function NA(t){t._nesting--,jx(t)}class s6{constructor(){this.hasPendingMicrotasks=!1,this.hasPendingMacrotasks=!1,this.isStable=!0,this.onUnstable=new nn,this.onMicrotaskEmpty=new nn,this.onStable=new nn,this.onError=new nn}run(n,e,r){return n.apply(e,r)}runGuarded(n,e,r){return n.apply(e,r)}runOutsideAngular(n){return n()}runTask(n,e,r,s){return n.apply(e,r)}}const AA=new Ct(""),Mm=new Ct("");let Yx,Kx=(()=>{class t{constructor(e,r,s){this._ngZone=e,this.registry=r,this._pendingCount=0,this._isZoneStable=!0,this._didWork=!1,this._callbacks=[],this.taskTrackingZone=null,Yx||(function o6(t){Yx=t}(s),s.addToWindow(r)),this._watchAngularEvents(),e.run(()=>{this.taskTrackingZone=typeof Zone>"u"?null:Zone.current.get("TaskTrackingZone")})}_watchAngularEvents(){this._ngZone.onUnstable.subscribe({next:()=>{this._didWork=!0,this._isZoneStable=!1}}),this._ngZone.runOutsideAngular(()=>{this._ngZone.onStable.subscribe({next:()=>{ur.assertNotInAngularZone(),Hx(()=>{this._isZoneStable=!0,this._runCallbacksIfReady()})}})})}increasePendingRequestCount(){return this._pendingCount+=1,this._didWork=!0,this._pendingCount}decreasePendingRequestCount(){if(this._pendingCount-=1,this._pendingCount<0)throw new Error("pending async requests below zero");return this._runCallbacksIfReady(),this._pendingCount}isStable(){return this._isZoneStable&&0===this._pendingCount&&!this._ngZone.hasPendingMacrotasks}_runCallbacksIfReady(){if(this.isStable())Hx(()=>{for(;0!==this._callbacks.length;){let e=this._callbacks.pop();clearTimeout(e.timeoutId),e.doneCb(this._didWork)}this._didWork=!1});else{let e=this.getPendingTasks();this._callbacks=this._callbacks.filter(r=>!r.updateCb||!r.updateCb(e)||(clearTimeout(r.timeoutId),!1)),this._didWork=!0}}getPendingTasks(){return this.taskTrackingZone?this.taskTrackingZone.macroTasks.map(e=>({source:e.source,creationLocation:e.creationLocation,data:e.data})):[]}addCallback(e,r,s){let o=-1;r&&r>0&&(o=setTimeout(()=>{this._callbacks=this._callbacks.filter(i=>i.timeoutId!==o),e(this._didWork,this.getPendingTasks())},r)),this._callbacks.push({doneCb:e,timeoutId:o,updateCb:s})}whenStable(e,r,s){if(s&&!this.taskTrackingZone)throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?');this.addCallback(e,r,s),this._runCallbacksIfReady()}getPendingRequestCount(){return this._pendingCount}registerApplication(e){this.registry.registerApplication(e,this)}unregisterApplication(e){this.registry.unregisterApplication(e)}findProviders(e,r,s){return[]}}return t.\u0275fac=function(e){return new(e||t)(Et(ur),Et(Xx),Et(Mm))},t.\u0275prov=kt({token:t,factory:t.\u0275fac}),t})(),Xx=(()=>{class t{constructor(){this._applications=new Map}registerApplication(e,r){this._applications.set(e,r)}unregisterApplication(e){this._applications.delete(e)}unregisterAllApplications(){this._applications.clear()}getTestability(e){return this._applications.get(e)||null}getAllTestabilities(){return Array.from(this._applications.values())}getAllRootElements(){return Array.from(this._applications.keys())}findTestabilityInTree(e,r=!0){return Yx?.findTestabilityInTree(this,e,r)??null}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=kt({token:t,factory:t.\u0275fac,providedIn:"platform"}),t})();const na=!1;let Ia=null;const RA=new Ct("AllowMultipleToken"),Zx=new Ct("PlatformDestroyListeners"),FA=new Ct("appBootstrapListener");class OA{constructor(n,e){this.name=n,this.token=e}}function MA(t,n,e=[]){const r=`Platform: ${n}`,s=new Ct(r);return(o=[])=>{let i=Qx();if(!i||i.injector.get(RA,!1)){const a=[...e,...o,{provide:s,useValue:!0}];t?t(a):function l6(t){if(Ia&&!Ia.get(RA,!1))throw new Xe(400,!1);Ia=t;const n=t.get(LA);(function PA(t){const n=t.get(IA,null);n&&n.forEach(e=>e())})(t)}(function $A(t=[],n){return Ds.create({name:n,providers:[{provide:L0,useValue:"platform"},{provide:Zx,useValue:new Set([()=>Ia=null])},...t]})}(a,r))}return function c6(t){const n=Qx();if(!n)throw new Xe(401,!1);return n}()}}function Qx(){return Ia?.get(LA)??null}let LA=(()=>{class t{constructor(e){this._injector=e,this._modules=[],this._destroyListeners=[],this._destroyed=!1}bootstrapModuleFactory(e,r){const s=function BA(t,n){let e;return e="noop"===t?new s6:("zone.js"===t?void 0:t)||new ur(n),e}(r?.ngZone,function VA(t){return{enableLongStackTrace:!1,shouldCoalesceEventChangeDetection:!(!t||!t.ngZoneEventCoalescing)||!1,shouldCoalesceRunChangeDetection:!(!t||!t.ngZoneRunCoalescing)||!1}}(r)),o=[{provide:ur,useValue:s}];return s.run(()=>{const i=Ds.create({providers:o,parent:this.injector,name:e.moduleType.name}),a=e.create(i),l=a.injector.get(Gu,null);if(!l)throw new Xe(402,!1);return s.runOutsideAngular(()=>{const u=s.onError.subscribe({next:c=>{l.handleError(c)}});a.onDestroy(()=>{$m(this._modules,a),u.unsubscribe()})}),function zA(t,n,e){try{const r=e();return Wd(r)?r.catch(s=>{throw n.runOutsideAngular(()=>t.handleError(s)),s}):r}catch(r){throw n.runOutsideAngular(()=>t.handleError(r)),r}}(l,s,()=>{const u=a.injector.get(Pm);return u.runInitializers(),u.donePromise.then(()=>(function hN(t){bo(t,"Expected localeId to be defined"),"string"==typeof t&&(dN=t.toLowerCase().replace(/_/g,"-"))}(a.injector.get(ta,oc)||oc),this._moduleDoBootstrap(a),a))})})}bootstrapModule(e,r=[]){const s=UA({},r);return function i6(t,n,e){const r=new kx(e);return Promise.resolve(r)}(0,0,e).then(o=>this.bootstrapModuleFactory(o,s))}_moduleDoBootstrap(e){const r=e.injector.get(eh);if(e._bootstrapComponents.length>0)e._bootstrapComponents.forEach(s=>r.bootstrap(s));else{if(!e.instance.ngDoBootstrap)throw new Xe(-403,!1);e.instance.ngDoBootstrap(r)}this._modules.push(e)}onDestroy(e){this._destroyListeners.push(e)}get injector(){return this._injector}destroy(){if(this._destroyed)throw new Xe(404,!1);this._modules.slice().forEach(r=>r.destroy()),this._destroyListeners.forEach(r=>r());const e=this._injector.get(Zx,null);e&&(e.forEach(r=>r()),e.clear()),this._destroyed=!0}get destroyed(){return this._destroyed}}return t.\u0275fac=function(e){return new(e||t)(Et(Ds))},t.\u0275prov=kt({token:t,factory:t.\u0275fac,providedIn:"platform"}),t})();function UA(t,n){return Array.isArray(n)?n.reduce(UA,t):{...t,...n}}let eh=(()=>{class t{get destroyed(){return this._destroyed}get injector(){return this._injector}constructor(e,r,s){this._zone=e,this._injector=r,this._exceptionHandler=s,this._bootstrapListeners=[],this._views=[],this._runningTick=!1,this._stable=!0,this._destroyed=!1,this._destroyListeners=[],this.componentTypes=[],this.components=[],this._onMicrotaskEmptySubscription=this._zone.onMicrotaskEmpty.subscribe({next:()=>{this._zone.run(()=>{this.tick()})}});const o=new Ve(a=>{this._stable=this._zone.isStable&&!this._zone.hasPendingMacrotasks&&!this._zone.hasPendingMicrotasks,this._zone.runOutsideAngular(()=>{a.next(this._stable),a.complete()})}),i=new Ve(a=>{let l;this._zone.runOutsideAngular(()=>{l=this._zone.onStable.subscribe(()=>{ur.assertNotInAngularZone(),Hx(()=>{!this._stable&&!this._zone.hasPendingMacrotasks&&!this._zone.hasPendingMicrotasks&&(this._stable=!0,a.next(!0))})})});const u=this._zone.onUnstable.subscribe(()=>{ur.assertInAngularZone(),this._stable&&(this._stable=!1,this._zone.runOutsideAngular(()=>{a.next(!1)}))});return()=>{l.unsubscribe(),u.unsubscribe()}});this.isStable=function bz(...t){const n=pd(t),e=function hz(t,n){return"number"==typeof Db(t)?t.pop():n}(t,1/0),r=t;return r.length?1===r.length?vo(r[0]):_u(e)(_r(r,n)):di}(o,i.pipe(function xz(t={}){const{connector:n=(()=>new Zt),resetOnError:e=!0,resetOnComplete:r=!0,resetOnRefCountZero:s=!0}=t;return o=>{let i,a,l,u=0,c=!1,d=!1;const h=()=>{a?.unsubscribe(),a=void 0},p=()=>{h(),i=l=void 0,c=d=!1},f=()=>{const g=i;p(),g?.unsubscribe()};return In((g,m)=>{u++,!d&&!c&&h();const y=l=l??n();m.add(()=>{u--,0===u&&!d&&!c&&(a=Tb(f,s))}),y.subscribe(m),!i&&u>0&&(i=new ue({next:v=>y.next(v),error:v=>{d=!0,h(),a=Tb(p,e,v),y.error(v)},complete:()=>{c=!0,h(),a=Tb(p,r),y.complete()}}),vo(g).subscribe(i))})(o)}}()))}bootstrap(e,r){const s=e instanceof vk;if(!this._injector.get(Pm).done){!s&&function Su(t){const n=_n(t)||os(t)||Ls(t);return null!==n&&n.standalone}(e);throw new Xe(405,na)}let i;i=s?e:this._injector.get(Uu).resolveComponentFactory(e),this.componentTypes.push(i.componentType);const a=function a6(t){return t.isBoundToModule}(i)?void 0:this._injector.get(ic),u=i.create(Ds.NULL,[],r||i.selector,a),c=u.location.nativeElement,d=u.injector.get(AA,null);return d?.registerApplication(c),u.onDestroy(()=>{this.detachView(u.hostView),$m(this.components,u),d?.unregisterApplication(c)}),this._loadComponent(u),u}tick(){if(this._runningTick)throw new Xe(101,!1);try{this._runningTick=!0;for(let e of this._views)e.detectChanges()}catch(e){this._zone.runOutsideAngular(()=>this._exceptionHandler.handleError(e))}finally{this._runningTick=!1}}attachView(e){const r=e;this._views.push(r),r.attachToAppRef(this)}detachView(e){const r=e;$m(this._views,r),r.detachFromAppRef()}_loadComponent(e){this.attachView(e.hostView),this.tick(),this.components.push(e);const r=this._injector.get(FA,[]);r.push(...this._bootstrapListeners),r.forEach(s=>s(e))}ngOnDestroy(){if(!this._destroyed)try{this._destroyListeners.forEach(e=>e()),this._views.slice().forEach(e=>e.destroy()),this._onMicrotaskEmptySubscription.unsubscribe()}finally{this._destroyed=!0,this._views=[],this._bootstrapListeners=[],this._destroyListeners=[]}}onDestroy(e){return this._destroyListeners.push(e),()=>$m(this._destroyListeners,e)}destroy(){if(this._destroyed)throw new Xe(406,!1);const e=this._injector;e.destroy&&!e.destroyed&&e.destroy()}get viewCount(){return this._views.length}warnIfDestroyed(){}}return t.\u0275fac=function(e){return new(e||t)(Et(ur),Et(Yi),Et(Gu))},t.\u0275prov=kt({token:t,factory:t.\u0275fac,providedIn:"root"}),t})();function $m(t,n){const e=t.indexOf(n);e>-1&&t.splice(e,1)}let th=(()=>{class t{}return t.__NG_ELEMENT_ID__=h6,t})();function h6(t){return function p6(t,n,e){if(wd(t)&&!e){const r=no(t.index,n);return new Bd(r,r)}return 47&t.type?new Bd(n[as],n):null}(Zr(),Le(),16==(16&t))}class qA{constructor(){}supports(n){return xm(n)}create(n){return new b6(n)}}const v6=(t,n)=>n;class b6{constructor(n){this.length=0,this._linkedRecords=null,this._unlinkedRecords=null,this._previousItHead=null,this._itHead=null,this._itTail=null,this._additionsHead=null,this._additionsTail=null,this._movesHead=null,this._movesTail=null,this._removalsHead=null,this._removalsTail=null,this._identityChangesHead=null,this._identityChangesTail=null,this._trackByFn=n||v6}forEachItem(n){let e;for(e=this._itHead;null!==e;e=e._next)n(e)}forEachOperation(n){let e=this._itHead,r=this._removalsHead,s=0,o=null;for(;e||r;){const i=!r||e&&e.currentIndex<XA(r,s,o)?e:r,a=XA(i,s,o),l=i.currentIndex;if(i===r)s--,r=r._nextRemoved;else if(e=e._next,null==i.previousIndex)s++;else{o||(o=[]);const u=a-s,c=l-s;if(u!=c){for(let h=0;h<u;h++){const p=h<o.length?o[h]:o[h]=0,f=p+h;c<=f&&f<u&&(o[h]=p+1)}o[i.previousIndex]=c-u}}a!==l&&n(i,a,l)}}forEachPreviousItem(n){let e;for(e=this._previousItHead;null!==e;e=e._nextPrevious)n(e)}forEachAddedItem(n){let e;for(e=this._additionsHead;null!==e;e=e._nextAdded)n(e)}forEachMovedItem(n){let e;for(e=this._movesHead;null!==e;e=e._nextMoved)n(e)}forEachRemovedItem(n){let e;for(e=this._removalsHead;null!==e;e=e._nextRemoved)n(e)}forEachIdentityChange(n){let e;for(e=this._identityChangesHead;null!==e;e=e._nextIdentityChange)n(e)}diff(n){if(null==n&&(n=[]),!xm(n))throw new Xe(900,!1);return this.check(n)?this:null}onDestroy(){}check(n){this._reset();let s,o,i,e=this._itHead,r=!1;if(Array.isArray(n)){this.length=n.length;for(let a=0;a<this.length;a++)o=n[a],i=this._trackByFn(a,o),null!==e&&Object.is(e.trackById,i)?(r&&(e=this._verifyReinsertion(e,o,i,a)),Object.is(e.item,o)||this._addIdentityChange(e,o)):(e=this._mismatch(e,o,i,a),r=!0),e=e._next}else s=0,function XG(t,n){if(Array.isArray(t))for(let e=0;e<t.length;e++)n(t[e]);else{const e=t[Symbol.iterator]();let r;for(;!(r=e.next()).done;)n(r.value)}}(n,a=>{i=this._trackByFn(s,a),null!==e&&Object.is(e.trackById,i)?(r&&(e=this._verifyReinsertion(e,a,i,s)),Object.is(e.item,a)||this._addIdentityChange(e,a)):(e=this._mismatch(e,a,i,s),r=!0),e=e._next,s++}),this.length=s;return this._truncate(e),this.collection=n,this.isDirty}get isDirty(){return null!==this._additionsHead||null!==this._movesHead||null!==this._removalsHead||null!==this._identityChangesHead}_reset(){if(this.isDirty){let n;for(n=this._previousItHead=this._itHead;null!==n;n=n._next)n._nextPrevious=n._next;for(n=this._additionsHead;null!==n;n=n._nextAdded)n.previousIndex=n.currentIndex;for(this._additionsHead=this._additionsTail=null,n=this._movesHead;null!==n;n=n._nextMoved)n.previousIndex=n.currentIndex;this._movesHead=this._movesTail=null,this._removalsHead=this._removalsTail=null,this._identityChangesHead=this._identityChangesTail=null}}_mismatch(n,e,r,s){let o;return null===n?o=this._itTail:(o=n._prev,this._remove(n)),null!==(n=null===this._unlinkedRecords?null:this._unlinkedRecords.get(r,null))?(Object.is(n.item,e)||this._addIdentityChange(n,e),this._reinsertAfter(n,o,s)):null!==(n=null===this._linkedRecords?null:this._linkedRecords.get(r,s))?(Object.is(n.item,e)||this._addIdentityChange(n,e),this._moveAfter(n,o,s)):n=this._addAfter(new x6(e,r),o,s),n}_verifyReinsertion(n,e,r,s){let o=null===this._unlinkedRecords?null:this._unlinkedRecords.get(r,null);return null!==o?n=this._reinsertAfter(o,n._prev,s):n.currentIndex!=s&&(n.currentIndex=s,this._addToMoves(n,s)),n}_truncate(n){for(;null!==n;){const e=n._next;this._addToRemovals(this._unlink(n)),n=e}null!==this._unlinkedRecords&&this._unlinkedRecords.clear(),null!==this._additionsTail&&(this._additionsTail._nextAdded=null),null!==this._movesTail&&(this._movesTail._nextMoved=null),null!==this._itTail&&(this._itTail._next=null),null!==this._removalsTail&&(this._removalsTail._nextRemoved=null),null!==this._identityChangesTail&&(this._identityChangesTail._nextIdentityChange=null)}_reinsertAfter(n,e,r){null!==this._unlinkedRecords&&this._unlinkedRecords.remove(n);const s=n._prevRemoved,o=n._nextRemoved;return null===s?this._removalsHead=o:s._nextRemoved=o,null===o?this._removalsTail=s:o._prevRemoved=s,this._insertAfter(n,e,r),this._addToMoves(n,r),n}_moveAfter(n,e,r){return this._unlink(n),this._insertAfter(n,e,r),this._addToMoves(n,r),n}_addAfter(n,e,r){return this._insertAfter(n,e,r),this._additionsTail=null===this._additionsTail?this._additionsHead=n:this._additionsTail._nextAdded=n,n}_insertAfter(n,e,r){const s=null===e?this._itHead:e._next;return n._next=s,n._prev=e,null===s?this._itTail=n:s._prev=n,null===e?this._itHead=n:e._next=n,null===this._linkedRecords&&(this._linkedRecords=new KA),this._linkedRecords.put(n),n.currentIndex=r,n}_remove(n){return this._addToRemovals(this._unlink(n))}_unlink(n){null!==this._linkedRecords&&this._linkedRecords.remove(n);const e=n._prev,r=n._next;return null===e?this._itHead=r:e._next=r,null===r?this._itTail=e:r._prev=e,n}_addToMoves(n,e){return n.previousIndex===e||(this._movesTail=null===this._movesTail?this._movesHead=n:this._movesTail._nextMoved=n),n}_addToRemovals(n){return null===this._unlinkedRecords&&(this._unlinkedRecords=new KA),this._unlinkedRecords.put(n),n.currentIndex=null,n._nextRemoved=null,null===this._removalsTail?(this._removalsTail=this._removalsHead=n,n._prevRemoved=null):(n._prevRemoved=this._removalsTail,this._removalsTail=this._removalsTail._nextRemoved=n),n}_addIdentityChange(n,e){return n.item=e,this._identityChangesTail=null===this._identityChangesTail?this._identityChangesHead=n:this._identityChangesTail._nextIdentityChange=n,n}}class x6{constructor(n,e){this.item=n,this.trackById=e,this.currentIndex=null,this.previousIndex=null,this._nextPrevious=null,this._prev=null,this._next=null,this._prevDup=null,this._nextDup=null,this._prevRemoved=null,this._nextRemoved=null,this._nextAdded=null,this._nextMoved=null,this._nextIdentityChange=null}}class w6{constructor(){this._head=null,this._tail=null}add(n){null===this._head?(this._head=this._tail=n,n._nextDup=null,n._prevDup=null):(this._tail._nextDup=n,n._prevDup=this._tail,n._nextDup=null,this._tail=n)}get(n,e){let r;for(r=this._head;null!==r;r=r._nextDup)if((null===e||e<=r.currentIndex)&&Object.is(r.trackById,n))return r;return null}remove(n){const e=n._prevDup,r=n._nextDup;return null===e?this._head=r:e._nextDup=r,null===r?this._tail=e:r._prevDup=e,null===this._head}}class KA{constructor(){this.map=new Map}put(n){const e=n.trackById;let r=this.map.get(e);r||(r=new w6,this.map.set(e,r)),r.add(n)}get(n,e){const s=this.map.get(n);return s?s.get(n,e):null}remove(n){const e=n.trackById;return this.map.get(e).remove(n)&&this.map.delete(e),n}get isEmpty(){return 0===this.map.size}clear(){this.map.clear()}}function XA(t,n,e){const r=t.previousIndex;if(null===r)return r;let s=0;return e&&r<e.length&&(s=e[r]),r+n+s}class YA{constructor(){}supports(n){return n instanceof Map||cx(n)}create(){return new _6}}class _6{constructor(){this._records=new Map,this._mapHead=null,this._appendAfter=null,this._previousMapHead=null,this._changesHead=null,this._changesTail=null,this._additionsHead=null,this._additionsTail=null,this._removalsHead=null,this._removalsTail=null}get isDirty(){return null!==this._additionsHead||null!==this._changesHead||null!==this._removalsHead}forEachItem(n){let e;for(e=this._mapHead;null!==e;e=e._next)n(e)}forEachPreviousItem(n){let e;for(e=this._previousMapHead;null!==e;e=e._nextPrevious)n(e)}forEachChangedItem(n){let e;for(e=this._changesHead;null!==e;e=e._nextChanged)n(e)}forEachAddedItem(n){let e;for(e=this._additionsHead;null!==e;e=e._nextAdded)n(e)}forEachRemovedItem(n){let e;for(e=this._removalsHead;null!==e;e=e._nextRemoved)n(e)}diff(n){if(n){if(!(n instanceof Map||cx(n)))throw new Xe(900,!1)}else n=new Map;return this.check(n)?this:null}onDestroy(){}check(n){this._reset();let e=this._mapHead;if(this._appendAfter=null,this._forEach(n,(r,s)=>{if(e&&e.key===s)this._maybeAddToChanges(e,r),this._appendAfter=e,e=e._next;else{const o=this._getOrCreateRecordForKey(s,r);e=this._insertBeforeOrAppend(e,o)}}),e){e._prev&&(e._prev._next=null),this._removalsHead=e;for(let r=e;null!==r;r=r._nextRemoved)r===this._mapHead&&(this._mapHead=null),this._records.delete(r.key),r._nextRemoved=r._next,r.previousValue=r.currentValue,r.currentValue=null,r._prev=null,r._next=null}return this._changesTail&&(this._changesTail._nextChanged=null),this._additionsTail&&(this._additionsTail._nextAdded=null),this.isDirty}_insertBeforeOrAppend(n,e){if(n){const r=n._prev;return e._next=n,e._prev=r,n._prev=e,r&&(r._next=e),n===this._mapHead&&(this._mapHead=e),this._appendAfter=n,n}return this._appendAfter?(this._appendAfter._next=e,e._prev=this._appendAfter):this._mapHead=e,this._appendAfter=e,null}_getOrCreateRecordForKey(n,e){if(this._records.has(n)){const s=this._records.get(n);this._maybeAddToChanges(s,e);const o=s._prev,i=s._next;return o&&(o._next=i),i&&(i._prev=o),s._next=null,s._prev=null,s}const r=new C6(n);return this._records.set(n,r),r.currentValue=e,this._addToAdditions(r),r}_reset(){if(this.isDirty){let n;for(this._previousMapHead=this._mapHead,n=this._previousMapHead;null!==n;n=n._next)n._nextPrevious=n._next;for(n=this._changesHead;null!==n;n=n._nextChanged)n.previousValue=n.currentValue;for(n=this._additionsHead;null!=n;n=n._nextAdded)n.previousValue=n.currentValue;this._changesHead=this._changesTail=null,this._additionsHead=this._additionsTail=null,this._removalsHead=null}}_maybeAddToChanges(n,e){Object.is(e,n.currentValue)||(n.previousValue=n.currentValue,n.currentValue=e,this._addToChanges(n))}_addToAdditions(n){null===this._additionsHead?this._additionsHead=this._additionsTail=n:(this._additionsTail._nextAdded=n,this._additionsTail=n)}_addToChanges(n){null===this._changesHead?this._changesHead=this._changesTail=n:(this._changesTail._nextChanged=n,this._changesTail=n)}_forEach(n,e){n instanceof Map?n.forEach(e):Object.keys(n).forEach(r=>e(n[r],r))}}class C6{constructor(n){this.key=n,this.previousValue=null,this.currentValue=null,this._nextPrevious=null,this._next=null,this._prev=null,this._nextAdded=null,this._nextRemoved=null,this._nextChanged=null}}function ZA(){return new Bm([new qA])}let Bm=(()=>{class t{constructor(e){this.factories=e}static create(e,r){if(null!=r){const s=r.factories.slice();e=e.concat(s)}return new t(e)}static extend(e){return{provide:t,useFactory:r=>t.create(e,r||ZA()),deps:[[t,new Ed,new kd]]}}find(e){const r=this.factories.find(s=>s.supports(e));if(null!=r)return r;throw new Xe(901,!1)}}return t.\u0275prov=kt({token:t,providedIn:"root",factory:ZA}),t})();function QA(){return new nh([new YA])}let nh=(()=>{class t{constructor(e){this.factories=e}static create(e,r){if(r){const s=r.factories.slice();e=e.concat(s)}return new t(e)}static extend(e){return{provide:t,useFactory:r=>t.create(e,r||QA()),deps:[[t,new Ed,new kd]]}}find(e){const r=this.factories.find(s=>s.supports(e));if(r)return r;throw new Xe(901,!1)}}return t.\u0275prov=kt({token:t,providedIn:"root",factory:QA}),t})();const D6=MA(null,"core",[]);let T6=(()=>{class t{constructor(e){}}return t.\u0275fac=function(e){return new(e||t)(Et(eh))},t.\u0275mod=wo({type:t}),t.\u0275inj=Zs({}),t})();let rw=null;function ra(){return rw}class N6{}const Ns=new Ct("DocumentToken");let sw=(()=>{class t{historyGo(e){throw new Error("Not implemented")}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=kt({token:t,factory:function(){return function A6(){return Et(JA)}()},providedIn:"platform"}),t})();const R6=new Ct("Location Initialized");let JA=(()=>{class t extends sw{constructor(e){super(),this._doc=e,this._location=window.location,this._history=window.history}getBaseHrefFromDOM(){return ra().getBaseHref(this._doc)}onPopState(e){const r=ra().getGlobalEventTarget(this._doc,"window");return r.addEventListener("popstate",e,!1),()=>r.removeEventListener("popstate",e)}onHashChange(e){const r=ra().getGlobalEventTarget(this._doc,"window");return r.addEventListener("hashchange",e,!1),()=>r.removeEventListener("hashchange",e)}get href(){return this._location.href}get protocol(){return this._location.protocol}get hostname(){return this._location.hostname}get port(){return this._location.port}get pathname(){return this._location.pathname}get search(){return this._location.search}get hash(){return this._location.hash}set pathname(e){this._location.pathname=e}pushState(e,r,s){e2()?this._history.pushState(e,r,s):this._location.hash=s}replaceState(e,r,s){e2()?this._history.replaceState(e,r,s):this._location.hash=s}forward(){this._history.forward()}back(){this._history.back()}historyGo(e=0){this._history.go(e)}getState(){return this._history.state}}return t.\u0275fac=function(e){return new(e||t)(Et(Ns))},t.\u0275prov=kt({token:t,factory:function(){return function F6(){return new JA(Et(Ns))}()},providedIn:"platform"}),t})();function e2(){return!!window.history.pushState}function ow(t,n){if(0==t.length)return n;if(0==n.length)return t;let e=0;return t.endsWith("/")&&e++,n.startsWith("/")&&e++,2==e?t+n.substring(1):1==e?t+n:t+"/"+n}function t2(t){const n=t.match(/#|\?|$/),e=n&&n.index||t.length;return t.slice(0,e-("/"===t[e-1]?1:0))+t.slice(e)}function sa(t){return t&&"?"!==t[0]?"?"+t:t}let Fl=(()=>{class t{historyGo(e){throw new Error("Not implemented")}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=kt({token:t,factory:function(){return cn(r2)},providedIn:"root"}),t})();const n2=new Ct("appBaseHref");let r2=(()=>{class t extends Fl{constructor(e,r){super(),this._platformLocation=e,this._removeListenerFns=[],this._baseHref=r??this._platformLocation.getBaseHrefFromDOM()??cn(Ns).location?.origin??""}ngOnDestroy(){for(;this._removeListenerFns.length;)this._removeListenerFns.pop()()}onPopState(e){this._removeListenerFns.push(this._platformLocation.onPopState(e),this._platformLocation.onHashChange(e))}getBaseHref(){return this._baseHref}prepareExternalUrl(e){return ow(this._baseHref,e)}path(e=!1){const r=this._platformLocation.pathname+sa(this._platformLocation.search),s=this._platformLocation.hash;return s&&e?`${r}${s}`:r}pushState(e,r,s,o){const i=this.prepareExternalUrl(s+sa(o));this._platformLocation.pushState(e,r,i)}replaceState(e,r,s,o){const i=this.prepareExternalUrl(s+sa(o));this._platformLocation.replaceState(e,r,i)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}getState(){return this._platformLocation.getState()}historyGo(e=0){this._platformLocation.historyGo?.(e)}}return t.\u0275fac=function(e){return new(e||t)(Et(sw),Et(n2,8))},t.\u0275prov=kt({token:t,factory:t.\u0275fac,providedIn:"root"}),t})(),O6=(()=>{class t extends Fl{constructor(e,r){super(),this._platformLocation=e,this._baseHref="",this._removeListenerFns=[],null!=r&&(this._baseHref=r)}ngOnDestroy(){for(;this._removeListenerFns.length;)this._removeListenerFns.pop()()}onPopState(e){this._removeListenerFns.push(this._platformLocation.onPopState(e),this._platformLocation.onHashChange(e))}getBaseHref(){return this._baseHref}path(e=!1){let r=this._platformLocation.hash;return null==r&&(r="#"),r.length>0?r.substring(1):r}prepareExternalUrl(e){const r=ow(this._baseHref,e);return r.length>0?"#"+r:r}pushState(e,r,s,o){let i=this.prepareExternalUrl(s+sa(o));0==i.length&&(i=this._platformLocation.pathname),this._platformLocation.pushState(e,r,i)}replaceState(e,r,s,o){let i=this.prepareExternalUrl(s+sa(o));0==i.length&&(i=this._platformLocation.pathname),this._platformLocation.replaceState(e,r,i)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}getState(){return this._platformLocation.getState()}historyGo(e=0){this._platformLocation.historyGo?.(e)}}return t.\u0275fac=function(e){return new(e||t)(Et(sw),Et(n2,8))},t.\u0275prov=kt({token:t,factory:t.\u0275fac}),t})(),iw=(()=>{class t{constructor(e){this._subject=new nn,this._urlChangeListeners=[],this._urlChangeSubscription=null,this._locationStrategy=e;const r=this._locationStrategy.getBaseHref();this._basePath=function $6(t){if(new RegExp("^(https?:)?//").test(t)){const[,e]=t.split(/\/\/[^\/]+/);return e}return t}(t2(s2(r))),this._locationStrategy.onPopState(s=>{this._subject.emit({url:this.path(!0),pop:!0,state:s.state,type:s.type})})}ngOnDestroy(){this._urlChangeSubscription?.unsubscribe(),this._urlChangeListeners=[]}path(e=!1){return this.normalize(this._locationStrategy.path(e))}getState(){return this._locationStrategy.getState()}isCurrentPathEqualTo(e,r=""){return this.path()==this.normalize(e+sa(r))}normalize(e){return t.stripTrailingSlash(function M6(t,n){if(!t||!n.startsWith(t))return n;const e=n.substring(t.length);return""===e||["/",";","?","#"].includes(e[0])?e:n}(this._basePath,s2(e)))}prepareExternalUrl(e){return e&&"/"!==e[0]&&(e="/"+e),this._locationStrategy.prepareExternalUrl(e)}go(e,r="",s=null){this._locationStrategy.pushState(s,"",e,r),this._notifyUrlChangeListeners(this.prepareExternalUrl(e+sa(r)),s)}replaceState(e,r="",s=null){this._locationStrategy.replaceState(s,"",e,r),this._notifyUrlChangeListeners(this.prepareExternalUrl(e+sa(r)),s)}forward(){this._locationStrategy.forward()}back(){this._locationStrategy.back()}historyGo(e=0){this._locationStrategy.historyGo?.(e)}onUrlChange(e){return this._urlChangeListeners.push(e),this._urlChangeSubscription||(this._urlChangeSubscription=this.subscribe(r=>{this._notifyUrlChangeListeners(r.url,r.state)})),()=>{const r=this._urlChangeListeners.indexOf(e);this._urlChangeListeners.splice(r,1),0===this._urlChangeListeners.length&&(this._urlChangeSubscription?.unsubscribe(),this._urlChangeSubscription=null)}}_notifyUrlChangeListeners(e="",r){this._urlChangeListeners.forEach(s=>s(e,r))}subscribe(e,r,s){return this._subject.subscribe({next:e,error:r,complete:s})}}return t.normalizeQueryParams=sa,t.joinWithSlash=ow,t.stripTrailingSlash=t2,t.\u0275fac=function(e){return new(e||t)(Et(Fl))},t.\u0275prov=kt({token:t,factory:function(){return function P6(){return new iw(Et(Fl))}()},providedIn:"root"}),t})();function s2(t){return t.replace(/\/index.html$/,"")}const gw=/\s+/,p2=[];let f2=(()=>{class t{constructor(e,r,s,o){this._iterableDiffers=e,this._keyValueDiffers=r,this._ngEl=s,this._renderer=o,this.initialClasses=p2,this.stateMap=new Map}set klass(e){this.initialClasses=null!=e?e.trim().split(gw):p2}set ngClass(e){this.rawClass="string"==typeof e?e.trim().split(gw):e}ngDoCheck(){for(const r of this.initialClasses)this._updateState(r,!0);const e=this.rawClass;if(Array.isArray(e)||e instanceof Set)for(const r of e)this._updateState(r,!0);else if(null!=e)for(const r of Object.keys(e))this._updateState(r,Boolean(e[r]));this._applyStateDiff()}_updateState(e,r){const s=this.stateMap.get(e);void 0!==s?(s.enabled!==r&&(s.changed=!0,s.enabled=r),s.touched=!0):this.stateMap.set(e,{enabled:r,changed:!0,touched:!0})}_applyStateDiff(){for(const e of this.stateMap){const r=e[0],s=e[1];s.changed?(this._toggleClass(r,s.enabled),s.changed=!1):s.touched||(s.enabled&&this._toggleClass(r,!1),this.stateMap.delete(r)),s.touched=!1}}_toggleClass(e,r){(e=e.trim()).length>0&&e.split(gw).forEach(s=>{r?this._renderer.addClass(this._ngEl.nativeElement,s):this._renderer.removeClass(this._ngEl.nativeElement,s)})}}return t.\u0275fac=function(e){return new(e||t)(Pe(Bm),Pe(nh),Pe(us),Pe(Zi))},t.\u0275dir=Pt({type:t,selectors:[["","ngClass",""]],inputs:{klass:["class","klass"],ngClass:"ngClass"},standalone:!0}),t})();class _8{constructor(n,e,r,s){this.$implicit=n,this.ngForOf=e,this.index=r,this.count=s}get first(){return 0===this.index}get last(){return this.index===this.count-1}get even(){return this.index%2==0}get odd(){return!this.even}}let Ym=(()=>{class t{set ngForOf(e){this._ngForOf=e,this._ngForOfDirty=!0}set ngForTrackBy(e){this._trackByFn=e}get ngForTrackBy(){return this._trackByFn}constructor(e,r,s){this._viewContainer=e,this._template=r,this._differs=s,this._ngForOf=null,this._ngForOfDirty=!0,this._differ=null}set ngForTemplate(e){e&&(this._template=e)}ngDoCheck(){if(this._ngForOfDirty){this._ngForOfDirty=!1;const e=this._ngForOf;!this._differ&&e&&(this._differ=this._differs.find(e).create(this.ngForTrackBy))}if(this._differ){const e=this._differ.diff(this._ngForOf);e&&this._applyChanges(e)}}_applyChanges(e){const r=this._viewContainer;e.forEachOperation((s,o,i)=>{if(null==s.previousIndex)r.createEmbeddedView(this._template,new _8(s.item,this._ngForOf,-1,-1),null===i?void 0:i);else if(null==i)r.remove(null===o?void 0:o);else if(null!==o){const a=r.get(o);r.move(a,i),y2(a,s)}});for(let s=0,o=r.length;s<o;s++){const a=r.get(s).context;a.index=s,a.count=o,a.ngForOf=this._ngForOf}e.forEachIdentityChange(s=>{y2(r.get(s.currentIndex),s)})}static ngTemplateContextGuard(e,r){return!0}}return t.\u0275fac=function(e){return new(e||t)(Pe(Do),Pe(ea),Pe(Bm))},t.\u0275dir=Pt({type:t,selectors:[["","ngFor","","ngForOf",""]],inputs:{ngForOf:"ngForOf",ngForTrackBy:"ngForTrackBy",ngForTemplate:"ngForTemplate"},standalone:!0}),t})();function y2(t,n){t.context.$implicit=n.item}let yw=(()=>{class t{constructor(e,r){this._viewContainer=e,this._context=new S8,this._thenTemplateRef=null,this._elseTemplateRef=null,this._thenViewRef=null,this._elseViewRef=null,this._thenTemplateRef=r}set ngIf(e){this._context.$implicit=this._context.ngIf=e,this._updateView()}set ngIfThen(e){v2("ngIfThen",e),this._thenTemplateRef=e,this._thenViewRef=null,this._updateView()}set ngIfElse(e){v2("ngIfElse",e),this._elseTemplateRef=e,this._elseViewRef=null,this._updateView()}_updateView(){this._context.$implicit?this._thenViewRef||(this._viewContainer.clear(),this._elseViewRef=null,this._thenTemplateRef&&(this._thenViewRef=this._viewContainer.createEmbeddedView(this._thenTemplateRef,this._context))):this._elseViewRef||(this._viewContainer.clear(),this._thenViewRef=null,this._elseTemplateRef&&(this._elseViewRef=this._viewContainer.createEmbeddedView(this._elseTemplateRef,this._context)))}static ngTemplateContextGuard(e,r){return!0}}return t.\u0275fac=function(e){return new(e||t)(Pe(Do),Pe(ea))},t.\u0275dir=Pt({type:t,selectors:[["","ngIf",""]],inputs:{ngIf:"ngIf",ngIfThen:"ngIfThen",ngIfElse:"ngIfElse"},standalone:!0}),t})();class S8{constructor(){this.$implicit=null,this.ngIf=null}}function v2(t,n){if(n&&!n.createEmbeddedView)throw new Error(`${t} must be a TemplateRef, but received '${Bn(n)}'.`)}let x2=(()=>{class t{constructor(e,r,s){this._ngEl=e,this._differs=r,this._renderer=s,this._ngStyle=null,this._differ=null}set ngStyle(e){this._ngStyle=e,!this._differ&&e&&(this._differ=this._differs.find(e).create())}ngDoCheck(){if(this._differ){const e=this._differ.diff(this._ngStyle);e&&this._applyChanges(e)}}_setStyle(e,r){const[s,o]=e.split("."),i=-1===s.indexOf("-")?void 0:Vs.DashCase;null!=r?this._renderer.setStyle(this._ngEl.nativeElement,s,o?`${r}${o}`:r,i):this._renderer.removeStyle(this._ngEl.nativeElement,s,i)}_applyChanges(e){e.forEachRemovedItem(r=>this._setStyle(r.key,null)),e.forEachAddedItem(r=>this._setStyle(r.key,r.currentValue)),e.forEachChangedItem(r=>this._setStyle(r.key,r.currentValue))}}return t.\u0275fac=function(e){return new(e||t)(Pe(us),Pe(nh),Pe(Zi))},t.\u0275dir=Pt({type:t,selectors:[["","ngStyle",""]],inputs:{ngStyle:"ngStyle"},standalone:!0}),t})(),w2=(()=>{class t{constructor(e){this._viewContainerRef=e,this._viewRef=null,this.ngTemplateOutletContext=null,this.ngTemplateOutlet=null,this.ngTemplateOutletInjector=null}ngOnChanges(e){if(e.ngTemplateOutlet||e.ngTemplateOutletInjector){const r=this._viewContainerRef;if(this._viewRef&&r.remove(r.indexOf(this._viewRef)),this.ngTemplateOutlet){const{ngTemplateOutlet:s,ngTemplateOutletContext:o,ngTemplateOutletInjector:i}=this;this._viewRef=r.createEmbeddedView(s,o,i?{injector:i}:void 0)}else this._viewRef=null}else this._viewRef&&e.ngTemplateOutletContext&&this.ngTemplateOutletContext&&(this._viewRef.context=this.ngTemplateOutletContext)}}return t.\u0275fac=function(e){return new(e||t)(Pe(Do))},t.\u0275dir=Pt({type:t,selectors:[["","ngTemplateOutlet",""]],inputs:{ngTemplateOutletContext:"ngTemplateOutletContext",ngTemplateOutlet:"ngTemplateOutlet",ngTemplateOutletInjector:"ngTemplateOutletInjector"},standalone:!0,features:[eo]}),t})(),C2=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=wo({type:t}),t.\u0275inj=Zs({}),t})();const S2="browser";let eq=(()=>{class t{}return t.\u0275prov=kt({token:t,providedIn:"root",factory:()=>new tq(Et(Ns),window)}),t})();class tq{constructor(n,e){this.document=n,this.window=e,this.offset=()=>[0,0]}setOffset(n){this.offset=Array.isArray(n)?()=>n:n}getScrollPosition(){return this.supportsScrolling()?[this.window.pageXOffset,this.window.pageYOffset]:[0,0]}scrollToPosition(n){this.supportsScrolling()&&this.window.scrollTo(n[0],n[1])}scrollToAnchor(n){if(!this.supportsScrolling())return;const e=function nq(t,n){const e=t.getElementById(n)||t.getElementsByName(n)[0];if(e)return e;if("function"==typeof t.createTreeWalker&&t.body&&(t.body.createShadowRoot||t.body.attachShadow)){const r=t.createTreeWalker(t.body,NodeFilter.SHOW_ELEMENT);let s=r.currentNode;for(;s;){const o=s.shadowRoot;if(o){const i=o.getElementById(n)||o.querySelector(`[name="${n}"]`);if(i)return i}s=r.nextNode()}}return null}(this.document,n);e&&(this.scrollToElement(e),e.focus())}setHistoryScrollRestoration(n){if(this.supportScrollRestoration()){const e=this.window.history;e&&e.scrollRestoration&&(e.scrollRestoration=n)}}scrollToElement(n){const e=n.getBoundingClientRect(),r=e.left+this.window.pageXOffset,s=e.top+this.window.pageYOffset,o=this.offset();this.window.scrollTo(r-o[0],s-o[1])}supportScrollRestoration(){try{if(!this.supportsScrolling())return!1;const n=I2(this.window.history)||I2(Object.getPrototypeOf(this.window.history));return!(!n||!n.writable&&!n.set)}catch{return!1}}supportsScrolling(){try{return!!this.window&&!!this.window.scrollTo&&"pageXOffset"in this.window}catch{return!1}}}function I2(t){return Object.getOwnPropertyDescriptor(t,"scrollRestoration")}class Nq extends N6{constructor(){super(...arguments),this.supportsDOMEvents=!0}}class Sw extends Nq{static makeCurrent(){!function E6(t){rw||(rw=t)}(new Sw)}onAndCancel(n,e,r){return n.addEventListener(e,r,!1),()=>{n.removeEventListener(e,r,!1)}}dispatchEvent(n,e){n.dispatchEvent(e)}remove(n){n.parentNode&&n.parentNode.removeChild(n)}createElement(n,e){return(e=e||this.getDefaultDocument()).createElement(n)}createHtmlDocument(){return document.implementation.createHTMLDocument("fakeTitle")}getDefaultDocument(){return document}isElementNode(n){return n.nodeType===Node.ELEMENT_NODE}isShadowRoot(n){return n instanceof DocumentFragment}getGlobalEventTarget(n,e){return"window"===e?window:"document"===e?n:"body"===e?n.body:null}getBaseHref(n){const e=function Aq(){return ih=ih||document.querySelector("base"),ih?ih.getAttribute("href"):null}();return null==e?null:function Rq(t){Jm=Jm||document.createElement("a"),Jm.setAttribute("href",t);const n=Jm.pathname;return"/"===n.charAt(0)?n:`/${n}`}(e)}resetBaseElement(){ih=null}getUserAgent(){return window.navigator.userAgent}getCookie(n){return function x8(t,n){n=encodeURIComponent(n);for(const e of t.split(";")){const r=e.indexOf("="),[s,o]=-1==r?[e,""]:[e.slice(0,r),e.slice(r+1)];if(s.trim()===n)return decodeURIComponent(o)}return null}(document.cookie,n)}}let Jm,ih=null;const N2=new Ct("TRANSITION_ID"),Oq=[{provide:Om,useFactory:function Fq(t,n,e){return()=>{e.get(Pm).donePromise.then(()=>{const r=ra(),s=n.querySelectorAll(`style[ng-transition="${t}"]`);for(let o=0;o<s.length;o++)r.remove(s[o])})}},deps:[N2,Ns,Ds],multi:!0}];let Mq=(()=>{class t{build(){return new XMLHttpRequest}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=kt({token:t,factory:t.\u0275fac}),t})();const eg=new Ct("EventManagerPlugins");let tg=(()=>{class t{constructor(e,r){this._zone=r,this._eventNameToPlugin=new Map,e.forEach(s=>{s.manager=this}),this._plugins=e.slice().reverse()}addEventListener(e,r,s){return this._findPluginFor(r).addEventListener(e,r,s)}addGlobalEventListener(e,r,s){return this._findPluginFor(r).addGlobalEventListener(e,r,s)}getZone(){return this._zone}_findPluginFor(e){const r=this._eventNameToPlugin.get(e);if(r)return r;const s=this._plugins;for(let o=0;o<s.length;o++){const i=s[o];if(i.supports(e))return this._eventNameToPlugin.set(e,i),i}throw new Error(`No event manager plugin found for event ${e}`)}}return t.\u0275fac=function(e){return new(e||t)(Et(eg),Et(ur))},t.\u0275prov=kt({token:t,factory:t.\u0275fac}),t})();class A2{constructor(n){this._doc=n}addGlobalEventListener(n,e,r){const s=ra().getGlobalEventTarget(this._doc,n);if(!s)throw new Error(`Unsupported event target ${s} for event ${e}`);return this.addEventListener(s,e,r)}}let R2=(()=>{class t{constructor(){this.usageCount=new Map}addStyles(e){for(const r of e)1===this.changeUsageCount(r,1)&&this.onStyleAdded(r)}removeStyles(e){for(const r of e)0===this.changeUsageCount(r,-1)&&this.onStyleRemoved(r)}onStyleRemoved(e){}onStyleAdded(e){}getAllStyles(){return this.usageCount.keys()}changeUsageCount(e,r){const s=this.usageCount;let o=s.get(e)??0;return o+=r,o>0?s.set(e,o):s.delete(e),o}ngOnDestroy(){for(const e of this.getAllStyles())this.onStyleRemoved(e);this.usageCount.clear()}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=kt({token:t,factory:t.\u0275fac}),t})(),ah=(()=>{class t extends R2{constructor(e){super(),this.doc=e,this.styleRef=new Map,this.hostNodes=new Set,this.resetHostNodes()}onStyleAdded(e){for(const r of this.hostNodes)this.addStyleToHost(r,e)}onStyleRemoved(e){const r=this.styleRef;r.get(e)?.forEach(o=>o.remove()),r.delete(e)}ngOnDestroy(){super.ngOnDestroy(),this.styleRef.clear(),this.resetHostNodes()}addHost(e){this.hostNodes.add(e);for(const r of this.getAllStyles())this.addStyleToHost(e,r)}removeHost(e){this.hostNodes.delete(e)}addStyleToHost(e,r){const s=this.doc.createElement("style");s.textContent=r,e.appendChild(s);const o=this.styleRef.get(r);o?o.push(s):this.styleRef.set(r,[s])}resetHostNodes(){const e=this.hostNodes;e.clear(),e.add(this.doc.head)}}return t.\u0275fac=function(e){return new(e||t)(Et(Ns))},t.\u0275prov=kt({token:t,factory:t.\u0275fac}),t})();const Iw={svg:"http://www.w3.org/2000/svg",xhtml:"http://www.w3.org/1999/xhtml",xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/",math:"http://www.w3.org/1998/MathML/"},Dw=/%COMP%/g,P2=new Ct("RemoveStylesOnCompDestory",{providedIn:"root",factory:()=>!1});function M2(t,n){return n.flat(100).map(e=>e.replace(Dw,t))}function $2(t){return n=>{if("__ngUnwrap__"===n)return t;!1===t(n)&&(n.preventDefault(),n.returnValue=!1)}}let Tw=(()=>{class t{constructor(e,r,s,o){this.eventManager=e,this.sharedStylesHost=r,this.appId=s,this.removeStylesOnCompDestory=o,this.rendererByCompId=new Map,this.defaultRenderer=new kw(e)}createRenderer(e,r){if(!e||!r)return this.defaultRenderer;const s=this.getOrCreateRenderer(e,r);return s instanceof B2?s.applyToHost(e):s instanceof Ew&&s.applyStyles(),s}getOrCreateRenderer(e,r){const s=this.rendererByCompId;let o=s.get(r.id);if(!o){const i=this.eventManager,a=this.sharedStylesHost,l=this.removeStylesOnCompDestory;switch(r.encapsulation){case pi.Emulated:o=new B2(i,a,r,this.appId,l);break;case pi.ShadowDom:return new Wq(i,a,e,r);default:o=new Ew(i,a,r,l)}o.onDestroy=()=>s.delete(r.id),s.set(r.id,o)}return o}ngOnDestroy(){this.rendererByCompId.clear()}begin(){}end(){}}return t.\u0275fac=function(e){return new(e||t)(Et(tg),Et(ah),Et(Jd),Et(P2))},t.\u0275prov=kt({token:t,factory:t.\u0275fac}),t})();class kw{constructor(n){this.eventManager=n,this.data=Object.create(null),this.destroyNode=null}destroy(){}createElement(n,e){return e?document.createElementNS(Iw[e]||e,n):document.createElement(n)}createComment(n){return document.createComment(n)}createText(n){return document.createTextNode(n)}appendChild(n,e){(V2(n)?n.content:n).appendChild(e)}insertBefore(n,e,r){n&&(V2(n)?n.content:n).insertBefore(e,r)}removeChild(n,e){n&&n.removeChild(e)}selectRootElement(n,e){let r="string"==typeof n?document.querySelector(n):n;if(!r)throw new Error(`The selector "${n}" did not match any elements`);return e||(r.textContent=""),r}parentNode(n){return n.parentNode}nextSibling(n){return n.nextSibling}setAttribute(n,e,r,s){if(s){e=s+":"+e;const o=Iw[s];o?n.setAttributeNS(o,e,r):n.setAttribute(e,r)}else n.setAttribute(e,r)}removeAttribute(n,e,r){if(r){const s=Iw[r];s?n.removeAttributeNS(s,e):n.removeAttribute(`${r}:${e}`)}else n.removeAttribute(e)}addClass(n,e){n.classList.add(e)}removeClass(n,e){n.classList.remove(e)}setStyle(n,e,r,s){s&(Vs.DashCase|Vs.Important)?n.style.setProperty(e,r,s&Vs.Important?"important":""):n.style[e]=r}removeStyle(n,e,r){r&Vs.DashCase?n.style.removeProperty(e):n.style[e]=""}setProperty(n,e,r){n[e]=r}setValue(n,e){n.nodeValue=e}listen(n,e,r){return"string"==typeof n?this.eventManager.addGlobalEventListener(n,e,$2(r)):this.eventManager.addEventListener(n,e,$2(r))}}function V2(t){return"TEMPLATE"===t.tagName&&void 0!==t.content}class Wq extends kw{constructor(n,e,r,s){super(n),this.sharedStylesHost=e,this.hostEl=r,this.shadowRoot=r.attachShadow({mode:"open"}),this.sharedStylesHost.addHost(this.shadowRoot);const o=M2(s.id,s.styles);for(const i of o){const a=document.createElement("style");a.textContent=i,this.shadowRoot.appendChild(a)}}nodeOrShadowRoot(n){return n===this.hostEl?this.shadowRoot:n}appendChild(n,e){return super.appendChild(this.nodeOrShadowRoot(n),e)}insertBefore(n,e,r){return super.insertBefore(this.nodeOrShadowRoot(n),e,r)}removeChild(n,e){return super.removeChild(this.nodeOrShadowRoot(n),e)}parentNode(n){return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(n)))}destroy(){this.sharedStylesHost.removeHost(this.shadowRoot)}}class Ew extends kw{constructor(n,e,r,s,o=r.id){super(n),this.sharedStylesHost=e,this.removeStylesOnCompDestory=s,this.rendererUsageCount=0,this.styles=M2(o,r.styles)}applyStyles(){this.sharedStylesHost.addStyles(this.styles),this.rendererUsageCount++}destroy(){this.removeStylesOnCompDestory&&(this.sharedStylesHost.removeStyles(this.styles),this.rendererUsageCount--,0===this.rendererUsageCount&&this.onDestroy?.())}}class B2 extends Ew{constructor(n,e,r,s,o){const i=s+"-"+r.id;super(n,e,r,o,i),this.contentAttr=function Bq(t){return"_ngcontent-%COMP%".replace(Dw,t)}(i),this.hostAttr=function zq(t){return"_nghost-%COMP%".replace(Dw,t)}(i)}applyToHost(n){this.applyStyles(),this.setAttribute(n,this.hostAttr,"")}createElement(n,e){const r=super.createElement(n,e);return super.setAttribute(r,this.contentAttr,""),r}}let Gq=(()=>{class t extends A2{constructor(e){super(e)}supports(e){return!0}addEventListener(e,r,s){return e.addEventListener(r,s,!1),()=>this.removeEventListener(e,r,s)}removeEventListener(e,r,s){return e.removeEventListener(r,s)}}return t.\u0275fac=function(e){return new(e||t)(Et(Ns))},t.\u0275prov=kt({token:t,factory:t.\u0275fac}),t})();const z2=["alt","control","meta","shift"],Hq={"\b":"Backspace","\t":"Tab","\x7f":"Delete","\x1b":"Escape",Del:"Delete",Esc:"Escape",Left:"ArrowLeft",Right:"ArrowRight",Up:"ArrowUp",Down:"ArrowDown",Menu:"ContextMenu",Scroll:"ScrollLock",Win:"OS"},jq={alt:t=>t.altKey,control:t=>t.ctrlKey,meta:t=>t.metaKey,shift:t=>t.shiftKey};let qq=(()=>{class t extends A2{constructor(e){super(e)}supports(e){return null!=t.parseEventName(e)}addEventListener(e,r,s){const o=t.parseEventName(r),i=t.eventCallback(o.fullKey,s,this.manager.getZone());return this.manager.getZone().runOutsideAngular(()=>ra().onAndCancel(e,o.domEventName,i))}static parseEventName(e){const r=e.toLowerCase().split("."),s=r.shift();if(0===r.length||"keydown"!==s&&"keyup"!==s)return null;const o=t._normalizeKey(r.pop());let i="",a=r.indexOf("code");if(a>-1&&(r.splice(a,1),i="code."),z2.forEach(u=>{const c=r.indexOf(u);c>-1&&(r.splice(c,1),i+=u+".")}),i+=o,0!=r.length||0===o.length)return null;const l={};return l.domEventName=s,l.fullKey=i,l}static matchEventFullKeyCode(e,r){let s=Hq[e.key]||e.key,o="";return r.indexOf("code.")>-1&&(s=e.code,o="code."),!(null==s||!s)&&(s=s.toLowerCase()," "===s?s="space":"."===s&&(s="dot"),z2.forEach(i=>{i!==s&&(0,jq[i])(e)&&(o+=i+".")}),o+=s,o===r)}static eventCallback(e,r,s){return o=>{t.matchEventFullKeyCode(o,e)&&s.runGuarded(()=>r(o))}}static _normalizeKey(e){return"esc"===e?"escape":e}}return t.\u0275fac=function(e){return new(e||t)(Et(Ns))},t.\u0275prov=kt({token:t,factory:t.\u0275fac}),t})();const Zq=MA(D6,"browser",[{provide:Gx,useValue:S2},{provide:IA,useValue:function Kq(){Sw.makeCurrent()},multi:!0},{provide:Ns,useFactory:function Yq(){return function F4(t){E0=t}(document),document},deps:[]}]),G2=new Ct(""),H2=[{provide:Mm,useClass:class Pq{addToWindow(n){Wn.getAngularTestability=(r,s=!0)=>{const o=n.findTestabilityInTree(r,s);if(null==o)throw new Error("Could not find testability for element.");return o},Wn.getAllAngularTestabilities=()=>n.getAllTestabilities(),Wn.getAllAngularRootElements=()=>n.getAllRootElements(),Wn.frameworkStabilizers||(Wn.frameworkStabilizers=[]),Wn.frameworkStabilizers.push(r=>{const s=Wn.getAllAngularTestabilities();let o=s.length,i=!1;const a=function(l){i=i||l,o--,0==o&&r(i)};s.forEach(function(l){l.whenStable(a)})})}findTestabilityInTree(n,e,r){return null==e?null:n.getTestability(e)??(r?ra().isShadowRoot(e)?this.findTestabilityInTree(n,e.host,!0):this.findTestabilityInTree(n,e.parentElement,!0):null)}},deps:[]},{provide:AA,useClass:Kx,deps:[ur,Xx,Mm]},{provide:Kx,useClass:Kx,deps:[ur,Xx,Mm]}],j2=[{provide:L0,useValue:"root"},{provide:Gu,useFactory:function Xq(){return new Gu},deps:[]},{provide:eg,useClass:Gq,multi:!0,deps:[Ns,ur,Gx]},{provide:eg,useClass:qq,multi:!0,deps:[Ns]},{provide:Tw,useClass:Tw,deps:[tg,ah,Jd,P2]},{provide:xk,useExisting:Tw},{provide:R2,useExisting:ah},{provide:ah,useClass:ah,deps:[Ns]},{provide:tg,useClass:tg,deps:[eg,ur]},{provide:class rq{},useClass:Mq,deps:[]},[]];let Qq=(()=>{class t{constructor(e){}static withServerTransition(e){return{ngModule:t,providers:[{provide:Jd,useValue:e.appId},{provide:N2,useExisting:Jd},Oq]}}}return t.\u0275fac=function(e){return new(e||t)(Et(G2,12))},t.\u0275mod=wo({type:t}),t.\u0275inj=Zs({providers:[...j2,...H2],imports:[C2,T6]}),t})(),q2=(()=>{class t{constructor(e){this._doc=e}getTitle(){return this._doc.title}setTitle(e){this._doc.title=e||""}}return t.\u0275fac=function(e){return new(e||t)(Et(Ns))},t.\u0275prov=kt({token:t,factory:function(e){let r=null;return r=e?new e:function eK(){return new q2(Et(Ns))}(),r},providedIn:"root"}),t})();function At(...t){return _r(t,pd(t))}typeof window<"u"&&window;class Zo extends Zt{constructor(n){super(),this._value=n}get value(){return this.getValue()}_subscribe(n){const e=super._subscribe(n);return!e.closed&&n.next(this._value),e}getValue(){const{hasError:n,thrownError:e,_value:r}=this;if(n)throw e;return this._throwIfClosed(),r}next(n){super.next(this._value=n)}}const ng=G(t=>function(){t(this),this.name="EmptyError",this.message="no elements in sequence"}),{isArray:iK}=Array,{getPrototypeOf:aK,prototype:lK,keys:uK}=Object;function Y2(t){if(1===t.length){const n=t[0];if(iK(n))return{args:n,keys:null};if(function cK(t){return t&&"object"==typeof t&&aK(t)===lK}(n)){const e=uK(n);return{args:e.map(r=>n[r]),keys:e}}}return{args:t,keys:null}}const{isArray:dK}=Array;function Z2(t){return ye(n=>function hK(t,n){return dK(n)?t(...n):t(n)}(t,n))}function Q2(t,n){return t.reduce((e,r,s)=>(e[r]=n[s],e),{})}function J2(...t){const n=pd(t),e=cD(t),{args:r,keys:s}=Y2(t);if(0===r.length)return _r([],n);const o=new Ve(function pK(t,n,e=ce){return r=>{eR(n,()=>{const{length:s}=t,o=new Array(s);let i=s,a=s;for(let l=0;l<s;l++)eR(n,()=>{const u=_r(t[l],n);let c=!1;u.subscribe(vn(r,d=>{o[l]=d,c||(c=!0,a--),a||r.next(e(o.slice()))},()=>{--i||r.complete()}))},r)},r)}}(r,n,s?i=>Q2(s,i):ce));return e?o.pipe(Z2(e)):o}function eR(t,n,e){t?Ui(e,t,n):n()}function Rw(...t){return function fK(){return _u(1)}()(_r(t,pd(t)))}function tR(t){return new Ve(n=>{vo(t()).subscribe(n)})}function lh(t,n){const e=P(t)?t:()=>t,r=s=>s.error(e());return new Ve(n?s=>n.schedule(r,0,s):r)}function Fw(){return In((t,n)=>{let e=null;t._refCount++;const r=vn(n,void 0,void 0,void 0,()=>{if(!t||t._refCount<=0||0<--t._refCount)return void(e=null);const s=t._connection,o=e;e=null,s&&(!o||s===o)&&s.unsubscribe(),n.unsubscribe()});t.subscribe(r),r.closed||(e=t.connect())})}class nR extends Ve{constructor(n,e){super(),this.source=n,this.subjectFactory=e,this._subject=null,this._refCount=0,this._connection=null,Xn(n)&&(this.lift=n.lift)}_subscribe(n){return this.getSubject().subscribe(n)}getSubject(){const n=this._subject;return(!n||n.isStopped)&&(this._subject=this.subjectFactory()),this._subject}_teardown(){this._refCount=0;const{_connection:n}=this;this._subject=this._connection=null,n?.unsubscribe()}connect(){let n=this._connection;if(!n){n=this._connection=new T;const e=this.getSubject();n.add(this.source.subscribe(vn(e,void 0,()=>{this._teardown(),e.complete()},r=>{this._teardown(),e.error(r)},()=>this._teardown()))),n.closed&&(this._connection=null,n=T.EMPTY)}return n}refCount(){return Fw()(this)}}function _i(t,n){return In((e,r)=>{let s=null,o=0,i=!1;const a=()=>i&&!s&&r.complete();e.subscribe(vn(r,l=>{s?.unsubscribe();let u=0;const c=o++;vo(t(l,c)).subscribe(s=vn(r,d=>r.next(n?n(l,d,c,u++):d),()=>{s=null,a()}))},()=>{i=!0,a()}))})}function uh(t){return t<=0?()=>di:In((n,e)=>{let r=0;n.subscribe(vn(e,s=>{++r<=t&&(e.next(s),t<=r&&e.complete())}))})}function Ta(t,n){return In((e,r)=>{let s=0;e.subscribe(vn(r,o=>t.call(n,o,s++)&&r.next(o)))})}function rg(t){return In((n,e)=>{let r=!1;n.subscribe(vn(e,s=>{r=!0,e.next(s)},()=>{r||e.next(t),e.complete()}))})}function rR(t=gK){return In((n,e)=>{let r=!1;n.subscribe(vn(e,s=>{r=!0,e.next(s)},()=>r?e.complete():e.error(t())))})}function gK(){return new ng}function ka(t,n){const e=arguments.length>=2;return r=>r.pipe(t?Ta((s,o)=>t(s,o,r)):ce,uh(1),e?rg(n):rR(()=>new ng))}function Ol(t,n){return P(n)?Xr(t,n,1):Xr(t,1)}function ds(t,n,e){const r=P(t)||n||e?{next:t,error:n,complete:e}:t;return r?In((s,o)=>{var i;null===(i=r.subscribe)||void 0===i||i.call(r);let a=!0;s.subscribe(vn(o,l=>{var u;null===(u=r.next)||void 0===u||u.call(r,l),o.next(l)},()=>{var l;a=!1,null===(l=r.complete)||void 0===l||l.call(r),o.complete()},l=>{var u;a=!1,null===(u=r.error)||void 0===u||u.call(r,l),o.error(l)},()=>{var l,u;a&&(null===(l=r.unsubscribe)||void 0===l||l.call(r)),null===(u=r.finalize)||void 0===u||u.call(r)}))}):ce}function Ea(t){return In((n,e)=>{let o,r=null,s=!1;r=n.subscribe(vn(e,void 0,void 0,i=>{o=vo(t(i,Ea(t)(n))),r?(r.unsubscribe(),r=null,o.subscribe(e)):s=!0})),s&&(r.unsubscribe(),r=null,o.subscribe(e))})}function sR(t,n){return In(function yK(t,n,e,r,s){return(o,i)=>{let a=e,l=n,u=0;o.subscribe(vn(i,c=>{const d=u++;l=a?t(l,c,d):(a=!0,c),r&&i.next(l)},s&&(()=>{a&&i.next(l),i.complete()})))}}(t,n,arguments.length>=2,!0))}function Ow(t){return t<=0?()=>di:In((n,e)=>{let r=[];n.subscribe(vn(e,s=>{r.push(s),t<r.length&&r.shift()},()=>{for(const s of r)e.next(s);e.complete()},void 0,()=>{r=null}))})}function oR(t,n){const e=arguments.length>=2;return r=>r.pipe(t?Ta((s,o)=>t(s,o,r)):ce,Ow(1),e?rg(n):rR(()=>new ng))}function Pw(t){return In((n,e)=>{try{n.subscribe(e)}finally{e.add(t)}})}const Gt="primary",ch=Symbol("RouteTitle");class xK{constructor(n){this.params=n||{}}has(n){return Object.prototype.hasOwnProperty.call(this.params,n)}get(n){if(this.has(n)){const e=this.params[n];return Array.isArray(e)?e[0]:e}return null}getAll(n){if(this.has(n)){const e=this.params[n];return Array.isArray(e)?e:[e]}return[]}get keys(){return Object.keys(this.params)}}function dc(t){return new xK(t)}function wK(t,n,e){const r=e.path.split("/");if(r.length>t.length||"full"===e.pathMatch&&(n.hasChildren()||r.length<t.length))return null;const s={};for(let o=0;o<r.length;o++){const i=r[o],a=t[o];if(i.startsWith(":"))s[i.substring(1)]=a;else if(i!==a.path)return null}return{consumed:t.slice(0,r.length),posParams:s}}function Ci(t,n){const e=t?Object.keys(t):void 0,r=n?Object.keys(n):void 0;if(!e||!r||e.length!=r.length)return!1;let s;for(let o=0;o<e.length;o++)if(s=e[o],!iR(t[s],n[s]))return!1;return!0}function iR(t,n){if(Array.isArray(t)&&Array.isArray(n)){if(t.length!==n.length)return!1;const e=[...t].sort(),r=[...n].sort();return e.every((s,o)=>r[o]===s)}return t===n}function aR(t){return Array.prototype.concat.apply([],t)}function lR(t){return t.length>0?t[t.length-1]:null}function Jr(t,n){for(const e in t)t.hasOwnProperty(e)&&n(t[e],e)}function Na(t){return gx(t)?t:Wd(t)?_r(Promise.resolve(t)):At(t)}const sg=!1,CK={exact:function dR(t,n,e){if(!Pl(t.segments,n.segments)||!og(t.segments,n.segments,e)||t.numberOfChildren!==n.numberOfChildren)return!1;for(const r in n.children)if(!t.children[r]||!dR(t.children[r],n.children[r],e))return!1;return!0},subset:hR},uR={exact:function SK(t,n){return Ci(t,n)},subset:function IK(t,n){return Object.keys(n).length<=Object.keys(t).length&&Object.keys(n).every(e=>iR(t[e],n[e]))},ignored:()=>!0};function cR(t,n,e){return CK[e.paths](t.root,n.root,e.matrixParams)&&uR[e.queryParams](t.queryParams,n.queryParams)&&!("exact"===e.fragment&&t.fragment!==n.fragment)}function hR(t,n,e){return pR(t,n,n.segments,e)}function pR(t,n,e,r){if(t.segments.length>e.length){const s=t.segments.slice(0,e.length);return!(!Pl(s,e)||n.hasChildren()||!og(s,e,r))}if(t.segments.length===e.length){if(!Pl(t.segments,e)||!og(t.segments,e,r))return!1;for(const s in n.children)if(!t.children[s]||!hR(t.children[s],n.children[s],r))return!1;return!0}{const s=e.slice(0,t.segments.length),o=e.slice(t.segments.length);return!!(Pl(t.segments,s)&&og(t.segments,s,r)&&t.children[Gt])&&pR(t.children[Gt],n,o,r)}}function og(t,n,e){return n.every((r,s)=>uR[e](t[s].parameters,r.parameters))}class Aa{constructor(n=new rn([],{}),e={},r=null){this.root=n,this.queryParams=e,this.fragment=r}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=dc(this.queryParams)),this._queryParamMap}toString(){return kK.serialize(this)}}class rn{constructor(n,e){this.segments=n,this.children=e,this.parent=null,Jr(e,(r,s)=>r.parent=this)}hasChildren(){return this.numberOfChildren>0}get numberOfChildren(){return Object.keys(this.children).length}toString(){return ig(this)}}class dh{constructor(n,e){this.path=n,this.parameters=e}get parameterMap(){return this._parameterMap||(this._parameterMap=dc(this.parameters)),this._parameterMap}toString(){return gR(this)}}function Pl(t,n){return t.length===n.length&&t.every((e,r)=>e.path===n[r].path)}let hh=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=kt({token:t,factory:function(){return new Mw},providedIn:"root"}),t})();class Mw{parse(n){const e=new $K(n);return new Aa(e.parseRootSegment(),e.parseQueryParams(),e.parseFragment())}serialize(n){const e=`/${ph(n.root,!0)}`,r=function AK(t){const n=Object.keys(t).map(e=>{const r=t[e];return Array.isArray(r)?r.map(s=>`${ag(e)}=${ag(s)}`).join("&"):`${ag(e)}=${ag(r)}`}).filter(e=>!!e);return n.length?`?${n.join("&")}`:""}(n.queryParams);return`${e}${r}${"string"==typeof n.fragment?`#${function EK(t){return encodeURI(t)}(n.fragment)}`:""}`}}const kK=new Mw;function ig(t){return t.segments.map(n=>gR(n)).join("/")}function ph(t,n){if(!t.hasChildren())return ig(t);if(n){const e=t.children[Gt]?ph(t.children[Gt],!1):"",r=[];return Jr(t.children,(s,o)=>{o!==Gt&&r.push(`${o}:${ph(s,!1)}`)}),r.length>0?`${e}(${r.join("//")})`:e}{const e=function TK(t,n){let e=[];return Jr(t.children,(r,s)=>{s===Gt&&(e=e.concat(n(r,s)))}),Jr(t.children,(r,s)=>{s!==Gt&&(e=e.concat(n(r,s)))}),e}(t,(r,s)=>s===Gt?[ph(t.children[Gt],!1)]:[`${s}:${ph(r,!1)}`]);return 1===Object.keys(t.children).length&&null!=t.children[Gt]?`${ig(t)}/${e[0]}`:`${ig(t)}/(${e.join("//")})`}}function fR(t){return encodeURIComponent(t).replace(/%40/g,"@").replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",")}function ag(t){return fR(t).replace(/%3B/gi,";")}function $w(t){return fR(t).replace(/\(/g,"%28").replace(/\)/g,"%29").replace(/%26/gi,"&")}function lg(t){return decodeURIComponent(t)}function mR(t){return lg(t.replace(/\+/g,"%20"))}function gR(t){return`${$w(t.path)}${function NK(t){return Object.keys(t).map(n=>`;${$w(n)}=${$w(t[n])}`).join("")}(t.parameters)}`}const RK=/^[^\/()?;=#]+/;function ug(t){const n=t.match(RK);return n?n[0]:""}const FK=/^[^=?&#]+/,PK=/^[^&#]+/;class $K{constructor(n){this.url=n,this.remaining=n}parseRootSegment(){return this.consumeOptional("/"),""===this.remaining||this.peekStartsWith("?")||this.peekStartsWith("#")?new rn([],{}):new rn([],this.parseChildren())}parseQueryParams(){const n={};if(this.consumeOptional("?"))do{this.parseQueryParam(n)}while(this.consumeOptional("&"));return n}parseFragment(){return this.consumeOptional("#")?decodeURIComponent(this.remaining):null}parseChildren(){if(""===this.remaining)return{};this.consumeOptional("/");const n=[];for(this.peekStartsWith("(")||n.push(this.parseSegment());this.peekStartsWith("/")&&!this.peekStartsWith("//")&&!this.peekStartsWith("/(");)this.capture("/"),n.push(this.parseSegment());let e={};this.peekStartsWith("/(")&&(this.capture("/"),e=this.parseParens(!0));let r={};return this.peekStartsWith("(")&&(r=this.parseParens(!1)),(n.length>0||Object.keys(e).length>0)&&(r[Gt]=new rn(n,e)),r}parseSegment(){const n=ug(this.remaining);if(""===n&&this.peekStartsWith(";"))throw new Xe(4009,sg);return this.capture(n),new dh(lg(n),this.parseMatrixParams())}parseMatrixParams(){const n={};for(;this.consumeOptional(";");)this.parseParam(n);return n}parseParam(n){const e=ug(this.remaining);if(!e)return;this.capture(e);let r="";if(this.consumeOptional("=")){const s=ug(this.remaining);s&&(r=s,this.capture(r))}n[lg(e)]=lg(r)}parseQueryParam(n){const e=function OK(t){const n=t.match(FK);return n?n[0]:""}(this.remaining);if(!e)return;this.capture(e);let r="";if(this.consumeOptional("=")){const i=function MK(t){const n=t.match(PK);return n?n[0]:""}(this.remaining);i&&(r=i,this.capture(r))}const s=mR(e),o=mR(r);if(n.hasOwnProperty(s)){let i=n[s];Array.isArray(i)||(i=[i],n[s]=i),i.push(o)}else n[s]=o}parseParens(n){const e={};for(this.capture("(");!this.consumeOptional(")")&&this.remaining.length>0;){const r=ug(this.remaining),s=this.remaining[r.length];if("/"!==s&&")"!==s&&";"!==s)throw new Xe(4010,sg);let o;r.indexOf(":")>-1?(o=r.slice(0,r.indexOf(":")),this.capture(o),this.capture(":")):n&&(o=Gt);const i=this.parseChildren();e[o]=1===Object.keys(i).length?i[Gt]:new rn([],i),this.consumeOptional("//")}return e}peekStartsWith(n){return this.remaining.startsWith(n)}consumeOptional(n){return!!this.peekStartsWith(n)&&(this.remaining=this.remaining.substring(n.length),!0)}capture(n){if(!this.consumeOptional(n))throw new Xe(4011,sg)}}function Lw(t){return t.segments.length>0?new rn([],{[Gt]:t}):t}function cg(t){const n={};for(const r of Object.keys(t.children)){const o=cg(t.children[r]);(o.segments.length>0||o.hasChildren())&&(n[r]=o)}return function LK(t){if(1===t.numberOfChildren&&t.children[Gt]){const n=t.children[Gt];return new rn(t.segments.concat(n.segments),n.children)}return t}(new rn(t.segments,n))}function Ml(t){return t instanceof Aa}const Vw=!1;function VK(t,n,e,r,s){if(0===e.length)return hc(n.root,n.root,n.root,r,s);const o=function wR(t){if("string"==typeof t[0]&&1===t.length&&"/"===t[0])return new xR(!0,0,t);let n=0,e=!1;const r=t.reduce((s,o,i)=>{if("object"==typeof o&&null!=o){if(o.outlets){const a={};return Jr(o.outlets,(l,u)=>{a[u]="string"==typeof l?l.split("/"):l}),[...s,{outlets:a}]}if(o.segmentPath)return[...s,o.segmentPath]}return"string"!=typeof o?[...s,o]:0===i?(o.split("/").forEach((a,l)=>{0==l&&"."===a||(0==l&&""===a?e=!0:".."===a?n++:""!=a&&s.push(a))}),s):[...s,o]},[]);return new xR(e,n,r)}(e);return o.toRoot()?hc(n.root,n.root,new rn([],{}),r,s):function i(l){const u=function zK(t,n,e,r){if(t.isAbsolute)return new pc(n.root,!0,0);if(-1===r)return new pc(e,e===n.root,0);return function _R(t,n,e){let r=t,s=n,o=e;for(;o>s;){if(o-=s,r=r.parent,!r)throw new Xe(4005,Vw&&"Invalid number of '../'");s=r.segments.length}return new pc(r,!1,s-o)}(e,r+(fh(t.commands[0])?0:1),t.numberOfDoubleDots)}(o,n,t.snapshot?._urlSegment,l),c=u.processChildren?fc(u.segmentGroup,u.index,o.commands):Bw(u.segmentGroup,u.index,o.commands);return hc(n.root,u.segmentGroup,c,r,s)}(t.snapshot?._lastPathIndex)}function fh(t){return"object"==typeof t&&null!=t&&!t.outlets&&!t.segmentPath}function mh(t){return"object"==typeof t&&null!=t&&t.outlets}function hc(t,n,e,r,s){let i,o={};r&&Jr(r,(l,u)=>{o[u]=Array.isArray(l)?l.map(c=>`${c}`):`${l}`}),i=t===n?e:bR(t,n,e);const a=Lw(cg(i));return new Aa(a,o,s)}function bR(t,n,e){const r={};return Jr(t.children,(s,o)=>{r[o]=s===n?e:bR(s,n,e)}),new rn(t.segments,r)}class xR{constructor(n,e,r){if(this.isAbsolute=n,this.numberOfDoubleDots=e,this.commands=r,n&&r.length>0&&fh(r[0]))throw new Xe(4003,Vw&&"Root segment cannot have matrix parameters");const s=r.find(mh);if(s&&s!==lR(r))throw new Xe(4004,Vw&&"{outlets:{}} has to be the last command")}toRoot(){return this.isAbsolute&&1===this.commands.length&&"/"==this.commands[0]}}class pc{constructor(n,e,r){this.segmentGroup=n,this.processChildren=e,this.index=r}}function Bw(t,n,e){if(t||(t=new rn([],{})),0===t.segments.length&&t.hasChildren())return fc(t,n,e);const r=function WK(t,n,e){let r=0,s=n;const o={match:!1,pathIndex:0,commandIndex:0};for(;s<t.segments.length;){if(r>=e.length)return o;const i=t.segments[s],a=e[r];if(mh(a))break;const l=`${a}`,u=r<e.length-1?e[r+1]:null;if(s>0&&void 0===l)break;if(l&&u&&"object"==typeof u&&void 0===u.outlets){if(!SR(l,u,i))return o;r+=2}else{if(!SR(l,{},i))return o;r++}s++}return{match:!0,pathIndex:s,commandIndex:r}}(t,n,e),s=e.slice(r.commandIndex);if(r.match&&r.pathIndex<t.segments.length){const o=new rn(t.segments.slice(0,r.pathIndex),{});return o.children[Gt]=new rn(t.segments.slice(r.pathIndex),t.children),fc(o,0,s)}return r.match&&0===s.length?new rn(t.segments,{}):r.match&&!t.hasChildren()?zw(t,n,e):r.match?fc(t,0,s):zw(t,n,e)}function fc(t,n,e){if(0===e.length)return new rn(t.segments,{});{const r=function UK(t){return mh(t[0])?t[0].outlets:{[Gt]:t}}(e),s={};return!r[Gt]&&t.children[Gt]&&1===t.numberOfChildren&&0===t.children[Gt].segments.length?fc(t.children[Gt],n,e):(Jr(r,(o,i)=>{"string"==typeof o&&(o=[o]),null!==o&&(s[i]=Bw(t.children[i],n,o))}),Jr(t.children,(o,i)=>{void 0===r[i]&&(s[i]=o)}),new rn(t.segments,s))}}function zw(t,n,e){const r=t.segments.slice(0,n);let s=0;for(;s<e.length;){const o=e[s];if(mh(o)){const l=GK(o.outlets);return new rn(r,l)}if(0===s&&fh(e[0])){r.push(new dh(t.segments[n].path,CR(e[0]))),s++;continue}const i=mh(o)?o.outlets[Gt]:`${o}`,a=s<e.length-1?e[s+1]:null;i&&a&&fh(a)?(r.push(new dh(i,CR(a))),s+=2):(r.push(new dh(i,{})),s++)}return new rn(r,{})}function GK(t){const n={};return Jr(t,(e,r)=>{"string"==typeof e&&(e=[e]),null!==e&&(n[r]=zw(new rn([],{}),0,e))}),n}function CR(t){const n={};return Jr(t,(e,r)=>n[r]=`${e}`),n}function SR(t,n,e){return t==e.path&&Ci(n,e.parameters)}const gh="imperative";class Si{constructor(n,e){this.id=n,this.url=e}}class Uw extends Si{constructor(n,e,r="imperative",s=null){super(n,e),this.type=0,this.navigationTrigger=r,this.restoredState=s}toString(){return`NavigationStart(id: ${this.id}, url: '${this.url}')`}}class $l extends Si{constructor(n,e,r){super(n,e),this.urlAfterRedirects=r,this.type=1}toString(){return`NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`}}class dg extends Si{constructor(n,e,r,s){super(n,e),this.reason=r,this.code=s,this.type=2}toString(){return`NavigationCancel(id: ${this.id}, url: '${this.url}')`}}class hg extends Si{constructor(n,e,r,s){super(n,e),this.reason=r,this.code=s,this.type=16}}class Ww extends Si{constructor(n,e,r,s){super(n,e),this.error=r,this.target=s,this.type=3}toString(){return`NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`}}class HK extends Si{constructor(n,e,r,s){super(n,e),this.urlAfterRedirects=r,this.state=s,this.type=4}toString(){return`RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class jK extends Si{constructor(n,e,r,s){super(n,e),this.urlAfterRedirects=r,this.state=s,this.type=7}toString(){return`GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class qK extends Si{constructor(n,e,r,s,o){super(n,e),this.urlAfterRedirects=r,this.state=s,this.shouldActivate=o,this.type=8}toString(){return`GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`}}class KK extends Si{constructor(n,e,r,s){super(n,e),this.urlAfterRedirects=r,this.state=s,this.type=5}toString(){return`ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class XK extends Si{constructor(n,e,r,s){super(n,e),this.urlAfterRedirects=r,this.state=s,this.type=6}toString(){return`ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class YK{constructor(n){this.route=n,this.type=9}toString(){return`RouteConfigLoadStart(path: ${this.route.path})`}}class ZK{constructor(n){this.route=n,this.type=10}toString(){return`RouteConfigLoadEnd(path: ${this.route.path})`}}class QK{constructor(n){this.snapshot=n,this.type=11}toString(){return`ChildActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class JK{constructor(n){this.snapshot=n,this.type=12}toString(){return`ChildActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class e7{constructor(n){this.snapshot=n,this.type=13}toString(){return`ActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class t7{constructor(n){this.snapshot=n,this.type=14}toString(){return`ActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class IR{constructor(n,e,r){this.routerEvent=n,this.position=e,this.anchor=r,this.type=15}toString(){return`Scroll(anchor: '${this.anchor}', position: '${this.position?`${this.position[0]}, ${this.position[1]}`:null}')`}}let s7=(()=>{class t{createUrlTree(e,r,s,o,i,a){return VK(e||r.root,s,o,i,a)}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=kt({token:t,factory:t.\u0275fac}),t})(),i7=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=kt({token:t,factory:function(n){return s7.\u0275fac(n)},providedIn:"root"}),t})();class DR{constructor(n){this._root=n}get root(){return this._root.value}parent(n){const e=this.pathFromRoot(n);return e.length>1?e[e.length-2]:null}children(n){const e=Gw(n,this._root);return e?e.children.map(r=>r.value):[]}firstChild(n){const e=Gw(n,this._root);return e&&e.children.length>0?e.children[0].value:null}siblings(n){const e=Hw(n,this._root);return e.length<2?[]:e[e.length-2].children.map(s=>s.value).filter(s=>s!==n)}pathFromRoot(n){return Hw(n,this._root).map(e=>e.value)}}function Gw(t,n){if(t===n.value)return n;for(const e of n.children){const r=Gw(t,e);if(r)return r}return null}function Hw(t,n){if(t===n.value)return[n];for(const e of n.children){const r=Hw(t,e);if(r.length)return r.unshift(n),r}return[]}class ia{constructor(n,e){this.value=n,this.children=e}toString(){return`TreeNode(${this.value})`}}function mc(t){const n={};return t&&t.children.forEach(e=>n[e.value.outlet]=e),n}class TR extends DR{constructor(n,e){super(n),this.snapshot=e,jw(this,n)}toString(){return this.snapshot.toString()}}function kR(t,n){const e=function a7(t,n){const i=new pg([],{},{},"",{},Gt,n,null,t.root,-1,{});return new NR("",new ia(i,[]))}(t,n),r=new Zo([new dh("",{})]),s=new Zo({}),o=new Zo({}),i=new Zo({}),a=new Zo(""),l=new gc(r,s,i,a,o,Gt,n,e.root);return l.snapshot=e.root,new TR(new ia(l,[]),e)}class gc{constructor(n,e,r,s,o,i,a,l){this.url=n,this.params=e,this.queryParams=r,this.fragment=s,this.data=o,this.outlet=i,this.component=a,this.title=this.data?.pipe(ye(u=>u[ch]))??At(void 0),this._futureSnapshot=l}get routeConfig(){return this._futureSnapshot.routeConfig}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap||(this._paramMap=this.params.pipe(ye(n=>dc(n)))),this._paramMap}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=this.queryParams.pipe(ye(n=>dc(n)))),this._queryParamMap}toString(){return this.snapshot?this.snapshot.toString():`Future(${this._futureSnapshot})`}}function ER(t,n="emptyOnly"){const e=t.pathFromRoot;let r=0;if("always"!==n)for(r=e.length-1;r>=1;){const s=e[r],o=e[r-1];if(s.routeConfig&&""===s.routeConfig.path)r--;else{if(o.component)break;r--}}return function l7(t){return t.reduce((n,e)=>({params:{...n.params,...e.params},data:{...n.data,...e.data},resolve:{...e.data,...n.resolve,...e.routeConfig?.data,...e._resolvedData}}),{params:{},data:{},resolve:{}})}(e.slice(r))}class pg{get title(){return this.data?.[ch]}constructor(n,e,r,s,o,i,a,l,u,c,d){this.url=n,this.params=e,this.queryParams=r,this.fragment=s,this.data=o,this.outlet=i,this.component=a,this.routeConfig=l,this._urlSegment=u,this._lastPathIndex=c,this._resolve=d}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap||(this._paramMap=dc(this.params)),this._paramMap}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=dc(this.queryParams)),this._queryParamMap}toString(){return`Route(url:'${this.url.map(r=>r.toString()).join("/")}', path:'${this.routeConfig?this.routeConfig.path:""}')`}}class NR extends DR{constructor(n,e){super(e),this.url=n,jw(this,e)}toString(){return AR(this._root)}}function jw(t,n){n.value._routerState=t,n.children.forEach(e=>jw(t,e))}function AR(t){const n=t.children.length>0?` { ${t.children.map(AR).join(", ")} } `:"";return`${t.value}${n}`}function qw(t){if(t.snapshot){const n=t.snapshot,e=t._futureSnapshot;t.snapshot=e,Ci(n.queryParams,e.queryParams)||t.queryParams.next(e.queryParams),n.fragment!==e.fragment&&t.fragment.next(e.fragment),Ci(n.params,e.params)||t.params.next(e.params),function _K(t,n){if(t.length!==n.length)return!1;for(let e=0;e<t.length;++e)if(!Ci(t[e],n[e]))return!1;return!0}(n.url,e.url)||t.url.next(e.url),Ci(n.data,e.data)||t.data.next(e.data)}else t.snapshot=t._futureSnapshot,t.data.next(t._futureSnapshot.data)}function Kw(t,n){const e=Ci(t.params,n.params)&&function DK(t,n){return Pl(t,n)&&t.every((e,r)=>Ci(e.parameters,n[r].parameters))}(t.url,n.url);return e&&!(!t.parent!=!n.parent)&&(!t.parent||Kw(t.parent,n.parent))}function yh(t,n,e){if(e&&t.shouldReuseRoute(n.value,e.value.snapshot)){const r=e.value;r._futureSnapshot=n.value;const s=function c7(t,n,e){return n.children.map(r=>{for(const s of e.children)if(t.shouldReuseRoute(r.value,s.value.snapshot))return yh(t,r,s);return yh(t,r)})}(t,n,e);return new ia(r,s)}{if(t.shouldAttach(n.value)){const o=t.retrieve(n.value);if(null!==o){const i=o.route;return i.value._futureSnapshot=n.value,i.children=n.children.map(a=>yh(t,a)),i}}const r=function d7(t){return new gc(new Zo(t.url),new Zo(t.params),new Zo(t.queryParams),new Zo(t.fragment),new Zo(t.data),t.outlet,t.component,t)}(n.value),s=n.children.map(o=>yh(t,o));return new ia(r,s)}}const Xw="ngNavigationCancelingError";function RR(t,n){const{redirectTo:e,navigationBehaviorOptions:r}=Ml(n)?{redirectTo:n,navigationBehaviorOptions:void 0}:n,s=FR(!1,0,n);return s.url=e,s.navigationBehaviorOptions=r,s}function FR(t,n,e){const r=new Error("NavigationCancelingError: "+(t||""));return r[Xw]=!0,r.cancellationCode=n,e&&(r.url=e),r}function OR(t){return PR(t)&&Ml(t.url)}function PR(t){return t&&t[Xw]}class h7{constructor(){this.outlet=null,this.route=null,this.resolver=null,this.injector=null,this.children=new vh,this.attachRef=null}}let vh=(()=>{class t{constructor(){this.contexts=new Map}onChildOutletCreated(e,r){const s=this.getOrCreateContext(e);s.outlet=r,this.contexts.set(e,s)}onChildOutletDestroyed(e){const r=this.getContext(e);r&&(r.outlet=null,r.attachRef=null)}onOutletDeactivated(){const e=this.contexts;return this.contexts=new Map,e}onOutletReAttached(e){this.contexts=e}getOrCreateContext(e){let r=this.getContext(e);return r||(r=new h7,this.contexts.set(e,r)),r}getContext(e){return this.contexts.get(e)||null}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=kt({token:t,factory:t.\u0275fac,providedIn:"root"}),t})();const fg=!1;let MR=(()=>{class t{constructor(){this.activated=null,this._activatedRoute=null,this.name=Gt,this.activateEvents=new nn,this.deactivateEvents=new nn,this.attachEvents=new nn,this.detachEvents=new nn,this.parentContexts=cn(vh),this.location=cn(Do),this.changeDetector=cn(th),this.environmentInjector=cn(Yi)}ngOnChanges(e){if(e.name){const{firstChange:r,previousValue:s}=e.name;if(r)return;this.isTrackedInParentContexts(s)&&(this.deactivate(),this.parentContexts.onChildOutletDestroyed(s)),this.initializeOutletWithName()}}ngOnDestroy(){this.isTrackedInParentContexts(this.name)&&this.parentContexts.onChildOutletDestroyed(this.name)}isTrackedInParentContexts(e){return this.parentContexts.getContext(e)?.outlet===this}ngOnInit(){this.initializeOutletWithName()}initializeOutletWithName(){if(this.parentContexts.onChildOutletCreated(this.name,this),this.activated)return;const e=this.parentContexts.getContext(this.name);e?.route&&(e.attachRef?this.attach(e.attachRef,e.route):this.activateWith(e.route,e.injector))}get isActivated(){return!!this.activated}get component(){if(!this.activated)throw new Xe(4012,fg);return this.activated.instance}get activatedRoute(){if(!this.activated)throw new Xe(4012,fg);return this._activatedRoute}get activatedRouteData(){return this._activatedRoute?this._activatedRoute.snapshot.data:{}}detach(){if(!this.activated)throw new Xe(4012,fg);this.location.detach();const e=this.activated;return this.activated=null,this._activatedRoute=null,this.detachEvents.emit(e.instance),e}attach(e,r){this.activated=e,this._activatedRoute=r,this.location.insert(e.hostView),this.attachEvents.emit(e.instance)}deactivate(){if(this.activated){const e=this.component;this.activated.destroy(),this.activated=null,this._activatedRoute=null,this.deactivateEvents.emit(e)}}activateWith(e,r){if(this.isActivated)throw new Xe(4013,fg);this._activatedRoute=e;const s=this.location,i=e.snapshot.component,a=this.parentContexts.getOrCreateContext(this.name).children,l=new p7(e,a,s.injector);if(r&&function f7(t){return!!t.resolveComponentFactory}(r)){const u=r.resolveComponentFactory(i);this.activated=s.createComponent(u,s.length,l)}else this.activated=s.createComponent(i,{index:s.length,injector:l,environmentInjector:r??this.environmentInjector});this.changeDetector.markForCheck(),this.activateEvents.emit(this.activated.instance)}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275dir=Pt({type:t,selectors:[["router-outlet"]],inputs:{name:"name"},outputs:{activateEvents:"activate",deactivateEvents:"deactivate",attachEvents:"attach",detachEvents:"detach"},exportAs:["outlet"],standalone:!0,features:[eo]}),t})();class p7{constructor(n,e,r){this.route=n,this.childContexts=e,this.parent=r}get(n,e){return n===gc?this.route:n===vh?this.childContexts:this.parent.get(n,e)}}let Yw=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275cmp=yl({type:t,selectors:[["ng-component"]],standalone:!0,features:[VN],decls:1,vars:0,template:function(e,r){1&e&&sn(0,"router-outlet")},dependencies:[MR],encapsulation:2}),t})();function $R(t,n){return t.providers&&!t._injector&&(t._injector=km(t.providers,n,`Route: ${t.path}`)),t._injector??n}function Qw(t){const n=t.children&&t.children.map(Qw),e=n?{...t,children:n}:{...t};return!e.component&&!e.loadComponent&&(n||e.loadChildren)&&e.outlet&&e.outlet!==Gt&&(e.component=Yw),e}function Eo(t){return t.outlet||Gt}function LR(t,n){const e=t.filter(r=>Eo(r)===n);return e.push(...t.filter(r=>Eo(r)!==n)),e}function bh(t){if(!t)return null;if(t.routeConfig?._injector)return t.routeConfig._injector;for(let n=t.parent;n;n=n.parent){const e=n.routeConfig;if(e?._loadedInjector)return e._loadedInjector;if(e?._injector)return e._injector}return null}class b7{constructor(n,e,r,s){this.routeReuseStrategy=n,this.futureState=e,this.currState=r,this.forwardEvent=s}activate(n){const e=this.futureState._root,r=this.currState?this.currState._root:null;this.deactivateChildRoutes(e,r,n),qw(this.futureState.root),this.activateChildRoutes(e,r,n)}deactivateChildRoutes(n,e,r){const s=mc(e);n.children.forEach(o=>{const i=o.value.outlet;this.deactivateRoutes(o,s[i],r),delete s[i]}),Jr(s,(o,i)=>{this.deactivateRouteAndItsChildren(o,r)})}deactivateRoutes(n,e,r){const s=n.value,o=e?e.value:null;if(s===o)if(s.component){const i=r.getContext(s.outlet);i&&this.deactivateChildRoutes(n,e,i.children)}else this.deactivateChildRoutes(n,e,r);else o&&this.deactivateRouteAndItsChildren(e,r)}deactivateRouteAndItsChildren(n,e){n.value.component&&this.routeReuseStrategy.shouldDetach(n.value.snapshot)?this.detachAndStoreRouteSubtree(n,e):this.deactivateRouteAndOutlet(n,e)}detachAndStoreRouteSubtree(n,e){const r=e.getContext(n.value.outlet),s=r&&n.value.component?r.children:e,o=mc(n);for(const i of Object.keys(o))this.deactivateRouteAndItsChildren(o[i],s);if(r&&r.outlet){const i=r.outlet.detach(),a=r.children.onOutletDeactivated();this.routeReuseStrategy.store(n.value.snapshot,{componentRef:i,route:n,contexts:a})}}deactivateRouteAndOutlet(n,e){const r=e.getContext(n.value.outlet),s=r&&n.value.component?r.children:e,o=mc(n);for(const i of Object.keys(o))this.deactivateRouteAndItsChildren(o[i],s);r&&r.outlet&&(r.outlet.deactivate(),r.children.onOutletDeactivated(),r.attachRef=null,r.resolver=null,r.route=null)}activateChildRoutes(n,e,r){const s=mc(e);n.children.forEach(o=>{this.activateRoutes(o,s[o.value.outlet],r),this.forwardEvent(new t7(o.value.snapshot))}),n.children.length&&this.forwardEvent(new JK(n.value.snapshot))}activateRoutes(n,e,r){const s=n.value,o=e?e.value:null;if(qw(s),s===o)if(s.component){const i=r.getOrCreateContext(s.outlet);this.activateChildRoutes(n,e,i.children)}else this.activateChildRoutes(n,e,r);else if(s.component){const i=r.getOrCreateContext(s.outlet);if(this.routeReuseStrategy.shouldAttach(s.snapshot)){const a=this.routeReuseStrategy.retrieve(s.snapshot);this.routeReuseStrategy.store(s.snapshot,null),i.children.onOutletReAttached(a.contexts),i.attachRef=a.componentRef,i.route=a.route.value,i.outlet&&i.outlet.attach(a.componentRef,a.route.value),qw(a.route.value),this.activateChildRoutes(n,null,i.children)}else{const a=bh(s.snapshot),l=a?.get(Uu)??null;i.attachRef=null,i.route=s,i.resolver=l,i.injector=a,i.outlet&&i.outlet.activateWith(s,i.injector),this.activateChildRoutes(n,null,i.children)}}else this.activateChildRoutes(n,null,r)}}class VR{constructor(n){this.path=n,this.route=this.path[this.path.length-1]}}class mg{constructor(n,e){this.component=n,this.route=e}}function x7(t,n,e){const r=t._root;return xh(r,n?n._root:null,e,[r.value])}function yc(t,n){const e=Symbol(),r=n.get(t,e);return r===e?"function"!=typeof t||function Tz(t){return null!==Rf(t)}(t)?n.get(t):t:r}function xh(t,n,e,r,s={canDeactivateChecks:[],canActivateChecks:[]}){const o=mc(n);return t.children.forEach(i=>{(function _7(t,n,e,r,s={canDeactivateChecks:[],canActivateChecks:[]}){const o=t.value,i=n?n.value:null,a=e?e.getContext(t.value.outlet):null;if(i&&o.routeConfig===i.routeConfig){const l=function C7(t,n,e){if("function"==typeof e)return e(t,n);switch(e){case"pathParamsChange":return!Pl(t.url,n.url);case"pathParamsOrQueryParamsChange":return!Pl(t.url,n.url)||!Ci(t.queryParams,n.queryParams);case"always":return!0;case"paramsOrQueryParamsChange":return!Kw(t,n)||!Ci(t.queryParams,n.queryParams);default:return!Kw(t,n)}}(i,o,o.routeConfig.runGuardsAndResolvers);l?s.canActivateChecks.push(new VR(r)):(o.data=i.data,o._resolvedData=i._resolvedData),xh(t,n,o.component?a?a.children:null:e,r,s),l&&a&&a.outlet&&a.outlet.isActivated&&s.canDeactivateChecks.push(new mg(a.outlet.component,i))}else i&&wh(n,a,s),s.canActivateChecks.push(new VR(r)),xh(t,null,o.component?a?a.children:null:e,r,s)})(i,o[i.value.outlet],e,r.concat([i.value]),s),delete o[i.value.outlet]}),Jr(o,(i,a)=>wh(i,e.getContext(a),s)),s}function wh(t,n,e){const r=mc(t),s=t.value;Jr(r,(o,i)=>{wh(o,s.component?n?n.children.getContext(i):null:n,e)}),e.canDeactivateChecks.push(new mg(s.component&&n&&n.outlet&&n.outlet.isActivated?n.outlet.component:null,s))}function _h(t){return"function"==typeof t}function Jw(t){return t instanceof ng||"EmptyError"===t?.name}const gg=Symbol("INITIAL_VALUE");function vc(){return _i(t=>J2(t.map(n=>n.pipe(uh(1),function mK(...t){const n=pd(t);return In((e,r)=>{(n?Rw(t,e,n):Rw(t,e)).subscribe(r)})}(gg)))).pipe(ye(n=>{for(const e of n)if(!0!==e){if(e===gg)return gg;if(!1===e||e instanceof Aa)return e}return!0}),Ta(n=>n!==gg),uh(1)))}function BR(t){return function le(...t){return ft(t)}(ds(n=>{if(Ml(n))throw RR(0,n)}),ye(n=>!0===n))}const e_={matched:!1,consumedSegments:[],remainingSegments:[],parameters:{},positionalParamSegments:{}};function zR(t,n,e,r,s){const o=t_(t,n,e);return o.matched?function B7(t,n,e,r){const s=n.canMatch;return s&&0!==s.length?At(s.map(i=>{const a=yc(i,t);return Na(function E7(t){return t&&_h(t.canMatch)}(a)?a.canMatch(n,e):t.runInContext(()=>a(n,e)))})).pipe(vc(),BR()):At(!0)}(r=$R(n,r),n,e).pipe(ye(i=>!0===i?o:{...e_})):At(o)}function t_(t,n,e){if(""===n.path)return"full"===n.pathMatch&&(t.hasChildren()||e.length>0)?{...e_}:{matched:!0,consumedSegments:[],remainingSegments:e,parameters:{},positionalParamSegments:{}};const s=(n.matcher||wK)(e,t,n);if(!s)return{...e_};const o={};Jr(s.posParams,(a,l)=>{o[l]=a.path});const i=s.consumed.length>0?{...o,...s.consumed[s.consumed.length-1].parameters}:o;return{matched:!0,consumedSegments:s.consumed,remainingSegments:e.slice(s.consumed.length),parameters:i,positionalParamSegments:s.posParams??{}}}function yg(t,n,e,r){if(e.length>0&&function W7(t,n,e){return e.some(r=>vg(t,n,r)&&Eo(r)!==Gt)}(t,e,r)){const o=new rn(n,function U7(t,n,e,r){const s={};s[Gt]=r,r._sourceSegment=t,r._segmentIndexShift=n.length;for(const o of e)if(""===o.path&&Eo(o)!==Gt){const i=new rn([],{});i._sourceSegment=t,i._segmentIndexShift=n.length,s[Eo(o)]=i}return s}(t,n,r,new rn(e,t.children)));return o._sourceSegment=t,o._segmentIndexShift=n.length,{segmentGroup:o,slicedSegments:[]}}if(0===e.length&&function G7(t,n,e){return e.some(r=>vg(t,n,r))}(t,e,r)){const o=new rn(t.segments,function z7(t,n,e,r,s){const o={};for(const i of r)if(vg(t,e,i)&&!s[Eo(i)]){const a=new rn([],{});a._sourceSegment=t,a._segmentIndexShift=n.length,o[Eo(i)]=a}return{...s,...o}}(t,n,e,r,t.children));return o._sourceSegment=t,o._segmentIndexShift=n.length,{segmentGroup:o,slicedSegments:e}}const s=new rn(t.segments,t.children);return s._sourceSegment=t,s._segmentIndexShift=n.length,{segmentGroup:s,slicedSegments:e}}function vg(t,n,e){return(!(t.hasChildren()||n.length>0)||"full"!==e.pathMatch)&&""===e.path}function UR(t,n,e,r){return!!(Eo(t)===r||r!==Gt&&vg(n,e,t))&&("**"===t.path||t_(n,t,e).matched)}function WR(t,n,e){return 0===n.length&&!t.children[e]}const bg=!1;class xg{constructor(n){this.segmentGroup=n||null}}class GR{constructor(n){this.urlTree=n}}function Ch(t){return lh(new xg(t))}function HR(t){return lh(new GR(t))}class K7{constructor(n,e,r,s,o){this.injector=n,this.configLoader=e,this.urlSerializer=r,this.urlTree=s,this.config=o,this.allowRedirects=!0}apply(){const n=yg(this.urlTree.root,[],[],this.config).segmentGroup,e=new rn(n.segments,n.children);return this.expandSegmentGroup(this.injector,this.config,e,Gt).pipe(ye(o=>this.createUrlTree(cg(o),this.urlTree.queryParams,this.urlTree.fragment))).pipe(Ea(o=>{if(o instanceof GR)return this.allowRedirects=!1,this.match(o.urlTree);throw o instanceof xg?this.noMatchError(o):o}))}match(n){return this.expandSegmentGroup(this.injector,this.config,n.root,Gt).pipe(ye(s=>this.createUrlTree(cg(s),n.queryParams,n.fragment))).pipe(Ea(s=>{throw s instanceof xg?this.noMatchError(s):s}))}noMatchError(n){return new Xe(4002,bg)}createUrlTree(n,e,r){const s=Lw(n);return new Aa(s,e,r)}expandSegmentGroup(n,e,r,s){return 0===r.segments.length&&r.hasChildren()?this.expandChildren(n,e,r).pipe(ye(o=>new rn([],o))):this.expandSegment(n,r,e,r.segments,s,!0)}expandChildren(n,e,r){const s=[];for(const o of Object.keys(r.children))"primary"===o?s.unshift(o):s.push(o);return _r(s).pipe(Ol(o=>{const i=r.children[o],a=LR(e,o);return this.expandSegmentGroup(n,a,i,o).pipe(ye(l=>({segment:l,outlet:o})))}),sR((o,i)=>(o[i.outlet]=i.segment,o),{}),oR())}expandSegment(n,e,r,s,o,i){return _r(r).pipe(Ol(a=>this.expandSegmentAgainstRoute(n,e,r,a,s,o,i).pipe(Ea(u=>{if(u instanceof xg)return At(null);throw u}))),ka(a=>!!a),Ea((a,l)=>{if(Jw(a))return WR(e,s,o)?At(new rn([],{})):Ch(e);throw a}))}expandSegmentAgainstRoute(n,e,r,s,o,i,a){return UR(s,e,o,i)?void 0===s.redirectTo?this.matchSegmentAgainstRoute(n,e,s,o,i):a&&this.allowRedirects?this.expandSegmentAgainstRouteUsingRedirect(n,e,r,s,o,i):Ch(e):Ch(e)}expandSegmentAgainstRouteUsingRedirect(n,e,r,s,o,i){return"**"===s.path?this.expandWildCardWithParamsAgainstRouteUsingRedirect(n,r,s,i):this.expandRegularSegmentAgainstRouteUsingRedirect(n,e,r,s,o,i)}expandWildCardWithParamsAgainstRouteUsingRedirect(n,e,r,s){const o=this.applyRedirectCommands([],r.redirectTo,{});return r.redirectTo.startsWith("/")?HR(o):this.lineralizeSegments(r,o).pipe(Xr(i=>{const a=new rn(i,{});return this.expandSegment(n,a,e,i,s,!1)}))}expandRegularSegmentAgainstRouteUsingRedirect(n,e,r,s,o,i){const{matched:a,consumedSegments:l,remainingSegments:u,positionalParamSegments:c}=t_(e,s,o);if(!a)return Ch(e);const d=this.applyRedirectCommands(l,s.redirectTo,c);return s.redirectTo.startsWith("/")?HR(d):this.lineralizeSegments(s,d).pipe(Xr(h=>this.expandSegment(n,e,r,h.concat(u),i,!1)))}matchSegmentAgainstRoute(n,e,r,s,o){return"**"===r.path?(n=$R(r,n),r.loadChildren?(r._loadedRoutes?At({routes:r._loadedRoutes,injector:r._loadedInjector}):this.configLoader.loadChildren(n,r)).pipe(ye(a=>(r._loadedRoutes=a.routes,r._loadedInjector=a.injector,new rn(s,{})))):At(new rn(s,{}))):zR(e,r,s,n).pipe(_i(({matched:i,consumedSegments:a,remainingSegments:l})=>i?this.getChildConfig(n=r._injector??n,r,s).pipe(Xr(c=>{const d=c.injector??n,h=c.routes,{segmentGroup:p,slicedSegments:f}=yg(e,a,l,h),g=new rn(p.segments,p.children);if(0===f.length&&g.hasChildren())return this.expandChildren(d,h,g).pipe(ye(b=>new rn(a,b)));if(0===h.length&&0===f.length)return At(new rn(a,{}));const m=Eo(r)===o;return this.expandSegment(d,g,h,f,m?Gt:o,!0).pipe(ye(v=>new rn(a.concat(v.segments),v.children)))})):Ch(e)))}getChildConfig(n,e,r){return e.children?At({routes:e.children,injector:n}):e.loadChildren?void 0!==e._loadedRoutes?At({routes:e._loadedRoutes,injector:e._loadedInjector}):function V7(t,n,e,r){const s=n.canLoad;return void 0===s||0===s.length?At(!0):At(s.map(i=>{const a=yc(i,t);return Na(function I7(t){return t&&_h(t.canLoad)}(a)?a.canLoad(n,e):t.runInContext(()=>a(n,e)))})).pipe(vc(),BR())}(n,e,r).pipe(Xr(s=>s?this.configLoader.loadChildren(n,e).pipe(ds(o=>{e._loadedRoutes=o.routes,e._loadedInjector=o.injector})):function j7(t){return lh(FR(bg,3))}())):At({routes:[],injector:n})}lineralizeSegments(n,e){let r=[],s=e.root;for(;;){if(r=r.concat(s.segments),0===s.numberOfChildren)return At(r);if(s.numberOfChildren>1||!s.children[Gt])return n.redirectTo,lh(new Xe(4e3,bg));s=s.children[Gt]}}applyRedirectCommands(n,e,r){return this.applyRedirectCreateUrlTree(e,this.urlSerializer.parse(e),n,r)}applyRedirectCreateUrlTree(n,e,r,s){const o=this.createSegmentGroup(n,e.root,r,s);return new Aa(o,this.createQueryParams(e.queryParams,this.urlTree.queryParams),e.fragment)}createQueryParams(n,e){const r={};return Jr(n,(s,o)=>{if("string"==typeof s&&s.startsWith(":")){const a=s.substring(1);r[o]=e[a]}else r[o]=s}),r}createSegmentGroup(n,e,r,s){const o=this.createSegments(n,e.segments,r,s);let i={};return Jr(e.children,(a,l)=>{i[l]=this.createSegmentGroup(n,a,r,s)}),new rn(o,i)}createSegments(n,e,r,s){return e.map(o=>o.path.startsWith(":")?this.findPosParam(n,o,s):this.findOrReturn(o,r))}findPosParam(n,e,r){const s=r[e.path.substring(1)];if(!s)throw new Xe(4001,bg);return s}findOrReturn(n,e){let r=0;for(const s of e){if(s.path===n.path)return e.splice(r),s;r++}return n}}class Y7{}class J7{constructor(n,e,r,s,o,i,a){this.injector=n,this.rootComponentType=e,this.config=r,this.urlTree=s,this.url=o,this.paramsInheritanceStrategy=i,this.urlSerializer=a}recognize(){const n=yg(this.urlTree.root,[],[],this.config.filter(e=>void 0===e.redirectTo)).segmentGroup;return this.processSegmentGroup(this.injector,this.config,n,Gt).pipe(ye(e=>{if(null===e)return null;const r=new pg([],Object.freeze({}),Object.freeze({...this.urlTree.queryParams}),this.urlTree.fragment,{},Gt,this.rootComponentType,null,this.urlTree.root,-1,{}),s=new ia(r,e),o=new NR(this.url,s);return this.inheritParamsAndData(o._root),o}))}inheritParamsAndData(n){const e=n.value,r=ER(e,this.paramsInheritanceStrategy);e.params=Object.freeze(r.params),e.data=Object.freeze(r.data),n.children.forEach(s=>this.inheritParamsAndData(s))}processSegmentGroup(n,e,r,s){return 0===r.segments.length&&r.hasChildren()?this.processChildren(n,e,r):this.processSegment(n,e,r,r.segments,s)}processChildren(n,e,r){return _r(Object.keys(r.children)).pipe(Ol(s=>{const o=r.children[s],i=LR(e,s);return this.processSegmentGroup(n,i,o,s)}),sR((s,o)=>s&&o?(s.push(...o),s):null),function vK(t,n=!1){return In((e,r)=>{let s=0;e.subscribe(vn(r,o=>{const i=t(o,s++);(i||n)&&r.next(o),!i&&r.complete()}))})}(s=>null!==s),rg(null),oR(),ye(s=>{if(null===s)return null;const o=qR(s);return function e9(t){t.sort((n,e)=>n.value.outlet===Gt?-1:e.value.outlet===Gt?1:n.value.outlet.localeCompare(e.value.outlet))}(o),o}))}processSegment(n,e,r,s,o){return _r(e).pipe(Ol(i=>this.processSegmentAgainstRoute(i._injector??n,i,r,s,o)),ka(i=>!!i),Ea(i=>{if(Jw(i))return WR(r,s,o)?At([]):At(null);throw i}))}processSegmentAgainstRoute(n,e,r,s,o){if(e.redirectTo||!UR(e,r,s,o))return At(null);let i;if("**"===e.path){const a=s.length>0?lR(s).parameters:{},l=XR(r)+s.length;i=At({snapshot:new pg(s,a,Object.freeze({...this.urlTree.queryParams}),this.urlTree.fragment,YR(e),Eo(e),e.component??e._loadedComponent??null,e,KR(r),l,ZR(e)),consumedSegments:[],remainingSegments:[]})}else i=zR(r,e,s,n).pipe(ye(({matched:a,consumedSegments:l,remainingSegments:u,parameters:c})=>{if(!a)return null;const d=XR(r)+l.length;return{snapshot:new pg(l,c,Object.freeze({...this.urlTree.queryParams}),this.urlTree.fragment,YR(e),Eo(e),e.component??e._loadedComponent??null,e,KR(r),d,ZR(e)),consumedSegments:l,remainingSegments:u}}));return i.pipe(_i(a=>{if(null===a)return At(null);const{snapshot:l,consumedSegments:u,remainingSegments:c}=a;n=e._injector??n;const d=e._loadedInjector??n,h=function t9(t){return t.children?t.children:t.loadChildren?t._loadedRoutes:[]}(e),{segmentGroup:p,slicedSegments:f}=yg(r,u,c,h.filter(m=>void 0===m.redirectTo));if(0===f.length&&p.hasChildren())return this.processChildren(d,h,p).pipe(ye(m=>null===m?null:[new ia(l,m)]));if(0===h.length&&0===f.length)return At([new ia(l,[])]);const g=Eo(e)===o;return this.processSegment(d,h,p,f,g?Gt:o).pipe(ye(m=>null===m?null:[new ia(l,m)]))}))}}function n9(t){const n=t.value.routeConfig;return n&&""===n.path&&void 0===n.redirectTo}function qR(t){const n=[],e=new Set;for(const r of t){if(!n9(r)){n.push(r);continue}const s=n.find(o=>r.value.routeConfig===o.value.routeConfig);void 0!==s?(s.children.push(...r.children),e.add(s)):n.push(r)}for(const r of e){const s=qR(r.children);n.push(new ia(r.value,s))}return n.filter(r=>!e.has(r))}function KR(t){let n=t;for(;n._sourceSegment;)n=n._sourceSegment;return n}function XR(t){let n=t,e=n._segmentIndexShift??0;for(;n._sourceSegment;)n=n._sourceSegment,e+=n._segmentIndexShift??0;return e-1}function YR(t){return t.data||{}}function ZR(t){return t.resolve||{}}function QR(t){return"string"==typeof t.title||null===t.title}function n_(t){return _i(n=>{const e=t(n);return e?_r(e).pipe(ye(()=>n)):At(n)})}const bc=new Ct("ROUTES");let r_=(()=>{class t{constructor(e,r){this.injector=e,this.compiler=r,this.componentLoaders=new WeakMap,this.childrenLoaders=new WeakMap}loadComponent(e){if(this.componentLoaders.get(e))return this.componentLoaders.get(e);if(e._loadedComponent)return At(e._loadedComponent);this.onLoadStartListener&&this.onLoadStartListener(e);const r=Na(e.loadComponent()).pipe(ye(eF),ds(o=>{this.onLoadEndListener&&this.onLoadEndListener(e),e._loadedComponent=o}),Pw(()=>{this.componentLoaders.delete(e)})),s=new nR(r,()=>new Zt).pipe(Fw());return this.componentLoaders.set(e,s),s}loadChildren(e,r){if(this.childrenLoaders.get(r))return this.childrenLoaders.get(r);if(r._loadedRoutes)return At({routes:r._loadedRoutes,injector:r._loadedInjector});this.onLoadStartListener&&this.onLoadStartListener(r);const o=this.loadModuleFactoryOrRoutes(r.loadChildren).pipe(ye(a=>{this.onLoadEndListener&&this.onLoadEndListener(r);let l,u,c=!1;Array.isArray(a)?u=a:(l=a.create(e).injector,u=aR(l.get(bc,[],Ot.Self|Ot.Optional)));return{routes:u.map(Qw),injector:l}}),Pw(()=>{this.childrenLoaders.delete(r)})),i=new nR(o,()=>new Zt).pipe(Fw());return this.childrenLoaders.set(r,i),i}loadModuleFactoryOrRoutes(e){return Na(e()).pipe(ye(eF),Xr(s=>s instanceof $N||Array.isArray(s)?At(s):_r(this.compiler.compileModuleAsync(s))))}}return t.\u0275fac=function(e){return new(e||t)(Et(Ds),Et(DA))},t.\u0275prov=kt({token:t,factory:t.\u0275fac,providedIn:"root"}),t})();function eF(t){return function d9(t){return t&&"object"==typeof t&&"default"in t}(t)?t.default:t}let _g=(()=>{class t{get hasRequestedNavigation(){return 0!==this.navigationId}constructor(){this.currentNavigation=null,this.lastSuccessfulNavigation=null,this.events=new Zt,this.configLoader=cn(r_),this.environmentInjector=cn(Yi),this.urlSerializer=cn(hh),this.rootContexts=cn(vh),this.navigationId=0,this.afterPreactivation=()=>At(void 0),this.rootComponentType=null,this.configLoader.onLoadEndListener=s=>this.events.next(new ZK(s)),this.configLoader.onLoadStartListener=s=>this.events.next(new YK(s))}complete(){this.transitions?.complete()}handleNavigationRequest(e){const r=++this.navigationId;this.transitions?.next({...this.transitions.value,...e,id:r})}setupNavigations(e){return this.transitions=new Zo({id:0,targetPageId:0,currentUrlTree:e.currentUrlTree,currentRawUrl:e.currentUrlTree,extractedUrl:e.urlHandlingStrategy.extract(e.currentUrlTree),urlAfterRedirects:e.urlHandlingStrategy.extract(e.currentUrlTree),rawUrl:e.currentUrlTree,extras:{},resolve:null,reject:null,promise:Promise.resolve(!0),source:gh,restoredState:null,currentSnapshot:e.routerState.snapshot,targetSnapshot:null,currentRouterState:e.routerState,targetRouterState:null,guards:{canActivateChecks:[],canDeactivateChecks:[]},guardsResult:null}),this.transitions.pipe(Ta(r=>0!==r.id),ye(r=>({...r,extractedUrl:e.urlHandlingStrategy.extract(r.rawUrl)})),_i(r=>{let s=!1,o=!1;return At(r).pipe(ds(i=>{this.currentNavigation={id:i.id,initialUrl:i.rawUrl,extractedUrl:i.extractedUrl,trigger:i.source,extras:i.extras,previousNavigation:this.lastSuccessfulNavigation?{...this.lastSuccessfulNavigation,previousNavigation:null}:null}}),_i(i=>{const a=e.browserUrlTree.toString(),l=!e.navigated||i.extractedUrl.toString()!==a||a!==e.currentUrlTree.toString();if(!l&&"reload"!==(i.extras.onSameUrlNavigation??e.onSameUrlNavigation)){const c="";return this.events.next(new hg(i.id,e.serializeUrl(r.rawUrl),c,0)),e.rawUrlTree=i.rawUrl,i.resolve(null),di}if(e.urlHandlingStrategy.shouldProcessUrl(i.rawUrl))return tF(i.source)&&(e.browserUrlTree=i.extractedUrl),At(i).pipe(_i(c=>{const d=this.transitions?.getValue();return this.events.next(new Uw(c.id,this.urlSerializer.serialize(c.extractedUrl),c.source,c.restoredState)),d!==this.transitions?.getValue()?di:Promise.resolve(c)}),function X7(t,n,e,r){return _i(s=>function q7(t,n,e,r,s){return new K7(t,n,e,r,s).apply()}(t,n,e,s.extractedUrl,r).pipe(ye(o=>({...s,urlAfterRedirects:o}))))}(this.environmentInjector,this.configLoader,this.urlSerializer,e.config),ds(c=>{this.currentNavigation={...this.currentNavigation,finalUrl:c.urlAfterRedirects},r.urlAfterRedirects=c.urlAfterRedirects}),function s9(t,n,e,r,s){return Xr(o=>function Q7(t,n,e,r,s,o,i="emptyOnly"){return new J7(t,n,e,r,s,i,o).recognize().pipe(_i(a=>null===a?function Z7(t){return new Ve(n=>n.error(t))}(new Y7):At(a)))}(t,n,e,o.urlAfterRedirects,r.serialize(o.urlAfterRedirects),r,s).pipe(ye(i=>({...o,targetSnapshot:i}))))}(this.environmentInjector,this.rootComponentType,e.config,this.urlSerializer,e.paramsInheritanceStrategy),ds(c=>{if(r.targetSnapshot=c.targetSnapshot,"eager"===e.urlUpdateStrategy){if(!c.extras.skipLocationChange){const h=e.urlHandlingStrategy.merge(c.urlAfterRedirects,c.rawUrl);e.setBrowserUrl(h,c)}e.browserUrlTree=c.urlAfterRedirects}const d=new HK(c.id,this.urlSerializer.serialize(c.extractedUrl),this.urlSerializer.serialize(c.urlAfterRedirects),c.targetSnapshot);this.events.next(d)}));if(l&&e.urlHandlingStrategy.shouldProcessUrl(e.rawUrlTree)){const{id:c,extractedUrl:d,source:h,restoredState:p,extras:f}=i,g=new Uw(c,this.urlSerializer.serialize(d),h,p);this.events.next(g);const m=kR(d,this.rootComponentType).snapshot;return At(r={...i,targetSnapshot:m,urlAfterRedirects:d,extras:{...f,skipLocationChange:!1,replaceUrl:!1}})}{const c="";return this.events.next(new hg(i.id,e.serializeUrl(r.extractedUrl),c,1)),e.rawUrlTree=i.rawUrl,i.resolve(null),di}}),ds(i=>{const a=new jK(i.id,this.urlSerializer.serialize(i.extractedUrl),this.urlSerializer.serialize(i.urlAfterRedirects),i.targetSnapshot);this.events.next(a)}),ye(i=>r={...i,guards:x7(i.targetSnapshot,i.currentSnapshot,this.rootContexts)}),function A7(t,n){return Xr(e=>{const{targetSnapshot:r,currentSnapshot:s,guards:{canActivateChecks:o,canDeactivateChecks:i}}=e;return 0===i.length&&0===o.length?At({...e,guardsResult:!0}):function R7(t,n,e,r){return _r(t).pipe(Xr(s=>function L7(t,n,e,r,s){const o=n&&n.routeConfig?n.routeConfig.canDeactivate:null;return o&&0!==o.length?At(o.map(a=>{const l=bh(n)??s,u=yc(a,l);return Na(function k7(t){return t&&_h(t.canDeactivate)}(u)?u.canDeactivate(t,n,e,r):l.runInContext(()=>u(t,n,e,r))).pipe(ka())})).pipe(vc()):At(!0)}(s.component,s.route,e,n,r)),ka(s=>!0!==s,!0))}(i,r,s,t).pipe(Xr(a=>a&&function S7(t){return"boolean"==typeof t}(a)?function F7(t,n,e,r){return _r(n).pipe(Ol(s=>Rw(function P7(t,n){return null!==t&&n&&n(new QK(t)),At(!0)}(s.route.parent,r),function O7(t,n){return null!==t&&n&&n(new e7(t)),At(!0)}(s.route,r),function $7(t,n,e){const r=n[n.length-1],o=n.slice(0,n.length-1).reverse().map(i=>function w7(t){const n=t.routeConfig?t.routeConfig.canActivateChild:null;return n&&0!==n.length?{node:t,guards:n}:null}(i)).filter(i=>null!==i).map(i=>tR(()=>At(i.guards.map(l=>{const u=bh(i.node)??e,c=yc(l,u);return Na(function T7(t){return t&&_h(t.canActivateChild)}(c)?c.canActivateChild(r,t):u.runInContext(()=>c(r,t))).pipe(ka())})).pipe(vc())));return At(o).pipe(vc())}(t,s.path,e),function M7(t,n,e){const r=n.routeConfig?n.routeConfig.canActivate:null;if(!r||0===r.length)return At(!0);const s=r.map(o=>tR(()=>{const i=bh(n)??e,a=yc(o,i);return Na(function D7(t){return t&&_h(t.canActivate)}(a)?a.canActivate(n,t):i.runInContext(()=>a(n,t))).pipe(ka())}));return At(s).pipe(vc())}(t,s.route,e))),ka(s=>!0!==s,!0))}(r,o,t,n):At(a)),ye(a=>({...e,guardsResult:a})))})}(this.environmentInjector,i=>this.events.next(i)),ds(i=>{if(r.guardsResult=i.guardsResult,Ml(i.guardsResult))throw RR(0,i.guardsResult);const a=new qK(i.id,this.urlSerializer.serialize(i.extractedUrl),this.urlSerializer.serialize(i.urlAfterRedirects),i.targetSnapshot,!!i.guardsResult);this.events.next(a)}),Ta(i=>!!i.guardsResult||(e.restoreHistory(i),this.cancelNavigationTransition(i,"",3),!1)),n_(i=>{if(i.guards.canActivateChecks.length)return At(i).pipe(ds(a=>{const l=new KK(a.id,this.urlSerializer.serialize(a.extractedUrl),this.urlSerializer.serialize(a.urlAfterRedirects),a.targetSnapshot);this.events.next(l)}),_i(a=>{let l=!1;return At(a).pipe(function o9(t,n){return Xr(e=>{const{targetSnapshot:r,guards:{canActivateChecks:s}}=e;if(!s.length)return At(e);let o=0;return _r(s).pipe(Ol(i=>function i9(t,n,e,r){const s=t.routeConfig,o=t._resolve;return void 0!==s?.title&&!QR(s)&&(o[ch]=s.title),function a9(t,n,e,r){const s=function l9(t){return[...Object.keys(t),...Object.getOwnPropertySymbols(t)]}(t);if(0===s.length)return At({});const o={};return _r(s).pipe(Xr(i=>function u9(t,n,e,r){const s=bh(n)??r,o=yc(t,s);return Na(o.resolve?o.resolve(n,e):s.runInContext(()=>o(n,e)))}(t[i],n,e,r).pipe(ka(),ds(a=>{o[i]=a}))),Ow(1),function bK(t){return ye(()=>t)}(o),Ea(i=>Jw(i)?di:lh(i)))}(o,t,n,r).pipe(ye(i=>(t._resolvedData=i,t.data=ER(t,e).resolve,s&&QR(s)&&(t.data[ch]=s.title),null)))}(i.route,r,t,n)),ds(()=>o++),Ow(1),Xr(i=>o===s.length?At(e):di))})}(e.paramsInheritanceStrategy,this.environmentInjector),ds({next:()=>l=!0,complete:()=>{l||(e.restoreHistory(a),this.cancelNavigationTransition(a,"",2))}}))}),ds(a=>{const l=new XK(a.id,this.urlSerializer.serialize(a.extractedUrl),this.urlSerializer.serialize(a.urlAfterRedirects),a.targetSnapshot);this.events.next(l)}))}),n_(i=>{const a=l=>{const u=[];l.routeConfig?.loadComponent&&!l.routeConfig._loadedComponent&&u.push(this.configLoader.loadComponent(l.routeConfig).pipe(ds(c=>{l.component=c}),ye(()=>{})));for(const c of l.children)u.push(...a(c));return u};return J2(a(i.targetSnapshot.root)).pipe(rg(),uh(1))}),n_(()=>this.afterPreactivation()),ye(i=>{const a=function u7(t,n,e){const r=yh(t,n._root,e?e._root:void 0);return new TR(r,n)}(e.routeReuseStrategy,i.targetSnapshot,i.currentRouterState);return r={...i,targetRouterState:a}}),ds(i=>{e.currentUrlTree=i.urlAfterRedirects,e.rawUrlTree=e.urlHandlingStrategy.merge(i.urlAfterRedirects,i.rawUrl),e.routerState=i.targetRouterState,"deferred"===e.urlUpdateStrategy&&(i.extras.skipLocationChange||e.setBrowserUrl(e.rawUrlTree,i),e.browserUrlTree=i.urlAfterRedirects)}),((t,n,e)=>ye(r=>(new b7(n,r.targetRouterState,r.currentRouterState,e).activate(t),r)))(this.rootContexts,e.routeReuseStrategy,i=>this.events.next(i)),ds({next:i=>{s=!0,this.lastSuccessfulNavigation=this.currentNavigation,e.navigated=!0,this.events.next(new $l(i.id,this.urlSerializer.serialize(i.extractedUrl),this.urlSerializer.serialize(e.currentUrlTree))),e.titleStrategy?.updateTitle(i.targetRouterState.snapshot),i.resolve(!0)},complete:()=>{s=!0}}),Pw(()=>{s||o||this.cancelNavigationTransition(r,"",1),this.currentNavigation?.id===r.id&&(this.currentNavigation=null)}),Ea(i=>{if(o=!0,PR(i)){OR(i)||(e.navigated=!0,e.restoreHistory(r,!0));const a=new dg(r.id,this.urlSerializer.serialize(r.extractedUrl),i.message,i.cancellationCode);if(this.events.next(a),OR(i)){const l=e.urlHandlingStrategy.merge(i.url,e.rawUrlTree),u={skipLocationChange:r.extras.skipLocationChange,replaceUrl:"eager"===e.urlUpdateStrategy||tF(r.source)};e.scheduleNavigation(l,gh,null,u,{resolve:r.resolve,reject:r.reject,promise:r.promise})}else r.resolve(!1)}else{e.restoreHistory(r,!0);const a=new Ww(r.id,this.urlSerializer.serialize(r.extractedUrl),i,r.targetSnapshot??void 0);this.events.next(a);try{r.resolve(e.errorHandler(i))}catch(l){r.reject(l)}}return di}))}))}cancelNavigationTransition(e,r,s){const o=new dg(e.id,this.urlSerializer.serialize(e.extractedUrl),r,s);this.events.next(o),e.resolve(!1)}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=kt({token:t,factory:t.\u0275fac,providedIn:"root"}),t})();function tF(t){return t!==gh}let nF=(()=>{class t{buildTitle(e){let r,s=e.root;for(;void 0!==s;)r=this.getResolvedTitleForRoute(s)??r,s=s.children.find(o=>o.outlet===Gt);return r}getResolvedTitleForRoute(e){return e.data[ch]}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=kt({token:t,factory:function(){return cn(h9)},providedIn:"root"}),t})(),h9=(()=>{class t extends nF{constructor(e){super(),this.title=e}updateTitle(e){const r=this.buildTitle(e);void 0!==r&&this.title.setTitle(r)}}return t.\u0275fac=function(e){return new(e||t)(Et(q2))},t.\u0275prov=kt({token:t,factory:t.\u0275fac,providedIn:"root"}),t})(),p9=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=kt({token:t,factory:function(){return cn(m9)},providedIn:"root"}),t})();class f9{shouldDetach(n){return!1}store(n,e){}shouldAttach(n){return!1}retrieve(n){return null}shouldReuseRoute(n,e){return n.routeConfig===e.routeConfig}}let m9=(()=>{class t extends f9{}return t.\u0275fac=function(){let n;return function(r){return(n||(n=Qr(t)))(r||t)}}(),t.\u0275prov=kt({token:t,factory:t.\u0275fac,providedIn:"root"}),t})();const Cg=new Ct("",{providedIn:"root",factory:()=>({})});let y9=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=kt({token:t,factory:function(){return cn(v9)},providedIn:"root"}),t})(),v9=(()=>{class t{shouldProcessUrl(e){return!0}extract(e){return e}merge(e,r){return e}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=kt({token:t,factory:t.\u0275fac,providedIn:"root"}),t})();function b9(t){throw t}function x9(t,n,e){return n.parse("/")}const w9={paths:"exact",fragment:"ignored",matrixParams:"ignored",queryParams:"exact"},_9={paths:"subset",fragment:"ignored",matrixParams:"ignored",queryParams:"subset"};let oo=(()=>{class t{get navigationId(){return this.navigationTransitions.navigationId}get browserPageId(){return this.location.getState()?.\u0275routerPageId}get events(){return this.navigationTransitions.events}constructor(){this.disposed=!1,this.currentPageId=0,this.console=cn(q5),this.isNgZoneEnabled=!1,this.options=cn(Cg,{optional:!0})||{},this.errorHandler=this.options.errorHandler||b9,this.malformedUriErrorHandler=this.options.malformedUriErrorHandler||x9,this.navigated=!1,this.lastSuccessfulId=-1,this.urlHandlingStrategy=cn(y9),this.routeReuseStrategy=cn(p9),this.urlCreationStrategy=cn(i7),this.titleStrategy=cn(nF),this.onSameUrlNavigation=this.options.onSameUrlNavigation||"ignore",this.paramsInheritanceStrategy=this.options.paramsInheritanceStrategy||"emptyOnly",this.urlUpdateStrategy=this.options.urlUpdateStrategy||"deferred",this.canceledNavigationResolution=this.options.canceledNavigationResolution||"replace",this.config=aR(cn(bc,{optional:!0})??[]),this.navigationTransitions=cn(_g),this.urlSerializer=cn(hh),this.location=cn(iw),this.isNgZoneEnabled=cn(ur)instanceof ur&&ur.isInAngularZone(),this.resetConfig(this.config),this.currentUrlTree=new Aa,this.rawUrlTree=this.currentUrlTree,this.browserUrlTree=this.currentUrlTree,this.routerState=kR(this.currentUrlTree,null),this.navigationTransitions.setupNavigations(this).subscribe(e=>{this.lastSuccessfulId=e.id,this.currentPageId=e.targetPageId},e=>{this.console.warn(`Unhandled Navigation Error: ${e}`)})}resetRootComponentType(e){this.routerState.root.component=e,this.navigationTransitions.rootComponentType=e}initialNavigation(){if(this.setUpLocationChangeListener(),!this.navigationTransitions.hasRequestedNavigation){const e=this.location.getState();this.navigateToSyncWithBrowser(this.location.path(!0),gh,e)}}setUpLocationChangeListener(){this.locationSubscription||(this.locationSubscription=this.location.subscribe(e=>{const r="popstate"===e.type?"popstate":"hashchange";"popstate"===r&&setTimeout(()=>{this.navigateToSyncWithBrowser(e.url,r,e.state)},0)}))}navigateToSyncWithBrowser(e,r,s){const o={replaceUrl:!0},i=s?.navigationId?s:null;if(s){const l={...s};delete l.navigationId,delete l.\u0275routerPageId,0!==Object.keys(l).length&&(o.state=l)}const a=this.parseUrl(e);this.scheduleNavigation(a,r,i,o)}get url(){return this.serializeUrl(this.currentUrlTree)}getCurrentNavigation(){return this.navigationTransitions.currentNavigation}resetConfig(e){this.config=e.map(Qw),this.navigated=!1,this.lastSuccessfulId=-1}ngOnDestroy(){this.dispose()}dispose(){this.navigationTransitions.complete(),this.locationSubscription&&(this.locationSubscription.unsubscribe(),this.locationSubscription=void 0),this.disposed=!0}createUrlTree(e,r={}){const{relativeTo:s,queryParams:o,fragment:i,queryParamsHandling:a,preserveFragment:l}=r,u=l?this.currentUrlTree.fragment:i;let c=null;switch(a){case"merge":c={...this.currentUrlTree.queryParams,...o};break;case"preserve":c=this.currentUrlTree.queryParams;break;default:c=o||null}return null!==c&&(c=this.removeEmptyProps(c)),this.urlCreationStrategy.createUrlTree(s,this.routerState,this.currentUrlTree,e,c,u??null)}navigateByUrl(e,r={skipLocationChange:!1}){const s=Ml(e)?e:this.parseUrl(e),o=this.urlHandlingStrategy.merge(s,this.rawUrlTree);return this.scheduleNavigation(o,gh,null,r)}navigate(e,r={skipLocationChange:!1}){return function C9(t){for(let n=0;n<t.length;n++){const e=t[n];if(null==e)throw new Xe(4008,false)}}(e),this.navigateByUrl(this.createUrlTree(e,r),r)}serializeUrl(e){return this.urlSerializer.serialize(e)}parseUrl(e){let r;try{r=this.urlSerializer.parse(e)}catch(s){r=this.malformedUriErrorHandler(s,this.urlSerializer,e)}return r}isActive(e,r){let s;if(s=!0===r?{...w9}:!1===r?{..._9}:r,Ml(e))return cR(this.currentUrlTree,e,s);const o=this.parseUrl(e);return cR(this.currentUrlTree,o,s)}removeEmptyProps(e){return Object.keys(e).reduce((r,s)=>{const o=e[s];return null!=o&&(r[s]=o),r},{})}scheduleNavigation(e,r,s,o,i){if(this.disposed)return Promise.resolve(!1);let a,l,u,c;return i?(a=i.resolve,l=i.reject,u=i.promise):u=new Promise((d,h)=>{a=d,l=h}),c="computed"===this.canceledNavigationResolution?s&&s.\u0275routerPageId?s.\u0275routerPageId:o.replaceUrl||o.skipLocationChange?this.browserPageId??0:(this.browserPageId??0)+1:0,this.navigationTransitions.handleNavigationRequest({targetPageId:c,source:r,restoredState:s,currentUrlTree:this.currentUrlTree,currentRawUrl:this.currentUrlTree,rawUrl:e,extras:o,resolve:a,reject:l,promise:u,currentSnapshot:this.routerState.snapshot,currentRouterState:this.routerState}),u.catch(d=>Promise.reject(d))}setBrowserUrl(e,r){const s=this.urlSerializer.serialize(e),o={...r.extras.state,...this.generateNgRouterState(r.id,r.targetPageId)};this.location.isCurrentPathEqualTo(s)||r.extras.replaceUrl?this.location.replaceState(s,"",o):this.location.go(s,"",o)}restoreHistory(e,r=!1){if("computed"===this.canceledNavigationResolution){const s=this.currentPageId-e.targetPageId;"popstate"!==e.source&&"eager"!==this.urlUpdateStrategy&&this.currentUrlTree!==this.getCurrentNavigation()?.finalUrl||0===s?this.currentUrlTree===this.getCurrentNavigation()?.finalUrl&&0===s&&(this.resetState(e),this.browserUrlTree=e.currentUrlTree,this.resetUrlToCurrentUrlTree()):this.location.historyGo(s)}else"replace"===this.canceledNavigationResolution&&(r&&this.resetState(e),this.resetUrlToCurrentUrlTree())}resetState(e){this.routerState=e.currentRouterState,this.currentUrlTree=e.currentUrlTree,this.rawUrlTree=this.urlHandlingStrategy.merge(this.currentUrlTree,e.rawUrl)}resetUrlToCurrentUrlTree(){this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree),"",this.generateNgRouterState(this.lastSuccessfulId,this.currentPageId))}generateNgRouterState(e,r){return"computed"===this.canceledNavigationResolution?{navigationId:e,\u0275routerPageId:r}:{navigationId:e}}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=kt({token:t,factory:t.\u0275fac,providedIn:"root"}),t})();class rF{}let D9=(()=>{class t{constructor(e,r,s,o,i){this.router=e,this.injector=s,this.preloadingStrategy=o,this.loader=i}setUpPreloading(){this.subscription=this.router.events.pipe(Ta(e=>e instanceof $l),Ol(()=>this.preload())).subscribe(()=>{})}preload(){return this.processRoutes(this.injector,this.router.config)}ngOnDestroy(){this.subscription&&this.subscription.unsubscribe()}processRoutes(e,r){const s=[];for(const o of r){o.providers&&!o._injector&&(o._injector=km(o.providers,e,`Route: ${o.path}`));const i=o._injector??e,a=o._loadedInjector??i;o.loadChildren&&!o._loadedRoutes&&void 0===o.canLoad||o.loadComponent&&!o._loadedComponent?s.push(this.preloadConfig(i,o)):(o.children||o._loadedRoutes)&&s.push(this.processRoutes(a,o.children??o._loadedRoutes))}return _r(s).pipe(_u())}preloadConfig(e,r){return this.preloadingStrategy.preload(r,()=>{let s;s=r.loadChildren&&void 0===r.canLoad?this.loader.loadChildren(e,r):At(null);const o=s.pipe(Xr(i=>null===i?At(void 0):(r._loadedRoutes=i.routes,r._loadedInjector=i.injector,this.processRoutes(i.injector??e,i.routes))));return r.loadComponent&&!r._loadedComponent?_r([o,this.loader.loadComponent(r)]).pipe(_u()):o})}}return t.\u0275fac=function(e){return new(e||t)(Et(oo),Et(DA),Et(Yi),Et(rF),Et(r_))},t.\u0275prov=kt({token:t,factory:t.\u0275fac,providedIn:"root"}),t})();const i_=new Ct("");let sF=(()=>{class t{constructor(e,r,s,o,i={}){this.urlSerializer=e,this.transitions=r,this.viewportScroller=s,this.zone=o,this.options=i,this.lastId=0,this.lastSource="imperative",this.restoredId=0,this.store={},i.scrollPositionRestoration=i.scrollPositionRestoration||"disabled",i.anchorScrolling=i.anchorScrolling||"disabled"}init(){"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.setHistoryScrollRestoration("manual"),this.routerEventsSubscription=this.createScrollEvents(),this.scrollEventsSubscription=this.consumeScrollEvents()}createScrollEvents(){return this.transitions.events.subscribe(e=>{e instanceof Uw?(this.store[this.lastId]=this.viewportScroller.getScrollPosition(),this.lastSource=e.navigationTrigger,this.restoredId=e.restoredState?e.restoredState.navigationId:0):e instanceof $l&&(this.lastId=e.id,this.scheduleScrollEvent(e,this.urlSerializer.parse(e.urlAfterRedirects).fragment))})}consumeScrollEvents(){return this.transitions.events.subscribe(e=>{e instanceof IR&&(e.position?"top"===this.options.scrollPositionRestoration?this.viewportScroller.scrollToPosition([0,0]):"enabled"===this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition(e.position):e.anchor&&"enabled"===this.options.anchorScrolling?this.viewportScroller.scrollToAnchor(e.anchor):"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition([0,0]))})}scheduleScrollEvent(e,r){this.zone.runOutsideAngular(()=>{setTimeout(()=>{this.zone.run(()=>{this.transitions.events.next(new IR(e,"popstate"===this.lastSource?this.store[this.restoredId]:null,r))})},0)})}ngOnDestroy(){this.routerEventsSubscription?.unsubscribe(),this.scrollEventsSubscription?.unsubscribe()}}return t.\u0275fac=function(e){!function Bk(){throw new Error("invalid")}()},t.\u0275prov=kt({token:t,factory:t.\u0275fac}),t})();var ao=(()=>((ao=ao||{})[ao.COMPLETE=0]="COMPLETE",ao[ao.FAILED=1]="FAILED",ao[ao.REDIRECTING=2]="REDIRECTING",ao))();const xc=!1;function Ra(t,n){return{\u0275kind:t,\u0275providers:n}}const a_=new Ct("",{providedIn:"root",factory:()=>!1});function iF(){const t=cn(Ds);return n=>{const e=t.get(eh);if(n!==e.components[0])return;const r=t.get(oo),s=t.get(aF);1===t.get(l_)&&r.initialNavigation(),t.get(lF,null,Ot.Optional)?.setUpPreloading(),t.get(i_,null,Ot.Optional)?.init(),r.resetRootComponentType(e.componentTypes[0]),s.closed||(s.next(),s.unsubscribe())}}const aF=new Ct(xc?"bootstrap done indicator":"",{factory:()=>new Zt}),l_=new Ct(xc?"initial navigation":"",{providedIn:"root",factory:()=>1});function A9(){let t=[];return t=xc?[{provide:cm,multi:!0,useFactory:()=>{const n=cn(oo);return()=>n.events.subscribe(e=>{console.group?.(`Router Event: ${e.constructor.name}`),console.log(function n7(t){if(!("type"in t))return`Unknown Router Event: ${t.constructor.name}`;switch(t.type){case 14:return`ActivationEnd(path: '${t.snapshot.routeConfig?.path||""}')`;case 13:return`ActivationStart(path: '${t.snapshot.routeConfig?.path||""}')`;case 12:return`ChildActivationEnd(path: '${t.snapshot.routeConfig?.path||""}')`;case 11:return`ChildActivationStart(path: '${t.snapshot.routeConfig?.path||""}')`;case 8:return`GuardsCheckEnd(id: ${t.id}, url: '${t.url}', urlAfterRedirects: '${t.urlAfterRedirects}', state: ${t.state}, shouldActivate: ${t.shouldActivate})`;case 7:return`GuardsCheckStart(id: ${t.id}, url: '${t.url}', urlAfterRedirects: '${t.urlAfterRedirects}', state: ${t.state})`;case 2:return`NavigationCancel(id: ${t.id}, url: '${t.url}')`;case 16:return`NavigationSkipped(id: ${t.id}, url: '${t.url}')`;case 1:return`NavigationEnd(id: ${t.id}, url: '${t.url}', urlAfterRedirects: '${t.urlAfterRedirects}')`;case 3:return`NavigationError(id: ${t.id}, url: '${t.url}', error: ${t.error})`;case 0:return`NavigationStart(id: ${t.id}, url: '${t.url}')`;case 6:return`ResolveEnd(id: ${t.id}, url: '${t.url}', urlAfterRedirects: '${t.urlAfterRedirects}', state: ${t.state})`;case 5:return`ResolveStart(id: ${t.id}, url: '${t.url}', urlAfterRedirects: '${t.urlAfterRedirects}', state: ${t.state})`;case 10:return`RouteConfigLoadEnd(path: ${t.route.path})`;case 9:return`RouteConfigLoadStart(path: ${t.route.path})`;case 4:return`RoutesRecognized(id: ${t.id}, url: '${t.url}', urlAfterRedirects: '${t.urlAfterRedirects}', state: ${t.state})`;case 15:return`Scroll(anchor: '${t.anchor}', position: '${t.position?`${t.position[0]}, ${t.position[1]}`:null}')`}}(e)),console.log(e),console.groupEnd?.()})}}]:[],Ra(1,t)}const lF=new Ct(xc?"router preloader":"");function R9(t){return Ra(0,[{provide:lF,useExisting:D9},{provide:rF,useExisting:t}])}const Sh=!1,uF=new Ct(Sh?"router duplicate forRoot guard":"ROUTER_FORROOT_GUARD"),F9=[iw,{provide:hh,useClass:Mw},oo,vh,{provide:gc,useFactory:function oF(t){return t.routerState.root},deps:[oo]},r_,Sh?{provide:a_,useValue:!0}:[]];function O9(){return new OA("Router",oo)}let cF=(()=>{class t{constructor(e){}static forRoot(e,r){return{ngModule:t,providers:[F9,Sh&&r?.enableTracing?A9().\u0275providers:[],{provide:bc,multi:!0,useValue:e},{provide:uF,useFactory:L9,deps:[[oo,new kd,new Ed]]},{provide:Cg,useValue:r||{}},r?.useHash?{provide:Fl,useClass:O6}:{provide:Fl,useClass:r2},{provide:i_,useFactory:()=>{const t=cn(eq),n=cn(ur),e=cn(Cg),r=cn(_g),s=cn(hh);return e.scrollOffset&&t.setOffset(e.scrollOffset),new sF(s,r,t,n,e)}},r?.preloadingStrategy?R9(r.preloadingStrategy).\u0275providers:[],{provide:OA,multi:!0,useFactory:O9},r?.initialNavigation?V9(r):[],[{provide:dF,useFactory:iF},{provide:FA,multi:!0,useExisting:dF}]]}}static forChild(e){return{ngModule:t,providers:[{provide:bc,multi:!0,useValue:e}]}}}return t.\u0275fac=function(e){return new(e||t)(Et(uF,8))},t.\u0275mod=wo({type:t}),t.\u0275inj=Zs({imports:[Yw]}),t})();function L9(t){if(Sh&&t)throw new Xe(4007,"The Router was provided more than once. This can happen if 'forRoot' is used outside of the root injector. Lazy loaded modules should use RouterModule.forChild() instead.");return"guarded"}function V9(t){return["disabled"===t.initialNavigation?Ra(3,[{provide:Om,multi:!0,useFactory:()=>{const n=cn(oo);return()=>{n.setUpLocationChangeListener()}}},{provide:l_,useValue:2}]).\u0275providers:[],"enabledBlocking"===t.initialNavigation?Ra(2,[{provide:l_,useValue:0},{provide:Om,multi:!0,deps:[Ds],useFactory:n=>{const e=n.get(R6,Promise.resolve());return()=>e.then(()=>new Promise(r=>{const s=n.get(oo),o=n.get(aF);(function T9(t,n){t.events.pipe(Ta(e=>e instanceof $l||e instanceof dg||e instanceof Ww||e instanceof hg),ye(e=>e instanceof $l||e instanceof hg?ao.COMPLETE:e instanceof dg&&(0===e.code||1===e.code)?ao.REDIRECTING:ao.FAILED),Ta(e=>e!==ao.REDIRECTING),uh(1)).subscribe(()=>{n()})})(s,()=>{r(!0)}),n.get(_g).afterPreactivation=()=>(r(!0),o.closed?At(void 0):o),s.initialNavigation()}))}}]).\u0275providers:[]]}const dF=new Ct(Sh?"Router Initializer":"");let hF=(()=>{class t{constructor(e,r){this._renderer=e,this._elementRef=r,this.onChange=s=>{},this.onTouched=()=>{}}setProperty(e,r){this._renderer.setProperty(this._elementRef.nativeElement,e,r)}registerOnTouched(e){this.onTouched=e}registerOnChange(e){this.onChange=e}setDisabledState(e){this.setProperty("disabled",e)}}return t.\u0275fac=function(e){return new(e||t)(Pe(Zi),Pe(us))},t.\u0275dir=Pt({type:t}),t})(),Ll=(()=>{class t extends hF{}return t.\u0275fac=function(){let n;return function(r){return(n||(n=Qr(t)))(r||t)}}(),t.\u0275dir=Pt({type:t,features:[Dn]}),t})();const Ii=new Ct("NgValueAccessor"),W9={provide:Ii,useExisting:zn(()=>Sg),multi:!0},H9=new Ct("CompositionEventMode");let Sg=(()=>{class t extends hF{constructor(e,r,s){super(e,r),this._compositionMode=s,this._composing=!1,null==this._compositionMode&&(this._compositionMode=!function G9(){const t=ra()?ra().getUserAgent():"";return/android (\d+)/.test(t.toLowerCase())}())}writeValue(e){this.setProperty("value",e??"")}_handleInput(e){(!this._compositionMode||this._compositionMode&&!this._composing)&&this.onChange(e)}_compositionStart(){this._composing=!0}_compositionEnd(e){this._composing=!1,this._compositionMode&&this.onChange(e)}}return t.\u0275fac=function(e){return new(e||t)(Pe(Zi),Pe(us),Pe(H9,8))},t.\u0275dir=Pt({type:t,selectors:[["input","formControlName","",3,"type","checkbox"],["textarea","formControlName",""],["input","formControl","",3,"type","checkbox"],["textarea","formControl",""],["input","ngModel","",3,"type","checkbox"],["textarea","ngModel",""],["","ngDefaultControl",""]],hostBindings:function(e,r){1&e&&at("input",function(o){return r._handleInput(o.target.value)})("blur",function(){return r.onTouched()})("compositionstart",function(){return r._compositionStart()})("compositionend",function(o){return r._compositionEnd(o.target.value)})},features:[Yn([W9]),Dn]}),t})();const j9=!1;function Fa(t){return null==t||("string"==typeof t||Array.isArray(t))&&0===t.length}function fF(t){return null!=t&&"number"==typeof t.length}const hs=new Ct("NgValidators"),Oa=new Ct("NgAsyncValidators"),q9=/^(?=.{1,254}$)(?=.{1,64}@)[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;class Ih{static min(n){return function mF(t){return n=>{if(Fa(n.value)||Fa(t))return null;const e=parseFloat(n.value);return!isNaN(e)&&e<t?{min:{min:t,actual:n.value}}:null}}(n)}static max(n){return function gF(t){return n=>{if(Fa(n.value)||Fa(t))return null;const e=parseFloat(n.value);return!isNaN(e)&&e>t?{max:{max:t,actual:n.value}}:null}}(n)}static required(n){return function yF(t){return Fa(t.value)?{required:!0}:null}(n)}static requiredTrue(n){return function vF(t){return!0===t.value?null:{required:!0}}(n)}static email(n){return function bF(t){return Fa(t.value)||q9.test(t.value)?null:{email:!0}}(n)}static minLength(n){return function xF(t){return n=>Fa(n.value)||!fF(n.value)?null:n.value.length<t?{minlength:{requiredLength:t,actualLength:n.value.length}}:null}(n)}static maxLength(n){return function wF(t){return n=>fF(n.value)&&n.value.length>t?{maxlength:{requiredLength:t,actualLength:n.value.length}}:null}(n)}static pattern(n){return function _F(t){if(!t)return Ig;let n,e;return"string"==typeof t?(e="","^"!==t.charAt(0)&&(e+="^"),e+=t,"$"!==t.charAt(t.length-1)&&(e+="$"),n=new RegExp(e)):(e=t.toString(),n=t),r=>{if(Fa(r.value))return null;const s=r.value;return n.test(s)?null:{pattern:{requiredPattern:e,actualValue:s}}}}(n)}static nullValidator(n){return null}static compose(n){return kF(n)}static composeAsync(n){return EF(n)}}function Ig(t){return null}function CF(t){return null!=t}function SF(t){const n=Wd(t)?_r(t):t;if(j9&&!gx(n)){let e="Expected async validator to return Promise or Observable.";throw"object"==typeof t&&(e+=" Are you using a synchronous validator where an async validator is expected?"),new Xe(-1101,e)}return n}function IF(t){let n={};return t.forEach(e=>{n=null!=e?{...n,...e}:n}),0===Object.keys(n).length?null:n}function DF(t,n){return n.map(e=>e(t))}function TF(t){return t.map(n=>function K9(t){return!t.validate}(n)?n:e=>n.validate(e))}function kF(t){if(!t)return null;const n=t.filter(CF);return 0==n.length?null:function(e){return IF(DF(e,n))}}function u_(t){return null!=t?kF(TF(t)):null}function EF(t){if(!t)return null;const n=t.filter(CF);return 0==n.length?null:function(e){return function z9(...t){const n=cD(t),{args:e,keys:r}=Y2(t),s=new Ve(o=>{const{length:i}=e;if(!i)return void o.complete();const a=new Array(i);let l=i,u=i;for(let c=0;c<i;c++){let d=!1;vo(e[c]).subscribe(vn(o,h=>{d||(d=!0,u--),a[c]=h},()=>l--,void 0,()=>{(!l||!d)&&(u||o.next(r?Q2(r,a):a),o.complete())}))}});return n?s.pipe(Z2(n)):s}(DF(e,n).map(SF)).pipe(ye(IF))}}function c_(t){return null!=t?EF(TF(t)):null}function NF(t,n){return null===t?[n]:Array.isArray(t)?[...t,n]:[t,n]}function AF(t){return t._rawValidators}function RF(t){return t._rawAsyncValidators}function d_(t){return t?Array.isArray(t)?t:[t]:[]}function Dg(t,n){return Array.isArray(t)?t.includes(n):t===n}function FF(t,n){const e=d_(n);return d_(t).forEach(s=>{Dg(e,s)||e.push(s)}),e}function OF(t,n){return d_(n).filter(e=>!Dg(t,e))}class PF{constructor(){this._rawValidators=[],this._rawAsyncValidators=[],this._onDestroyCallbacks=[]}get value(){return this.control?this.control.value:null}get valid(){return this.control?this.control.valid:null}get invalid(){return this.control?this.control.invalid:null}get pending(){return this.control?this.control.pending:null}get disabled(){return this.control?this.control.disabled:null}get enabled(){return this.control?this.control.enabled:null}get errors(){return this.control?this.control.errors:null}get pristine(){return this.control?this.control.pristine:null}get dirty(){return this.control?this.control.dirty:null}get touched(){return this.control?this.control.touched:null}get status(){return this.control?this.control.status:null}get untouched(){return this.control?this.control.untouched:null}get statusChanges(){return this.control?this.control.statusChanges:null}get valueChanges(){return this.control?this.control.valueChanges:null}get path(){return null}_setValidators(n){this._rawValidators=n||[],this._composedValidatorFn=u_(this._rawValidators)}_setAsyncValidators(n){this._rawAsyncValidators=n||[],this._composedAsyncValidatorFn=c_(this._rawAsyncValidators)}get validator(){return this._composedValidatorFn||null}get asyncValidator(){return this._composedAsyncValidatorFn||null}_registerOnDestroy(n){this._onDestroyCallbacks.push(n)}_invokeOnDestroyCallbacks(){this._onDestroyCallbacks.forEach(n=>n()),this._onDestroyCallbacks=[]}reset(n){this.control&&this.control.reset(n)}hasError(n,e){return!!this.control&&this.control.hasError(n,e)}getError(n,e){return this.control?this.control.getError(n,e):null}}class As extends PF{get formDirective(){return null}get path(){return null}}class Pa extends PF{constructor(){super(...arguments),this._parent=null,this.name=null,this.valueAccessor=null}}class MF{constructor(n){this._cd=n}get isTouched(){return!!this._cd?.control?.touched}get isUntouched(){return!!this._cd?.control?.untouched}get isPristine(){return!!this._cd?.control?.pristine}get isDirty(){return!!this._cd?.control?.dirty}get isValid(){return!!this._cd?.control?.valid}get isInvalid(){return!!this._cd?.control?.invalid}get isPending(){return!!this._cd?.control?.pending}get isSubmitted(){return!!this._cd?.submitted}}let $F=(()=>{class t extends MF{constructor(e){super(e)}}return t.\u0275fac=function(e){return new(e||t)(Pe(Pa,2))},t.\u0275dir=Pt({type:t,selectors:[["","formControlName",""],["","ngModel",""],["","formControl",""]],hostVars:14,hostBindings:function(e,r){2&e&&Ts("ng-untouched",r.isUntouched)("ng-touched",r.isTouched)("ng-pristine",r.isPristine)("ng-dirty",r.isDirty)("ng-valid",r.isValid)("ng-invalid",r.isInvalid)("ng-pending",r.isPending)},features:[Dn]}),t})(),LF=(()=>{class t extends MF{constructor(e){super(e)}}return t.\u0275fac=function(e){return new(e||t)(Pe(As,10))},t.\u0275dir=Pt({type:t,selectors:[["","formGroupName",""],["","formArrayName",""],["","ngModelGroup",""],["","formGroup",""],["form",3,"ngNoForm",""],["","ngForm",""]],hostVars:16,hostBindings:function(e,r){2&e&&Ts("ng-untouched",r.isUntouched)("ng-touched",r.isTouched)("ng-pristine",r.isPristine)("ng-dirty",r.isDirty)("ng-valid",r.isValid)("ng-invalid",r.isInvalid)("ng-pending",r.isPending)("ng-submitted",r.isSubmitted)},features:[Dn]}),t})();function VF(t,n){return t?`with name: '${n}'`:`at index: ${n}`}const f_=!1,Dh="VALID",kg="INVALID",wc="PENDING",Th="DISABLED";function m_(t){return(Eg(t)?t.validators:t)||null}function g_(t,n){return(Eg(n)?n.asyncValidators:t)||null}function Eg(t){return null!=t&&!Array.isArray(t)&&"object"==typeof t}function BF(t,n,e){const r=t.controls;if(!(n?Object.keys(r):r).length)throw new Xe(1e3,f_?function Q9(t){return`\n    There are no form controls registered with this ${t?"group":"array"} yet. If you're using ngModel,\n    you may want to check next tick (e.g. use setTimeout).\n  `}(n):"");if(!r[e])throw new Xe(1001,f_?function J9(t,n){return`Cannot find form control ${VF(t,n)}`}(n,e):"")}function zF(t,n,e){t._forEachChild((r,s)=>{if(void 0===e[s])throw new Xe(1002,f_?function eX(t,n){return`Must supply a value for form control ${VF(t,n)}`}(n,s):"")})}class Ng{constructor(n,e){this._pendingDirty=!1,this._hasOwnPendingAsyncValidator=!1,this._pendingTouched=!1,this._onCollectionChange=()=>{},this._parent=null,this.pristine=!0,this.touched=!1,this._onDisabledChange=[],this._assignValidators(n),this._assignAsyncValidators(e)}get validator(){return this._composedValidatorFn}set validator(n){this._rawValidators=this._composedValidatorFn=n}get asyncValidator(){return this._composedAsyncValidatorFn}set asyncValidator(n){this._rawAsyncValidators=this._composedAsyncValidatorFn=n}get parent(){return this._parent}get valid(){return this.status===Dh}get invalid(){return this.status===kg}get pending(){return this.status==wc}get disabled(){return this.status===Th}get enabled(){return this.status!==Th}get dirty(){return!this.pristine}get untouched(){return!this.touched}get updateOn(){return this._updateOn?this._updateOn:this.parent?this.parent.updateOn:"change"}setValidators(n){this._assignValidators(n)}setAsyncValidators(n){this._assignAsyncValidators(n)}addValidators(n){this.setValidators(FF(n,this._rawValidators))}addAsyncValidators(n){this.setAsyncValidators(FF(n,this._rawAsyncValidators))}removeValidators(n){this.setValidators(OF(n,this._rawValidators))}removeAsyncValidators(n){this.setAsyncValidators(OF(n,this._rawAsyncValidators))}hasValidator(n){return Dg(this._rawValidators,n)}hasAsyncValidator(n){return Dg(this._rawAsyncValidators,n)}clearValidators(){this.validator=null}clearAsyncValidators(){this.asyncValidator=null}markAsTouched(n={}){this.touched=!0,this._parent&&!n.onlySelf&&this._parent.markAsTouched(n)}markAllAsTouched(){this.markAsTouched({onlySelf:!0}),this._forEachChild(n=>n.markAllAsTouched())}markAsUntouched(n={}){this.touched=!1,this._pendingTouched=!1,this._forEachChild(e=>{e.markAsUntouched({onlySelf:!0})}),this._parent&&!n.onlySelf&&this._parent._updateTouched(n)}markAsDirty(n={}){this.pristine=!1,this._parent&&!n.onlySelf&&this._parent.markAsDirty(n)}markAsPristine(n={}){this.pristine=!0,this._pendingDirty=!1,this._forEachChild(e=>{e.markAsPristine({onlySelf:!0})}),this._parent&&!n.onlySelf&&this._parent._updatePristine(n)}markAsPending(n={}){this.status=wc,!1!==n.emitEvent&&this.statusChanges.emit(this.status),this._parent&&!n.onlySelf&&this._parent.markAsPending(n)}disable(n={}){const e=this._parentMarkedDirty(n.onlySelf);this.status=Th,this.errors=null,this._forEachChild(r=>{r.disable({...n,onlySelf:!0})}),this._updateValue(),!1!==n.emitEvent&&(this.valueChanges.emit(this.value),this.statusChanges.emit(this.status)),this._updateAncestors({...n,skipPristineCheck:e}),this._onDisabledChange.forEach(r=>r(!0))}enable(n={}){const e=this._parentMarkedDirty(n.onlySelf);this.status=Dh,this._forEachChild(r=>{r.enable({...n,onlySelf:!0})}),this.updateValueAndValidity({onlySelf:!0,emitEvent:n.emitEvent}),this._updateAncestors({...n,skipPristineCheck:e}),this._onDisabledChange.forEach(r=>r(!1))}_updateAncestors(n){this._parent&&!n.onlySelf&&(this._parent.updateValueAndValidity(n),n.skipPristineCheck||this._parent._updatePristine(),this._parent._updateTouched())}setParent(n){this._parent=n}getRawValue(){return this.value}updateValueAndValidity(n={}){this._setInitialStatus(),this._updateValue(),this.enabled&&(this._cancelExistingSubscription(),this.errors=this._runValidator(),this.status=this._calculateStatus(),(this.status===Dh||this.status===wc)&&this._runAsyncValidator(n.emitEvent)),!1!==n.emitEvent&&(this.valueChanges.emit(this.value),this.statusChanges.emit(this.status)),this._parent&&!n.onlySelf&&this._parent.updateValueAndValidity(n)}_updateTreeValidity(n={emitEvent:!0}){this._forEachChild(e=>e._updateTreeValidity(n)),this.updateValueAndValidity({onlySelf:!0,emitEvent:n.emitEvent})}_setInitialStatus(){this.status=this._allControlsDisabled()?Th:Dh}_runValidator(){return this.validator?this.validator(this):null}_runAsyncValidator(n){if(this.asyncValidator){this.status=wc,this._hasOwnPendingAsyncValidator=!0;const e=SF(this.asyncValidator(this));this._asyncValidationSubscription=e.subscribe(r=>{this._hasOwnPendingAsyncValidator=!1,this.setErrors(r,{emitEvent:n})})}}_cancelExistingSubscription(){this._asyncValidationSubscription&&(this._asyncValidationSubscription.unsubscribe(),this._hasOwnPendingAsyncValidator=!1)}setErrors(n,e={}){this.errors=n,this._updateControlsErrors(!1!==e.emitEvent)}get(n){let e=n;return null==e||(Array.isArray(e)||(e=e.split(".")),0===e.length)?null:e.reduce((r,s)=>r&&r._find(s),this)}getError(n,e){const r=e?this.get(e):this;return r&&r.errors?r.errors[n]:null}hasError(n,e){return!!this.getError(n,e)}get root(){let n=this;for(;n._parent;)n=n._parent;return n}_updateControlsErrors(n){this.status=this._calculateStatus(),n&&this.statusChanges.emit(this.status),this._parent&&this._parent._updateControlsErrors(n)}_initObservables(){this.valueChanges=new nn,this.statusChanges=new nn}_calculateStatus(){return this._allControlsDisabled()?Th:this.errors?kg:this._hasOwnPendingAsyncValidator||this._anyControlsHaveStatus(wc)?wc:this._anyControlsHaveStatus(kg)?kg:Dh}_anyControlsHaveStatus(n){return this._anyControls(e=>e.status===n)}_anyControlsDirty(){return this._anyControls(n=>n.dirty)}_anyControlsTouched(){return this._anyControls(n=>n.touched)}_updatePristine(n={}){this.pristine=!this._anyControlsDirty(),this._parent&&!n.onlySelf&&this._parent._updatePristine(n)}_updateTouched(n={}){this.touched=this._anyControlsTouched(),this._parent&&!n.onlySelf&&this._parent._updateTouched(n)}_registerOnCollectionChange(n){this._onCollectionChange=n}_setUpdateStrategy(n){Eg(n)&&null!=n.updateOn&&(this._updateOn=n.updateOn)}_parentMarkedDirty(n){return!n&&!(!this._parent||!this._parent.dirty)&&!this._parent._anyControlsDirty()}_find(n){return null}_assignValidators(n){this._rawValidators=Array.isArray(n)?n.slice():n,this._composedValidatorFn=function tX(t){return Array.isArray(t)?u_(t):t||null}(this._rawValidators)}_assignAsyncValidators(n){this._rawAsyncValidators=Array.isArray(n)?n.slice():n,this._composedAsyncValidatorFn=function nX(t){return Array.isArray(t)?c_(t):t||null}(this._rawAsyncValidators)}}class kh extends Ng{constructor(n,e,r){super(m_(e),g_(r,e)),this.controls=n,this._initObservables(),this._setUpdateStrategy(e),this._setUpControls(),this.updateValueAndValidity({onlySelf:!0,emitEvent:!!this.asyncValidator})}registerControl(n,e){return this.controls[n]?this.controls[n]:(this.controls[n]=e,e.setParent(this),e._registerOnCollectionChange(this._onCollectionChange),e)}addControl(n,e,r={}){this.registerControl(n,e),this.updateValueAndValidity({emitEvent:r.emitEvent}),this._onCollectionChange()}removeControl(n,e={}){this.controls[n]&&this.controls[n]._registerOnCollectionChange(()=>{}),delete this.controls[n],this.updateValueAndValidity({emitEvent:e.emitEvent}),this._onCollectionChange()}setControl(n,e,r={}){this.controls[n]&&this.controls[n]._registerOnCollectionChange(()=>{}),delete this.controls[n],e&&this.registerControl(n,e),this.updateValueAndValidity({emitEvent:r.emitEvent}),this._onCollectionChange()}contains(n){return this.controls.hasOwnProperty(n)&&this.controls[n].enabled}setValue(n,e={}){zF(this,!0,n),Object.keys(n).forEach(r=>{BF(this,!0,r),this.controls[r].setValue(n[r],{onlySelf:!0,emitEvent:e.emitEvent})}),this.updateValueAndValidity(e)}patchValue(n,e={}){null!=n&&(Object.keys(n).forEach(r=>{const s=this.controls[r];s&&s.patchValue(n[r],{onlySelf:!0,emitEvent:e.emitEvent})}),this.updateValueAndValidity(e))}reset(n={},e={}){this._forEachChild((r,s)=>{r.reset(n[s],{onlySelf:!0,emitEvent:e.emitEvent})}),this._updatePristine(e),this._updateTouched(e),this.updateValueAndValidity(e)}getRawValue(){return this._reduceChildren({},(n,e,r)=>(n[r]=e.getRawValue(),n))}_syncPendingControls(){let n=this._reduceChildren(!1,(e,r)=>!!r._syncPendingControls()||e);return n&&this.updateValueAndValidity({onlySelf:!0}),n}_forEachChild(n){Object.keys(this.controls).forEach(e=>{const r=this.controls[e];r&&n(r,e)})}_setUpControls(){this._forEachChild(n=>{n.setParent(this),n._registerOnCollectionChange(this._onCollectionChange)})}_updateValue(){this.value=this._reduceValue()}_anyControls(n){for(const[e,r]of Object.entries(this.controls))if(this.contains(e)&&n(r))return!0;return!1}_reduceValue(){return this._reduceChildren({},(e,r,s)=>((r.enabled||this.disabled)&&(e[s]=r.value),e))}_reduceChildren(n,e){let r=n;return this._forEachChild((s,o)=>{r=e(r,s,o)}),r}_allControlsDisabled(){for(const n of Object.keys(this.controls))if(this.controls[n].enabled)return!1;return Object.keys(this.controls).length>0||this.disabled}_find(n){return this.controls.hasOwnProperty(n)?this.controls[n]:null}}class UF extends kh{}const Vl=new Ct("CallSetDisabledState",{providedIn:"root",factory:()=>Eh}),Eh="always";function Ag(t,n){return[...n.path,t]}function Nh(t,n,e=Eh){y_(t,n),n.valueAccessor.writeValue(t.value),(t.disabled||"always"===e)&&n.valueAccessor.setDisabledState?.(t.disabled),function sX(t,n){n.valueAccessor.registerOnChange(e=>{t._pendingValue=e,t._pendingChange=!0,t._pendingDirty=!0,"change"===t.updateOn&&WF(t,n)})}(t,n),function iX(t,n){const e=(r,s)=>{n.valueAccessor.writeValue(r),s&&n.viewToModelUpdate(r)};t.registerOnChange(e),n._registerOnDestroy(()=>{t._unregisterOnChange(e)})}(t,n),function oX(t,n){n.valueAccessor.registerOnTouched(()=>{t._pendingTouched=!0,"blur"===t.updateOn&&t._pendingChange&&WF(t,n),"submit"!==t.updateOn&&t.markAsTouched()})}(t,n),function rX(t,n){if(n.valueAccessor.setDisabledState){const e=r=>{n.valueAccessor.setDisabledState(r)};t.registerOnDisabledChange(e),n._registerOnDestroy(()=>{t._unregisterOnDisabledChange(e)})}}(t,n)}function Rg(t,n,e=!0){const r=()=>{};n.valueAccessor&&(n.valueAccessor.registerOnChange(r),n.valueAccessor.registerOnTouched(r)),Og(t,n),t&&(n._invokeOnDestroyCallbacks(),t._registerOnCollectionChange(()=>{}))}function Fg(t,n){t.forEach(e=>{e.registerOnValidatorChange&&e.registerOnValidatorChange(n)})}function y_(t,n){const e=AF(t);null!==n.validator?t.setValidators(NF(e,n.validator)):"function"==typeof e&&t.setValidators([e]);const r=RF(t);null!==n.asyncValidator?t.setAsyncValidators(NF(r,n.asyncValidator)):"function"==typeof r&&t.setAsyncValidators([r]);const s=()=>t.updateValueAndValidity();Fg(n._rawValidators,s),Fg(n._rawAsyncValidators,s)}function Og(t,n){let e=!1;if(null!==t){if(null!==n.validator){const s=AF(t);if(Array.isArray(s)&&s.length>0){const o=s.filter(i=>i!==n.validator);o.length!==s.length&&(e=!0,t.setValidators(o))}}if(null!==n.asyncValidator){const s=RF(t);if(Array.isArray(s)&&s.length>0){const o=s.filter(i=>i!==n.asyncValidator);o.length!==s.length&&(e=!0,t.setAsyncValidators(o))}}}const r=()=>{};return Fg(n._rawValidators,r),Fg(n._rawAsyncValidators,r),e}function WF(t,n){t._pendingDirty&&t.markAsDirty(),t.setValue(t._pendingValue,{emitModelToViewChange:!1}),n.viewToModelUpdate(t._pendingValue),t._pendingChange=!1}function b_(t,n){if(!t.hasOwnProperty("model"))return!1;const e=t.model;return!!e.isFirstChange()||!Object.is(n,e.currentValue)}function x_(t,n){if(!n)return null;let e,r,s;return Array.isArray(n),n.forEach(o=>{o.constructor===Sg?e=o:function uX(t){return Object.getPrototypeOf(t.constructor)===Ll}(o)?r=o:s=o}),s||r||e||null}function jF(t,n){const e=t.indexOf(n);e>-1&&t.splice(e,1)}function qF(t){return"object"==typeof t&&null!==t&&2===Object.keys(t).length&&"value"in t&&"disabled"in t}const Rh=class extends Ng{constructor(n=null,e,r){super(m_(e),g_(r,e)),this.defaultValue=null,this._onChange=[],this._pendingChange=!1,this._applyFormState(n),this._setUpdateStrategy(e),this._initObservables(),this.updateValueAndValidity({onlySelf:!0,emitEvent:!!this.asyncValidator}),Eg(e)&&(e.nonNullable||e.initialValueIsDefault)&&(this.defaultValue=qF(n)?n.value:n)}setValue(n,e={}){this.value=this._pendingValue=n,this._onChange.length&&!1!==e.emitModelToViewChange&&this._onChange.forEach(r=>r(this.value,!1!==e.emitViewToModelChange)),this.updateValueAndValidity(e)}patchValue(n,e={}){this.setValue(n,e)}reset(n=this.defaultValue,e={}){this._applyFormState(n),this.markAsPristine(e),this.markAsUntouched(e),this.setValue(this.value,e),this._pendingChange=!1}_updateValue(){}_anyControls(n){return!1}_allControlsDisabled(){return this.disabled}registerOnChange(n){this._onChange.push(n)}_unregisterOnChange(n){jF(this._onChange,n)}registerOnDisabledChange(n){this._onDisabledChange.push(n)}_unregisterOnDisabledChange(n){jF(this._onDisabledChange,n)}_forEachChild(n){}_syncPendingControls(){return!("submit"!==this.updateOn||(this._pendingDirty&&this.markAsDirty(),this._pendingTouched&&this.markAsTouched(),!this._pendingChange)||(this.setValue(this._pendingValue,{onlySelf:!0,emitModelToViewChange:!1}),0))}_applyFormState(n){qF(n)?(this.value=this._pendingValue=n.value,n.disabled?this.disable({onlySelf:!0,emitEvent:!1}):this.enable({onlySelf:!0,emitEvent:!1})):this.value=this._pendingValue=n}},fX={provide:Pa,useExisting:zn(()=>__)},YF=(()=>Promise.resolve())();let __=(()=>{class t extends Pa{constructor(e,r,s,o,i,a){super(),this._changeDetectorRef=i,this.callSetDisabledState=a,this.control=new Rh,this._registered=!1,this.update=new nn,this._parent=e,this._setValidators(r),this._setAsyncValidators(s),this.valueAccessor=x_(0,o)}ngOnChanges(e){if(this._checkForErrors(),!this._registered||"name"in e){if(this._registered&&(this._checkName(),this.formDirective)){const r=e.name.previousValue;this.formDirective.removeControl({name:r,path:this._getPath(r)})}this._setUpControl()}"isDisabled"in e&&this._updateDisabled(e),b_(e,this.viewModel)&&(this._updateValue(this.model),this.viewModel=this.model)}ngOnDestroy(){this.formDirective&&this.formDirective.removeControl(this)}get path(){return this._getPath(this.name)}get formDirective(){return this._parent?this._parent.formDirective:null}viewToModelUpdate(e){this.viewModel=e,this.update.emit(e)}_setUpControl(){this._setUpdateStrategy(),this._isStandalone()?this._setUpStandalone():this.formDirective.addControl(this),this._registered=!0}_setUpdateStrategy(){this.options&&null!=this.options.updateOn&&(this.control._updateOn=this.options.updateOn)}_isStandalone(){return!this._parent||!(!this.options||!this.options.standalone)}_setUpStandalone(){Nh(this.control,this,this.callSetDisabledState),this.control.updateValueAndValidity({emitEvent:!1})}_checkForErrors(){this._isStandalone()||this._checkParentType(),this._checkName()}_checkParentType(){}_checkName(){this.options&&this.options.name&&(this.name=this.options.name),this._isStandalone()}_updateValue(e){YF.then(()=>{this.control.setValue(e,{emitViewToModelChange:!1}),this._changeDetectorRef?.markForCheck()})}_updateDisabled(e){const r=e.isDisabled.currentValue,s=0!==r&&function cc(t){return"boolean"==typeof t?t:null!=t&&"false"!==t}(r);YF.then(()=>{s&&!this.control.disabled?this.control.disable():!s&&this.control.disabled&&this.control.enable(),this._changeDetectorRef?.markForCheck()})}_getPath(e){return this._parent?Ag(e,this._parent):[e]}}return t.\u0275fac=function(e){return new(e||t)(Pe(As,9),Pe(hs,10),Pe(Oa,10),Pe(Ii,10),Pe(th,8),Pe(Vl,8))},t.\u0275dir=Pt({type:t,selectors:[["","ngModel","",3,"formControlName","",3,"formControl",""]],inputs:{name:"name",isDisabled:["disabled","isDisabled"],model:["ngModel","model"],options:["ngModelOptions","options"]},outputs:{update:"ngModelChange"},exportAs:["ngModel"],features:[Yn([fX]),Dn,eo]}),t})(),ZF=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275dir=Pt({type:t,selectors:[["form",3,"ngNoForm","",3,"ngNativeValidate",""]],hostAttrs:["novalidate",""]}),t})();const mX={provide:Ii,useExisting:zn(()=>C_),multi:!0};let C_=(()=>{class t extends Ll{writeValue(e){this.setProperty("value",e??"")}registerOnChange(e){this.onChange=r=>{e(""==r?null:parseFloat(r))}}}return t.\u0275fac=function(){let n;return function(r){return(n||(n=Qr(t)))(r||t)}}(),t.\u0275dir=Pt({type:t,selectors:[["input","type","number","formControlName",""],["input","type","number","formControl",""],["input","type","number","ngModel",""]],hostBindings:function(e,r){1&e&&at("input",function(o){return r.onChange(o.target.value)})("blur",function(){return r.onTouched()})},features:[Yn([mX]),Dn]}),t})(),QF=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=wo({type:t}),t.\u0275inj=Zs({}),t})();const S_=new Ct("NgModelWithFormControlWarning"),xX={provide:As,useExisting:zn(()=>Pg)};let Pg=(()=>{class t extends As{constructor(e,r,s){super(),this.callSetDisabledState=s,this.submitted=!1,this._onCollectionChange=()=>this._updateDomValue(),this.directives=[],this.form=null,this.ngSubmit=new nn,this._setValidators(e),this._setAsyncValidators(r)}ngOnChanges(e){this._checkFormPresent(),e.hasOwnProperty("form")&&(this._updateValidators(),this._updateDomValue(),this._updateRegistrations(),this._oldForm=this.form)}ngOnDestroy(){this.form&&(Og(this.form,this),this.form._onCollectionChange===this._onCollectionChange&&this.form._registerOnCollectionChange(()=>{}))}get formDirective(){return this}get control(){return this.form}get path(){return[]}addControl(e){const r=this.form.get(e.path);return Nh(r,e,this.callSetDisabledState),r.updateValueAndValidity({emitEvent:!1}),this.directives.push(e),r}getControl(e){return this.form.get(e.path)}removeControl(e){Rg(e.control||null,e,!1),function cX(t,n){const e=t.indexOf(n);e>-1&&t.splice(e,1)}(this.directives,e)}addFormGroup(e){this._setUpFormContainer(e)}removeFormGroup(e){this._cleanUpFormContainer(e)}getFormGroup(e){return this.form.get(e.path)}addFormArray(e){this._setUpFormContainer(e)}removeFormArray(e){this._cleanUpFormContainer(e)}getFormArray(e){return this.form.get(e.path)}updateModel(e,r){this.form.get(e.path).setValue(r)}onSubmit(e){return this.submitted=!0,function HF(t,n){t._syncPendingControls(),n.forEach(e=>{const r=e.control;"submit"===r.updateOn&&r._pendingChange&&(e.viewToModelUpdate(r._pendingValue),r._pendingChange=!1)})}(this.form,this.directives),this.ngSubmit.emit(e),"dialog"===e?.target?.method}onReset(){this.resetForm()}resetForm(e){this.form.reset(e),this.submitted=!1}_updateDomValue(){this.directives.forEach(e=>{const r=e.control,s=this.form.get(e.path);r!==s&&(Rg(r||null,e),(t=>t instanceof Rh)(s)&&(Nh(s,e,this.callSetDisabledState),e.control=s))}),this.form._updateTreeValidity({emitEvent:!1})}_setUpFormContainer(e){const r=this.form.get(e.path);(function GF(t,n){y_(t,n)})(r,e),r.updateValueAndValidity({emitEvent:!1})}_cleanUpFormContainer(e){if(this.form){const r=this.form.get(e.path);r&&function aX(t,n){return Og(t,n)}(r,e)&&r.updateValueAndValidity({emitEvent:!1})}}_updateRegistrations(){this.form._registerOnCollectionChange(this._onCollectionChange),this._oldForm&&this._oldForm._registerOnCollectionChange(()=>{})}_updateValidators(){y_(this.form,this),this._oldForm&&Og(this._oldForm,this)}_checkFormPresent(){}}return t.\u0275fac=function(e){return new(e||t)(Pe(hs,10),Pe(Oa,10),Pe(Vl,8))},t.\u0275dir=Pt({type:t,selectors:[["","formGroup",""]],hostBindings:function(e,r){1&e&&at("submit",function(o){return r.onSubmit(o)})("reset",function(){return r.onReset()})},inputs:{form:["formGroup","form"]},outputs:{ngSubmit:"ngSubmit"},exportAs:["ngForm"],features:[Yn([xX]),Dn,eo]}),t})();const CX={provide:Pa,useExisting:zn(()=>T_)};let T_=(()=>{class t extends Pa{set isDisabled(e){}constructor(e,r,s,o,i){super(),this._ngModelWarningConfig=i,this._added=!1,this.update=new nn,this._ngModelWarningSent=!1,this._parent=e,this._setValidators(r),this._setAsyncValidators(s),this.valueAccessor=x_(0,o)}ngOnChanges(e){this._added||this._setUpControl(),b_(e,this.viewModel)&&(this.viewModel=this.model,this.formDirective.updateModel(this,this.model))}ngOnDestroy(){this.formDirective&&this.formDirective.removeControl(this)}viewToModelUpdate(e){this.viewModel=e,this.update.emit(e)}get path(){return Ag(null==this.name?this.name:this.name.toString(),this._parent)}get formDirective(){return this._parent?this._parent.formDirective:null}_checkParentType(){}_setUpControl(){this._checkParentType(),this.control=this.formDirective.addControl(this),this._added=!0}}return t._ngModelWarningSentOnce=!1,t.\u0275fac=function(e){return new(e||t)(Pe(As,13),Pe(hs,10),Pe(Oa,10),Pe(Ii,10),Pe(S_,8))},t.\u0275dir=Pt({type:t,selectors:[["","formControlName",""]],inputs:{name:["formControlName","name"],isDisabled:["disabled","isDisabled"],model:["ngModel","model"]},outputs:{update:"ngModelChange"},features:[Yn([CX]),Dn,eo]}),t})();const SX={provide:Ii,useExisting:zn(()=>Mg),multi:!0};function rO(t,n){return null==t?`${n}`:(n&&"object"==typeof n&&(n="Object"),`${t}: ${n}`.slice(0,50))}let Mg=(()=>{class t extends Ll{constructor(){super(...arguments),this._optionMap=new Map,this._idCounter=0,this._compareWith=Object.is}set compareWith(e){this._compareWith=e}writeValue(e){this.value=e;const s=rO(this._getOptionId(e),e);this.setProperty("value",s)}registerOnChange(e){this.onChange=r=>{this.value=this._getOptionValue(r),e(this.value)}}_registerOption(){return(this._idCounter++).toString()}_getOptionId(e){for(const r of Array.from(this._optionMap.keys()))if(this._compareWith(this._optionMap.get(r),e))return r;return null}_getOptionValue(e){const r=function IX(t){return t.split(":")[0]}(e);return this._optionMap.has(r)?this._optionMap.get(r):e}}return t.\u0275fac=function(){let n;return function(r){return(n||(n=Qr(t)))(r||t)}}(),t.\u0275dir=Pt({type:t,selectors:[["select","formControlName","",3,"multiple",""],["select","formControl","",3,"multiple",""],["select","ngModel","",3,"multiple",""]],hostBindings:function(e,r){1&e&&at("change",function(o){return r.onChange(o.target.value)})("blur",function(){return r.onTouched()})},inputs:{compareWith:"compareWith"},features:[Yn([SX]),Dn]}),t})(),sO=(()=>{class t{constructor(e,r,s){this._element=e,this._renderer=r,this._select=s,this._select&&(this.id=this._select._registerOption())}set ngValue(e){null!=this._select&&(this._select._optionMap.set(this.id,e),this._setElementValue(rO(this.id,e)),this._select.writeValue(this._select.value))}set value(e){this._setElementValue(e),this._select&&this._select.writeValue(this._select.value)}_setElementValue(e){this._renderer.setProperty(this._element.nativeElement,"value",e)}ngOnDestroy(){this._select&&(this._select._optionMap.delete(this.id),this._select.writeValue(this._select.value))}}return t.\u0275fac=function(e){return new(e||t)(Pe(us),Pe(Zi),Pe(Mg,9))},t.\u0275dir=Pt({type:t,selectors:[["option"]],inputs:{ngValue:"ngValue",value:"value"}}),t})();const DX={provide:Ii,useExisting:zn(()=>k_),multi:!0};function oO(t,n){return null==t?`${n}`:("string"==typeof n&&(n=`'${n}'`),n&&"object"==typeof n&&(n="Object"),`${t}: ${n}`.slice(0,50))}let k_=(()=>{class t extends Ll{constructor(){super(...arguments),this._optionMap=new Map,this._idCounter=0,this._compareWith=Object.is}set compareWith(e){this._compareWith=e}writeValue(e){let r;if(this.value=e,Array.isArray(e)){const s=e.map(o=>this._getOptionId(o));r=(o,i)=>{o._setSelected(s.indexOf(i.toString())>-1)}}else r=(s,o)=>{s._setSelected(!1)};this._optionMap.forEach(r)}registerOnChange(e){this.onChange=r=>{const s=[],o=r.selectedOptions;if(void 0!==o){const i=o;for(let a=0;a<i.length;a++){const u=this._getOptionValue(i[a].value);s.push(u)}}else{const i=r.options;for(let a=0;a<i.length;a++){const l=i[a];if(l.selected){const u=this._getOptionValue(l.value);s.push(u)}}}this.value=s,e(s)}}_registerOption(e){const r=(this._idCounter++).toString();return this._optionMap.set(r,e),r}_getOptionId(e){for(const r of Array.from(this._optionMap.keys()))if(this._compareWith(this._optionMap.get(r)._value,e))return r;return null}_getOptionValue(e){const r=function TX(t){return t.split(":")[0]}(e);return this._optionMap.has(r)?this._optionMap.get(r)._value:e}}return t.\u0275fac=function(){let n;return function(r){return(n||(n=Qr(t)))(r||t)}}(),t.\u0275dir=Pt({type:t,selectors:[["select","multiple","","formControlName",""],["select","multiple","","formControl",""],["select","multiple","","ngModel",""]],hostBindings:function(e,r){1&e&&at("change",function(o){return r.onChange(o.target)})("blur",function(){return r.onTouched()})},inputs:{compareWith:"compareWith"},features:[Yn([DX]),Dn]}),t})(),iO=(()=>{class t{constructor(e,r,s){this._element=e,this._renderer=r,this._select=s,this._select&&(this.id=this._select._registerOption(this))}set ngValue(e){null!=this._select&&(this._value=e,this._setElementValue(oO(this.id,e)),this._select.writeValue(this._select.value))}set value(e){this._select?(this._value=e,this._setElementValue(oO(this.id,e)),this._select.writeValue(this._select.value)):this._setElementValue(e)}_setElementValue(e){this._renderer.setProperty(this._element.nativeElement,"value",e)}_setSelected(e){this._renderer.setProperty(this._element.nativeElement,"selected",e)}ngOnDestroy(){this._select&&(this._select._optionMap.delete(this.id),this._select.writeValue(this._select.value))}}return t.\u0275fac=function(e){return new(e||t)(Pe(us),Pe(Zi),Pe(k_,9))},t.\u0275dir=Pt({type:t,selectors:[["option"]],inputs:{ngValue:"ngValue",value:"value"}}),t})(),gO=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=wo({type:t}),t.\u0275inj=Zs({imports:[QF]}),t})();class yO extends Ng{constructor(n,e,r){super(m_(e),g_(r,e)),this.controls=n,this._initObservables(),this._setUpdateStrategy(e),this._setUpControls(),this.updateValueAndValidity({onlySelf:!0,emitEvent:!!this.asyncValidator})}at(n){return this.controls[this._adjustIndex(n)]}push(n,e={}){this.controls.push(n),this._registerControl(n),this.updateValueAndValidity({emitEvent:e.emitEvent}),this._onCollectionChange()}insert(n,e,r={}){this.controls.splice(n,0,e),this._registerControl(e),this.updateValueAndValidity({emitEvent:r.emitEvent})}removeAt(n,e={}){let r=this._adjustIndex(n);r<0&&(r=0),this.controls[r]&&this.controls[r]._registerOnCollectionChange(()=>{}),this.controls.splice(r,1),this.updateValueAndValidity({emitEvent:e.emitEvent})}setControl(n,e,r={}){let s=this._adjustIndex(n);s<0&&(s=0),this.controls[s]&&this.controls[s]._registerOnCollectionChange(()=>{}),this.controls.splice(s,1),e&&(this.controls.splice(s,0,e),this._registerControl(e)),this.updateValueAndValidity({emitEvent:r.emitEvent}),this._onCollectionChange()}get length(){return this.controls.length}setValue(n,e={}){zF(this,!1,n),n.forEach((r,s)=>{BF(this,!1,s),this.at(s).setValue(r,{onlySelf:!0,emitEvent:e.emitEvent})}),this.updateValueAndValidity(e)}patchValue(n,e={}){null!=n&&(n.forEach((r,s)=>{this.at(s)&&this.at(s).patchValue(r,{onlySelf:!0,emitEvent:e.emitEvent})}),this.updateValueAndValidity(e))}reset(n=[],e={}){this._forEachChild((r,s)=>{r.reset(n[s],{onlySelf:!0,emitEvent:e.emitEvent})}),this._updatePristine(e),this._updateTouched(e),this.updateValueAndValidity(e)}getRawValue(){return this.controls.map(n=>n.getRawValue())}clear(n={}){this.controls.length<1||(this._forEachChild(e=>e._registerOnCollectionChange(()=>{})),this.controls.splice(0),this.updateValueAndValidity({emitEvent:n.emitEvent}))}_adjustIndex(n){return n<0?n+this.length:n}_syncPendingControls(){let n=this.controls.reduce((e,r)=>!!r._syncPendingControls()||e,!1);return n&&this.updateValueAndValidity({onlySelf:!0}),n}_forEachChild(n){this.controls.forEach((e,r)=>{n(e,r)})}_updateValue(){this.value=this.controls.filter(n=>n.enabled||this.disabled).map(n=>n.value)}_anyControls(n){return this.controls.some(e=>e.enabled&&n(e))}_setUpControls(){this._forEachChild(n=>this._registerControl(n))}_allControlsDisabled(){for(const n of this.controls)if(n.enabled)return!1;return this.controls.length>0||this.disabled}_registerControl(n){n.setParent(this),n._registerOnCollectionChange(this._onCollectionChange)}_find(n){return this.at(n)??null}}function vO(t){return!!t&&(void 0!==t.asyncValidators||void 0!==t.validators||void 0!==t.updateOn)}let MX=(()=>{class t{constructor(){this.useNonNullable=!1}get nonNullable(){const e=new t;return e.useNonNullable=!0,e}group(e,r=null){const s=this._reduceControls(e);let o={};return vO(r)?o=r:null!==r&&(o.validators=r.validator,o.asyncValidators=r.asyncValidator),new kh(s,o)}record(e,r=null){const s=this._reduceControls(e);return new UF(s,r)}control(e,r,s){let o={};return this.useNonNullable?(vO(r)?o=r:(o.validators=r,o.asyncValidators=s),new Rh(e,{...o,nonNullable:!0})):new Rh(e,r,s)}array(e,r,s){const o=e.map(i=>this._createControl(i));return new yO(o,r,s)}_reduceControls(e){const r={};return Object.keys(e).forEach(s=>{r[s]=this._createControl(e[s])}),r}_createControl(e){return e instanceof Rh||e instanceof Ng?e:Array.isArray(e)?this.control(e[0],e.length>1?e[1]:null,e.length>2?e[2]:null):this.control(e)}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=kt({token:t,factory:t.\u0275fac,providedIn:"root"}),t})(),$X=(()=>{class t{static withConfig(e){return{ngModule:t,providers:[{provide:Vl,useValue:e.callSetDisabledState??Eh}]}}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=wo({type:t}),t.\u0275inj=Zs({imports:[gO]}),t})(),LX=(()=>{class t{static withConfig(e){return{ngModule:t,providers:[{provide:S_,useValue:e.warnOnNgModelWithFormControl??"always"},{provide:Vl,useValue:e.callSetDisabledState??Eh}]}}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=wo({type:t}),t.\u0275inj=Zs({imports:[gO]}),t})();class VX{constructor(n,e,r,s,o,i,a){this.titleColor=n,this.contentColor=e,this.backgroundColor=r,this.contentFontFamily=s,this.titleFontFamily=o,this.textAlign=i,this.camAlign=a}}var Ma=(()=>{return(t=Ma||(Ma={}))[t.center=0]="center",t[t.right=1]="right",t[t.left=2]="left",t[t.justify=3]="justify",Ma;var t})(),BX=ne(650),zX=ne.n(BX),UX=ne(327);class N_{constructor(n,e,r){this.name=n,this.minValue=e,this.maxValue=r}}class WX{constructor(n,e,r,s,o,i,a){this.title=n,this.description=e,this.modelURL=r,this.width=s,this.height=o,this.style=i,this.categories=a}}let A_=(()=>{class t{constructor(){const e=new VX("#000000","#000000","#FFFFFF","Arial","Arial",Ma.center,Ma.center),r=new Array;r.push(new N_("Gato",0,.5)),r.push(new N_("Perro",.5,Number.MAX_SAFE_INTEGER)),this.configs=[new WX("Perros y gatos","","./assets/perros-gatos/model.json",100,100,e,r)]}addConfig(e){let r=!1;return this.configs.some(s=>s.title==e.title)||(this.configs.push(e),r=!0),r}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=kt({token:t,factory:t.\u0275fac,providedIn:"root"}),t})();const GX=["dialogPopup"],HX=["hueSlider"],jX=["alphaSlider"];function qX(t,n){if(1&t&&sn(0,"div"),2&t){const e=ot();(function ZE(t,n,e){qo(ro,wi,Xu(Le(),t,n,e),!0)})("arrow arrow-",e.cpUsePosition,""),vr("left",e.cpArrowPosition)("top",e.arrowTop,"px")}}function KX(t,n){if(1&t){const e=ar();Re(0,"div",28),at("newValue",function(s){return St(e),It(ot().onColorChange(s))})("dragStart",function(){return St(e),It(ot().onDragStart("saturation-lightness"))})("dragEnd",function(){return St(e),It(ot().onDragEnd("saturation-lightness"))}),sn(1,"div",14),Ee()}if(2&t){const e=ot();vr("background-color",e.hueSliderColor),nt("rgX",1)("rgY",1),Ke(1),vr("top",null==e.slider?null:e.slider.v,"px")("left",null==e.slider?null:e.slider.s,"px")}}function XX(t,n){1&t&&(function XD(){zt.lFrame.currentNamespace=FD}(),Re(0,"svg",29),sn(1,"path",30)(2,"path",31),Ee())}function YX(t,n){if(1&t){const e=ar();Re(0,"button",32),at("click",function(s){St(e);const o=ot();return It(o.onAddPresetColor(s,o.selectedColor))}),bt(1),Ee()}if(2&t){const e=ot();Tl(e.cpAddColorButtonClass),nt("disabled",e.cpPresetColors&&e.cpPresetColors.length>=e.cpMaxPresetColorsLength),Ke(1),Io(" ",e.cpAddColorButtonText," ")}}function ZX(t,n){1&t&&sn(0,"div",33)}function QX(t,n){if(1&t){const e=ar();Re(0,"input",39),at("keyup.enter",function(s){return St(e),It(ot(2).onAcceptColor(s))})("newValue",function(s){return St(e),It(ot(2).onAlphaInput(s))}),Ee()}if(2&t){const e=ot(2);nt("rg",1)("value",null==e.cmykText?null:e.cmykText.a)}}function JX(t,n){1&t&&(Re(0,"div"),bt(1,"A"),Ee())}function eY(t,n){if(1&t){const e=ar();Re(0,"div",34)(1,"div",35)(2,"input",36),at("keyup.enter",function(s){return St(e),It(ot().onAcceptColor(s))})("newValue",function(s){return St(e),It(ot().onCyanInput(s))}),Ee(),Re(3,"input",36),at("keyup.enter",function(s){return St(e),It(ot().onAcceptColor(s))})("newValue",function(s){return St(e),It(ot().onMagentaInput(s))}),Ee(),Re(4,"input",36),at("keyup.enter",function(s){return St(e),It(ot().onAcceptColor(s))})("newValue",function(s){return St(e),It(ot().onYellowInput(s))}),Ee(),Re(5,"input",36),at("keyup.enter",function(s){return St(e),It(ot().onAcceptColor(s))})("newValue",function(s){return St(e),It(ot().onBlackInput(s))}),Ee(),ln(6,QX,1,2,"input",37),Ee(),Re(7,"div",35)(8,"div"),bt(9,"C"),Ee(),Re(10,"div"),bt(11,"M"),Ee(),Re(12,"div"),bt(13,"Y"),Ee(),Re(14,"div"),bt(15,"K"),Ee(),ln(16,JX,2,0,"div",38),Ee()()}if(2&t){const e=ot();vr("display",3!==e.format?"none":"block"),Ke(2),nt("rg",100)("value",null==e.cmykText?null:e.cmykText.c),Ke(1),nt("rg",100)("value",null==e.cmykText?null:e.cmykText.m),Ke(1),nt("rg",100)("value",null==e.cmykText?null:e.cmykText.y),Ke(1),nt("rg",100)("value",null==e.cmykText?null:e.cmykText.k),Ke(1),nt("ngIf","disabled"!==e.cpAlphaChannel),Ke(10),nt("ngIf","disabled"!==e.cpAlphaChannel)}}function tY(t,n){if(1&t){const e=ar();Re(0,"input",39),at("keyup.enter",function(s){return St(e),It(ot(2).onAcceptColor(s))})("newValue",function(s){return St(e),It(ot(2).onAlphaInput(s))}),Ee()}if(2&t){const e=ot(2);nt("rg",1)("value",null==e.hslaText?null:e.hslaText.a)}}function nY(t,n){1&t&&(Re(0,"div"),bt(1,"A"),Ee())}function rY(t,n){if(1&t){const e=ar();Re(0,"div",40)(1,"div",35)(2,"input",41),at("keyup.enter",function(s){return St(e),It(ot().onAcceptColor(s))})("newValue",function(s){return St(e),It(ot().onHueInput(s))}),Ee(),Re(3,"input",36),at("keyup.enter",function(s){return St(e),It(ot().onAcceptColor(s))})("newValue",function(s){return St(e),It(ot().onSaturationInput(s))}),Ee(),Re(4,"input",36),at("keyup.enter",function(s){return St(e),It(ot().onAcceptColor(s))})("newValue",function(s){return St(e),It(ot().onLightnessInput(s))}),Ee(),ln(5,tY,1,2,"input",37),Ee(),Re(6,"div",35)(7,"div"),bt(8,"H"),Ee(),Re(9,"div"),bt(10,"S"),Ee(),Re(11,"div"),bt(12,"L"),Ee(),ln(13,nY,2,0,"div",38),Ee()()}if(2&t){const e=ot();vr("display",2!==e.format?"none":"block"),Ke(2),nt("rg",360)("value",null==e.hslaText?null:e.hslaText.h),Ke(1),nt("rg",100)("value",null==e.hslaText?null:e.hslaText.s),Ke(1),nt("rg",100)("value",null==e.hslaText?null:e.hslaText.l),Ke(1),nt("ngIf","disabled"!==e.cpAlphaChannel),Ke(8),nt("ngIf","disabled"!==e.cpAlphaChannel)}}function sY(t,n){if(1&t){const e=ar();Re(0,"input",39),at("keyup.enter",function(s){return St(e),It(ot(2).onAcceptColor(s))})("newValue",function(s){return St(e),It(ot(2).onAlphaInput(s))}),Ee()}if(2&t){const e=ot(2);nt("rg",1)("value",null==e.rgbaText?null:e.rgbaText.a)}}function oY(t,n){1&t&&(Re(0,"div"),bt(1,"A"),Ee())}function iY(t,n){if(1&t){const e=ar();Re(0,"div",42)(1,"div",35)(2,"input",43),at("keyup.enter",function(s){return St(e),It(ot().onAcceptColor(s))})("newValue",function(s){return St(e),It(ot().onRedInput(s))}),Ee(),Re(3,"input",43),at("keyup.enter",function(s){return St(e),It(ot().onAcceptColor(s))})("newValue",function(s){return St(e),It(ot().onGreenInput(s))}),Ee(),Re(4,"input",43),at("keyup.enter",function(s){return St(e),It(ot().onAcceptColor(s))})("newValue",function(s){return St(e),It(ot().onBlueInput(s))}),Ee(),ln(5,sY,1,2,"input",37),Ee(),Re(6,"div",35)(7,"div"),bt(8,"R"),Ee(),Re(9,"div"),bt(10,"G"),Ee(),Re(11,"div"),bt(12,"B"),Ee(),ln(13,oY,2,0,"div",38),Ee()()}if(2&t){const e=ot();vr("display",1!==e.format?"none":"block"),Ke(2),nt("rg",255)("value",null==e.rgbaText?null:e.rgbaText.r),Ke(1),nt("rg",255)("value",null==e.rgbaText?null:e.rgbaText.g),Ke(1),nt("rg",255)("value",null==e.rgbaText?null:e.rgbaText.b),Ke(1),nt("ngIf","disabled"!==e.cpAlphaChannel),Ke(8),nt("ngIf","disabled"!==e.cpAlphaChannel)}}function aY(t,n){if(1&t){const e=ar();Re(0,"input",39),at("keyup.enter",function(s){return St(e),It(ot(2).onAcceptColor(s))})("newValue",function(s){return St(e),It(ot(2).onAlphaInput(s))}),Ee()}if(2&t){const e=ot(2);nt("rg",1)("value",e.hexAlpha)}}function lY(t,n){1&t&&(Re(0,"div"),bt(1,"A"),Ee())}function uY(t,n){if(1&t){const e=ar();Re(0,"div",44)(1,"div",35)(2,"input",45),at("blur",function(){return St(e),It(ot().onHexInput(null))})("keyup.enter",function(s){return St(e),It(ot().onAcceptColor(s))})("newValue",function(s){return St(e),It(ot().onHexInput(s))}),Ee(),ln(3,aY,1,2,"input",37),Ee(),Re(4,"div",35)(5,"div"),bt(6,"Hex"),Ee(),ln(7,lY,2,0,"div",38),Ee()()}if(2&t){const e=ot();vr("display",0!==e.format?"none":"block"),Ts("hex-alpha","forced"===e.cpAlphaChannel),Ke(2),nt("value",e.hexText),Ke(1),nt("ngIf","forced"===e.cpAlphaChannel),Ke(4),nt("ngIf","forced"===e.cpAlphaChannel)}}function cY(t,n){if(1&t){const e=ar();Re(0,"input",39),at("keyup.enter",function(s){return St(e),It(ot(2).onAcceptColor(s))})("newValue",function(s){return St(e),It(ot(2).onAlphaInput(s))}),Ee()}if(2&t){const e=ot(2);nt("rg",1)("value",null==e.hslaText?null:e.hslaText.a)}}function dY(t,n){if(1&t){const e=ar();Re(0,"div",46)(1,"div",35)(2,"input",36),at("keyup.enter",function(s){return St(e),It(ot().onAcceptColor(s))})("newValue",function(s){return St(e),It(ot().onValueInput(s))}),Ee(),ln(3,cY,1,2,"input",37),Ee(),Re(4,"div",35)(5,"div"),bt(6,"V"),Ee(),Re(7,"div"),bt(8,"A"),Ee()()()}if(2&t){const e=ot();Ke(2),nt("rg",100)("value",null==e.hslaText?null:e.hslaText.l),Ke(1),nt("ngIf","disabled"!==e.cpAlphaChannel)}}function hY(t,n){if(1&t){const e=ar();Re(0,"div",47)(1,"span",48),at("click",function(){return St(e),It(ot().onFormatToggle(-1))}),Ee(),Re(2,"span",48),at("click",function(){return St(e),It(ot().onFormatToggle(1))}),Ee()()}}function pY(t,n){if(1&t){const e=ar();Re(0,"span",55),at("click",function(s){St(e);const o=ot().$implicit;return It(ot(3).onRemovePresetColor(s,o))}),Ee()}2&t&&Tl(ot(4).cpRemoveColorButtonClass)}function fY(t,n){if(1&t){const e=ar();Re(0,"div",53),at("click",function(){const o=St(e).$implicit;return It(ot(3).setColorFromString(o))}),ln(1,pY,1,3,"span",54),Ee()}if(2&t){const e=n.$implicit,r=ot(3);vr("background-color",e),Ke(1),nt("ngIf",r.cpAddColorButton)}}function mY(t,n){if(1&t&&(Re(0,"div"),ln(1,fY,2,3,"div",52),Ee()),2&t){const e=ot(2);Tl(e.cpPresetColorsClass),Ke(1),nt("ngForOf",e.cpPresetColors)}}function gY(t,n){if(1&t&&(Re(0,"div"),bt(1),Ee()),2&t){const e=ot(2);Tl(e.cpPresetEmptyMessageClass),Ke(1),kl(e.cpPresetEmptyMessage)}}function yY(t,n){if(1&t&&(Re(0,"div",49),sn(1,"hr"),Re(2,"div",50),bt(3),Ee(),ln(4,mY,2,4,"div",51),ln(5,gY,2,4,"div",51),Ee()),2&t){const e=ot();Ke(3),kl(e.cpPresetLabel),Ke(1),nt("ngIf",null==e.cpPresetColors?null:e.cpPresetColors.length),Ke(1),nt("ngIf",!(null!=e.cpPresetColors&&e.cpPresetColors.length)&&e.cpAddColorButton)}}function vY(t,n){if(1&t){const e=ar();Re(0,"button",58),at("click",function(s){return St(e),It(ot(2).onCancelColor(s))}),bt(1),Ee()}if(2&t){const e=ot(2);Tl(e.cpCancelButtonClass),Ke(1),kl(e.cpCancelButtonText)}}function bY(t,n){if(1&t){const e=ar();Re(0,"button",58),at("click",function(s){return St(e),It(ot(2).onAcceptColor(s))}),bt(1),Ee()}if(2&t){const e=ot(2);Tl(e.cpOKButtonClass),Ke(1),kl(e.cpOKButtonText)}}function xY(t,n){if(1&t&&(Re(0,"div",56),ln(1,vY,2,4,"button",57),ln(2,bY,2,4,"button",57),Ee()),2&t){const e=ot();Ke(1),nt("ngIf",e.cpCancelButton),Ke(1),nt("ngIf",e.cpOKButton)}}function wY(t,n){1&t&&mx(0)}function _Y(t,n){if(1&t&&(Re(0,"div",59),ln(1,wY,1,0,"ng-container",60),Ee()),2&t){const e=ot();Ke(1),nt("ngTemplateOutlet",e.cpExtraTemplate)}}var es=(()=>{return(t=es||(es={}))[t.HEX=0]="HEX",t[t.RGBA=1]="RGBA",t[t.HSLA=2]="HSLA",t[t.CMYK=3]="CMYK",es;var t})();class aa{constructor(n,e,r,s){this.r=n,this.g=e,this.b=r,this.a=s}}class $g{constructor(n,e,r,s){this.h=n,this.s=e,this.v=r,this.a=s}}class zl{constructor(n,e,r,s){this.h=n,this.s=e,this.l=r,this.a=s}}class Fh{constructor(n,e,r,s,o=1){this.c=n,this.m=e,this.y=r,this.k=s,this.a=o}}let IY=(()=>{class t{constructor(){this.newValue=new nn}inputChange(e){const r=e.target.value;if(void 0===this.rg)this.newValue.emit(r);else{const s=parseFloat(r);this.newValue.emit({v:s,rg:this.rg})}}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275dir=Pt({type:t,selectors:[["","text",""]],hostBindings:function(e,r){1&e&&at("input",function(o){return r.inputChange(o)})},inputs:{rg:"rg",text:"text"},outputs:{newValue:"newValue"}}),t})(),DY=(()=>{class t{constructor(e){this.elRef=e,this.dragEnd=new nn,this.dragStart=new nn,this.newValue=new nn,this.listenerMove=r=>this.move(r),this.listenerStop=()=>this.stop()}mouseDown(e){this.start(e)}touchStart(e){this.start(e)}move(e){e.preventDefault(),this.setCursor(e)}start(e){this.setCursor(e),e.stopPropagation(),document.addEventListener("mouseup",this.listenerStop),document.addEventListener("touchend",this.listenerStop),document.addEventListener("mousemove",this.listenerMove),document.addEventListener("touchmove",this.listenerMove),this.dragStart.emit()}stop(){document.removeEventListener("mouseup",this.listenerStop),document.removeEventListener("touchend",this.listenerStop),document.removeEventListener("mousemove",this.listenerMove),document.removeEventListener("touchmove",this.listenerMove),this.dragEnd.emit()}getX(e){const r=this.elRef.nativeElement.getBoundingClientRect();return(void 0!==e.pageX?e.pageX:e.touches[0].pageX)-r.left-window.pageXOffset}getY(e){const r=this.elRef.nativeElement.getBoundingClientRect();return(void 0!==e.pageY?e.pageY:e.touches[0].pageY)-r.top-window.pageYOffset}setCursor(e){const r=this.elRef.nativeElement.offsetWidth,s=this.elRef.nativeElement.offsetHeight,o=Math.max(0,Math.min(this.getX(e),r)),i=Math.max(0,Math.min(this.getY(e),s));void 0!==this.rgX&&void 0!==this.rgY?this.newValue.emit({s:o/r,v:1-i/s,rgX:this.rgX,rgY:this.rgY}):void 0===this.rgX&&void 0!==this.rgY?this.newValue.emit({v:i/s,rgY:this.rgY}):void 0!==this.rgX&&void 0===this.rgY&&this.newValue.emit({v:o/r,rgX:this.rgX})}}return t.\u0275fac=function(e){return new(e||t)(Pe(us))},t.\u0275dir=Pt({type:t,selectors:[["","slider",""]],hostBindings:function(e,r){1&e&&at("mousedown",function(o){return r.mouseDown(o)})("touchstart",function(o){return r.touchStart(o)})},inputs:{rgX:"rgX",rgY:"rgY",slider:"slider"},outputs:{dragEnd:"dragEnd",dragStart:"dragStart",newValue:"newValue"}}),t})();class bO{constructor(n,e,r,s){this.h=n,this.s=e,this.v=r,this.a=s}}class xO{constructor(n,e,r,s){this.h=n,this.s=e,this.v=r,this.a=s}}let R_=(()=>{class t{constructor(){this.active=null}setActive(e){this.active&&this.active!==e&&"inline"!==this.active.cpDialogDisplay&&this.active.closeDialog(),this.active=e}hsva2hsla(e){const r=e.h,s=e.s,o=e.v,i=e.a;if(0===o)return new zl(r,0,0,i);if(0===s&&1===o)return new zl(r,1,1,i);{const a=o*(2-s)/2;return new zl(r,o*s/(1-Math.abs(2*a-1)),a,i)}}hsla2hsva(e){const r=Math.min(e.h,1),s=Math.min(e.s,1),o=Math.min(e.l,1),i=Math.min(e.a,1);if(0===o)return new $g(r,0,0,i);{const a=o+s*(1-Math.abs(2*o-1))/2;return new $g(r,2*(a-o)/a,a,i)}}hsvaToRgba(e){let r,s,o;const i=e.h,a=e.s,l=e.v,u=e.a,c=Math.floor(6*i),d=6*i-c,h=l*(1-a),p=l*(1-d*a),f=l*(1-(1-d)*a);switch(c%6){case 0:r=l,s=f,o=h;break;case 1:r=p,s=l,o=h;break;case 2:r=h,s=l,o=f;break;case 3:r=h,s=p,o=l;break;case 4:r=f,s=h,o=l;break;case 5:r=l,s=h,o=p;break;default:r=0,s=0,o=0}return new aa(r,s,o,u)}cmykToRgb(e){return new aa((1-e.c)*(1-e.k),(1-e.m)*(1-e.k),(1-e.y)*(1-e.k),e.a)}rgbaToCmyk(e){const r=1-Math.max(e.r,e.g,e.b);return 1===r?new Fh(0,0,0,1,e.a):new Fh((1-e.r-r)/(1-r),(1-e.g-r)/(1-r),(1-e.b-r)/(1-r),r,e.a)}rgbaToHsva(e){let r,s;const o=Math.min(e.r,1),i=Math.min(e.g,1),a=Math.min(e.b,1),l=Math.min(e.a,1),u=Math.max(o,i,a),c=Math.min(o,i,a),d=u,h=u-c;if(s=0===u?0:h/u,u===c)r=0;else{switch(u){case o:r=(i-a)/h+(i<a?6:0);break;case i:r=(a-o)/h+2;break;case a:r=(o-i)/h+4;break;default:r=0}r/=6}return new $g(r,s,d,l)}rgbaToHex(e,r){let s="#"+(16777216|e.r<<16|e.g<<8|e.b).toString(16).substr(1);return r&&(s+=(256|Math.round(255*e.a)).toString(16).substr(1)),s}normalizeCMYK(e){return new Fh(e.c/100,e.m/100,e.y/100,e.k/100,e.a)}denormalizeCMYK(e){return new Fh(Math.floor(100*e.c),Math.floor(100*e.m),Math.floor(100*e.y),Math.floor(100*e.k),e.a)}denormalizeRGBA(e){return new aa(Math.round(255*e.r),Math.round(255*e.g),Math.round(255*e.b),e.a)}stringToHsva(e="",r=!1){let s=null;e=(e||"").toLowerCase();const o=[{re:/(rgb)a?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*%?,\s*(\d{1,3})\s*%?(?:,\s*(\d+(?:\.\d+)?)\s*)?\)/,parse:function(i){return new aa(parseInt(i[2],10)/255,parseInt(i[3],10)/255,parseInt(i[4],10)/255,isNaN(parseFloat(i[5]))?1:parseFloat(i[5]))}},{re:/(hsl)a?\(\s*(\d{1,3})\s*,\s*(\d{1,3})%\s*,\s*(\d{1,3})%\s*(?:,\s*(\d+(?:\.\d+)?)\s*)?\)/,parse:function(i){return new zl(parseInt(i[2],10)/360,parseInt(i[3],10)/100,parseInt(i[4],10)/100,isNaN(parseFloat(i[5]))?1:parseFloat(i[5]))}}];o.push(r?{re:/#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})?$/,parse:function(i){return new aa(parseInt(i[1],16)/255,parseInt(i[2],16)/255,parseInt(i[3],16)/255,parseInt(i[4]||"FF",16)/255)}}:{re:/#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})$/,parse:function(i){return new aa(parseInt(i[1],16)/255,parseInt(i[2],16)/255,parseInt(i[3],16)/255,1)}}),o.push({re:/#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])$/,parse:function(i){return new aa(parseInt(i[1]+i[1],16)/255,parseInt(i[2]+i[2],16)/255,parseInt(i[3]+i[3],16)/255,1)}});for(const i in o)if(o.hasOwnProperty(i)){const a=o[i],l=a.re.exec(e),u=l&&a.parse(l);if(u)return u instanceof aa?s=this.rgbaToHsva(u):u instanceof zl&&(s=this.hsla2hsva(u)),s}return s}outputFormat(e,r,s){switch("auto"===r&&(r=e.a<1?"rgba":"hex"),r){case"hsla":const o=this.hsva2hsla(e),i=new zl(Math.round(360*o.h),Math.round(100*o.s),Math.round(100*o.l),Math.round(100*o.a)/100);return e.a<1||"always"===s?"hsla("+i.h+","+i.s+"%,"+i.l+"%,"+i.a+")":"hsl("+i.h+","+i.s+"%,"+i.l+"%)";case"rgba":const a=this.denormalizeRGBA(this.hsvaToRgba(e));return e.a<1||"always"===s?"rgba("+a.r+","+a.g+","+a.b+","+Math.round(100*a.a)/100+")":"rgb("+a.r+","+a.g+","+a.b+")";default:const l="always"===s||"forced"===s;return this.rgbaToHex(this.denormalizeRGBA(this.hsvaToRgba(e)),l)}}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=kt({token:t,factory:t.\u0275fac}),t})();const wO=typeof window<"u"&&"ontouchstart"in window;let TY=(()=>{class t{constructor(e,r,s,o,i,a){this.ngZone=e,this.elRef=r,this.cdRef=s,this.document=o,this.platformId=i,this.service=a,this.isIE10=!1,this.dialogArrowSize=10,this.dialogArrowOffset=15,this.dialogInputFields=[es.HEX,es.RGBA,es.HSLA,es.CMYK],this.useRootViewContainer=!1,this.eyeDropperSupported=function J8(t){return t===S2}(this.platformId)&&"EyeDropper"in this.document.defaultView}handleEsc(e){this.show&&"popup"===this.cpDialogDisplay&&this.onCancelColor(e)}handleEnter(e){this.show&&"popup"===this.cpDialogDisplay&&this.onAcceptColor(e)}ngOnInit(){this.slider=new bO(0,0,0,0),this.sliderDimMax=new xO(this.hueSlider.nativeElement.offsetWidth||140,this.cpWidth,130,this.alphaSlider.nativeElement.offsetWidth||140),this.format=this.cpCmykEnabled?es.CMYK:"rgba"===this.cpOutputFormat?es.RGBA:"hsla"===this.cpOutputFormat?es.HSLA:es.HEX,this.listenerMouseDown=s=>{this.onMouseDown(s)},this.listenerResize=()=>{this.onResize()},this.openDialog(this.initialColor,!1)}ngOnDestroy(){this.closeDialog()}ngAfterViewInit(){230===this.cpWidth&&"inline"!==this.cpDialogDisplay||(this.sliderDimMax=new xO(this.hueSlider.nativeElement.offsetWidth||140,this.cpWidth,130,this.alphaSlider.nativeElement.offsetWidth||140),this.updateColorPicker(!1),this.cdRef.detectChanges())}openDialog(e,r=!0){this.service.setActive(this),this.width||(this.cpWidth=this.directiveElementRef.nativeElement.offsetWidth),this.height||(this.height=320),this.setInitialColor(e),this.setColorFromString(e,r),this.openColorPicker()}closeDialog(){this.closeColorPicker()}setupDialog(e,r,s,o,i,a,l,u,c,d,h,p,f,g,m,y,v,b,x,w,k,V,z,K,Y,se,fe,ve,be,xe,De,Ne,we,Ae,ze,He,Ye,je){this.setInitialColor(s),this.setColorMode(u),this.isIE10=10===function SY(){let t="";typeof navigator<"u"&&(t=navigator.userAgent.toLowerCase());const n=t.indexOf("msie ");return n>0&&parseInt(t.substring(n+5,t.indexOf(".",n)),10)}(),this.directiveInstance=e,this.directiveElementRef=r,this.cpDisableInput=p,this.cpCmykEnabled=c,this.cpAlphaChannel=d,this.cpOutputFormat=h,this.cpDialogDisplay=a,this.cpIgnoredElements=f,this.cpSaveClickOutside=g,this.cpCloseClickOutside=m,this.useRootViewContainer=y,this.width=this.cpWidth=parseInt(o,10),this.height=this.cpHeight=parseInt(i,10),this.cpPosition=v,this.cpPositionOffset=parseInt(b,10),this.cpOKButton=se,this.cpOKButtonText=ve,this.cpOKButtonClass=fe,this.cpCancelButton=be,this.cpCancelButtonText=De,this.cpCancelButtonClass=xe,this.cpEyeDropper=He,this.fallbackColor=l||"#fff",this.setPresetConfig(w,k),this.cpPresetColorsClass=V,this.cpMaxPresetColorsLength=z,this.cpPresetEmptyMessage=K,this.cpPresetEmptyMessageClass=Y,this.cpAddColorButton=Ne,this.cpAddColorButtonText=Ae,this.cpAddColorButtonClass=we,this.cpRemoveColorButtonClass=ze,this.cpTriggerElement=Ye,this.cpExtraTemplate=je,x||(this.dialogArrowOffset=0),"inline"===a&&(this.dialogArrowSize=0,this.dialogArrowOffset=0),"hex"===h&&"always"!==d&&"forced"!==d&&(this.cpAlphaChannel="disabled")}setColorMode(e){switch(e.toString().toUpperCase()){case"1":case"C":case"COLOR":default:this.cpColorMode=1;break;case"2":case"G":case"GRAYSCALE":this.cpColorMode=2;break;case"3":case"P":case"PRESETS":this.cpColorMode=3}}setInitialColor(e){this.initialColor=e}setPresetConfig(e,r){this.cpPresetLabel=e,this.cpPresetColors=r}setColorFromString(e,r=!0,s=!0){let o;"always"===this.cpAlphaChannel||"forced"===this.cpAlphaChannel?(o=this.service.stringToHsva(e,!0),!o&&!this.hsva&&(o=this.service.stringToHsva(e,!1))):o=this.service.stringToHsva(e,!1),!o&&!this.hsva&&(o=this.service.stringToHsva(this.fallbackColor,!1)),o&&(this.hsva=o,this.sliderH=this.hsva.h,"hex"===this.cpOutputFormat&&"disabled"===this.cpAlphaChannel&&(this.hsva.a=1),this.updateColorPicker(r,s))}onResize(){"fixed"===this.position?this.setDialogPosition():"inline"!==this.cpDialogDisplay&&this.closeColorPicker()}onDragEnd(e){this.directiveInstance.sliderDragEnd({slider:e,color:this.outputColor})}onDragStart(e){this.directiveInstance.sliderDragStart({slider:e,color:this.outputColor})}onMouseDown(e){this.show&&!this.isIE10&&"popup"===this.cpDialogDisplay&&e.target!==this.directiveElementRef.nativeElement&&!this.isDescendant(this.elRef.nativeElement,e.target)&&!this.isDescendant(this.directiveElementRef.nativeElement,e.target)&&0===this.cpIgnoredElements.filter(r=>r===e.target).length&&this.ngZone.run(()=>{this.cpSaveClickOutside?this.directiveInstance.colorSelected(this.outputColor):(this.hsva=null,this.setColorFromString(this.initialColor,!1),this.cpCmykEnabled&&this.directiveInstance.cmykChanged(this.cmykColor),this.directiveInstance.colorChanged(this.initialColor),this.directiveInstance.colorCanceled()),this.cpCloseClickOutside&&this.closeColorPicker()})}onAcceptColor(e){e.stopPropagation(),this.outputColor&&this.directiveInstance.colorSelected(this.outputColor),"popup"===this.cpDialogDisplay&&this.closeColorPicker()}onCancelColor(e){this.hsva=null,e.stopPropagation(),this.directiveInstance.colorCanceled(),this.setColorFromString(this.initialColor,!0),"popup"===this.cpDialogDisplay&&(this.cpCmykEnabled&&this.directiveInstance.cmykChanged(this.cmykColor),this.directiveInstance.colorChanged(this.initialColor,!0),this.closeColorPicker())}onEyeDropper(){this.eyeDropperSupported&&(new window.EyeDropper).open().then(r=>{this.setColorFromString(r.sRGBHex,!0)})}onFormatToggle(e){const r=this.dialogInputFields.length-(this.cpCmykEnabled?0:1),s=((this.dialogInputFields.indexOf(this.format)+e)%r+r)%r;this.format=this.dialogInputFields[s]}onColorChange(e){this.hsva.s=e.s/e.rgX,this.hsva.v=e.v/e.rgY,this.updateColorPicker(),this.directiveInstance.sliderChanged({slider:"lightness",value:this.hsva.v,color:this.outputColor}),this.directiveInstance.sliderChanged({slider:"saturation",value:this.hsva.s,color:this.outputColor})}onHueChange(e){this.hsva.h=e.v/e.rgX,this.sliderH=this.hsva.h,this.updateColorPicker(),this.directiveInstance.sliderChanged({slider:"hue",value:this.hsva.h,color:this.outputColor})}onValueChange(e){this.hsva.v=e.v/e.rgX,this.updateColorPicker(),this.directiveInstance.sliderChanged({slider:"value",value:this.hsva.v,color:this.outputColor})}onAlphaChange(e){this.hsva.a=e.v/e.rgX,this.updateColorPicker(),this.directiveInstance.sliderChanged({slider:"alpha",value:this.hsva.a,color:this.outputColor})}onHexInput(e){if(null===e)this.updateColorPicker();else{e&&"#"!==e[0]&&(e="#"+e);let r=/^#([a-f0-9]{3}|[a-f0-9]{6})$/gi;"always"===this.cpAlphaChannel&&(r=/^#([a-f0-9]{3}|[a-f0-9]{6}|[a-f0-9]{8})$/gi);const s=r.test(e);s&&(e.length<5&&(e="#"+e.substring(1).split("").map(o=>o+o).join("")),"forced"===this.cpAlphaChannel&&(e+=Math.round(255*this.hsva.a).toString(16)),this.setColorFromString(e,!0,!1)),this.directiveInstance.inputChanged({input:"hex",valid:s,value:e,color:this.outputColor})}}onRedInput(e){const r=this.service.hsvaToRgba(this.hsva),s=!isNaN(e.v)&&e.v>=0&&e.v<=e.rg;s&&(r.r=e.v/e.rg,this.hsva=this.service.rgbaToHsva(r),this.sliderH=this.hsva.h,this.updateColorPicker()),this.directiveInstance.inputChanged({input:"red",valid:s,value:r.r,color:this.outputColor})}onBlueInput(e){const r=this.service.hsvaToRgba(this.hsva),s=!isNaN(e.v)&&e.v>=0&&e.v<=e.rg;s&&(r.b=e.v/e.rg,this.hsva=this.service.rgbaToHsva(r),this.sliderH=this.hsva.h,this.updateColorPicker()),this.directiveInstance.inputChanged({input:"blue",valid:s,value:r.b,color:this.outputColor})}onGreenInput(e){const r=this.service.hsvaToRgba(this.hsva),s=!isNaN(e.v)&&e.v>=0&&e.v<=e.rg;s&&(r.g=e.v/e.rg,this.hsva=this.service.rgbaToHsva(r),this.sliderH=this.hsva.h,this.updateColorPicker()),this.directiveInstance.inputChanged({input:"green",valid:s,value:r.g,color:this.outputColor})}onHueInput(e){const r=!isNaN(e.v)&&e.v>=0&&e.v<=e.rg;r&&(this.hsva.h=e.v/e.rg,this.sliderH=this.hsva.h,this.updateColorPicker()),this.directiveInstance.inputChanged({input:"hue",valid:r,value:this.hsva.h,color:this.outputColor})}onValueInput(e){const r=!isNaN(e.v)&&e.v>=0&&e.v<=e.rg;r&&(this.hsva.v=e.v/e.rg,this.updateColorPicker()),this.directiveInstance.inputChanged({input:"value",valid:r,value:this.hsva.v,color:this.outputColor})}onAlphaInput(e){const r=!isNaN(e.v)&&e.v>=0&&e.v<=e.rg;r&&(this.hsva.a=e.v/e.rg,this.updateColorPicker()),this.directiveInstance.inputChanged({input:"alpha",valid:r,value:this.hsva.a,color:this.outputColor})}onLightnessInput(e){const r=this.service.hsva2hsla(this.hsva),s=!isNaN(e.v)&&e.v>=0&&e.v<=e.rg;s&&(r.l=e.v/e.rg,this.hsva=this.service.hsla2hsva(r),this.sliderH=this.hsva.h,this.updateColorPicker()),this.directiveInstance.inputChanged({input:"lightness",valid:s,value:r.l,color:this.outputColor})}onSaturationInput(e){const r=this.service.hsva2hsla(this.hsva),s=!isNaN(e.v)&&e.v>=0&&e.v<=e.rg;s&&(r.s=e.v/e.rg,this.hsva=this.service.hsla2hsva(r),this.sliderH=this.hsva.h,this.updateColorPicker()),this.directiveInstance.inputChanged({input:"saturation",valid:s,value:r.s,color:this.outputColor})}onCyanInput(e){!isNaN(e.v)&&e.v>=0&&e.v<=e.rg&&(this.cmyk.c=e.v,this.updateColorPicker(!1,!0,!0)),this.directiveInstance.inputChanged({input:"cyan",valid:!0,value:this.cmyk.c,color:this.outputColor})}onMagentaInput(e){!isNaN(e.v)&&e.v>=0&&e.v<=e.rg&&(this.cmyk.m=e.v,this.updateColorPicker(!1,!0,!0)),this.directiveInstance.inputChanged({input:"magenta",valid:!0,value:this.cmyk.m,color:this.outputColor})}onYellowInput(e){!isNaN(e.v)&&e.v>=0&&e.v<=e.rg&&(this.cmyk.y=e.v,this.updateColorPicker(!1,!0,!0)),this.directiveInstance.inputChanged({input:"yellow",valid:!0,value:this.cmyk.y,color:this.outputColor})}onBlackInput(e){!isNaN(e.v)&&e.v>=0&&e.v<=e.rg&&(this.cmyk.k=e.v,this.updateColorPicker(!1,!0,!0)),this.directiveInstance.inputChanged({input:"black",valid:!0,value:this.cmyk.k,color:this.outputColor})}onAddPresetColor(e,r){e.stopPropagation(),this.cpPresetColors.filter(s=>s===r).length||(this.cpPresetColors=this.cpPresetColors.concat(r),this.directiveInstance.presetColorsChanged(this.cpPresetColors))}onRemovePresetColor(e,r){e.stopPropagation(),this.cpPresetColors=this.cpPresetColors.filter(s=>s!==r),this.directiveInstance.presetColorsChanged(this.cpPresetColors)}openColorPicker(){this.show||(this.show=!0,this.hidden=!0,setTimeout(()=>{this.hidden=!1,this.setDialogPosition(),this.cdRef.detectChanges()},0),this.directiveInstance.stateChanged(!0),this.isIE10||this.ngZone.runOutsideAngular(()=>{wO?document.addEventListener("touchstart",this.listenerMouseDown):document.addEventListener("mousedown",this.listenerMouseDown)}),window.addEventListener("resize",this.listenerResize))}closeColorPicker(){this.show&&(this.show=!1,this.directiveInstance.stateChanged(!1),this.isIE10||(wO?document.removeEventListener("touchstart",this.listenerMouseDown):document.removeEventListener("mousedown",this.listenerMouseDown)),window.removeEventListener("resize",this.listenerResize),this.cdRef.destroyed||this.cdRef.detectChanges())}updateColorPicker(e=!0,r=!0,s=!1){if(this.sliderDimMax){let o,i,a;2===this.cpColorMode&&(this.hsva.s=0);const l=this.outputColor;if(i=this.service.hsva2hsla(this.hsva),this.cpCmykEnabled?(s?(a=this.service.cmykToRgb(this.service.normalizeCMYK(this.cmyk)),this.hsva=this.service.rgbaToHsva(a)):(a=this.service.hsvaToRgba(this.hsva),this.cmyk=this.service.denormalizeCMYK(this.service.rgbaToCmyk(a))),a=this.service.denormalizeRGBA(a),this.sliderH=this.hsva.h):a=this.service.denormalizeRGBA(this.service.hsvaToRgba(this.hsva)),o=this.service.denormalizeRGBA(this.service.hsvaToRgba(new $g(this.sliderH||this.hsva.h,1,1,1))),r&&(this.hslaText=new zl(Math.round(360*i.h),Math.round(100*i.s),Math.round(100*i.l),Math.round(100*i.a)/100),this.rgbaText=new aa(a.r,a.g,a.b,Math.round(100*a.a)/100),this.cpCmykEnabled&&(this.cmykText=new Fh(this.cmyk.c,this.cmyk.m,this.cmyk.y,this.cmyk.k,Math.round(100*this.cmyk.a)/100)),this.hexText=this.service.rgbaToHex(a,"always"===this.cpAlphaChannel),this.hexAlpha=this.rgbaText.a),"auto"===this.cpOutputFormat&&this.format!==es.RGBA&&this.format!==es.CMYK&&this.format!==es.HSLA&&this.hsva.a<1&&(this.format=this.hsva.a<1?es.RGBA:es.HEX),this.hueSliderColor="rgb("+o.r+","+o.g+","+o.b+")",this.alphaSliderColor="rgb("+a.r+","+a.g+","+a.b+")",this.outputColor=this.service.outputFormat(this.hsva,this.cpOutputFormat,this.cpAlphaChannel),this.selectedColor=this.service.outputFormat(this.hsva,"rgba",null),this.format!==es.CMYK)this.cmykColor="";else if("always"===this.cpAlphaChannel||"enabled"===this.cpAlphaChannel||"forced"===this.cpAlphaChannel){const u=Math.round(100*this.cmyk.a)/100;this.cmykColor=`cmyka(${this.cmyk.c},${this.cmyk.m},${this.cmyk.y},${this.cmyk.k},${u})`}else this.cmykColor=`cmyk(${this.cmyk.c},${this.cmyk.m},${this.cmyk.y},${this.cmyk.k})`;this.slider=new bO((this.sliderH||this.hsva.h)*this.sliderDimMax.h-8,this.hsva.s*this.sliderDimMax.s-8,(1-this.hsva.v)*this.sliderDimMax.v-8,this.hsva.a*this.sliderDimMax.a-8),e&&l!==this.outputColor&&(this.cpCmykEnabled&&this.directiveInstance.cmykChanged(this.cmykColor),this.directiveInstance.colorChanged(this.outputColor))}}setDialogPosition(){if("inline"===this.cpDialogDisplay)this.position="relative";else{let s,e="static",r="",o=null,i=null,a=this.directiveElementRef.nativeElement.parentNode;const l=this.dialogElement.nativeElement.offsetHeight;for(;null!==a&&"HTML"!==a.tagName;){if(s=window.getComputedStyle(a),e=s.getPropertyValue("position"),r=s.getPropertyValue("transform"),"static"!==e&&null===o&&(o=a),r&&"none"!==r&&null===i&&(i=a),"fixed"===e){o=i;break}a=a.parentNode}const u=this.createDialogBox(this.directiveElementRef.nativeElement,"fixed"!==e);if(this.useRootViewContainer||"fixed"===e&&(!o||o instanceof HTMLUnknownElement))this.top=u.top,this.left=u.left;else{null===o&&(o=a);const d=this.createDialogBox(o,"fixed"!==e);this.top=u.top-d.top,this.left=u.left-d.left}"fixed"===e&&(this.position="fixed");let c=this.cpPosition;if("auto"===this.cpPosition){const d=this.dialogElement.nativeElement.getBoundingClientRect(),h=window.innerHeight,p=window.innerWidth,f=this.elRef.nativeElement.getBoundingClientRect();this.top+d.height>h&&(this.top=h-d.height,this.cpArrowPosition=f.x/2-20),this.left+d.width>p&&(this.left=p-d.width,this.cpArrowPosition=f.x/2-20),c=function CY(t,n){let e="right",r="bottom";const{height:s,width:o}=t,{top:i,left:a}=n,l=i+n.height,u=a+n.width,c=i-s<0,d=l+s>(window.innerHeight||document.documentElement.clientHeight),h=a-o<0,p=u+o>(window.innerWidth||document.documentElement.clientWidth);return d&&(r="top"),c&&(r="bottom"),h&&(e="right"),p&&(e="left"),c&&d&&h&&p?["left","right","top","bottom"].reduce((m,y)=>t[m]>t[y]?m:y):h&&p?c?"bottom":d||i>l?"top":"bottom":c&&d?h?"right":p||a>u?"left":"right":`${r}-${e}`}(d,this.cpTriggerElement.nativeElement.getBoundingClientRect())}"top"===c?(this.arrowTop=l-1,this.top-=l+this.dialogArrowSize,this.left+=this.cpPositionOffset/100*u.width-this.dialogArrowOffset):"bottom"===c?(this.top+=u.height+this.dialogArrowSize,this.left+=this.cpPositionOffset/100*u.width-this.dialogArrowOffset):"top-left"===c||"left-top"===c?(this.top-=l-u.height+u.height*this.cpPositionOffset/100,this.left-=this.cpWidth+this.dialogArrowSize-2-this.dialogArrowOffset):"top-right"===c||"right-top"===c?(this.top-=l-u.height+u.height*this.cpPositionOffset/100,this.left+=u.width+this.dialogArrowSize-2-this.dialogArrowOffset):"left"===c||"bottom-left"===c||"left-bottom"===c?(this.top+=u.height*this.cpPositionOffset/100-this.dialogArrowOffset,this.left-=this.cpWidth+this.dialogArrowSize-2):(this.top+=u.height*this.cpPositionOffset/100-this.dialogArrowOffset,this.left+=u.width+this.dialogArrowSize-2),this.cpUsePosition=c}}isDescendant(e,r){let s=r.parentNode;for(;null!==s;){if(s===e)return!0;s=s.parentNode}return!1}createDialogBox(e,r){const{top:s,left:o}=e.getBoundingClientRect();return{top:s+(r?window.pageYOffset:0),left:o+(r?window.pageXOffset:0),width:e.offsetWidth,height:e.offsetHeight}}}return t.\u0275fac=function(e){return new(e||t)(Pe(ur),Pe(us),Pe(th),Pe(Ns),Pe(Gx),Pe(R_))},t.\u0275cmp=yl({type:t,selectors:[["color-picker"]],viewQuery:function(e,r){if(1&e&&(ac(GX,7),ac(HX,7),ac(jX,7)),2&e){let s;Nl(s=Al())&&(r.dialogElement=s.first),Nl(s=Al())&&(r.hueSlider=s.first),Nl(s=Al())&&(r.alphaSlider=s.first)}},hostBindings:function(e,r){1&e&&at("keyup.esc",function(o){return r.handleEsc(o)},0,H0)("keyup.enter",function(o){return r.handleEnter(o)},!1,H0)},decls:30,vars:51,consts:[[1,"color-picker",3,"click"],["dialogPopup",""],[3,"left","class","top",4,"ngIf"],["class","saturation-lightness",3,"slider","rgX","rgY","background-color","newValue","dragStart","dragEnd",4,"ngIf"],[1,"hue-alpha","box"],[1,"left"],[1,"selected-color-background"],[1,"selected-color",3,"click"],["class","eyedropper-icon","xmlns","http://www.w3.org/2000/svg","height","24px","viewBox","0 0 24 24","width","24px","fill","#000000",4,"ngIf"],["type","button",3,"class","disabled","click",4,"ngIf"],[1,"right"],["style","height: 16px;",4,"ngIf"],[1,"hue",3,"slider","rgX","newValue","dragStart","dragEnd"],["hueSlider",""],[1,"cursor"],[1,"value",3,"slider","rgX","newValue","dragStart","dragEnd"],["valueSlider",""],[1,"alpha",3,"slider","rgX","newValue","dragStart","dragEnd"],["alphaSlider",""],["class","cmyk-text",3,"display",4,"ngIf"],["class","hsla-text",3,"display",4,"ngIf"],["class","rgba-text",3,"display",4,"ngIf"],["class","hex-text",3,"hex-alpha","display",4,"ngIf"],["class","value-text",4,"ngIf"],["class","type-policy",4,"ngIf"],["class","preset-area",4,"ngIf"],["class","button-area",4,"ngIf"],["class","extra-template",4,"ngIf"],[1,"saturation-lightness",3,"slider","rgX","rgY","newValue","dragStart","dragEnd"],["xmlns","http://www.w3.org/2000/svg","height","24px","viewBox","0 0 24 24","width","24px","fill","#000000",1,"eyedropper-icon"],["d","M0 0h24v24H0V0z","fill","none"],["d","M17.66 5.41l.92.92-2.69 2.69-.92-.92 2.69-2.69M17.67 3c-.26 0-.51.1-.71.29l-3.12 3.12-1.93-1.91-1.41 1.41 1.42 1.42L3 16.25V21h4.75l8.92-8.92 1.42 1.42 1.41-1.41-1.92-1.92 3.12-3.12c.4-.4.4-1.03.01-1.42l-2.34-2.34c-.2-.19-.45-.29-.7-.29zM6.92 19L5 17.08l8.06-8.06 1.92 1.92L6.92 19z"],["type","button",3,"disabled","click"],[2,"height","16px"],[1,"cmyk-text"],[1,"box"],["type","number","pattern","[0-9]*","min","0","max","100",3,"text","rg","value","keyup.enter","newValue"],["type","number","pattern","[0-9]+([\\.,][0-9]{1,2})?","min","0","max","1","step","0.1",3,"text","rg","value","keyup.enter","newValue",4,"ngIf"],[4,"ngIf"],["type","number","pattern","[0-9]+([\\.,][0-9]{1,2})?","min","0","max","1","step","0.1",3,"text","rg","value","keyup.enter","newValue"],[1,"hsla-text"],["type","number","pattern","[0-9]*","min","0","max","360",3,"text","rg","value","keyup.enter","newValue"],[1,"rgba-text"],["type","number","pattern","[0-9]*","min","0","max","255",3,"text","rg","value","keyup.enter","newValue"],[1,"hex-text"],[3,"text","value","blur","keyup.enter","newValue"],[1,"value-text"],[1,"type-policy"],[1,"type-policy-arrow",3,"click"],[1,"preset-area"],[1,"preset-label"],[3,"class",4,"ngIf"],["class","preset-color",3,"backgroundColor","click",4,"ngFor","ngForOf"],[1,"preset-color",3,"click"],[3,"class","click",4,"ngIf"],[3,"click"],[1,"button-area"],["type","button",3,"class","click",4,"ngIf"],["type","button",3,"click"],[1,"extra-template"],[4,"ngTemplateOutlet"]],template:function(e,r){1&e&&(Re(0,"div",0,1),at("click",function(o){return o.stopPropagation()}),ln(2,qX,1,7,"div",2),ln(3,KX,2,8,"div",3),Re(4,"div",4)(5,"div",5),sn(6,"div",6),Re(7,"div",7),at("click",function(){return r.eyeDropperSupported&&r.cpEyeDropper&&r.onEyeDropper()}),ln(8,XX,3,0,"svg",8),Ee(),ln(9,YX,2,5,"button",9),Ee(),Re(10,"div",10),ln(11,ZX,1,0,"div",11),Re(12,"div",12,13),at("newValue",function(o){return r.onHueChange(o)})("dragStart",function(){return r.onDragStart("hue")})("dragEnd",function(){return r.onDragEnd("hue")}),sn(14,"div",14),Ee(),Re(15,"div",15,16),at("newValue",function(o){return r.onValueChange(o)})("dragStart",function(){return r.onDragStart("value")})("dragEnd",function(){return r.onDragEnd("value")}),sn(17,"div",14),Ee(),Re(18,"div",17,18),at("newValue",function(o){return r.onAlphaChange(o)})("dragStart",function(){return r.onDragStart("alpha")})("dragEnd",function(){return r.onDragEnd("alpha")}),sn(20,"div",14),Ee()()(),ln(21,eY,17,12,"div",19),ln(22,rY,14,10,"div",20),ln(23,iY,14,10,"div",21),ln(24,uY,8,7,"div",22),ln(25,dY,9,3,"div",23),ln(26,hY,3,0,"div",24),ln(27,yY,6,3,"div",25),ln(28,xY,3,2,"div",26),ln(29,_Y,2,1,"div",27),Ee()),2&e&&(vr("display",r.show?"block":"none")("visibility",r.hidden?"hidden":"visible")("top",r.top,"px")("left",r.left,"px")("position",r.position)("height",r.cpHeight,"px")("width",r.cpWidth,"px"),Ts("open",r.show),Ke(2),nt("ngIf","popup"===r.cpDialogDisplay),Ke(1),nt("ngIf",1===(r.cpColorMode||1)),Ke(4),vr("background-color",r.selectedColor)("cursor",r.eyeDropperSupported&&r.cpEyeDropper?"pointer":null),Ke(1),nt("ngIf",r.eyeDropperSupported&&r.cpEyeDropper),Ke(1),nt("ngIf",r.cpAddColorButton),Ke(2),nt("ngIf","disabled"===r.cpAlphaChannel),Ke(1),vr("display",1===(r.cpColorMode||1)?"block":"none"),nt("rgX",1),Ke(2),vr("left",null==r.slider?null:r.slider.h,"px"),Ke(1),vr("display",2===(r.cpColorMode||1)?"block":"none"),nt("rgX",1),Ke(2),vr("right",null==r.slider?null:r.slider.v,"px"),Ke(1),vr("display","disabled"===r.cpAlphaChannel?"none":"block")("background-color",r.alphaSliderColor),nt("rgX",1),Ke(2),vr("left",null==r.slider?null:r.slider.a,"px"),Ke(1),nt("ngIf",!r.cpDisableInput&&1===(r.cpColorMode||1)),Ke(1),nt("ngIf",!r.cpDisableInput&&1===(r.cpColorMode||1)),Ke(1),nt("ngIf",!r.cpDisableInput&&1===(r.cpColorMode||1)),Ke(1),nt("ngIf",!r.cpDisableInput&&1===(r.cpColorMode||1)),Ke(1),nt("ngIf",!r.cpDisableInput&&2===(r.cpColorMode||1)),Ke(1),nt("ngIf",!r.cpDisableInput&&1===(r.cpColorMode||1)),Ke(1),nt("ngIf",(null==r.cpPresetColors?null:r.cpPresetColors.length)||r.cpAddColorButton),Ke(1),nt("ngIf",r.cpOKButton||r.cpCancelButton),Ke(1),nt("ngIf",r.cpExtraTemplate))},dependencies:[Ym,yw,w2,IY,DY],styles:['.color-picker{position:absolute;z-index:1000;width:230px;height:auto;border:#777 solid 1px;cursor:default;-webkit-user-select:none;user-select:none;background-color:#fff}.color-picker *{box-sizing:border-box;margin:0;font-size:11px}.color-picker input{width:0;height:26px;min-width:0;font-size:13px;text-align:center;color:#000}.color-picker input:invalid,.color-picker input:-moz-ui-invalid,.color-picker input:-moz-submit-invalid{box-shadow:none}.color-picker input::-webkit-inner-spin-button,.color-picker input::-webkit-outer-spin-button{margin:0;-webkit-appearance:none}.color-picker .arrow{position:absolute;z-index:999999;width:0;height:0;border-style:solid}.color-picker .arrow.arrow-top{left:8px;border-width:10px 5px;border-color:#777 rgba(0,0,0,0) rgba(0,0,0,0) rgba(0,0,0,0)}.color-picker .arrow.arrow-bottom{top:-20px;left:8px;border-width:10px 5px;border-color:rgba(0,0,0,0) rgba(0,0,0,0) #777 rgba(0,0,0,0)}.color-picker .arrow.arrow-top-left,.color-picker .arrow.arrow-left-top{right:-21px;bottom:8px;border-width:5px 10px;border-color:rgba(0,0,0,0) rgba(0,0,0,0) rgba(0,0,0,0) #777}.color-picker .arrow.arrow-top-right,.color-picker .arrow.arrow-right-top{bottom:8px;left:-20px;border-width:5px 10px;border-color:rgba(0,0,0,0) #777 rgba(0,0,0,0) rgba(0,0,0,0)}.color-picker .arrow.arrow-left,.color-picker .arrow.arrow-left-bottom,.color-picker .arrow.arrow-bottom-left{top:8px;right:-21px;border-width:5px 10px;border-color:rgba(0,0,0,0) rgba(0,0,0,0) rgba(0,0,0,0) #777}.color-picker .arrow.arrow-right,.color-picker .arrow.arrow-right-bottom,.color-picker .arrow.arrow-bottom-right{top:8px;left:-20px;border-width:5px 10px;border-color:rgba(0,0,0,0) #777 rgba(0,0,0,0) rgba(0,0,0,0)}.color-picker .cursor{position:relative;width:16px;height:16px;border:#222 solid 2px;border-radius:50%;cursor:default}.color-picker .box{display:flex;padding:4px 8px}.color-picker .left{position:relative;padding:16px 8px}.color-picker .right{flex:1 1 auto;padding:12px 8px}.color-picker .button-area{padding:0 16px 16px;text-align:right}.color-picker .button-area button{margin-left:8px}.color-picker .preset-area{padding:4px 15px}.color-picker .preset-area .preset-label{overflow:hidden;width:100%;padding:4px;font-size:11px;white-space:nowrap;text-align:left;text-overflow:ellipsis;color:#555}.color-picker .preset-area .preset-color{position:relative;display:inline-block;width:18px;height:18px;margin:4px 6px 8px;border:#a9a9a9 solid 1px;border-radius:25%;cursor:pointer}.color-picker .preset-area .preset-empty-message{min-height:18px;margin-top:4px;margin-bottom:8px;font-style:italic;text-align:center}.color-picker .hex-text{width:100%;padding:4px 8px;font-size:11px}.color-picker .hex-text .box{padding:0 24px 8px 8px}.color-picker .hex-text .box div{float:left;flex:1 1 auto;text-align:center;color:#555;clear:left}.color-picker .hex-text .box input{flex:1 1 auto;padding:1px;border:#a9a9a9 solid 1px}.color-picker .hex-alpha .box div:first-child,.color-picker .hex-alpha .box input:first-child{flex-grow:3;margin-right:8px}.color-picker .cmyk-text,.color-picker .hsla-text,.color-picker .rgba-text,.color-picker .value-text{width:100%;padding:4px 8px;font-size:11px}.color-picker .cmyk-text .box,.color-picker .hsla-text .box,.color-picker .rgba-text .box{padding:0 24px 8px 8px}.color-picker .value-text .box{padding:0 8px 8px}.color-picker .cmyk-text .box div,.color-picker .hsla-text .box div,.color-picker .rgba-text .box div,.color-picker .value-text .box div{flex:1 1 auto;margin-right:8px;text-align:center;color:#555}.color-picker .cmyk-text .box div:last-child,.color-picker .hsla-text .box div:last-child,.color-picker .rgba-text .box div:last-child,.color-picker .value-text .box div:last-child{margin-right:0}.color-picker .cmyk-text .box input,.color-picker .hsla-text .box input,.color-picker .rgba-text .box input,.color-picker .value-text .box input{float:left;flex:1;padding:1px;margin:0 8px 0 0;border:#a9a9a9 solid 1px}.color-picker .cmyk-text .box input:last-child,.color-picker .hsla-text .box input:last-child,.color-picker .rgba-text .box input:last-child,.color-picker .value-text .box input:last-child{margin-right:0}.color-picker .hue-alpha{align-items:center;margin-bottom:3px}.color-picker .hue{direction:ltr;width:100%;height:16px;margin-bottom:16px;border:none;cursor:pointer;background-size:100% 100%;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJYAAAAQCAYAAAD06IYnAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4AIWDwkUFWbCCAAAAFxJREFUaN7t0kEKg0AQAME2x83/n2qu5qCgD1iDhCoYdpnbQC9bbY1qVO/jvc6k3ad91s7/7F1/csgPrujuQ17BDYSFsBAWwgJhISyEBcJCWAgLhIWwEBYIi2f7Ar/1TCgFH2X9AAAAAElFTkSuQmCC)}.color-picker .value{direction:rtl;width:100%;height:16px;margin-bottom:16px;border:none;cursor:pointer;background-size:100% 100%;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJYAAAAQCAYAAAD06IYnAAACTklEQVR42u3SYUcrABhA4U2SkmRJMmWSJklKJiWZZpKUJJskKUmaTFImKZOUzMySpGRmliRNJilJSpKSJEtmSpIpmWmSdO736/6D+x7OP3gUCoWCv1cqlSQlJZGcnExKSgqpqamkpaWRnp5ORkYGmZmZqFQqsrKyyM7OJicnh9zcXNRqNXl5eeTn56PRaCgoKKCwsJCioiK0Wi3FxcWUlJRQWlpKWVkZ5eXlVFRUUFlZiU6no6qqiurqampqaqitraWurg69Xk99fT0GgwGj0UhDQwONjY00NTXR3NxMS0sLra2ttLW10d7ejslkwmw209HRQWdnJ11dXXR3d9PT00Nvby99fX309/czMDDA4OAgFouFoaEhrFYrw8PDjIyMMDo6ytjYGDabjfHxcSYmJpicnGRqagq73c709DQzMzPMzs4yNzfH/Pw8DocDp9OJy+XC7XazsLDA4uIiS0tLLC8vs7KywurqKmtra3g8HrxeLz6fD7/fz/r6OhsbG2xubrK1tcX29jaBQICdnR2CwSC7u7vs7e2xv7/PwcEBh4eHHB0dcXx8zMnJCaenp5ydnXF+fs7FxQWXl5dcXV1xfX3Nzc0Nt7e33N3dEQqFuL+/5+HhgXA4TCQS4fHxkaenJ56fn3l5eeH19ZVoNMrb2xvv7+98fHwQi8WIx+N8fn6SSCT4+vri+/ubn58ffn9/+VcKgSWwBJbAElgCS2AJLIElsASWwBJYAktgCSyBJbAElsASWAJLYAksgSWwBJbAElgCS2AJLIElsP4/WH8AmJ5Z6jHS4h8AAAAASUVORK5CYII=)}.color-picker .alpha{direction:ltr;width:100%;height:16px;border:none;cursor:pointer;background-size:100% 100%;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJYAAAAQCAYAAAD06IYnAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4AIWDwYQlZMa3gAAAWVJREFUaN7tmEGO6jAQRCsOArHgBpyAJYGjcGocxAm4A2IHpmoWE0eBH+ezmFlNvU06shJ3W6VEelWMUQAIIF9f6qZpimsA1LYtS2uF51/u27YVAFZVRUkEoGHdPV/sIcbIEIIkUdI/9Xa7neyv61+SWFUVAVCSct00TWn2fv6u3+Ecfd3tXzy/0+nEUu+SPjo/kqzrmiQpScN6v98XewfA8/lMkiLJ2WxGSUopcT6fM6U0NX9/frfbjev1WtfrlZfLhYfDQQHG/AIOlnGwjINlHCxjHCzjYJm/TJWdCwquJXseFFzGwDNNeiKMOJTO8xQdDQaeB29+K9efeLaBo9J7vdvtJj1RjFFjfiv7qv95tjx/7leSQgh93e1ffMeIp6O+YQjho/N791t1XVOSSI7N//K+4/GoxWLBx+PB5/Op5XLJ+/3OlJJWqxU3m83ovv5iGf8KjYNlHCxjHCzjYBkHy5gf5gusvQU7U37jTAAAAABJRU5ErkJggg==)}.color-picker .type-policy{position:absolute;top:218px;right:12px;width:16px;height:24px;background-size:8px 16px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAAgCAYAAAAffCjxAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAACewAAAnsB01CO3AAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAIASURBVEiJ7ZY9axRRFIafsxMStrLQJpAgpBFhi+C9w1YSo00I6RZ/g9vZpBf/QOr4GyRgkSKNSrAadsZqQGwCkuAWyRZJsySwvhZ7N/vhzrgbLH3Ld8597jlzz50zJokyxXH8DqDVar0qi6v8BbItqSGpEcfxdlmsFWXkvX8AfAVWg3UKPEnT9GKujMzsAFgZsVaCN1VTQd77XUnrgE1kv+6935268WRpzrnHZvYRWC7YvC3pRZZl3wozqtVqiyH9IgjAspkd1Gq1xUJQtVrdB9ZKIAOthdg/Qc65LUk7wNIMoCVJO865rYFhkqjX6/d7vV4GPJwBMqofURS5JEk6FYBer/eeYb/Mo9WwFnPOvQbeAvfuAAK4BN4sAJtAG/gJIElmNuiJyba3EGNmZiPeZuEVmVell/Y/6N+CzDn3AXhEOOo7Hv/3BeAz8IzQkMPnJbuPx1wC+yYJ7/0nYIP5S/0FHKdp+rwCEEXRS/rf5Hl1Gtb2M0iSpCOpCZzPATmX1EySpHMLAsiy7MjMDoHrGSDXZnaYZdnRwBh7J91utwmczAA6CbG3GgPleX4jqUH/a1CktqRGnuc3hSCAMB32gKspkCtgb3KCQMmkjeP4WNJThrNNZval1WptTIsv7JtQ4tmIdRa8qSoEpWl6YWZNoAN0zKxZNPehpLSBZv2t+Q0CJ9lLnARQLAAAAABJRU5ErkJggg==);background-repeat:no-repeat;background-position:center}.color-picker .type-policy .type-policy-arrow{display:block;width:100%;height:50%}.color-picker .selected-color{position:absolute;top:16px;left:8px;width:40px;height:40px;border:1px solid #a9a9a9;border-radius:50%}.color-picker .selected-color-background{width:40px;height:40px;border-radius:50%;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAoCAYAAACM/rhtAAAAh0lEQVRYR+2W0QlAMQgD60zdfwOdqa8TmI/wQMr5K0I5bZLIzLOa2nt37VVVbd+dDx5obgCC3KBLwJ2ff4PnVidkf+ucIhw80HQaCLo3DMH3CRK3iFsmAWVl6hPNDwt8EvNE5q+YuEXcMgkonVM6SdyCoEvAnZ8v1Hjx817MilmxSUB5rdLJDycZgUAZUch/AAAAAElFTkSuQmCC)}.color-picker .saturation-lightness{direction:ltr;width:100%;height:130px;border:none;cursor:pointer;touch-action:manipulation;background-size:100% 100%;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAOYAAACCCAYAAABSD7T3AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4AIWDwksPWR6lgAAIABJREFUeNrtnVuT47gRrAHN+P//Or/61Y5wONZ7mZ1u3XAeLMjJZGZVgdKsfc5xR3S0RIIUW+CHzCpc2McYo7XGv3ex7UiZd57rjyzzv+v+33X/R/+3r/f7vR386Y+TvKNcf/wdhTLPcv9qU2wZd74uth0t1821jkIZLPcsI/6nWa4XvutquU0Z85mnx80S/ZzgpnLnOtHNt7/ofx1TKXcSNzN/7qbMQ3ju7rNQmMYYd/4s2j9aa+P+gGaMcZrb1M/tdrvf7/d2v99P9/t93O/3cbvdxu12G9frdVwul3E+n8c///nP+2+//Xb66aefxl//+tfx5z//2YK5Al2rgvf4UsbpdGrB52bAvArXpuzjmiqAVSGz5eDmGYXzhbAZmCrnmzddpUU+8Y1dAOYeXCtDUwVwV7YCGH6uAmyMcZ9l5vkUaBPGMUZ7/J5w/792/fvv9Xq93263dr/fTxPECeME8nK5jM/Pz/HTTz/dv337dvrll1/GP/7xj/G3v/1t/OUvfwkVswongjdOp9PzH3U3D3zmWGnZVXn4jCqs7wC2BKP4/8tAzkZsoWx6XrqeHZymvp4ABCBJhTQwKfDT8gzrZCIqi5AhiACjBfEB2rP8/X63MM7f6/V6v9/v7Xa7bYC83W7jcrlsVHIq5ffv30+//fbb+OWXX8ZPP/00/v73v4+ff/75JSvbeu+bL2WMMaFbAlpBNM85QX+ct6qoSqkPAwuQlBVKqGNFSUOAA3Bmu7gC5hNOd15nSwvAOUW7C4giUCV8Sgn5L9hNFIqTsp0GxI0ysioyjAjkY/tGJVEpz+fz+OWXX+7fv38//f777+Pbt2/j119/HT///PP49ddfx8fHRwrmTjV779EXu2px2xhjwtdJZQcAWQIPLPISsMJaSwiD8gzIKrwSyATE5j5nAbR5c1dBUwBlsEWW0h6LqiYsqFPAQxCyRZ3wOSARxmlXMX5k64pQfvv27f75+dk+Pj5OHx8f4/v37+Pbt2/jt99+G9++fRsfHx/jcrmUFLO31gYDWblxRIs/TqfT7ousxJsAxXA2Gc7TA9XdgfdoHbFsj76X2+1WArgI1ageGwA3qupqoHsmcbI6Fu93quggFa9d7LeDtgKfAFHBJ+NEByIkcJ5KervdTmhhGcgJJSZ5vn//fj+fz+18Pp8+Pz/H5+fnmGD+/vvv4/v37+Pj42N8fn6O2+1Ws7JjjP6wraMI5E4RZ8x2vV5TSwkquotV7/d7Tz6HFWsD/qNcdw0CQ3q/321c686TwDVIdbuy73zNldhSHb8I2klZznm+InBS4U6n0302aBFsLhHDAKJVJVglfI9jhvu53W53sLANYNxAiDA6MCeUHx8f9+v12i6XS7tcLqcZW57P5yeY8/fz83Ocz+fnsSmYUyknWEG85WBst9stzSLyMdfr9Qi08iY15UZ0LlDGLhR3o5zK2j7OPUTD0E+nU3tk7Xb/16NFbhloAMuY1zjLUOO3BKeIDe+Z8s3/J4gFo4TM5jPmuRg28foUKKVSwo16TgA5npywcWLHgYl/Pz8/73/605/ab7/91m63W7tcLie0sZj4mao5gTyfz88E0f1+j8EcYzwTPEG2cqjyfHNF0M8fuqEiaOVnRzZZQNh5fwQyHg/HDGfJo89Q1zb/quu5XC6773I2XKfTqd/v9+d3wuqWva/YTdUdEV3fhIv/Viyps6YE3x3r43K5bJQS66zaxVGFsvd+//j4aF+/fm3fv39vt9utff36tf3+++/tdrudvn37ZuNLBaaCMgUzC+rZRiFowxUuJI8YMqcCp9Opq5vagaYU6lGJA1XQqejchw6Cj0Gw5nYBrGw01A2O206n04BGouNNyTfp/FwElhUey6nXrIKw7QQWddxuN2ldL5fL839gSPF8ahu/JvBO48CPSuqMf8Vp9/P53L58+dLu93s7n8/tfr8/39/v9/b5+TkhPJ3P56mQ436/j+/fv+/iSgbzer0+AZx/5+88bv6OMda6S5z6kd21fYC9dxv7cIJJ2d9AOS30fPMzyHiTM8B4DF6XUlYHp4KQW3W+1t77MNB1vGHxWq7Xa7vf78+y5/N5A+H1et29xuP5dbYtyaRu4AksbPq6936fjRzXRxBbPr/b+b18+fKljTHaBBBfn8/n0/1+H1++fBnn8zm0sB8fH5u4cr5GuBhMVk0EEn9RsctgVhM+ixlJtMA23R8B6yysAstBOgFXIKKCMIgToMqNEu2fYMH7ztc732dQKkCj1ytAZtY0Kx8pIr8GGJ+AT3V+2Hirhl++fBmXy2Wz73w+b17P8p+fn8/tUwGVleVkTyUb68DkfayWY4zxNRihU4EpLJPZVrK+u7J4/mgfKqeLW9X2REWlItL1diynbDDb3+jXgYjQqn0rrxWc+NkILP7F7xIbMvx7vV53x40xnlbWJF12ZSag/N0pW6t+ZzmOMzHjajKwDfond78zYTdfq18up97zr2q8v3IioBprRtBl0EZ9og5WBRGOdOHjIjXF7UotFbgOWnXzIJyzYvjG5IYgsmMOxHkz8OsMSrVNWeq5T8DaOcbEv1Od5rbs9aO7YvMet63EkF++fMExq+MRl4/L5bLZN/+ez+fnZ6KazuMqXSQVO5spJXflHAIzes/xJseckRJiDMog9d6VfRrqXMr6KpVV27jRwJacGovOAM1zMdQMnwK1AubK63kdCChvI1C7g0z9nf/D+Xze2Vj8H7Gx4P9duQlsYCrqyN8XqG3Hm/10Oj3jw/n+crlstuM+jPmmxT2dTuPz83Pzt2pn1XsEHX/bnPaVqVmh0xwOt0o6XLLAHePUU203wHfcrspCwmV3TryB5s0Mseeg97x/BwzCjBlbB+pRAPla0BVQuT6V6QHdBlj3d0KG147b+DqxQeUymDO43W4dQar+TIjwmAd0z8/h65vf0/yLv3Pb5XLpru/ydDo9s7ET0I+Pj6dKK9VUEIeKWQWPAOrJ8LKd4vE+t91Y3e7UFlWatg2VwJnb+HPmtvm/sfK59/OaWF3x/eP1UPHvA5DDYDpYXfb0drv1V2DkBkxtw/tEWVVlXWdC9pFYs5/jfh9dS/16vW7s6lTG+TfqsxSJHxkXXq/Xdr1eu4LsfD6P3vsT3N77DkL+zPm5jSdKL4zR3AxQd6rHkLkYlSowsrq7znzu6wSwdsMJOXmA5fBcjxtgMGBYHlr5zokhtsMCTgXLQOW4XC6dEyEMprL8mAQzXRgduix2yZzorxkYsDn3hB1VeMLGsXsVtgl2pW8S3svk0vw7R4hNaHvv4cACl5HFzwIH0Kc6zu4XjDPR/jpAVxWzO1Xk2DDb3vTcxeGU1iWZHkmIDWziWKvirCJ4Dravs6IJ/GG6cTqWdXDy+fArQDVVkLqkVjAoZIITdmmIqXwqa95N3+MGYoZQdRVNO53Y1xRkhO16vY7eu507Ca9lJnbGpxOemQhSw/AQsmmp5zU9BiU8G6wvX76M6/U6Pj4+do0Bz4CpgiknTUeDqwlKBmg3u4OVjrZ1A+rAcgaejWq6eJCvCYFDONSwOgHX4EQRw8lxbzDOdEK6gZ3Hk1b+8g2o1JFtKXyv/fEdTXuWjWXdAZiBp6ADeDrCFiim7B6ZFneeI7Gvm/PMkUDX67W7xI8b0D7/v8dA9qfN5oaCf74WZjH0mf1cmfY1Y0JUFmVrTWu8uzkNcLtEj7u5FXBTkfC6GOA5q8YMxO8KVvF6sAVGdcrUbsKODcQKkLMOMdmlxum642YrPm26AlhZW1YB1R+rrGswE8TaYAWeUMxdf+WjwSvZ2Ef3ytOyfn5+PpVPAaqOn43MtNBqvmjjxbjM4lZjZY4gqNMI5ktaW/sYKNwS+9lFQzGihmMCKPa7+Z0V6Eb0GRmobtpX8JljWu5FMLN5ja6hG9kwQgZqf5+1NH5UxzkFReCdWhJ8XdlGUkxO7HRlYRm4mVO43W7ter12TPJEw/rmEN3L5SKHIWZg9mz+pUoKOYq5bJTJdX2gme1UcxMZQFaEQIlHct32M+Y1BzGkGuzfiyAN9z+ugplZ1symCrDCYYkGxDTpI9RzBy0rHyeDUC1nWaeUaD9n4xkNyYMBDZtzZ3B++fJlY21XFDOcARJlabOyiS3uCpLI9jrZjCDkaVvcCCjwognKShWdzXZWlZMvVTgD8LpqlCLrqgbcB+qYwrgKYpT0ccCqbKyCValkEabn/FynogCrPKfqf51xJ7sGB2ZXcZmxoSOztjx300DZi7a0/2AIR0UlBag9SuDw6KcAzlaB7vHZvWpjK90dyrq6bKyDUZQbR0B05biLQkHIcSUmgIK+SwuqgHCnoio2RQU1yj+BnBy9pphVKLGyC7ZzFK1pxWK+E8IhVCWLN/uLtnUU4ayoYLoaANz8FdtaSvY4pV0BEW2ls61czqllBKpTyKgMAhrZ1cdc1RROtPmvWNkdcKZ7ZKxaWjiPLJMpp7OZKxA+rqG/oJLjxf0pnJlqLoDZo3gyU0mKGys2taKecj/d1C+rJSplBqlTyAqgR+D8KjKlmRL2gtUcAdCtsL+ijCNT1oqqqkH2OHEbG5sDFnUg5Aa+yLou2VU1ptj1S2ZQqv1ORZN9IWzRfgaRBxKoBE8UWyqlJFtrIc0AxNjSjed99CTY/XDfSzCz5M0IZoVEsWnPFNTsl8ooVC1TzbGgqFZNDSgVwKK+1sGDMKqxZCWGVMDysiEr1jVSQJUYwj5iHOlThdHt44SQg9CN+nl8D90NMIgAdgr46JqRiR9I8vRdFvbr17m/yxUMKjNLMiVUADwu2CWGhhi+F55TWM9M9cogzms1dnM4uOF/LAEYWdcqnM7yFmyq3IfwmOROd7Y1iFWtOjoY8To41mTV5IysgFFuRzsbWFGbNIIJCDv1dOo4lZG7jWBwRFtVTKuWyeCByJKOan8oZ3ep9XddNl0tDuaywLz9cXPYeDAA0SpkBO9sbVcTOVWldPv4uyzEkzxHtjvonHoSkFEWNoo1d8DhcQputd2ppNon4BzoAiJ1hBFQg0dVtdbGHHDQWushmNEQukLM2QO1G2Y8bgTXqFhcBJj7EjPgcPts8US8qPpPB/dXznOh5Z438tzH5ec6QgrOKrRRfKmysBmUDB+PhYabMlVPER+GCSITTzr7am2tArH3bgcEzPJm+cr5jJ4NnHNFDVrFXcI5Le9k5Jnw+bedbV+FfRzZIHaOOaOsLY0/7UGs58DjrGwKMIMFIGzOEW1/jGsdAtCN6hEAI4hBe9YXeRROBSVPAVPAqvIM5bx5hVKWAMP6zBRy3iescridVdFBinBxXDnG2GRY2XbCvp1lhvGtO9Bxu5h908XQu42lnSArMFdizMim8uwRCxPGnnOS8lwpnbOiDqTAjsrRN/PcoAScCbaACqVM40ylnjjTBs+bwWlAG23/UKbdkiwKWIQPGzWaczpoSlxPEj822cNWkpS7FyzsDrqpfgpG3jahw2vgbaSQAxuLWZYt7JzyNe8JoZpNAcvDFOdw0wqYT9AK1rZz/DdbSlLPp0ryIxgQJlK9AZlEq7IOXpohg9PIhrCng88JsOxiV4ZWAYfg4sikx/8ky2Z9l862uqwrfscIH8+ugTmVGyiddeVYUgEMn4GZzg14EwIsh9sx2cKKiWXReuOE5gzGOQgdlRKVVdlevqb279Xq0Qnsts2VDaBO0coezsruWtHApu6sKG4IBhN0aGU2kLrMKGRTN3HmbCDwKV14zvkMEDG4QfZVspVlaNU2mhc5TEZ3N1h/zqTheuLpW05ZWTGVjb3dbnNmxKZBnN8JqidaVLKAOyARNLS+MB54Z2+VaqoMLKroVBlngefnTPAcoHNWCSvlfA8CI0HEmBNBnBlXyMrzU7A7WVm94PPqQ2gmqKx+WDGsnvilmcSOBJqOK1nYyAIzuAyesq3UdSK3KfWcYKD95HmfYOU3qser2CtYEUA+FpfqdNvgPBZUBhDrGONRVlQsh8rLcaUCykHG0OOUwTlLBrsh5soEMGezi1E4HRVt1icp5wZEFXdibCkG8Y8vX75sbO4E0iom9z+hjSiOfy3DhpXItpVhE+UGQdvoWjtChmrGHf4YAzKgBNnGtuJxFCeGdhUAfQLLK8kBYAP6gvFJZajMG3Xkycy8KuC0q4Eyymwtwdxdv2M0mIBtK0LKnf640j00Auq4gUkdWGlhs22qJc6dZCsL19oxnlTJG4SYVRIGpD8TPFBuM6OElbS1pldid4mGAyN6ZIupbC5bXJN9fdpbThSxLUaI8IG1XIYBxW3Tjs6KQosKcxfxcQmdnwRGM10GnFcCy2XYunLMyAkdgk4mePiczsLygthcBut6goOqS7YVFXADLjaosB6s6ofcZWAZSIRYqSUkizYwttYab3vUOQ9w2HRxIIg8WwRVeE68xi4UtL3zRphxplzwuZrcqYCq1I3jPI5dnJIygEohMbPqVJSzrwzxBJTs5zN+ReUSgxikPQVF3JVBeNQxbHENrEMNvEdFZVV9lH9+ORGEsNZQpyTNc4C3AG7XF4ngzq+DrO2zbuaaOXgdaFcdkEotoSFBVX2qJ0C8OWZeG4KGlpghA0XfTOPCqV2qqwQ26QWfF2PMLhI2w1lVAa2aPsYd0za25MQRwgcZN6uQDCi+ZxiD4XEM2kZxOT41FnZnaRlcpZouzlRqqdbQVWopQoSB58RV50lBNrHi/AwXS5LrwDVlpY3Fc3ByiYGc52Trist6kOXdwInAQtJpp5QchyaquYOV7Su+fxVMaV3dc0RE2S6mUY0gLt2pMcYqrKIQ9w2l1gpQUMtQYcmmbt5DTNxdhnUCjQqtbK9SUSzvrC0mmhhE1e2FS2+oxypy/ZASutkmtjx3vcBC24PX65nbqkBCRhfjS9kIYPnee8cMagVOhI/3T1fAmdtAWZsCswTJCkQVNa0qWKSKPOpHAUhD9DrbVcyoYkwqhvh17vYAayXLQyKGYdxlUDFp494rBXRjYgO17DDYetNIUj/ezp6S0lnlpEwsWmJMkOwsKXeZKEAjIHn0EQJISaRBcO6UMINz7p/bEjjnw4ft+xmDvksxX4G2rIris7qaeKwAFMP2Oi7n4criuZwtpSUwpfLxSnORSrIqusc5ZFaXysqRWjiZ2DyAWEIL35tVSoQElFACjOeGGSE7AHEQgdo/LSvCOgGBvkxsmDbvlS3Fp5vhaB2TAGqRKrKKMrhLVpaGzEVjZ0OQxDhaCTA+QyRR1d15aQzrJntL3RibsipjG6jlgL4yqbS0sNYg1e84vhbBVrElK64CUcWYXDfKxhpIuxiVJZUxsbMy/uRBKTNRQ4kQ3LdRYLS0rJjRPlTPqY6gdJsEDc+aQXAn+HgsNUCbRuF0Oj0zwnA7bWDkbhO5Ens00qeQhS1laBMl5M/cAaxsLF8rKyql+Tf7ELLEGu/ixiimdCvo0TjfpjKwaggen4eh5v7LokLKbLuyvHhcZG8dhGrEDx7Hg93ZppJF7qBqO3iVveXEDQNInzeoe8Yq6ePaZBZ2JviM3W2UAGotekRCAGq4EkF1X3DOnR11yRsBL1tRa0PVcZiNFXZ2c34FskvomInQQ6lzpJoZbJxk43NwKJFBquJSsrByHydxKOnTxQASBmS3j+JMnsHSla3Ec6K9VWoJVn9zfjwOM7hqYAAqJQwE2a3nA48J2QGegRkpZNivSY+ys3EkKd4oJIwsvIHl3cWgLt5k4NH6OmtLWdpurOkwEMupYc7eMtDRhOcI2ui5JhVIzXzLyto/GAPuZoyo8wkoduVgJglCt7OhGbgID4Mq4si+63zUS1FuFFXFlqyaj2emHlLMcBqYu0FMuR28BbB7lOxRMSiCQXFhCKuwkhZ+pYDiGSgbsKKV8MiSRsuHSIWM9rklRiIlZZuqXjsQK8ooYJMgq3JKWVkhHbhsVxFUzthOWPkYijcbx54IKsSdT+uLr3crGKyoYgFiGR9iBk4kfloUX+JIlQRQqabmpgnhqtpQpb6RVQ1WH5DnrS4hEoGZqaerQ2dhFbz8XePxShmDbo70eISjoorO2vK8SJXI4SUmEU4zWKDzUDtWTYw7xXlbSTEj4FRg7zKnKoGRALv0Gs9Tgc1BpCywGZRQAtqVz2xrBcAMzEpfZwFSa2G5W0QBFjSMapWAEFa3HcGN7CxDzECyIkJ97qwrqWNTWVo876PPsjPkj2wvgroM5lLZKMETKVql/CvnWVFiFa/SzJUQwkoZsr67Y6vlSRV3/2tmNTOY3vnaxYwMuoPKqdzR1w7IqHymlPxaAThfU7Ko2ZXYj4AYJHL+kNdKwRQYESTRa5fsUZ/rVC1TMTyWVyYoqNtuzaHsMyv2tvoarxdfqwYgU1axFo/cnql1FGsqK+uAROV8BX4GU8WcZTATi2q7Qcyi0O0V+GhWBMNRUkn8H1SsWVE5By3Gi0ECqUeJoBfAtDa4amkdXG37AGP5Ggeb84p7UazpoKRzdFzeQ8HkoHGxprKy/Hpm5t12p47J6xTYDEz7uINEXSuxYXvFskYAc+ySxH9sf5ftKzU6IbwVBcUGg5e5FMCEXSErZR0wGayV19woM9guPjTqJdVTqR4uE4nJnLldWVkECCZLd2VLF+xtamex7IpiriSDUpvrpn9lrwGMCHyppMH+ps6LILsuFGUj1XEOXiqbqSHPUKnClpWV68kqtURVNDY4TNaocykoYeTU5ngGEQa/S1DnnE4AeXMcKjHPAmFVjCBENaeyLVNHfr3px8xUstJ94hIpfH4HKE/eDaArK6lSyVVFbdt1gxTIVk3pppVlFXi4pEhVBTObquohU85MLXn1iahvUkHJjSCMc01tLFveVVBx0DodM6jftCu7DOtIzYxrc0qp1JGP2ayYFz2Gb6HvMrO8cnGtV6Gjm3uImSfD2GpWK6uowbZGMxFKQCo1pOMtcMXFpRst+hXGoAomF3sSTBGgTglbBKWwsQ3tZqaYSp0Z1CimRDWFcCJUPYJ00BI5FkKYNoifuQxmN88SWVXWLMaUqqqgC0BmQJR6sk3u9NCf6jYLXxAfqsYEgVLAhRY2AtgtflZNFmFyhxdrLkAdWlk4D88M2ixHyepIdhMHrG/iR1ZGtq0MGpbDbRPYOXeSY1M6Ny4ZstvGSktK+XbFPATj2D371saPEsAMXhXrsZ0km/XStkhhMyBfsa6uXFZe2VCe+YMr1+GKgwrQyNYq1VRrB+EizAow6NsdNKcyVEkYeM73ys6q4kAHp6BiFklTkIrVC5oYV7uzwOGCz4UJ0Stq2lWMJy4wtb+RetL6tZFicnJmBw5UjCvXXMZVJX2MQkbf+XN5EWd78Vz8/JEsMZTBiKNzsm1inLRUQ74H4NidaqI68j5sAFgxcRveC7ieLJXfQYxjZZ2CsiWFewZXJmBIlZ1tdtrX4hSuateKso/RZOtOKW2nmq1oTzeK6dRWAWu2NRVb4hq0SXm1GvtugHrbr5IXqmSktg5CuDE2MSlPwsY5kNE2Wp3AqiZbWVLAxiBF+2iBZbuNj6MB6rsMLC7FyasaYDyo7KkoPyEtw3pEMXfPvxAJi2jAQQgjrz0rLIZSWZlIoNhwd5xK4AR9mYNjWAaLrnuImJeBVN9zBORObVvbr+mTTfFSEJLSRnHo7hEJoIi8MFqjxmvgmF5URZz4zLFgZZ8Ctu2X7ggVccKm9gVxIsOHqxXgNMKnFWZYnf1dBnOhayXq17QwFlWW09eNKyVJFmXqaONGA5aCegMbJ3UUkGY1ic3nKWgjq8qfVYGQG1gRt6rs62a6HiqqUOqdesK5NmX4nGofJoiE1d0dF9lVVkvT1/kEEaaCoYOwFpcVcoLM+7669PxC9rWqktH0sWUYld0VCpuBZ/stVRcGgy9WX2+U1Qthi9SzAqSxzZsy+OiFzBYnySGV6Gku44rD8BCOZBV3BvD5+AKRHNwMEsB6EzHnJpkTAeiUlEGkcECeB6GDZTp5YEJTlvdrknxYjTllMkfNtXwDjM7uVjK5JXUUn43rrqpK2jytaxHW0M5G8DC8rtHMYs7KSgduVQMGTYFqFvVS6rkD3sDJ46afdYFwoq11AOKCBLhvwoUgc8IGANycR6knZrdJPdsuxnyjfd3FovTlRMdEdtOl5CMV5EHsXQBis7TOwvIDZaGj2Vnpbh7cpK63VwYEMLwqbjzyl699sawFFkF1yqjUU31HfC6sW1ZFVFuXVXVgz9keEaw0ys1lWfm+azQAQSWA+hKYVfsZjPncAcUB9oIayy/UZXRNckDGji77GsWbvBo6tPrWPqOyVkBUq+INeqpzNdYs/u0ifh5qmpqIW+33JVSUcwY70KL4U9lYdU6ljtSls7lmfi9g3YzeQfVkaGFaV3ODCnaD2N8wsEDFklE3RzM3ZghdYkWHsszq70FIecnKkVkt8ezMzRq9bkGuKojRLBVSod3Y1yPqKgYW7JRQTPVyy5xIYLjOgxgT52RKJUY1dOrIiRd4futQx/A5AcSmEjz0vFWrkLzvbWAu9HOWbGgxFk1VNTpnBKk6TgwisI/HcxYXP1uAWO72ULFlBTq+aSu2VTUs6hrxM2CF+hEor1VIA9ZmFUaab1lSSgZsVs4sxzHlVLoJHr9H4DhONTkI1XC0/wiY2NoWAG5RlnHFnq6oLccpQddMuJ/O17JVA5OHLi0BqCztq7Y1++ucCd98qLI8MIHBV/cKjxQTme3hFBS3MyCqnDsuym2o80HjvFFTtrURmNaGJsmVahImjTsUXKtQZTAVs7Mvv8/+fzUrZAXcLJ6M4koe6XP0b6SmWWNDzyUpQ8bl+LtWx4tuqZ36cRYV3yuVxPNwvIiqiQCSmu7srgTzR6nkyhpCarXwFy1vGd5iP2cY06lFr5Njhhg1Y6+NB28ftbK83s8rf7kLJbKwDFPbLg25a0AdZJEiqr5phixKMDlRUtcssq1hriLqGoH+zeNgVm9OemjsETV8JdF0NHnkIFxWY1OB4Yrp7rtWJ7NgAAAPXklEQVQ3oNs5nplyVf8u2FoLu1JrHveaZWQjqAkshtFa2gzsSG3Zpkbvg3HafF9slPPlldjFlK80Gysm8Mr4MPhneNWENPGjAIpmilTPATdTRTXlCBYHYAQuPwA36xIpWtGN4q3Y2MhiGsUpuSSnlEJRD8PorC7CFYVw+F51qThgabxsTxWzCGY0ZSsb3lfqAy0OPNjNy8xiQQKsHYFQ2HBZVvVbBuq3m1oWKajqaonsM6uZUr6CjXWNZ0l5E3h3jURma6kP3MJIiy1Lm+kahQq41N2iZja5sjtlLYNZHZrH6qUGm4vMbDp6Rw2CFmvuyFkrBcCyMtFqBaECmsHoK9BZ2LA/lJcRqSaDqnaWbrZdGaz3DLgIvBln4woGztbyJGqslwxkhhHrTjTYFXCtOoKS8uLdofVdAbOylGU6nlYpXWZts4nXBq6WxJitMNokHUJnbnJplQm+aGpY2a5GMV2QD1hRubBPFKdumf5OHkLHz0F9luE5kjBjRa0nFE5CUGqHw32MmjZ6xkgINVnSnZ1VZStK2qKlRaLlQgK7uTq7JFXJwM+3SOEKyhZNI+tJ0I5qMYy9k2qJD7dVWdqKXa0CKNR0Ccjg+B2IYu2fcBZJZkMFgM11r0X92wilghFGgzVnexlqB7xL9mS29SiYUVY2nXOZjNBRsyDsQPRWW5hrZ4XcdC4HVWRbjgJr4sFofK5SzjQ7rhI1UebdPdEbj6sqIvTZQZ5va08rABsAW0UxeWytAk7A2KJ9ZpxzCioB24XFtYAeXYxr6anSqhLgppEqWbGwLunTgrV+IjWlL29ljaAl4EQMGsErp4apeZiquwRXLXAqOCeru32mmydc6oWTSWpFAGdzeTB8RTHVMEtlM90CbbQCYhPjq3egYr1FGdYIQjiuDGZ5zZ/AzobKGOyLxti6c4Rwtv2anyWlLICnlLhxJRXt6A5ebDBWFNONbxWZ2d02mnu4S9YECpeppV1zSWRBWxHYzVIv1CXSouwqqX3jBBBDZdYQbpTQW4ZQlS8r5kH4suSRmg2++3JN10x1PaAmEkmtYlEdeGpJEM6kOuCqCR22oSujj5IV2HdT0zj5prLKTjXFAPjdQlyq7xIBxAQP5yMczG4VxAKw0n6ilZ2QBce2pLulkuxxqnoIzFfgqyqjil9S1VNwBrFmeyeops8yOjZUybZdfS8CuaTIJumzs5tODaNtLpFDQ/PcJGweLhmeL1nB0KqiUDScsiUVD89Di3HtrKtSULw3RLiygZD+7sF8JTObgYsrGvDNUFRGl1iy0Ll1YkUc2aJYMog920I8qW6YDCg1Mqk0JHJFKXkbgbRreI+qpYNOZHrVcDUba7pjsphSJNtK6upgRNAVoOS0mugBeN4bIZgHhuPZ/s1ENaX6KsVr+YNrh1Nb7ipR0PE5zbNRegCbrHRUw6Yf07dLBJl1f8KB9as2V1nNqAsl62LBBhehwalerkHmB1JFIEZKSEusdl5JQj1nJlHXSCF342gJ9CYGrXelknJIXqVP8sD+qtplCR3XH2qfKq0ygMp+KnVkKxNlZ8m2YkIlVMiCnXUwl7qznBKSvQz3m3Pt6oQbXO5b5FixCh/fHxUQW/AEcK6zCNqKQnL9sywqmKuwvqSYzT/aPVNNpVyhvRW21aqciCsjdWvBwILUvh5VyCzbWoC1pJjJ680CWsl+udKB6T5RwG1mlohnlpbg47iz5U9ha0FGtmRLFYBtO99y97Ap0z+ZDTAog6kSLZsMHg/IFkkgp6CpvU2U0cYVSdnmkjwBdOmXbxTWNWzuIbipMioVxEckZEoahSOiy2M3K0jcC1LhVDwaqG0ZvkcWqCnrG4GIxykrqlbWdw6LQyBaZR8HmLRIhQWsHswD42ZXVLNkf9l+FlW0HVQ2lwFsC/Z1FdzlQR0KaPfo+Fdfu+/dwVRICu1CGR7AEIiAhc+AZUF0kOBaPxmUqg4i64vQnU4nFDYJ9Nz+1fVXveH9qmr+kPILx8oKcRV/BFbxbE0JMT0kSD4w6L/lNY8ocsqagVdU3A3MjxhxcGuqzsPH4irpaow1q6OyrVjvp9Npc59E91LldboYVzJWdimWfAW2SNEKcDaX2FmBLLA/uKxlmhh613Is1URQApbKfttwxL02q6Onx5pQxSbPojAg+v5hAnN6LHVRDXIsvKtRjiS0qJUyZTAXVbAK82ElFJWaQdVoqUC1Unt7BVaTQudM6SuqexjQJN4+0icaxv/utbKv83ETbT8H8gjcOKxOJmbUa6OOVXht3dFY6rHv9XoNzFLceEA1o8+pKm0LAHPHZ2rYKjFq0hfZFixsqHJgD3eD5n+U0kb1mFjXkn2lvMSSOsNE/CdIAKF0Sytq6urOHUN5gwg4GZosgbmggM5ucra2qrS2Ig1cbiBBcxYzgzUDNLCvL8GbZXNp6ORy3LmS+Kk83zRIAK6A1ioKa2I9NapIuiUFdfC9766PFZUtqUr6KbWk+zZU1a/ZrIXEztrjTOfz7hwKziCeXIaraHtbZIMz+2pGgazCmw4qWAFvEdhodYp0Xq0pV7G1YWYWbO4qhGq42+Z8BYtrLWvluNPpZAeaFFS1vubPgbgxsqcpnAaszBovKaFoDQ8BGtjfUOl4NAG2nmQV04feJgumvX2fsrQEWZghL0JnVdYkn3DOZIeRN86RqPWCmsvGVqEMRnwxQAxwS8EMYo3IzmY2+BCcLp4MKiuyuhImamlbZFcNoNl7tp+RHd18ZjQIRKyXdFRhN98/hyKqwXWNo7O1wiaXoHN108REZZWEq6grnIfjzeg8jdRf1XEL4kkXa5bBjKxoKaljBjeHlVxQ4GaycpW4lDOAKtnTxHAtOfzOtZwHAM7sqVXkV6yu6kap1nHkXKqWF/4XHqjenNKqBjpR3l1ch3Ejg1+EsgdQhsdG0B4FM9sWAVWpuAyiwTPleZxt9VyZVS2qXfReWqTAilpr9ApoWTjxymit7NwV4JTriZyOA9B0k7HFfULourmKYHVnRQvqGL5HMHdqFcR2qWpmcK6eTwx2dipWrviDilr+fKWq3OWRWdHKwA4eu8wjchbeRzFilqjjZN3ufCpfkJ0/scVpnYk6L0PI77lxdWCZ87WiWm7B/AGquQSnujGKsB8CJmiJq8q1pKIVWyqOiTK66r18BN8r74/AE71fdC3yPS2MxdOpnE1tlVxD9JmVOoggN+r4PjAXVFPa3Eg5jVJGFVUGNolH20GVrUB7BOySWq6WqYQdWR92pcFMYMwckbSgCKCqD67DiiWu1g8MQC9ByfcFqW1L+jL714qNCuznoSxt0da2gtWN1G8F0BK0NN0nuimelUF9dIdAfjO44UT3CjQLoUeLHJFTO3gmpRuIIOvwBQCbqNeo3qtZ9iF6xVK13GRlo4zqimq+CGdTiR1uRY8oqgE02hZBa79kZXPMquxRHKla2saZWN4mRqZUj0vLCKhkjKnqOQHNuSZVJoKvAqS1wpEquvWDC1B2ypwrCPsRMEPVTODMLJMDv6qeKXwi2JYV5Sq4qKyvgGsHCLiuj2jR59V8gMqSJ2FJZRXEHVRHj3sFPrct6OpqlW1GpatQdt0GvwfM6n63InsGVFhJGaBqgqqIV6IsXllZgySPq4R3bnt3wi5cv+cN2yqQLW1T95KYVsWWtKk4cB9W53WQQflQYR6Wl4HaJZjvVE0D5yvq+RKgZCs5qdBEP5sD94cAvQLlSgNaSMAtHx88BuNQ41zdFsX30zKbcs0MLD/ihkpQzl0wiTqKLTfbKmCmyYICnK0IbaieC4CG9iSyLQ7cIMGQwau6TKoq60Apl3WN40LZpca1CKKK9VQyyIEn8w0F8F6CL2h8o3ixGwC7s7EWzCOqmcApYxYD4jsAzVS0sl2t98pA7vrKophCVSonbYpgH6mvSn24pTBV4sdtV3BtMq5k82y+IADvUJ0uAlkCVTxIaPm+UNu/qkV4F1TzHXCGrXIAqItBKypqK99VtAOVs64O4ObX7pHLVCpYHcRmwvLR7TvYAKBBN58LGVzDuFz+hQbWgncQyCZAk+VbsPSouf93261iZgmfCpwRbAvqmSqriU2PwhjaoOyYqtIegVXViTsmyta6bGySpY3gyRrpIyAeaWDDxtpsXwKyalMDKNP7YBXMqEskUsi2uC8FNAPxAKTVfT1o6VzM0E0jF+1rWcUuHvdyg7vgoFplX8HpvHpMCOMRUPHzZkInsqlFKNX/EIO52E0SxSzOwob2VmRLW5D1XIU0rbgM1AzWgyC7fe8G7xUAK/taEBat7luqtyP7EmsaJQOj5F+mrnZfCuYCfBUAWwShyd6pMY/vAHG1UqOYpbI/gy5T0CMKm+UO3gFuC85dgfDVeguPDfITrIBLsLrcgdh3CFgFZjaKJ4Iv3F8ANEqvuxR1tVKOgLoCa1jxboBAkj6v7j/icFbA7f4rfRnQDLRViG13i0vqBQrYVqBbADZT0ZpiHoSzvQpopKIFS3sE1HfBWlHXd0H7LnArqvougMtljHBgZnh3Eoz/BKjLML4Z2Aq0+hEJr9jaVUBbvNzCIUiroC7AWmmFw4o5AK3MtB5VypZMSFgs05JyGVwlwBqsEGAAa2ZU1CjUexXGsE4rKriilBvFzOKKo3AuAroE6QFQU3u8YpNXwS5k+1TZt5UrwouN4KiUEw+k3ZWDp1RXHNRqXb21Ts39945yZSg3VnZFNQ9CF3XeZyr5DgBXKiwCMa2MxeTDYXgP1Fsf9QNKZc0k81RJk3r6EQ3rCmBVyLL75EjZ1pIVDHoFtiOAHoB0BdTVylqBsKKKS+AeBXJVLY+CXASuGvO/Auq7GuEjDfGKg1oKa1z/dmmi9I9SUGNhl0AtfulHAawoYrnSkmNXAVuGEhrEVXvUF+A5Ct2PqNOjDetyna4CmeUolmeXLN4Aq7C5Sj10Q7yjgl+t6CNxSRHmI5X+CpwreYB3Qfdqna4q21KdBuc4GoZsn49ZOOiVinwHqK9WzjvgeweEh2AU5+vtxZ9Cd9Wqkh49V18E5oj6vVyn0RStAyGIO5edXRKd5B0VGVXq2yr3xYp+5Ut+C4QJ4P1N339pQMjRejj4vb/Dcr6rQc3O/0rjmtZpeYCBiCHfCemRbNhbK/pNUPc3wfKy5f2D7OlL3/uPhve/oU4T0F8f+VNM2vyoiv0jK+KHQfdHq+0bncz4oz73/+Y6LbKw1o/5B7eOf1Rl/0du9B9tn/9bvrf/j+v0h6ttn2tp/r/4819y4/zv5391uvzzfwDifz6phT1MPgAAAABJRU5ErkJggg==)}.color-picker .cp-add-color-button-class{position:absolute;display:inline;padding:0;margin:3px -3px;border:0;cursor:pointer;background:transparent}.color-picker .cp-add-color-button-class:hover{text-decoration:underline}.color-picker .cp-add-color-button-class:disabled{cursor:not-allowed;color:#999}.color-picker .cp-add-color-button-class:disabled:hover{text-decoration:none}.color-picker .cp-remove-color-button-class{position:absolute;top:-5px;right:-5px;display:block;width:10px;height:10px;border-radius:50%;cursor:pointer;text-align:center;background:#fff;box-shadow:1px 1px 5px #333}.color-picker .cp-remove-color-button-class:before{content:"x";position:relative;bottom:3.5px;display:inline-block;font-size:10px}.color-picker .eyedropper-icon{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);fill:#fff;mix-blend-mode:exclusion}\n'],encapsulation:2}),t})(),EY=(()=>{class t{constructor(e,r,s,o,i,a){this.injector=e,this.cfr=r,this.appRef=s,this.vcRef=o,this.elRef=i,this._service=a,this.dialogCreated=!1,this.ignoreChanges=!1,this.viewAttachedToAppRef=!1,this.cpWidth="230px",this.cpHeight="auto",this.cpToggle=!1,this.cpDisabled=!1,this.cpIgnoredElements=[],this.cpFallbackColor="",this.cpColorMode="color",this.cpCmykEnabled=!1,this.cpOutputFormat="auto",this.cpAlphaChannel="enabled",this.cpDisableInput=!1,this.cpDialogDisplay="popup",this.cpSaveClickOutside=!0,this.cpCloseClickOutside=!0,this.cpUseRootViewContainer=!1,this.cpPosition="auto",this.cpPositionOffset="0%",this.cpPositionRelativeToArrow=!1,this.cpOKButton=!1,this.cpOKButtonText="OK",this.cpOKButtonClass="cp-ok-button-class",this.cpCancelButton=!1,this.cpCancelButtonText="Cancel",this.cpCancelButtonClass="cp-cancel-button-class",this.cpEyeDropper=!1,this.cpPresetLabel="Preset colors",this.cpPresetColorsClass="cp-preset-colors-class",this.cpMaxPresetColorsLength=6,this.cpPresetEmptyMessage="No colors added",this.cpPresetEmptyMessageClass="preset-empty-message",this.cpAddColorButton=!1,this.cpAddColorButtonText="Add color",this.cpAddColorButtonClass="cp-add-color-button-class",this.cpRemoveColorButtonClass="cp-remove-color-button-class",this.cpArrowPosition=0,this.cpInputChange=new nn(!0),this.cpToggleChange=new nn(!0),this.cpSliderChange=new nn(!0),this.cpSliderDragEnd=new nn(!0),this.cpSliderDragStart=new nn(!0),this.colorPickerOpen=new nn(!0),this.colorPickerClose=new nn(!0),this.colorPickerCancel=new nn(!0),this.colorPickerSelect=new nn(!0),this.colorPickerChange=new nn(!1),this.cpCmykColorChange=new nn(!0),this.cpPresetColorsChange=new nn(!0)}handleClick(){this.inputFocus()}handleFocus(){this.inputFocus()}handleInput(e){this.inputChange(e)}ngOnDestroy(){null!=this.cmpRef&&(this.viewAttachedToAppRef&&this.appRef.detachView(this.cmpRef.hostView),this.cmpRef.destroy(),this.cmpRef=null,this.dialog=null)}ngOnChanges(e){e.cpToggle&&!this.cpDisabled&&(e.cpToggle.currentValue?this.openDialog():e.cpToggle.currentValue||this.closeDialog()),e.colorPicker&&(this.dialog&&!this.ignoreChanges&&("inline"===this.cpDialogDisplay&&this.dialog.setInitialColor(e.colorPicker.currentValue),this.dialog.setColorFromString(e.colorPicker.currentValue,!1),this.cpUseRootViewContainer&&"inline"!==this.cpDialogDisplay&&this.cmpRef.changeDetectorRef.detectChanges()),this.ignoreChanges=!1),(e.cpPresetLabel||e.cpPresetColors)&&this.dialog&&this.dialog.setPresetConfig(this.cpPresetLabel,this.cpPresetColors)}openDialog(){if(this.dialogCreated)this.dialog&&this.dialog.openDialog(this.colorPicker);else{let e=this.vcRef;if(this.dialogCreated=!0,this.viewAttachedToAppRef=!1,this.cpUseRootViewContainer&&"inline"!==this.cpDialogDisplay){const o=this.injector.get(this.appRef.componentTypes[0],Ds.NULL);o!==Ds.NULL?e=o.vcRef||o.viewContainerRef||this.vcRef:this.viewAttachedToAppRef=!0}const r=this.cfr.resolveComponentFactory(TY);if(this.viewAttachedToAppRef)this.cmpRef=r.create(this.injector),this.appRef.attachView(this.cmpRef.hostView),document.body.appendChild(this.cmpRef.hostView.rootNodes[0]);else{const s=Ds.create({providers:[],parent:e.injector});this.cmpRef=e.createComponent(r,0,s,[])}this.cmpRef.instance.setupDialog(this,this.elRef,this.colorPicker,this.cpWidth,this.cpHeight,this.cpDialogDisplay,this.cpFallbackColor,this.cpColorMode,this.cpCmykEnabled,this.cpAlphaChannel,this.cpOutputFormat,this.cpDisableInput,this.cpIgnoredElements,this.cpSaveClickOutside,this.cpCloseClickOutside,this.cpUseRootViewContainer,this.cpPosition,this.cpPositionOffset,this.cpPositionRelativeToArrow,this.cpPresetLabel,this.cpPresetColors,this.cpPresetColorsClass,this.cpMaxPresetColorsLength,this.cpPresetEmptyMessage,this.cpPresetEmptyMessageClass,this.cpOKButton,this.cpOKButtonClass,this.cpOKButtonText,this.cpCancelButton,this.cpCancelButtonClass,this.cpCancelButtonText,this.cpAddColorButton,this.cpAddColorButtonClass,this.cpAddColorButtonText,this.cpRemoveColorButtonClass,this.cpEyeDropper,this.elRef,this.cpExtraTemplate),this.dialog=this.cmpRef.instance,this.vcRef!==e&&this.cmpRef.changeDetectorRef.detectChanges()}}closeDialog(){this.dialog&&"popup"===this.cpDialogDisplay&&this.dialog.closeDialog()}cmykChanged(e){this.cpCmykColorChange.emit(e)}stateChanged(e){this.cpToggleChange.emit(e),e?this.colorPickerOpen.emit(this.colorPicker):this.colorPickerClose.emit(this.colorPicker)}colorChanged(e,r=!0){this.ignoreChanges=r,this.colorPickerChange.emit(e)}colorSelected(e){this.colorPickerSelect.emit(e)}colorCanceled(){this.colorPickerCancel.emit()}inputFocus(){const e=this.elRef.nativeElement,r=this.cpIgnoredElements.filter(s=>s===e);!this.cpDisabled&&!r.length&&(typeof document<"u"&&e===document.activeElement?this.openDialog():this.dialog&&this.dialog.show?this.closeDialog():this.openDialog())}inputChange(e){this.dialog?this.dialog.setColorFromString(e.target.value,!0):(this.colorPicker=e.target.value,this.colorPickerChange.emit(this.colorPicker))}inputChanged(e){this.cpInputChange.emit(e)}sliderChanged(e){this.cpSliderChange.emit(e)}sliderDragEnd(e){this.cpSliderDragEnd.emit(e)}sliderDragStart(e){this.cpSliderDragStart.emit(e)}presetColorsChanged(e){this.cpPresetColorsChange.emit(e)}}return t.\u0275fac=function(e){return new(e||t)(Pe(Ds),Pe(Uu),Pe(eh),Pe(Do),Pe(us),Pe(R_))},t.\u0275dir=Pt({type:t,selectors:[["","colorPicker",""]],hostBindings:function(e,r){1&e&&at("click",function(){return r.handleClick()})("focus",function(){return r.handleFocus()})("input",function(o){return r.handleInput(o)})},inputs:{colorPicker:"colorPicker",cpWidth:"cpWidth",cpHeight:"cpHeight",cpToggle:"cpToggle",cpDisabled:"cpDisabled",cpIgnoredElements:"cpIgnoredElements",cpFallbackColor:"cpFallbackColor",cpColorMode:"cpColorMode",cpCmykEnabled:"cpCmykEnabled",cpOutputFormat:"cpOutputFormat",cpAlphaChannel:"cpAlphaChannel",cpDisableInput:"cpDisableInput",cpDialogDisplay:"cpDialogDisplay",cpSaveClickOutside:"cpSaveClickOutside",cpCloseClickOutside:"cpCloseClickOutside",cpUseRootViewContainer:"cpUseRootViewContainer",cpPosition:"cpPosition",cpPositionOffset:"cpPositionOffset",cpPositionRelativeToArrow:"cpPositionRelativeToArrow",cpOKButton:"cpOKButton",cpOKButtonText:"cpOKButtonText",cpOKButtonClass:"cpOKButtonClass",cpCancelButton:"cpCancelButton",cpCancelButtonText:"cpCancelButtonText",cpCancelButtonClass:"cpCancelButtonClass",cpEyeDropper:"cpEyeDropper",cpPresetLabel:"cpPresetLabel",cpPresetColors:"cpPresetColors",cpPresetColorsClass:"cpPresetColorsClass",cpMaxPresetColorsLength:"cpMaxPresetColorsLength",cpPresetEmptyMessage:"cpPresetEmptyMessage",cpPresetEmptyMessageClass:"cpPresetEmptyMessageClass",cpAddColorButton:"cpAddColorButton",cpAddColorButtonText:"cpAddColorButtonText",cpAddColorButtonClass:"cpAddColorButtonClass",cpRemoveColorButtonClass:"cpRemoveColorButtonClass",cpArrowPosition:"cpArrowPosition",cpExtraTemplate:"cpExtraTemplate"},outputs:{cpInputChange:"cpInputChange",cpToggleChange:"cpToggleChange",cpSliderChange:"cpSliderChange",cpSliderDragEnd:"cpSliderDragEnd",cpSliderDragStart:"cpSliderDragStart",colorPickerOpen:"colorPickerOpen",colorPickerClose:"colorPickerClose",colorPickerCancel:"colorPickerCancel",colorPickerSelect:"colorPickerSelect",colorPickerChange:"colorPickerChange",cpCmykColorChange:"cpCmykColorChange",cpPresetColorsChange:"cpPresetColorsChange"},exportAs:["ngxColorPicker"],features:[eo]}),t})(),NY=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=wo({type:t}),t.\u0275inj=Zs({providers:[R_],imports:[C2]}),t})();function _O(t,n,e,r,s,o,i){try{var a=t[o](i),l=a.value}catch(u){return void e(u)}a.done?n(l):Promise.resolve(l).then(r,s)}function $e(t){return function(){var n=this,e=arguments;return new Promise(function(r,s){var o=t.apply(n,e);function i(l){_O(o,r,s,i,a,"next",l)}function a(l){_O(o,r,s,i,a,"throw",l)}i(void 0)})}}class CO{constructor(n,e){this.backend=n,this.dataMover=e,this.data=new WeakMap,this.dataIdsCount=0}get(n){return this.data.has(n)||this.dataMover.moveData(this.backend,n),this.data.get(n)}set(n,e){this.dataIdsCount++,this.data.set(n,e)}has(n){return this.data.has(n)}delete(n){return this.dataIdsCount--,this.data.delete(n)}numDataIds(){return this.dataIdsCount}}class F_{refCount(n){return Us("refCount")}incRef(n){return Us("incRef")}timerAvailable(){return!0}time(n){return Us("time")}read(n){return Us("read")}readSync(n){return Us("readSync")}readToGPU(n,e){return Us("readToGPU")}numDataIds(){return Us("numDataIds")}disposeData(n,e){return Us("disposeData")}write(n,e,r){return Us("write")}move(n,e,r,s,o){return Us("move")}createTensorFromGPUData(n,e,r){return Us("createTensorFromGPUData")}memory(){return Us("memory")}floatPrecision(){return Us("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return Us("dispose")}}function Us(t){throw new Error(`'${t}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function SO(t){let n=t.length,e=0;for(;n>0;)e=Math.random()*n|0,n--,$a(t,n,e)}function Ul(t,n,e){return Math.max(t,Math.min(n,e))}function O_(t){return t%2==0?t:t+1}function $a(t,n,e){const r=t[n];t[n]=t[e],t[e]=r}function R(t,n){if(!t)throw new Error("string"==typeof n?n:n())}function No(t,n,e=""){R(gn(t,n),()=>e+` Shapes ${t} and ${n} must match`)}function P_(t){R(null!=t,()=>"The input to the tensor constructor must be a non-null value.")}function _e(t){if(0===t.length)return 1;let n=t[0];for(let e=1;e<t.length;e++)n*=t[e];return n}function gn(t,n){if(t===n)return!0;if(null==t||null==n||t.length!==n.length)return!1;for(let e=0;e<t.length;e++)if(t[e]!==n[e])return!1;return!0}function _c(t){return t%1==0}function M_(t){const n=Math.ceil(Math.sqrt(t));return[n,Math.ceil(t/n)]}function Cc(t,n){return n<=t.length?t:t+" ".repeat(n-t.length)}function IO(t,n=(s=>0),e,r){return new Promise((s,o)=>{let i=0;const a=()=>{if(t())return void s();i++;const l=n(i);null!=e&&i>=e?o():null!=r?r(a,l):setTimeout(a,l)};a()})}function DO(t,n){let e=1,r=-1;for(let o=0;o<t.length;++o)if(t[o]>=0)e*=t[o];else if(-1===t[o]){if(-1!==r)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${o}`);r=o}else if(t[o]<0)throw Error(`Shapes can not be < 0. Found ${t[o]} at dim ${o}`);if(-1===r){if(n>0&&n!==e)throw Error(`Size(${n}) must match the product of shape ${t}`);return t}if(0===e)throw Error(`Cannot infer the missing size in [${t}] when there are 0 elements`);if(n%e!=0)throw Error(`The implicit shape can't be a fractional number. Got ${n} / ${e}`);const s=t.slice();return s[r]=n/e,s}function Jt(t,n){const e=n.length;return R((t=null==t?n.map((r,s)=>s):[].concat(t)).every(r=>r>=-e&&r<e),()=>`All values in axis param must be in range [-${e}, ${e}) but got axis ${t}`),R(t.every(r=>_c(r)),()=>`All values in axis param must be integers but got axis ${t}`),t.map(r=>r<0?e+r:r)}function La(t,n){const e=[],r=[],s=null!=n&&Array.isArray(n)&&0===n.length,o=null==n||s?null:Jt(n,t).sort();let i=0;for(let a=0;a<t.length;++a){if(null!=o){if(o[i]===a&&1!==t[a])throw new Error(`Can't squeeze axis ${a} since its dim '${t[a]}' is not 1`);(null==o[i]||o[i]>a)&&1===t[a]&&(e.push(t[a]),r.push(a)),o[i]<=a&&i++}1!==t[a]&&(e.push(t[a]),r.push(a))}return{newShape:e,keptDims:r}}function ts(t,n){return cr(t,n)}function cr(t,n){let e=null;if(null==t||"float32"===t)e=new Float32Array(n);else if("int32"===t)e=new Int32Array(n);else if("bool"===t)e=new Uint8Array(n);else{if("string"!==t)throw new Error(`Unknown data type ${t}`);e=new Array(n)}return e}function TO(t,n){return!("complex64"===n||"float32"===n&&"complex64"!==t||"int32"===n&&"float32"!==t&&"complex64"!==t||"bool"===n&&"bool"===t)}function Lg(t){if("float32"===t||"int32"===t)return 4;if("complex64"===t)return 8;if("bool"===t)return 1;throw new Error(`Unknown dtype ${t}`)}function Oh(t){return"string"==typeof t||t instanceof String}function $_(t){return"number"==typeof t}function Sc(t){return Array.isArray(t)?Sc(t[0]):t instanceof Float32Array?"float32":t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray?"int32":$_(t)?"float32":Oh(t)?"string":function $Y(t){return"boolean"==typeof t}(t)?"bool":"float32"}function L_(t){return!!(t&&t.constructor&&t.call&&t.apply)}function V_(t,n){for(let e=n;e<t;++e)if(t%e==0)return e;return t}function xt(t){const n=t.length;if(n<2)return[];const e=new Array(n-1);e[n-2]=t[n-1];for(let r=n-3;r>=0;--r)e[r]=e[r+1]*t[r+1];return e}function kO(t,n,e,r=!1){const s=new Array;if(1===n.length){const o=n[0]*(r?2:1);for(let i=0;i<o;i++)s[i]=e[t+i]}else{const o=n[0],i=n.slice(1),a=i.reduce((l,u)=>l*u)*(r?2:1);for(let l=0;l<o;l++)s[l]=kO(t+l*a,i,e,r)}return s}function Qo(t,n,e=!1){if(0===t.length)return n[0];const r=t.reduce((s,o)=>s*o)*(e?2:1);if(0===r)return[];if(r!==n.length)throw new Error(`[${t}] does not match the input size ${n.length}${e?" for a complex tensor":""}.`);return kO(0,t,n,e)}function B_(t,n){const e=ns(t,n);for(let r=0;r<e.length;r++)e[r]=1;return e}function ns(t,n){if(null==n||"float32"===n||"complex64"===n)return new Float32Array(t);if("int32"===n)return new Int32Array(t);if("bool"===n)return new Uint8Array(t);throw new Error(`Unknown data type ${n}`)}function EO(t,n){const e=t.reduce((r,s)=>r*s,1);if(null==n||"float32"===n)return Qo(t,new Float32Array(e));if("int32"===n)return Qo(t,new Int32Array(e));if("bool"===n)return Qo(t,new Uint8Array(e));throw new Error(`Unknown data type ${n}`)}function la(t){t.forEach(n=>{R(Number.isInteger(n)&&n>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${t}].`)})}function Di(t,n,e){if(0===n)return 0;if(1===n)return t[0];let r=t[t.length-1];for(let s=0;s<t.length-1;++s)r+=e[s]*t[s];return r}function Ic(t,n,e){if(0===n)return[];if(1===n)return[t];const r=new Array(n);for(let s=0;s<r.length-1;++s)r[s]=Math.floor(t/e[s]),t-=r[s]*e[s];return r[r.length-1]=t,r}function z_(t){return t&&t.then&&"function"==typeof t.then}const NO="tfjsflags";class VY{constructor(n){this.global=n,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=BY,this.populateURLFlags()}setPlatform(n,e){null!=this.platform&&(pe().getBool("IS_TEST")||pe().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${n}.`)),this.platformName=n,this.platform=e}registerFlag(n,e,r){if(this.flagRegistry[n]={evaluationFn:e,setHook:r},null!=this.urlFlags[n]){const s=this.urlFlags[n];pe().getBool("IS_TEST")||pe().getBool("PROD")||console.warn(`Setting feature override from URL ${n}: ${s}.`),this.set(n,s)}}getAsync(n){var e=this;return $e(function*(){return n in e.flags||(e.flags[n]=yield e.evaluateFlag(n)),e.flags[n]})()}get(n){if(n in this.flags)return this.flags[n];const e=this.evaluateFlag(n);if(z_(e))throw new Error(`Flag ${n} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[n]=e,this.flags[n]}getNumber(n){return this.get(n)}getBool(n){return this.get(n)}getFlags(){return this.flags}get features(){return this.flags}set(n,e){if(null==this.flagRegistry[n])throw new Error(`Cannot set flag ${n} as it has not been registered.`);this.flags[n]=e,null!=this.flagRegistry[n].setHook&&this.flagRegistry[n].setHook(e)}evaluateFlag(n){if(null==this.flagRegistry[n])throw new Error(`Cannot evaluate flag '${n}': no evaluation function found.`);return this.flagRegistry[n].evaluationFn()}setFlags(n){this.flags=Object.assign({},n)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const n=this.getQueryParams(this.global.location.search);NO in n&&n[NO].split(",").forEach(r=>{const[s,o]=r.split(":");this.urlFlags[s]=function UY(t,n){if("true"===(n=n.toLowerCase())||"false"===n)return"true"===n;if(""+ +n===n)return+n;throw new Error(`Could not parse value flag value ${n} for flag ${t}.`)}(s,o)})}}function BY(t){const n={};return t.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(e,...r)=>(function zY(t,n,e){t[decodeURIComponent(n)]=decodeURIComponent(e||"")}(n,r[0],r[1]),r.join("="))),n}function pe(){return AO}let U_,AO=null;function RO(){if(null==U_){let t;if(typeof window<"u")t=window;else if(typeof global<"u")t=global;else if(typeof process<"u")t=process;else{if(!(typeof self<"u"))throw new Error("Could not find a global object");t=self}U_=t}return U_}function W_(t,n){const e=function GY(){const t=RO();return null==t._tfGlobals&&(t._tfGlobals=new Map),t._tfGlobals}();if(e.has(t))return e.get(t);{const r=n();return e.set(t,r),e.get(t)}}const Vg="Abs",Ph="Acos",Mh="Acosh",Dc="Add",G_="AddN",Bg="ArgMax",zg="ArgMin",$h="Asin",Lh="Asinh",Vh="Atan",Bh="Atanh",zh="Atan2",Ug="AvgPool",q_="AvgPoolGrad",Wg="AvgPool3D",K_="AvgPool3DGrad",Gg="BatchMatMul",Hg="BatchToSpaceND",X_="Bincount",FO="BroadcastArgs",Uh="Cast",Wh="Ceil",Gh="ClipByValue",Y_="Complex",jg="ComplexAbs",qg="Concat",Kg="Conv2D",Z_="Conv2DBackpropFilter",Xg="Conv2DBackpropInput",Yg="Conv3D",Q_="Conv3DBackpropFilterV2",J_="Conv3DBackpropInputV2",Hh="Cos",jh="Cosh",eC="Cumprod",Zg="Cumsum",tC="CropAndResize",nC="DenseBincount",rC="DepthToSpace",Qg="DepthwiseConv2dNative",sC="DepthwiseConv2dNativeBackpropFilter",oC="DepthwiseConv2dNativeBackpropInput",Jg="Dilation2D",iC="Dilation2DBackpropInput",aC="Dilation2DBackpropFilter",qh="RealDiv",Kh="Elu",lC="EluGrad",Xh="Erf",ey="Equal",Yh="Exp",ty="ExpandDims",Zh="Expm1",cC="Fill",dC="FlipLeftRight",Qh="Floor",Jh="FloorDiv",ny="FusedBatchNorm",ry="GatherV2",MO="GatherNd",sy="Greater",ep="GreaterEqual",tp="Identity",hC="IFFT",pC="Imag",np="IsFinite",rp="IsInf",sp="IsNan",oy="LeakyRelu",iy="Less",ay="LessEqual",$O="LinSpace",op="Log",ip="Log1p",ly="LogicalAnd",uy="LogicalNot",cy="LogicalOr",dy="LRN",fC="LRNGrad",hy="Max",ap="Maximum",py="MaxPool",mC="MaxPoolGrad",fy="MaxPool3D",gC="MaxPool3DGrad",LO="MaxPoolWithArgmax",my="Mean",gy="Min",lp="Minimum",yy="MirrorPad",up="Mod",VO="Multinomial",cp="Multiply",vy="Neg",by="NotEqual",yC="NonMaxSuppressionV3",vC="NonMaxSuppressionV4",bC="NonMaxSuppressionV5",xy="OnesLike",wy="OneHot",_y="Pack",Cy="PadV2",dp="Pow",Sy="Prelu",Iy="Prod",BO="RaggedGather",zO="RaggedRange",UO="RaggedTensorToTensor",xC="Range",wC="Real",hp="Reciprocal",pp="Relu",Dy="Reshape",Ty="ResizeNearestNeighbor",_C="ResizeNearestNeighborGrad",ky="ResizeBilinear",CC="ResizeBilinearGrad",fp="Relu6",Ey="Reverse",mp="Round",gp="Rsqrt",WO="ScatterNd",GO="TensorScatterUpdate",HO="SearchSorted",Ny="Select",yp="Selu",Ay="Slice",vp="Sin",bp="Sinh",xp="Sign",wp="Sigmoid",_p="Softplus",Cp="Sqrt",Ry="Sum",Fy="SpaceToBatchND",Oy="SplitV",Py="Softmax",SC="SparseFillEmptyRows",IC="SparseReshape",DC="SparseSegmentMean",TC="SparseSegmentSum",jO="SparseToDense",Sp="SquaredDifference",kC="Square",My="StaticRegexReplace",EC="StridedSlice",NC="StringNGrams",AC="StringSplit",RC="StringToHashBucketFast",Ip="Sub",Dp="Tan",Tp="Tanh",kp="Tile",FC="TopK",OC="Transform",Tc="Transpose",PC="Unique",$y="Unpack",Ly="UnsortedSegmentSum",Vy="ZerosLike",Ep="Step",MC="FromPixels",$C="RotateWithOffset",By="_FusedMatMul",zy="FusedConv2D",Uy="FusedDepthwiseConv2D";function lo(...t){pe().getBool("IS_TEST")||pe().getBool("PROD")||console.warn(...t)}function qY(...t){pe().getBool("IS_TEST")||pe().getBool("PROD")||console.log(...t)}const kc=W_("kernelRegistry",()=>new Map),Np=W_("gradRegistry",()=>new Map);function LC(t,n){const e=zC(t,n);return kc.get(e)}function qO(t){return Np.get(t)}function VC(t){const n=kc.entries(),e=[];for(;;){const{done:r,value:s}=n.next();if(r)break;const[o,i]=s,[a]=o.split("_");a===t&&e.push(i)}return e}function BC(t){const{kernelName:n,backendName:e}=t,r=zC(n,e);kc.has(r)&&lo(`The kernel '${n}' for backend '${e}' is already registered`),kc.set(r,t)}function KY(t){const{kernelName:n}=t;Np.has(n)&&pe().getBool("DEBUG")&&lo(`Overriding the gradient for '${n}'`),Np.set(n,t)}function zC(t,n){return`${n}_${t}`}var KO=ne(658);const Wl=ne.n(KO)()||KO;function Wy(t){return Wl.fromString(t,!0,16)}const XO=Wy("c3a5c85c97cb3127"),Gl=Wy("b492b66fbe98f273"),ps=Wy("9ae16a3b2f90404f");function UC(t){return t.xor(t.shru(47))}function YO(t,n,e){const r=t.slice(n,n+e);return Wl.fromBytes(Array.from(r),!0,!0)}function On(t,n){return YO(t,n,8)}function ZO(t,n){return YO(t,n,4)}function Or(t,n){return 0===n?t:t.shru(n).or(t.shl(64-n))}function Va(t,n,e=Wy("9ddfea08eb382d69")){let r=t.xor(n).mul(e);r=r.xor(r.shru(47));let s=n.xor(r).mul(e);return s=s.xor(s.shru(47)),s=s.mul(e),s}function Gy(t,n,e,r){return function YY(t,n,e,r,s,o){s=s.add(t),o=Or(o.add(s).add(r),21);const i=s;return s=(s=s.add(n)).add(e),o=o.add(Or(s,44)),[s.add(r),o.add(i)]}(On(t,n),On(t,n+8),On(t,n+16),On(t,n+24),e,r)}function eZ(t,n=t.length){const e=Wl.fromNumber(81,!0);if(n<=32)return n<=16?function ZY(t,n=t.length){if(n>=8){const e=ps.add(2*n),r=On(t,0).add(ps),s=On(t,n-8);return Va(Or(s,37).mul(e).add(r),Or(r,25).add(s).mul(e),e)}if(n>=4){const e=ps.add(2*n);return Va(ZO(t,0).shl(3).add(n),ZO(t,n-4),e)}if(n>0){const i=n+(t[n-1]<<2);return UC(ps.mul(t[0]+(t[n>>1]<<8)).xor(XO.mul(i))).mul(ps)}return ps}(t,n):function QY(t,n=t.length){const e=ps.add(2*n),r=On(t,0).mul(Gl),s=On(t,8),o=On(t,n-8).mul(e),i=On(t,n-16).mul(ps);return Va(Or(r.add(s),43).add(Or(o,30)).add(i),r.add(Or(s.add(ps),18)).add(o),e)}(t,n);if(n<=64)return function JY(t,n=t.length){const e=ps.add(2*n),r=On(t,0).mul(ps),s=On(t,8),o=On(t,n-8).mul(e),i=On(t,n-16).mul(ps),a=Or(r.add(s),43).add(Or(o,30)).add(i),l=Va(a,r.add(Or(s.add(ps),18)).add(o),e),u=On(t,16).mul(e),c=On(t,24),d=a.add(On(t,n-32)).mul(e),h=l.add(On(t,n-24)).mul(e);return Va(Or(u.add(c),43).add(Or(d,30)).add(h),u.add(Or(c.add(r),18)).add(d),e)}(t,n);let r=e,s=e.mul(Gl).add(113),o=UC(s.mul(ps).add(113)).mul(ps),i=[Wl.UZERO,Wl.UZERO],a=[Wl.UZERO,Wl.UZERO];r=r.mul(ps).add(On(t,0));let l=0;const u=64*(n-1>>6),c=u+(n-1&63)-63;do{r=Or(r.add(s).add(i[0]).add(On(t,l+8)),37).mul(Gl),s=Or(s.add(i[1]).add(On(t,l+48)),42).mul(Gl),r=r.xor(a[1]),s=s.add(i[0]).add(On(t,l+40)),o=Or(o.add(a[0]),33).mul(Gl),i=Gy(t,l,i[1].mul(Gl),r.add(a[0])),a=Gy(t,l+32,o.add(a[1]),s.add(On(t,l+16))),[o,r]=[r,o],l+=64}while(l!==u);const d=Gl.add(o.and(255).shl(1));return l=c,a[0]=a[0].add(n-1&63),i[0]=i[0].add(a[0]),a[0]=a[0].add(i[0]),r=Or(r.add(s).add(i[0]).add(On(t,l+8)),37).mul(d),s=Or(s.add(i[1]).add(On(t,l+48)),42).mul(d),r=r.xor(a[1].mul(9)),s=s.add(i[0].mul(9).add(On(t,l+40))),o=Or(o.add(a[0]),33).mul(d),i=Gy(t,l,i[1].mul(d),r.add(a[0])),a=Gy(t,l+32,o.add(a[1]),s.add(On(t,l+16))),[o,r]=[r,o],Va(Va(i[0],a[0],d).add(UC(s).mul(XO)).add(o),Va(i[1],a[1],d).add(r),d)}function Ba(t,n){return"string"===n?za(t):Hl([t],n)}function Hl(t,n){if("string"===n)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(t)&&(t=jl(t)),pe().getBool("DEBUG")&&function OY(t,n){for(let e=0;e<t.length;e++){const r=t[e];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${n} being uploaded contains ${r}.`)}}(t,n),function tZ(t,n){return t instanceof Float32Array&&"float32"===n||t instanceof Int32Array&&"int32"===n||t instanceof Uint8Array&&"bool"===n}(t,n))return t;if(null==n||"float32"===n||"complex64"===n)return new Float32Array(t);if("int32"===n)return new Int32Array(t);if("bool"===n){const e=new Uint8Array(t.length);for(let r=0;r<e.length;++r)0!==Math.round(t[r])&&(e[r]=1);return e}throw new Error(`Unknown data type ${n}`)}function Rs(){return pe().platform.now()}function za(t,n="utf-8"){return n=n||"utf-8",pe().platform.encode(t,n)}function Ua(t,n="utf-8"){return n=n||"utf-8",pe().platform.decode(t,n)}function Jo(t){return pe().platform.isTypedArray(t)}function jl(t,n=[],e=!1){if(null==n&&(n=[]),"boolean"==typeof t||"number"==typeof t||"string"==typeof t||z_(t)||null==t||Jo(t)&&e)n.push(t);else if(Array.isArray(t)||Jo(t))for(let r=0;r<t.length;++r)jl(t[r],n,e);else{let r=-1;for(const s of Object.keys(t))/^([1-9]+[0-9]*|0)$/.test(s)&&(r=Math.max(r,Number(s)));for(let s=0;s<=r;s++)jl(t[s],n,e)}return n}class nZ{constructor(n,e){this.backendTimer=n,this.logger=e,null==e&&(this.logger=new sZ)}profileKernel(n,e,r){let s;const o=()=>{s=r()};let i;const a=Rs();if(this.backendTimer.timerAvailable())i=this.backendTimer.time(o);else{o();for(const u of s)u.dataSync();i=Promise.resolve({kernelMs:Rs()-a})}if(pe().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let u=0;u<s.length;u++){const c=s[u];c.data().then(d=>{rZ(d,c.dtype,n)})}return{kernelName:n,outputs:s,inputs:e,timeMs:i.then(u=>u.kernelMs),extraInfo:i.then(u=>null!=u.getExtraProfileInfo?u.getExtraProfileInfo():"")}}logKernelProfile(n){const{kernelName:e,outputs:r,timeMs:s,inputs:o,extraInfo:i}=n;r.forEach(a=>{Promise.all([a.data(),s,i]).then(l=>{this.logger.logKernelProfile(e,a,l[0],l[1],o,l[2])})})}}function rZ(t,n,e){if("float32"!==n)return!1;for(let r=0;r<t.length;r++){const s=t[r];if(isNaN(s)||!isFinite(s))return console.warn(`Found ${s} in the result of '${e}'`),!0}return!1}class sZ{logKernelProfile(n,e,r,s,o,i){const a="number"==typeof s?Cc(`${s}ms`,9):s.error,l=Cc(n,25),u=e.rank,c=e.size,d=Cc(e.shape.toString(),14);let h="";for(const p in o){const f=o[p];if(null!=f){const g=f.shape||e.shape,m=g.length;h+=`${p}: ${m}D ${m>0?g:""} `}}console.log(`%c${l}\t%c${a}\t%c${u}D ${d}\t%c${c}\t%c${h}\t%c${i}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}const QO=20,Ap=3,WC=7;function aZ(t,n,e,r){const s=xt(n),o=function lZ(t,n,e,r){const s=_e(n),o=r[r.length-1],i=new Array(o).fill(0),a=n.length,l="complex64"===e?Fp(t):t;if(a>1)for(let u=0;u<s/o;u++){const c=u*o;for(let d=0;d<o;d++)i[d]=Math.max(i[d],Rp(l[c+d],0,e).length)}return i}(t,n,e,s),i=n.length,a=Hy(t,n,e,s,o),l=["Tensor"];return r&&(l.push(`  dtype: ${e}`),l.push(`  rank: ${i}`),l.push(`  shape: [${n}]`),l.push("  values:")),l.push(a.map(u=>"    "+u).join("\n")),l.join("\n")}function Rp(t,n,e){let r;return r=Array.isArray(t)?`${parseFloat(t[0].toFixed(WC))} + ${parseFloat(t[1].toFixed(WC))}j`:Oh(t)?`'${t}'`:"bool"===e?JO(t):parseFloat(t.toFixed(WC)).toString(),Cc(r,n)}function JO(t){return 0===t?"false":"true"}function Hy(t,n,e,r,s,o=!0){const i="complex64"===e?2:1,a=n[0],l=n.length;if(0===l)return"complex64"===e?[Rp(Fp(t)[0],0,e)]:"bool"===e?[JO(t[0])]:[t[0].toString()];if(1===l){if(a>QO){let y=Array.from(t.slice(0,Ap*i)),v=Array.from(t.slice((a-Ap)*i,a*i));return"complex64"===e&&(y=Fp(y),v=Fp(v)),["["+y.map((b,x)=>Rp(b,s[x],e)).join(", ")+", ..., "+v.map((b,x)=>Rp(b,s[a-Ap+x],e)).join(", ")+"]"]}return["["+("complex64"===e?Fp(t):Array.from(t)).map((m,y)=>Rp(m,s[y],e)).join(", ")+"]"]}const u=n.slice(1),c=r.slice(1),d=r[0]*i,h=[];if(a>QO){for(let g=0;g<Ap;g++){const m=g*d;h.push(...Hy(t.slice(m,m+d),u,e,c,s,!1))}h.push("...");for(let g=a-Ap;g<a;g++){const m=g*d;h.push(...Hy(t.slice(m,m+d),u,e,c,s,g===a-1))}}else for(let g=0;g<a;g++){const m=g*d;h.push(...Hy(t.slice(m,m+d),u,e,c,s,g===a-1))}const p=2===l?",":"";h[0]="["+(a>0?h[0]+p:"");for(let g=1;g<h.length-1;g++)h[g]=" "+h[g]+p;let f=",\n";for(let g=2;g<l;g++)f+="\n";return h[h.length-1]=" "+h[h.length-1]+"]"+(o?"":f),h}function Fp(t){const n=[];for(let e=0;e<t.length;e+=2)n.push([t[e],t[e+1]]);return n}class Wr{constructor(n,e,r){if(this.dtype=e,this.shape=n.slice(),this.size=_e(n),null!=r){const s=r.length;R(s===this.size,()=>`Length of values '${s}' does not match the size inferred by the shape '${this.size}'.`)}if("complex64"===e)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=r||cr(e,this.size),this.strides=xt(n)}set(n,...e){0===e.length&&(e=[0]),R(e.length===this.rank,()=>`The number of provided coordinates (${e.length}) must match the rank (${this.rank})`);const r=this.locToIndex(e);this.values[r]=n}get(...n){0===n.length&&(n=[0]);let e=0;for(const s of n){if(s<0||s>=this.shape[e])throw new Error(`Requested out of range element at ${n}.   Buffer shape=${this.shape}`);e++}let r=n[n.length-1];for(let s=0;s<n.length-1;++s)r+=this.strides[s]*n[s];return this.values[r]}locToIndex(n){if(0===this.rank)return 0;if(1===this.rank)return n[0];let e=n[n.length-1];for(let r=0;r<n.length-1;++r)e+=this.strides[r]*n[r];return e}indexToLoc(n){if(0===this.rank)return[];if(1===this.rank)return[n];const e=new Array(this.shape.length);for(let r=0;r<e.length-1;++r)e[r]=Math.floor(n/this.strides[r]),n-=e[r]*this.strides[r];return e[e.length-1]=n,e}get rank(){return this.shape.length}toTensor(){return ei().makeTensor(this.values,this.shape,this.dtype)}}let ei=null,Ec=null,eP=null;class dr{constructor(n,e,r,s){this.kept=!1,this.isDisposedInternal=!1,this.shape=n.slice(),this.dtype=e||"float32",this.size=_e(n),this.strides=xt(n),this.dataId=r,this.id=s,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}buffer(){var n=this;return $e(function*(){const e=yield n.data();return Ec.buffer(n.shape,n.dtype,e)})()}bufferSync(){return Ec.buffer(this.shape,this.dtype,this.dataSync())}array(){var n=this;return $e(function*(){const e=yield n.data();return Qo(n.shape,e,"complex64"===n.dtype)})()}arraySync(){return Qo(this.shape,this.dataSync(),"complex64"===this.dtype)}data(){var n=this;return $e(function*(){n.throwIfDisposed();const e=ei().read(n.dataId);if("string"===n.dtype){const r=yield e;try{return r.map(s=>Ua(s))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e})()}dataToGPU(n){return this.throwIfDisposed(),ei().readToGPU(this.dataId,n)}dataSync(){this.throwIfDisposed();const n=ei().readSync(this.dataId);if("string"===this.dtype)try{return n.map(e=>Ua(e))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return n}bytes(){var n=this;return $e(function*(){n.throwIfDisposed();const e=yield ei().read(n.dataId);return"string"===n.dtype?e:new Uint8Array(e.buffer)})()}dispose(){this.isDisposed||(ei().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(n=!1){return Ec.print(this,n)}clone(){return this.throwIfDisposed(),Ec.clone(this)}toString(n=!1){return aZ(this.dataSync(),this.shape,this.dtype,n)}cast(n){return this.throwIfDisposed(),Ec.cast(this,n)}variable(n=!0,e,r){return this.throwIfDisposed(),ei().makeVariable(this,n,e,r)}}function Ce(){return W_("Tensor",()=>dr)}Object.defineProperty(dr,Symbol.hasInstance,{value:t=>!!t&&null!=t.data&&null!=t.dataSync&&null!=t.throwIfDisposed}),Ce();class jy extends dr{constructor(n,e,r,s){super(n.shape,n.dtype,n.dataId,s),this.trainable=e,this.name=r}assign(n){if(n.dtype!==this.dtype)throw new Error(`dtype of the new value (${n.dtype}) and previous value (${this.dtype}) must match`);if(!gn(n.shape,this.shape))throw new Error(`shape of the new value (${n.shape}) and previous value (${this.shape}) must match`);ei().disposeTensor(this),this.dataId=n.dataId,ei().incRef(this,null)}dispose(){ei().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(jy,Symbol.hasInstance,{value:t=>t instanceof dr&&null!=t.assign&&t.assign instanceof Function});var qy=(()=>{return(t=qy||(qy={})).float32="float32",t.int32="int32",t.bool="int32",t.complex64="complex64",qy;var t})(),Ky=(()=>{return(t=Ky||(Ky={})).float32="float32",t.int32="int32",t.bool="bool",t.complex64="complex64",Ky;var t})(),Xy=(()=>{return(t=Xy||(Xy={})).float32="float32",t.int32="float32",t.bool="float32",t.complex64="complex64",Xy;var t})(),Yy=(()=>{return(t=Yy||(Yy={})).float32="complex64",t.int32="complex64",t.bool="complex64",t.complex64="complex64",Yy;var t})();const hZ={float32:Xy,int32:qy,bool:Ky,complex64:Yy};function Ws(t,n){if("string"===t||"string"===n){if("string"===t&&"string"===n)return"string";throw new Error(`Can not upcast ${t} with ${n}`)}return hZ[t][n]}function GC(t){return Ws(t,"int32")}function tP(t){return null!=t&&"object"==typeof t&&"texture"in t&&t.texture instanceof WebGLTexture}function nP(t){return typeof GPUBuffer<"u"&&null!=t&&"object"==typeof t&&"buffer"in t&&t.buffer instanceof GPUBuffer}function rr(t,n){if(t.dtype===n.dtype)return[t,n];const e=Ws(t.dtype,n.dtype);return[t.cast(e),n.cast(e)]}function rP(t){const n=[];return sP(t,n,new Set),n}function sP(t,n,e){if(null==t)return;if(t instanceof dr)return void n.push(t);if(!function pZ(t){return Array.isArray(t)||"object"==typeof t}(t))return;const r=t;for(const s in r){const o=r[s];e.has(o)||(e.add(o),sP(o,n,e))}}function HC(t){return null!=t.kernelName}class oP{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(n=>n.name)))}}}dispose(){for(const n in this.registeredVariables)this.registeredVariables[n].dispose()}}let fZ=(()=>{class t{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new oP}ready(){var e=this;return $e(function*(){if(null!=e.pendingBackendInit)return e.pendingBackendInit.then(()=>{});if(null!=e.backendInstance)return;const r=e.getSortedBackends();for(let s=0;s<r.length;s++){const o=r[s];if(yield e.initializeBackend(o).success)return void(yield e.setBackend(o))}throw new Error("Could not initialize any backends, all backend initializations failed.")})()}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:e,asyncInit:r}=this.initializeBackendsAndReturnBest();if(r)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{const{asyncInit:r}=this.initializeBackend(e);if(r)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,r,s=1){return e in this.registryFactory?(lo(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:r,priority:s},!0)}setBackend(e){var r=this;return $e(function*(){if(null==r.registryFactory[e])throw new Error(`Backend name '${e}' not found in registry`);if(r.backendName=e,null==r.registry[e]){r.backendInstance=null;const{success:s,asyncInit:o}=r.initializeBackend(e);if(!(o?yield s:s))return!1}return r.backendInstance=r.registry[e],r.setupRegisteredKernels(),r.profiler=new nZ(r.backendInstance),!0})()}setupRegisteredKernels(){VC(this.backendName).forEach(r=>{null!=r.setupFunc&&r.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){VC(e).forEach(s=>{null!=s.disposeFunc&&s.disposeFunc(this.registry[e])})}initializeBackend(e){const r=this.registryFactory[e];if(null==r)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const s=r.factory();if(!s||s instanceof F_||"function"!=typeof s.then)return this.registry[e]=s,{success:!0,asyncInit:!1};{const o=++this.pendingBackendInitId,i=s.then(a=>!(o<this.pendingBackendInitId||(this.registry[e]=a,this.pendingBackendInit=null,0))).catch(a=>(o<this.pendingBackendInitId||(this.pendingBackendInit=null,lo(`Initialization of backend ${e} failed`),lo(a.stack||a.message)),!1));return this.pendingBackendInit=i,{success:i,asyncInit:!0}}}catch(s){return lo(`Initialization of backend ${e} failed`),lo(s.stack||s.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,r)=>this.registryFactory[r].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let r=0;r<e.length;r++){const s=e[r],{success:o,asyncInit:i}=this.initializeBackend(s);if(i||o)return{name:s,asyncInit:i}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,r){const s=this.state.tensorInfo.get(r),o=s.backend,i=this.readSync(r),a=o.refCount(r);o.disposeData(r,!0),s.backend=e,e.move(r,i,s.shape,s.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,r){let o,s=null;if(null==r){if("function"!=typeof e)throw new Error("Please provide a function to tidy()");r=e}else{if("string"!=typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof r)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");s=e}return this.scopedRun(()=>this.startScope(s),()=>this.endScope(o),()=>(o=r(),o instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),o))}scopedRun(e,r,s){e();try{const o=s();return r(),o}catch(o){throw r(),o}}nextTensorId(){return t.nextTensorId++}nextVariableId(){return t.nextVariableId++}clone(e){const r=J.runKernel(tp,{x:e});return this.addTapeNode(this.state.activeScope.name,{x:e},[r],a=>({x:()=>J.runKernel(Uh,{x:a},{dtype:"float32"})}),[],{}),r}runKernel(e,r,s){if(null==LC(e,this.backendName))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:r,attrs:s})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,r,s){const o=this.backend.numDataIds();let i=0;s.forEach(u=>{i+="complex64"===u.dtype?3:1});const l=o-r-i-this.state.numDataMovesStack[this.state.numDataMovesStack.length-1];if(l>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${l} data ids) after running '${e}'`)}runKernelFunc(e){let r,s=[];const o=this.isTapeOn(),i=this.state.numBytes,a=this.state.numTensors;let l,u;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);const c=HC(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(HC(e)){const{kernelName:g,inputs:m,attrs:y}=e,v=LC(g,this.backendName);R(null!=v,()=>`Cannot find registered kernel '${g}' for backend '${this.backendName}'`),l=()=>{const b=this.backend.numDataIds();u=v.kernelFunc({inputs:m,attrs:y,backend:this.backend});const x=Array.isArray(u)?u:[u];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(g,b,x);const w=x.map(k=>null!=k.rank?k:this.makeTensorFromTensorInfo(k));if(o){const k=this.getTensorsForGradient(g,m,w);s=this.saveTensorsForBackwardMode(k)}return w}}else{const{forwardFunc:g}=e,m=y=>{o&&(s=y.map(v=>this.keep(this.clone(v))))};l=()=>{const y=this.backend.numDataIds();u=this.tidy(()=>g(this.backend,m));const v=Array.isArray(u)?u:[u];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,y,v),v}}const{inputs:d,attrs:h}=e,p=HC(e)?null:e.backwardsFunc;let f;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(f=this.profiler.profileKernel(c,d,()=>l()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(f),r=f.outputs):r=l()}),o&&this.addTapeNode(c,d,r,p,s,h),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-i,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(d).map(g=>null!=d[g]?d[g].shape:null),outputShapes:r.map(g=>g.shape),kernelTimeMs:f.timeMs,extraInfo:f.extraInfo}),Array.isArray(u)?r:r[0]}saveTensorsForBackwardMode(e){return e.map(s=>this.keep(this.clone(s)))}getTensorsForGradient(e,r,s){const o=qO(e);if(null!=o){const i=o.inputsToSave||[],a=o.outputsToSave||[];let l;o.saveAllInputs?(R(Array.isArray(r),()=>"saveAllInputs is true, expected inputs to be an array."),l=Object.keys(r).map(c=>r[c])):l=i.map(c=>r[c]);const u=s.filter((c,d)=>a[d]);return l.concat(u)}return[]}makeTensor(e,r,s,o){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");o=o||this.backend;let i=e;"string"===(s=s||"float32")&&Oh(e[0])&&(i=e.map(u=>za(u)));const a=o.write(i,r,s),l=new dr(r,s,a,this.nextTensorId());if(this.trackTensor(l,o),"string"===s){const u=this.state.tensorInfo.get(a),c=function MY(t){if(null==t)return 0;let n=0;return t.forEach(e=>n+=e.length),n}(i);this.state.numBytes+=c-u.bytes,u.bytes=c}return l}makeTensorFromDataId(e,r,s,o){return this.makeTensorFromTensorInfo({dataId:e,shape:r,dtype:s=s||"float32"},o)}makeTensorFromTensorInfo(e,r){const{dataId:s,shape:o,dtype:i}=e,a=new dr(o,i,s,this.nextTensorId());return this.trackTensor(a,r),a}makeVariable(e,r=!0,s,o){s=s||this.nextVariableId().toString(),null!=o&&o!==e.dtype&&(e=e.cast(o));const i=new jy(e,r,s,this.nextTensorId());if(null!=this.state.registeredVariables[i.name])throw new Error(`Variable with name ${i.name} was already registered`);return this.state.registeredVariables[i.name]=i,this.incRef(i,this.backend),i}trackTensor(e,r){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let s=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(s=e.size*Lg(e.dtype)),this.state.numBytes+=s,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:r||this.backend,dtype:e.dtype,shape:e.shape,bytes:s})),e instanceof jy||this.track(e)}incRef(e,r){this.trackTensor(e,r),this.backend.incRef(e.dataId)}removeDataId(e,r){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===r&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const r=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=r.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){const s=e.size*Lg(e.dtype);this.state.numBytes-=s}r.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,r.backend)}disposeVariables(){for(const e in this.state.registeredVariables)this.disposeVariable(this.state.registeredVariables[e])}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}profile(e){var r=this;return $e(function*(){r.state.profiling=!0;const s=r.state.numBytes,o=r.state.numTensors;r.state.activeProfile.kernels=[],r.state.activeProfile.result=yield e(),r.state.profiling=!1,r.state.activeProfile.peakBytes=Math.max(...r.state.activeProfile.kernels.map(i=>i.totalBytesSnapshot)),r.state.activeProfile.newBytes=r.state.numBytes-s,r.state.activeProfile.newTensors=r.state.numTensors-o;for(const i of r.state.activeProfile.kernels)i.kernelTimeMs=yield i.kernelTimeMs,i.extraInfo=yield i.extraInfo;return r.state.activeProfile})()}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,r,s,o,i,a){const l={id:this.state.nextTapeNodeId++,kernelName:e,inputs:r,outputs:s,saved:i},u=qO(e);null!=u&&(o=u.gradFunc),null!=o&&(l.gradient=c=>(c=c.map((d,h)=>{if(null==d){const p=s[h],f=ns(p.size,p.dtype);return this.makeTensor(f,p.shape,p.dtype)}return d}),o(c.length>1?c:c[0],i,a))),this.state.activeTape.push(l)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const r={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(r.name=e),this.state.scopeStack.push(r),this.state.activeScope=r}endScope(e){const r=rP(e),s=new Set(r.map(i=>i.id));for(let i=0;i<this.state.activeScope.track.length;i++){const a=this.state.activeScope.track[i];!a.kept&&!s.has(a.id)&&a.dispose()}const o=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],r.forEach(i=>{!i.kept&&i.scopeId===o.id&&this.track(i)})}gradients(e,r,s,o=!1){if(R(r.length>0,()=>"gradients() received an empty list of xs."),null!=s&&"float32"!==s.dtype)throw new Error(`dy must have 'float32' dtype, but has '${s.dtype}'`);const i=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));R(i instanceof dr,()=>"The result y returned by f() must be a tensor.");const a=function oZ(t,n,e){const r={},s={};for(let l=0;l<n.length;l++)r[n[l].id]=!0;for(let l=0;l<t.length;l++){const u=t[l],c=u.inputs;for(const d in c){const h=c[d];let p=!1;for(let f=0;f<n.length;f++)if(r[h.id]){u.outputs.forEach(g=>r[g.id]=!0),p=!0,s[u.id]=!0;break}if(p)break}}const o={};o[e.id]=!0;const i={};for(let l=t.length-1;l>=0;l--){const u=t[l],c=u.inputs;for(let d=0;d<u.outputs.length;d++)if(o[u.outputs[d].id]){for(const h in c)o[c[h].id]=!0,i[u.id]=!0;break}}const a=[];for(let l=0;l<t.length;l++){const u=t[l];if(s[u.id]&&i[u.id]){const c={};for(const h in u.inputs){const p=u.inputs[h];r[p.id]&&(c[h]=p)}const d=Object.assign({},u);d.inputs=c,d.outputs=u.outputs,a.push(d)}}return a}(this.state.activeTape,r,i);if(!o&&0===a.length&&r.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const l={};l[i.id]=s??function mZ(t){const n=B_(_e(t),"float32");return J.makeTensor(n,t,"float32")}(i.shape),function iZ(t,n,e,r){for(let s=n.length-1;s>=0;s--){const o=n[s],i=[];if(o.outputs.forEach(l=>{const u=t[l.id];i.push(null!=u?u:null)}),null==o.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${o.kernelName}.`);const a=o.gradient(i);for(const l in o.inputs){if(!(l in a))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(a)}.`);const u=e(()=>a[l]());if("float32"!==u.dtype)throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${u.dtype}'`);const c=o.inputs[l];if(!gn(u.shape,c.shape))throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input '${l}' has shape '${u.shape}', which does not match the shape of the input '${c.shape}'`);if(null==t[c.id])t[c.id]=u;else{const d=t[c.id];t[c.id]=r(d,u),d.dispose()}}}}(l,a,c=>this.tidy(c),gZ);const u=r.map(c=>l[c.id]);return 0===this.state.gradientDepth&&(this.state.activeTape.forEach(c=>{for(const d of c.saved)d.dispose()}),this.state.activeTape=null),{value:i,grads:u}})}customGrad(e){return R(L_(e),()=>"The f passed in customGrad(f) must be a function."),(...r)=>{let s;R(r.every(l=>l instanceof dr),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");const o={};return r.forEach((l,u)=>{o[u]=l}),this.runKernelFunc({forwardFunc:(l,u)=>(s=e(...r,u),R(s.value instanceof dr,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),R(L_(s.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),s.value),backwardsFunc:(l,u)=>{const c=s.gradFunc(l,u),d=Array.isArray(c)?c:[c];R(d.length===r.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),R(d.every(p=>p instanceof dr),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const h={};return d.forEach((p,f)=>{h[f]=()=>p}),h},inputs:o})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,r){return this.state.tensorInfo.get(e).backend.readToGPU(e,r)}time(e){var r=this;return $e(function*(){const s=Rs(),o=yield r.backend.time(e);return o.wallMs=Rs()-s,o})()}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new oP;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}return t.nextTensorId=0,t.nextVariableId=0,t})();function iP(){const t=RO();if(null==t._tfengine){const n=new VY(t);t._tfengine=new fZ(n)}return function WY(t){AO=t}(t._tfengine.ENV),function uZ(t){ei=t}(()=>t._tfengine),t._tfengine}const J=iP();function gZ(t,n){return J.runKernel(Dc,{a:t,b:n})}let jC;function aP(t){if(void 0!==jC)return jC;if(t||function yZ(){return typeof navigator<"u"&&null!=navigator}()){if(t||(t=navigator),"ReactNative"===t.product)return!0;const n=t.userAgent||t.vendor||(typeof window<"u"?window.opera:"");return n?/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(n)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(n.substr(0,4)):t.userAgentData&&t.userAgentData.mobile}return!1}function lP(){return typeof window<"u"&&null!=window.document||typeof WorkerGlobalScope<"u"}const Fs=pe();function Op(t,n){let e=t;if(Jo(t))return"string"===n?[]:[t.length];if(tP(t))return[t.height,t.width*(t.channels||"RGBA").length];if(nP(t))return[t.buffer.size/(null==n?4:Lg(n))];if(!Array.isArray(t))return[];const r=[];for(;Array.isArray(e)||Jo(e)&&"string"!==n;)r.push(e.length),e=e[0];return Array.isArray(t)&&pe().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&uP(t,r,[]),r}function uP(t,n,e){if(e=e||[],!Array.isArray(t)&&!Jo(t))return void R(0===n.length,()=>`Element arr[${e.join("][")}] is a primitive, but should be an array/TypedArray of ${n[0]} elements`);R(n.length>0,()=>`Element arr[${e.join("][")}] should be a primitive, but is an array of ${t.length} elements`),R(t.length===n[0],()=>`Element arr[${e.join("][")}] should have ${n[0]} elements, but has ${t.length} elements`);const r=n.slice(1);for(let s=0;s<t.length;++s)uP(t[s],r,e.concat(s))}function cP(t,n,e,r){if("string_or_numeric"!==t){if(null==t)throw new Error("Expected dtype cannot be null.");if("numeric"!==t&&t!==n||"numeric"===t&&"string"===n)throw new Error(`Argument '${e}' passed to '${r}' must be ${t} tensor, but got ${n} tensor`)}}function $(t,n,e,r="numeric"){if(t instanceof dr)return cP(r,t.dtype,n,e),t;let s=Sc(t);if("string"!==s&&["bool","int32","float32"].indexOf(r)>=0&&(s=r),cP(r,s,n,e),null==t||!Jo(t)&&!Array.isArray(t)&&"number"!=typeof t&&"boolean"!=typeof t&&"string"!=typeof t)throw new Error(`Argument '${n}' passed to '${e}' must be a Tensor or TensorLike, but got '${null==t?"null":t.constructor.name}'`);const o=Op(t,s);!Jo(t)&&!Array.isArray(t)&&(t=[t]);const a="string"!==s?Hl(t,s):jl(t,[],!0);return J.makeTensor(a,o,s)}function dP(t,n,e,r="numeric"){if(!Array.isArray(t))throw new Error(`Argument ${n} passed to ${e} must be a \`Tensor[]\` or \`TensorLike[]\``);return t.map((o,i)=>$(o,`${n}[${i}]`,e,r))}Fs.registerFlag("DEBUG",()=>!1,t=>{t&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),Fs.registerFlag("IS_BROWSER",()=>lP()),Fs.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u"),Fs.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),Fs.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&null!=navigator&&null!=navigator.userAgent&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor)),Fs.registerFlag("PROD",()=>!1),Fs.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>Fs.getBool("DEBUG")),Fs.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),Fs.registerFlag("IS_TEST",()=>!1),Fs.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>Fs.getBool("DEBUG")),Fs.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1),Fs.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1),Fs.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);const vZ="__op";function te(t){const n=Object.keys(t);if(1!==n.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${n.length} keys.`);let e=n[0];const r=t[e];e.endsWith("_")&&(e=e.substring(0,e.length-1)),e+=vZ;const s=(...o)=>{J.startScope(e);try{const i=r(...o);return z_(i)&&console.error("Cannot return a Promise inside of tidy."),J.endScope(i),i}catch(i){throw J.endScope(null),i}};return Object.defineProperty(s,"name",{value:e,configurable:!0}),s}const ql=te({complex_:function bZ(t,n){const e=$(t,"real","complex"),r=$(n,"imag","complex");return No(e.shape,r.shape,`real and imag shapes, ${e.shape} and ${r.shape}, must match in call to tf.complex().`),J.runKernel(Y_,{real:e,imag:r})}});function Pp(t,n,e,r){if(null==r)r=Sc(t);else if("complex64"===r)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(nP(t)||tP(t)){if("float32"!==r&&"int32"!==r)throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return J.backend.createTensorFromGPUData(t,n||e,r)}if(!Jo(t)&&!Array.isArray(t)&&"number"!=typeof t&&"boolean"!=typeof t&&"string"!=typeof t)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=n){la(n);const s=_e(n),o=_e(e);R(s===o,()=>`Based on the provided shape, [${n}], the tensor should have ${s} values but has ${o}`);for(let i=0;i<e.length;++i){const l=i!==e.length-1||e[i]!==_e(n.slice(i));R(e[i]===n[i]||!l,()=>`Error creating a new Tensor. Inferred shape (${e}) does not match the provided shape (${n}). `)}}return!Jo(t)&&!Array.isArray(t)&&(t=[t]),n=n||e,t="string"!==r?Hl(t,r):jl(t,[],!0),J.makeTensor(t,n,r)}function Mp(t,n,e){return Pp(t,n,Op(t,e),e)}const qC={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8},Zy=4;function hP(t,n){return KC.apply(this,arguments)}function KC(){return KC=$e(function*(t,n){const e=[],r=[],s=Array.isArray(t)?t.map(i=>i.name):Object.keys(t);for(let i=0;i<s.length;++i){const a=s[i],l=Array.isArray(t)?t[i].tensor:t[a];if("float32"!==l.dtype&&"int32"!==l.dtype&&"bool"!==l.dtype&&"string"!==l.dtype&&"complex64"!==l.dtype)throw new Error(`Unsupported dtype in weight '${a}': ${l.dtype}`);const u={name:a,shape:l.shape,dtype:l.dtype};if("string"===l.dtype){const c=new Promise(function(){var d=$e(function*(h){const p=yield l.bytes(),f=p.reduce((y,v)=>y+v.length,0)+Zy*p.length,g=new Uint8Array(f);let m=0;for(let y=0;y<p.length;y++){const v=p[y],b=new Uint8Array(new Uint32Array([v.length]).buffer);g.set(b,m),m+=Zy,g.set(v,m),m+=v.length}h(g)});return function(h){return d.apply(this,arguments)}}());r.push(c)}else r.push(l.data());null!=n&&(u.group=n),e.push(u)}return{data:xZ(yield Promise.all(r)),specs:e}}),KC.apply(this,arguments)}function xZ(t){if(null===t)throw new Error(`Invalid input value: ${JSON.stringify(t)}`);let n=0;const e=[];t.forEach(o=>{if(n+=o.byteLength,e.push(o.byteLength===o.buffer.byteLength?o:new o.constructor(o)),!(o instanceof Float32Array||o instanceof Int32Array||o instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${o.constructor.name}`)});const r=new Uint8Array(n);let s=0;return e.forEach(o=>{r.set(new Uint8Array(o.buffer),s),s+=o.byteLength}),r.buffer}const XC=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function fP(t){return XC?Buffer.byteLength(t):new Blob([t]).size}function YC(t){if(1===t.length)return t[0];let n=0;t.forEach(s=>{n+=s.byteLength});const e=new Uint8Array(n);let r=0;return t.forEach(s=>{e.set(new Uint8Array(s),r),r+=s.byteLength}),e.buffer}function gP(t,n){const e={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,weightsManifest:n};return null!=t.signature&&(e.signature=t.signature),null!=t.userDefinedMetadata&&(e.userDefinedMetadata=t.userDefinedMetadata),null!=t.modelInitializer&&(e.modelInitializer=t.modelInitializer),null!=t.initializerSignature&&(e.initializerSignature=t.initializerSignature),null!=t.trainingConfig&&(e.trainingConfig=t.trainingConfig),e}function yP(t,n){return ZC.apply(this,arguments)}function ZC(){return(ZC=$e(function*(t,n){let e,r;return null!=t.weightsManifest&&([e,r]=yield n(t.weightsManifest)),function CZ(t,n,e){const r={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy};if(null!=t.trainingConfig&&(r.trainingConfig=t.trainingConfig),null!=t.weightsManifest){if(!n)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!e)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=n,r.weightData=e}return null!=t.signature&&(r.signature=t.signature),null!=t.userDefinedMetadata&&(r.userDefinedMetadata=t.userDefinedMetadata),null!=t.modelInitializer&&(r.modelInitializer=t.modelInitializer),null!=t.initializerSignature&&(r.initializerSignature=t.initializerSignature),r}(t,e,r)})).apply(this,arguments)}function Qy(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==t.modelTopology?0:fP(JSON.stringify(t.modelTopology)),weightSpecsBytes:null==t.weightSpecs?0:fP(JSON.stringify(t.weightSpecs)),weightDataBytes:null==t.weightData?0:t.weightData.byteLength}}function kZ(){const t=function IZ(){const t=e=>{let r=e<<13,s=0;for(;!(8388608&r);)s-=8388608,r<<=1;return r&=-8388609,s+=947912704,r|s},n=new Uint32Array(2048);n[0]=0;for(let e=1;e<1024;e++)n[e]=t(e);for(let e=1024;e<2048;e++)n[e]=939524096+(e-1024<<13);return n}(),n=function DZ(){const t=new Uint32Array(64);t[0]=0,t[31]=1199570944,t[32]=2147483648,t[63]=3347054592;for(let n=1;n<31;n++)t[n]=n<<23;for(let n=33;n<63;n++)t[n]=2147483648+(n-32<<23);return t}(),e=function TZ(){const t=new Uint32Array(64);for(let n=0;n<64;n++)t[n]=1024;return t[0]=t[32]=0,t}();return r=>{const s=new ArrayBuffer(4*r.length),o=new Uint32Array(s);for(let i=0;i<r.length;i++){const a=r[i];o[i]=t[e[a>>10]+(1023&a)]+n[a>>10]}return new Float32Array(s)}}class Zn{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==Zn.instance&&(Zn.instance=new Zn),Zn.instance}static registerSaveRouter(n){Zn.getInstance().saveRouters.push(n)}static registerLoadRouter(n){Zn.getInstance().loadRouters.push(n)}static getSaveHandlers(n){return Zn.getHandlers(n,"save")}static getLoadHandlers(n,e){return Zn.getHandlers(n,"load",e)}static getHandlers(n,e,r){const s=[];return("load"===e?Zn.getInstance().loadRouters:Zn.getInstance().saveRouters).forEach(i=>{const a=i(n,r);null!==a&&s.push(a)}),s}}const NZ=(t,n)=>Zn.getLoadHandlers(t,n),Jy="tensorflowjs",Kl="models_store",Wa="model_info_store";function e1(){if(!pe().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const t=typeof window>"u"?self:window,n=t.indexedDB||t.mozIndexedDB||t.webkitIndexedDB||t.msIndexedDB||t.shimIndexedDB;if(null==n)throw new Error("The current browser does not appear to support IndexedDB.");return n}function t1(t){const n=t.result;n.createObjectStore(Kl,{keyPath:"modelPath"}),n.createObjectStore(Wa,{keyPath:"modelPath"})}let Nc=(()=>{class t{constructor(e){if(this.indexedDB=e1(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}save(e){var r=this;return $e(function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return r.databaseAction(r.modelPath,e)})()}load(){var e=this;return $e(function*(){return e.databaseAction(e.modelPath)})()}databaseAction(e,r){return new Promise((s,o)=>{const i=this.indexedDB.open(Jy,1);i.onupgradeneeded=()=>t1(i),i.onsuccess=()=>{const a=i.result;if(null==r){const l=a.transaction(Kl,"readonly"),c=l.objectStore(Kl).get(this.modelPath);c.onsuccess=()=>{if(null==c.result)return a.close(),o(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));s(c.result.modelArtifacts)},c.onerror=d=>(a.close(),o(c.error)),l.oncomplete=()=>a.close()}else{const l=Qy(r),u=a.transaction(Wa,"readwrite");let d,h,c=u.objectStore(Wa);try{d=c.put({modelPath:this.modelPath,modelArtifactsInfo:l})}catch(p){return o(p)}d.onsuccess=()=>{h=a.transaction(Kl,"readwrite");const p=h.objectStore(Kl);let f;try{f=p.put({modelPath:this.modelPath,modelArtifacts:r,modelArtifactsInfo:l})}catch(g){return o(g)}f.onsuccess=()=>s({modelArtifactsInfo:l}),f.onerror=g=>{c=u.objectStore(Wa);const m=c.delete(this.modelPath);m.onsuccess=()=>(a.close(),o(f.error)),m.onerror=y=>(a.close(),o(f.error))}},d.onerror=p=>(a.close(),o(d.error)),u.oncomplete=()=>{null==h?a.close():h.oncomplete=()=>a.close()}}},i.onerror=a=>o(i.error)})}}return t.URL_SCHEME="indexeddb://",t})();const vP=t=>pe().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(Nc.URL_SCHEME)?function AZ(t){return new Nc(t)}(t.slice(Nc.URL_SCHEME.length)):null;Zn.registerSaveRouter(vP),Zn.registerLoadRouter(vP);class FZ{constructor(){this.indexedDB=e1()}listModels(){var n=this;return $e(function*(){return new Promise((e,r)=>{const s=n.indexedDB.open(Jy,1);s.onupgradeneeded=()=>t1(s),s.onsuccess=()=>{const o=s.result,i=o.transaction(Wa,"readonly"),l=i.objectStore(Wa).getAll();l.onsuccess=()=>{const u={};for(const c of l.result)u[c.modelPath]=c.modelArtifactsInfo;e(u)},l.onerror=u=>(o.close(),r(l.error)),i.oncomplete=()=>o.close()},s.onerror=o=>r(s.error)})})()}removeModel(n){var e=this;return $e(function*(){return n=function RZ(t){return t.startsWith(Nc.URL_SCHEME)?t.slice(Nc.URL_SCHEME.length):t}(n),new Promise((r,s)=>{const o=e.indexedDB.open(Jy,1);o.onupgradeneeded=()=>t1(o),o.onsuccess=()=>{const i=o.result,a=i.transaction(Wa,"readwrite"),l=a.objectStore(Wa),u=l.get(n);let c;u.onsuccess=()=>{if(null==u.result)return i.close(),s(new Error(`Cannot find model with path '${n}' in IndexedDB.`));{const d=l.delete(n),h=()=>{c=i.transaction(Kl,"readwrite");const f=c.objectStore(Kl).delete(n);f.onsuccess=()=>r(u.result.modelArtifactsInfo),f.onerror=g=>s(u.error)};d.onsuccess=h,d.onerror=p=>(h(),i.close(),s(u.error))}},u.onerror=d=>(i.close(),s(u.error)),a.oncomplete=()=>{null==c?i.close():c.oncomplete=()=>i.close()}},o.onerror=i=>s(o.error)})})()}}const Ti="/",Xl="tensorflowjs_models",bP="info",OZ="model_topology",PZ="weight_specs",MZ="weight_data",$Z="model_metadata";function xP(t){return{info:[Xl,t,bP].join(Ti),topology:[Xl,t,OZ].join(Ti),weightSpecs:[Xl,t,PZ].join(Ti),weightData:[Xl,t,MZ].join(Ti),modelMetadata:[Xl,t,$Z].join(Ti)}}function wP(t){for(const n of Object.values(t))window.localStorage.removeItem(n)}function _P(t){const n=t.split(Ti);if(n.length<3)throw new Error(`Invalid key format: ${t}`);return n.slice(1,n.length-1).join(Ti)}let Ac=(()=>{class t{constructor(e){if(!pe().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=xP(this.modelPath)}save(e){var r=this;return $e(function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const s=JSON.stringify(e.modelTopology),o=JSON.stringify(e.weightSpecs),i=Qy(e);try{return r.LS.setItem(r.keys.info,JSON.stringify(i)),r.LS.setItem(r.keys.topology,s),r.LS.setItem(r.keys.weightSpecs,o),r.LS.setItem(r.keys.weightData,function wZ(t){if(XC)return Buffer.from(t).toString("base64");const n=new Uint8Array(t);let e="";for(let r=0,s=n.length;r<s;r++)e+=String.fromCharCode(n[r]);return btoa(e)}(e.weightData)),r.LS.setItem(r.keys.modelMetadata,JSON.stringify({format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:null!=e.signature?e.signature:void 0,userDefinedMetadata:null!=e.userDefinedMetadata?e.userDefinedMetadata:void 0,modelInitializer:null!=e.modelInitializer?e.modelInitializer:void 0,initializerSignature:null!=e.initializerSignature?e.initializerSignature:void 0,trainingConfig:null!=e.trainingConfig?e.trainingConfig:void 0})),{modelArtifactsInfo:i}}catch{throw wP(r.keys),new Error(`Failed to save model '${r.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${i.modelTopologyBytes}, weightSpecsBytes=${i.weightSpecsBytes}, weightDataBytes=${i.weightDataBytes}.`)}}})()}load(){var e=this;return $e(function*(){const r=JSON.parse(e.LS.getItem(e.keys.info));if(null==r)throw new Error(`In local storage, there is no model with name '${e.modelPath}'`);if("JSON"!==r.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const s={},o=JSON.parse(e.LS.getItem(e.keys.topology));if(null==o)throw new Error(`In local storage, the topology of model '${e.modelPath}' is missing.`);s.modelTopology=o;const i=JSON.parse(e.LS.getItem(e.keys.weightSpecs));if(null==i)throw new Error(`In local storage, the weight specs of model '${e.modelPath}' are missing.`);s.weightSpecs=i;const a=e.LS.getItem(e.keys.modelMetadata);if(null!=a){const u=JSON.parse(a);s.format=u.format,s.generatedBy=u.generatedBy,s.convertedBy=u.convertedBy,null!=u.signature&&(s.signature=u.signature),null!=u.userDefinedMetadata&&(s.userDefinedMetadata=u.userDefinedMetadata),null!=u.modelInitializer&&(s.modelInitializer=u.modelInitializer),null!=u.initializerSignature&&(s.initializerSignature=u.initializerSignature),null!=u.trainingConfig&&(s.trainingConfig=u.trainingConfig)}const l=e.LS.getItem(e.keys.weightData);if(null==l)throw new Error(`In local storage, the binary weight values of model '${e.modelPath}' are missing.`);return s.weightData=function _Z(t){if(XC){const r=Buffer.from(t,"base64");return r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)}const n=atob(t),e=new Uint8Array(n.length);for(let r=0;r<n.length;++r)e.set([n.charCodeAt(r)],r);return e.buffer}(l),s})()}}return t.URL_SCHEME="localstorage://",t})();const CP=t=>pe().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(Ac.URL_SCHEME)?function VZ(t){return new Ac(t)}(t.slice(Ac.URL_SCHEME.length)):null;Zn.registerSaveRouter(CP),Zn.registerLoadRouter(CP);class BZ{constructor(){R(pe().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),R(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}listModels(){var n=this;return $e(function*(){const e={},r=Xl+Ti,s=Ti+bP;for(let o=0;o<n.LS.length;++o){const i=n.LS.key(o);i.startsWith(r)&&i.endsWith(s)&&(e[_P(i)]=JSON.parse(n.LS.getItem(i)))}return e})()}removeModel(n){var e=this;return $e(function*(){const r=xP(n=function LZ(t){return t.startsWith(Ac.URL_SCHEME)?t.slice(Ac.URL_SCHEME.length):t}(n));if(null==e.LS.getItem(r.info))throw new Error(`Cannot find model at path '${n}'`);const s=JSON.parse(e.LS.getItem(r.info));return wP(r),s})()}}class fs{constructor(){this.managers={}}static getInstance(){return null==fs.instance&&(fs.instance=new fs),fs.instance}static registerManager(n,e){R(null!=n,()=>"scheme must not be undefined or null."),n.endsWith("://")&&(n=n.slice(0,n.indexOf("://"))),R(n.length>0,()=>"scheme must not be an empty string.");const r=fs.getInstance();R(null==r.managers[n],()=>`A model store manager is already registered for scheme '${n}'.`),r.managers[n]=e}static getManager(n){const e=fs.getInstance().managers[n];if(null==e)throw new Error(`Cannot find model manager for scheme '${n}'`);return e}static getSchemes(){return Object.keys(fs.getInstance().managers)}}class zZ{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(n,e){return fetch(n,e)}now(){return performance.now()}encode(n,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Browser's encoder only supports utf-8, but got ${e}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(n)}decode(n,e){return new TextDecoder(e).decode(n)}setTimeoutCustom(n,e){typeof window>"u"||!pe().getBool("USE_SETTIMEOUTCUSTOM")?setTimeout(n,e):(this.functionRefs.push(n),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},e),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",r=>{r.source===window&&r.data.name===this.messageName&&(r.stopPropagation(),(0,this.functionRefs[r.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0))},!0)))}isTypedArray(n){return n instanceof Float32Array||n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray}}if(pe().get("IS_BROWSER")){pe().setPlatform("browser",new zZ);try{fs.registerManager(Ac.URL_SCHEME,new BZ)}catch{}try{fs.registerManager(Nc.URL_SCHEME,new FZ)}catch{}}let Fc;function en(t,n="float32",e){return n=n||"float32",la(t),new Wr(t,n,e)}pe().get("IS_NODE")&&!pe().get("IS_BROWSER")&&pe().setPlatform("node",new class WZ{constructor(){this.util=ne(628),this.textEncoder=new this.util.TextEncoder}fetch(n,e){return null!=pe().global.fetch?pe().global.fetch(n,e):(null==Fc&&(Fc=ne(410)),Fc(n,e))}now(){const n=process.hrtime();return 1e3*n[0]+n[1]/1e6}encode(n,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Node built-in encoder only supports utf-8, but got ${e}`);return this.textEncoder.encode(n)}decode(n,e){return 0===n.length?"":new this.util.TextDecoder(e).decode(n)}isTypedArray(n){return this.util.types.isFloat32Array(n)||this.util.types.isInt32Array(n)||this.util.types.isUint8Array(n)||this.util.types.isUint8ClampedArray(n)}});const it=te({cast_:function GZ(t,n){const e=$(t,"x","cast");if(!function PY(t){return"bool"===t||"complex64"===t||"float32"===t||"int32"===t||"string"===t}(n))throw new Error(`Failed to cast to unknown dtype ${n}`);if("string"===n&&"string"!==e.dtype||"string"!==n&&"string"===e.dtype)throw new Error("Only strings can be casted to strings");return J.runKernel(Uh,{x:e},{dtype:n})}}),Yl=te({clone_:function HZ(t){const e={x:$(t,"x","clone","string_or_numeric")};return J.runKernel(tp,e)}});function ki(){return J}function a1(){return J.memory()}function he(t,n){return J.tidy(t,n)}function Xt(t){rP(t).forEach(e=>e.dispose())}function Ei(t){return J.keep(t)}function IP(t,n,e=1){return J.registerBackend(t,n,e)}iP(),function cZ(t){Ec=t}({buffer:en,cast:it,clone:Yl,print:function jZ(t,n=!1){console.log(t.toString(n))}}),function dZ(t){eP=t}(function qZ(t){pe().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(t+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")});const Ge=te({add_:function XZ(t,n){let e=$(t,"a","add"),r=$(n,"b","add");return[e,r]=rr(e,r),J.runKernel(Dc,{a:e,b:r})}}),DP=te({floorDiv_:function YZ(t,n){let e=$(t,"a","floorDiv"),r=$(n,"b","floorDiv");return[e,r]=rr(e,r),J.runKernel(Jh,{a:e,b:r})}}),wt=te({div_:function ZZ(t,n){let e=$(t,"a","div"),r=$(n,"b","div");return[e,r]=rr(e,r),"int32"===e.dtype&&"int32"===r.dtype?DP(e,r):J.runKernel(qh,{a:e,b:r},{})}}),Q=te({mul_:function QZ(t,n){let e=$(t,"a","mul"),r=$(n,"b","mul");return[e,r]=rr(e,r),J.runKernel(cp,{a:e,b:r})}}),ms=te({sqrt_:function JZ(t){const e={x:$(t,"x","sqrt","float32")};return J.runKernel(Cp,e)}}),Pn=te({square_:function eQ(t){const n=$(t,"x","square");return J.runKernel("Square",{x:n},{})}}),dn=te({zerosLike_:function tQ(t){const e={x:$(t,"x","zerosLike")};return J.runKernel(Vy,e)}});function ua(t){return J.customGrad(t)}function Lt(t,n){if((Jo(t)&&"string"!==n||Array.isArray(t))&&"complex64"!==n)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===n&&Jo(t)&&!(t instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Pp(t,[],[],n)}class Oc{getClassName(){return this.constructor.className}static fromConfig(n,e){return new n(e)}}class Ao{constructor(){this.classNameMap={}}static getMap(){return null==Ao.instance&&(Ao.instance=new Ao),Ao.instance}static register(n){Ao.getMap().classNameMap[n.className]=[n,n.fromConfig]}}function Ue(t){R(null!=t.className,()=>"Class being registered does not have the static className property defined."),R("string"==typeof t.className,()=>"className is required to be a string, but got type "+typeof t.className),R(t.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),Ao.register(t)}class Ga extends Oc{minimize(n,e=!1,r){const{value:s,grads:o}=this.computeGradients(n,r);if(null!=r){const i=r.map(a=>({name:a.name,tensor:o[a.name]}));this.applyGradients(i)}else this.applyGradients(o);return Xt(o),e?s:(s.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(n,e){return function nQ(t,n){R(L_(t),()=>"The f passed in variableGrads(f) must be a function"),R(null==n||Array.isArray(n)&&n.every(u=>u instanceof jy),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const e=null!=n;if(!e){n=[];for(const u in J.registeredVariables)n.push(J.registeredVariables[u])}const r=e?n.filter(u=>!u.trainable):null,s=n.length;R((n=n.filter(u=>u.trainable)).length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${s} variables is trainable.`);const{value:i,grads:a}=J.gradients(t,n,null,!0);R(a.some(u=>null!=u),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),R(0===i.rank,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`);const l={};return n.forEach((u,c)=>{null!=a[c]&&(l[u.name]=a[c])}),r?.forEach(u=>l[u.name]=null),{value:i,grads:l}}(n,e)}dispose(){null!=this.iterations_&&Xt(this.iterations_)}saveIterations(){var n=this;return $e(function*(){return null==n.iterations_&&(n.iterations_=0),{name:"iter",tensor:Lt(n.iterations_,"int32")}})()}getWeights(){return $e(function*(){throw new Error("getWeights() is not implemented for this optimizer yet.")})()}setWeights(n){var e=this;return $e(function*(){throw new Error(`setWeights() is not implemented for this optimizer class ${e.getClassName()}`)})()}extractIterations(n){var e=this;return $e(function*(){return e.iterations_=(yield n[0].tensor.data())[0],n.slice(1)})()}}Object.defineProperty(Ga,Symbol.hasInstance,{value:t=>null!=t.minimize&&null!=t.computeGradients&&null!=t.applyGradients});class TP extends Ga{static get className(){return"Adadelta"}constructor(n,e,r=null){super(),this.learningRate=n,this.rho=e,this.epsilon=r,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==r&&(this.epsilon=J.backend.epsilon())}applyGradients(n){(Array.isArray(n)?n.map(r=>r.name):Object.keys(n)).forEach((r,s)=>{const o=J.registeredVariables[r];null==this.accumulatedGrads[s]&&(this.accumulatedGrads[s]={originalName:`${r}/accum_grad`,variable:he(()=>dn(o).variable(!1))}),null==this.accumulatedUpdates[s]&&(this.accumulatedUpdates[s]={originalName:`${r}/accum_var`,variable:he(()=>dn(o).variable(!1))});const a=Array.isArray(n)?n[s].tensor:n[r];if(null==a)return;const l=this.accumulatedGrads[s].variable,u=this.accumulatedUpdates[s].variable;he(()=>{const c=Ge(Q(l,this.rho),Q(Pn(a),1-this.rho)),d=Q(wt(ms(Ge(u,this.epsilon)),ms(Ge(l,this.epsilon))),a),h=Ge(Q(u,this.rho),Q(Pn(d),1-this.rho));l.assign(c),u.assign(h);const p=Ge(Q(d,-this.learningRate),o);o.assign(p)})}),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(Xt(this.accumulatedGrads.map(n=>n.variable)),Xt(this.accumulatedUpdates.map(n=>n.variable)))}getWeights(){var n=this;return $e(function*(){const e=[...n.accumulatedGrads,...n.accumulatedUpdates];return[yield n.saveIterations()].concat(e.map(r=>({name:r.originalName,tensor:r.variable})))})()}setWeights(n){var e=this;return $e(function*(){const r=(n=yield e.extractIterations(n)).length/2;e.accumulatedGrads=n.slice(0,r).map(o=>({originalName:o.name,variable:o.tensor.variable(!1)})),e.accumulatedUpdates=n.slice(r,2*r).map(o=>({originalName:o.name,variable:o.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(n,e){return new n(e.learningRate,e.rho,e.epsilon)}}function $p(t,n,e){return la(t),e=e||Sc(n),J.runKernel(cC,{},{shape:t,value:n,dtype:e})}class kP extends Ga{static get className(){return"Adagrad"}constructor(n,e=.1){super(),this.learningRate=n,this.initialAccumulatorValue=e,this.accumulatedGrads=[]}applyGradients(n){(Array.isArray(n)?n.map(r=>r.name):Object.keys(n)).forEach((r,s)=>{const o=J.registeredVariables[r];null==this.accumulatedGrads[s]&&(this.accumulatedGrads[s]={originalName:`${r}/accumulator`,variable:he(()=>$p(o.shape,this.initialAccumulatorValue).variable(!1))});const i=Array.isArray(n)?n[s].tensor:n[r];if(null==i)return;const a=this.accumulatedGrads[s].variable;he(()=>{const l=Ge(a,Pn(i));a.assign(l);const u=Ge(Q(wt(i,ms(Ge(l,J.backend.epsilon()))),-this.learningRate),o);o.assign(u)})}),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&Xt(this.accumulatedGrads.map(n=>n.variable))}getWeights(){var n=this;return $e(function*(){return[yield n.saveIterations()].concat(n.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))})()}setWeights(n){var e=this;return $e(function*(){n=yield e.extractIterations(n),e.accumulatedGrads=n.map(s=>({originalName:s.name,variable:s.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(n,e){return new n(e.learningRate,e.initialAccumulatorValue)}}const Pc=te({pow_:function rQ(t,n){let e=$(t,"base","pow"),r=$(n,"exp","pow");return[e,r]=rr(e,r),J.runKernel(dp,{a:e,b:r})}}),gt=te({sub_:function sQ(t,n){let e=$(t,"a","sub"),r=$(n,"b","sub");return[e,r]=rr(e,r),J.runKernel(Ip,{a:e,b:r})}});class EP extends Ga{static get className(){return"Adam"}constructor(n,e,r,s=null){super(),this.learningRate=n,this.beta1=e,this.beta2=r,this.epsilon=s,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],he(()=>{this.accBeta1=Lt(e).variable(),this.accBeta2=Lt(r).variable()}),null==s&&(this.epsilon=J.backend.epsilon())}applyGradients(n){const e=Array.isArray(n)?n.map(r=>r.name):Object.keys(n);he(()=>{const r=gt(1,this.accBeta1),s=gt(1,this.accBeta2);e.forEach((o,i)=>{const a=J.registeredVariables[o];null==this.accumulatedFirstMoment[i]&&(this.accumulatedFirstMoment[i]={originalName:`${o}/m`,variable:he(()=>dn(a).variable(!1))}),null==this.accumulatedSecondMoment[i]&&(this.accumulatedSecondMoment[i]={originalName:`${o}/v`,variable:he(()=>dn(a).variable(!1))});const u=Array.isArray(n)?n[i].tensor:n[o];if(null==u)return;const c=this.accumulatedFirstMoment[i].variable,d=this.accumulatedSecondMoment[i].variable,h=Ge(Q(c,this.beta1),Q(u,1-this.beta1)),p=Ge(Q(d,this.beta2),Q(Pn(u),1-this.beta2)),f=wt(h,r),g=wt(p,s);c.assign(h),d.assign(p);const m=Ge(Q(wt(f,Ge(ms(g),this.epsilon)),-this.learningRate),a);a.assign(m)}),this.accBeta1.assign(Q(this.accBeta1,this.beta1)),this.accBeta2.assign(Q(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&Xt(this.accumulatedFirstMoment.map(n=>n.variable)),null!=this.accumulatedSecondMoment&&Xt(this.accumulatedSecondMoment.map(n=>n.variable))}getWeights(){var n=this;return $e(function*(){const e=[...n.accumulatedFirstMoment,...n.accumulatedSecondMoment];return[yield n.saveIterations()].concat(e.map(r=>({name:r.originalName,tensor:r.variable})))})()}setWeights(n){var e=this;return $e(function*(){n=yield e.extractIterations(n),he(()=>{e.accBeta1.assign(Pc(e.beta1,e.iterations_+1)),e.accBeta2.assign(Pc(e.beta2,e.iterations_+1))});const r=n.length/2;e.accumulatedFirstMoment=n.slice(0,r).map(o=>({originalName:o.name,variable:o.tensor.variable(!1)})),e.accumulatedSecondMoment=n.slice(r,2*r).map(o=>({originalName:o.name,variable:o.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(n,e){return new n(e.learningRate,e.beta1,e.beta2,e.epsilon)}}const Pr=te({abs_:function oQ(t){const n=$(t,"x","abs");return J.runKernel("complex64"===n.dtype?jg:Vg,{x:n})}});function Mc(t,n){const e=t.length,r=[];for(let s=0;s<e;s++){const o=e-1-s;(n[n.length-1-s]||1)>1&&1===(t[o]||1)&&r.unshift(o)}return r}function Dr(t,n){const e=[];for(let r=0;r<n.length;r++){const s=t[t.length-r-1],o=n.length-r-1;(null==s||1===s&&n[o]>1)&&e.unshift(o)}return e}function Vt(t,n){const e=Math.max(t.length,n.length),r=new Array(e);for(let s=0;s<e;s++){let o=t[t.length-s-1];null==o&&(o=1);let i=n[n.length-s-1];if(null==i&&(i=1),1===o)r[e-s-1]=i;else if(1===i)r[e-s-1]=o;else{if(o!==i)throw Error(`Operands could not be broadcast together with shapes ${t} and ${n}.`);r[e-s-1]=o}}return r}const Ha=te({maximum_:function iQ(t,n){let e=$(t,"a","maximum"),r=$(n,"b","maximum");return[e,r]=rr(e,r),"bool"===e.dtype&&(e=it(e,"int32"),r=it(r,"int32")),Vt(e.shape,r.shape),J.runKernel(ap,{a:e,b:r})}});class NP extends Ga{static get className(){return"Adamax"}constructor(n,e,r,s=null,o=0){super(),this.learningRate=n,this.beta1=e,this.beta2=r,this.epsilon=s,this.decay=o,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],he(()=>{this.iteration=Lt(0).variable(),this.accBeta1=Lt(e).variable()}),null==s&&(this.epsilon=J.backend.epsilon())}applyGradients(n){const e=Array.isArray(n)?n.map(r=>r.name):Object.keys(n);he(()=>{const r=gt(1,this.accBeta1),s=wt(-this.learningRate,Ge(Q(this.iteration,this.decay),1));e.forEach((o,i)=>{const a=J.registeredVariables[o];null==this.accumulatedFirstMoment[i]&&(this.accumulatedFirstMoment[i]={originalName:`${o}/m`,variable:dn(a).variable(!1)}),null==this.accumulatedWeightedInfNorm[i]&&(this.accumulatedWeightedInfNorm[i]={originalName:`${o}/v`,variable:dn(a).variable(!1)});const u=Array.isArray(n)?n[i].tensor:n[o];if(null==u)return;const c=this.accumulatedFirstMoment[i].variable,d=this.accumulatedWeightedInfNorm[i].variable,h=Ge(Q(c,this.beta1),Q(u,1-this.beta1)),p=Q(d,this.beta2),f=Pr(u),g=Ha(p,f);c.assign(h),d.assign(g);const m=Ge(Q(wt(s,r),wt(h,Ge(g,this.epsilon))),a);a.assign(m)}),this.iteration.assign(Ge(this.iteration,1)),this.accBeta1.assign(Q(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&Xt(this.accumulatedFirstMoment.map(n=>n.variable)),null!=this.accumulatedWeightedInfNorm&&Xt(this.accumulatedWeightedInfNorm.map(n=>n.variable))}getWeights(){return $e(function*(){throw new Error("getWeights() is not implemented for Adamax yet.")})()}setWeights(n){return $e(function*(){throw new Error("setWeights() is not implemented for Adamax yet.")})()}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(n,e){return new n(e.learningRate,e.beta1,e.beta2,e.epsilon,e.decay)}}class l1 extends Ga{static get className(){return"SGD"}constructor(n){super(),this.learningRate=n,this.setLearningRate(n)}applyGradients(n){(Array.isArray(n)?n.map(r=>r.name):Object.keys(n)).forEach((r,s)=>{const o=Array.isArray(n)?n[s].tensor:n[r];if(null==o)return;const i=J.registeredVariables[r];he(()=>{const a=Ge(Q(this.c,o),i);i.assign(a)})}),this.incrementIterations()}setLearningRate(n){this.learningRate=n,null!=this.c&&this.c.dispose(),this.c=Ei(Lt(-n))}dispose(){this.c.dispose()}getWeights(){var n=this;return $e(function*(){return[yield n.saveIterations()]})()}setWeights(n){var e=this;return $e(function*(){if(0!==(n=yield e.extractIterations(n)).length)throw new Error("SGD optimizer does not have settable weights.")})()}getConfig(){return{learningRate:this.learningRate}}static fromConfig(n,e){return new n(e.learningRate)}}class AP extends l1{static get className(){return"Momentum"}constructor(n,e,r=!1){super(n),this.learningRate=n,this.momentum=e,this.useNesterov=r,this.accumulations=[],this.m=Lt(this.momentum)}applyGradients(n){(Array.isArray(n)?n.map(r=>r.name):Object.keys(n)).forEach((r,s)=>{const o=J.registeredVariables[r];null==this.accumulations[s]&&(this.accumulations[s]={originalName:`${r}/momentum`,variable:he(()=>dn(o).variable(!1))});const i=this.accumulations[s].variable,a=Array.isArray(n)?n[s].tensor:n[r];null!=a&&he(()=>{let l;const u=Ge(Q(this.m,i),a);l=Ge(Q(this.c,this.useNesterov?Ge(a,Q(u,this.m)):u),o),i.assign(u),o.assign(l)})}),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&Xt(this.accumulations.map(n=>n.variable))}setMomentum(n){this.momentum=n}getWeights(){var n=this;return $e(function*(){return[yield n.saveIterations()].concat(n.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))})()}setWeights(n){var e=this;return $e(function*(){n=yield e.extractIterations(n),e.accumulations=n.map(s=>({originalName:s.name,variable:s.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(n,e){return new n(e.learningRate,e.momentum,e.useNesterov)}}class RP extends Ga{static get className(){return"RMSProp"}constructor(n,e=.9,r=0,s=null,o=!1){if(super(),this.learningRate=n,this.decay=e,this.momentum=r,this.epsilon=s,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=o,null==s&&(this.epsilon=J.backend.epsilon()),null==n)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(n){(Array.isArray(n)?n.map(r=>r.name):Object.keys(n)).forEach((r,s)=>{const o=J.registeredVariables[r],i=!1;null==this.accumulatedMeanSquares[s]&&(this.accumulatedMeanSquares[s]={originalName:`${r}/rms`,variable:he(()=>dn(o).variable(i))}),null==this.accumulatedMoments[s]&&(this.accumulatedMoments[s]={originalName:`${r}/momentum`,variable:he(()=>dn(o).variable(i))}),null==this.accumulatedMeanGrads[s]&&this.centered&&(this.accumulatedMeanGrads[s]={originalName:`${r}/mg`,variable:he(()=>dn(o).variable(i))});const a=Array.isArray(n)?n[s].tensor:n[r];if(null==a)return;const l=this.accumulatedMeanSquares[s].variable,u=this.accumulatedMoments[s].variable;he(()=>{const c=Ge(Q(l,this.decay),Q(Pn(a),1-this.decay));if(this.centered){const d=this.accumulatedMeanGrads[s].variable,h=Ge(Q(d,this.decay),Q(a,1-this.decay)),p=wt(Q(a,this.learningRate),ms(gt(c,Ge(Pn(h),this.epsilon)))),f=Ge(Q(u,this.momentum),p);l.assign(c),d.assign(h),u.assign(f);const g=gt(o,f);o.assign(g)}else{const d=Ge(Q(l,this.decay),Q(Pn(a),1-this.decay)),h=Ge(Q(u,this.momentum),wt(Q(a,this.learningRate),ms(Ge(d,this.epsilon))));l.assign(d),u.assign(h);const p=gt(o,h);o.assign(p)}})}),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&Xt(this.accumulatedMeanSquares.map(n=>n.variable)),null!=this.accumulatedMeanGrads&&this.centered&&Xt(this.accumulatedMeanGrads.map(n=>n.variable)),null!=this.accumulatedMoments&&Xt(this.accumulatedMoments.map(n=>n.variable))}getWeights(){var n=this;return $e(function*(){const e=[...n.accumulatedMeanSquares,...n.accumulatedMoments];return n.centered&&e.push(...n.accumulatedMeanGrads),[yield n.saveIterations()].concat(e.map(r=>({name:r.originalName,tensor:r.variable})))})()}setWeights(n){var e=this;return $e(function*(){n=yield e.extractIterations(n);const r=e.centered?n.length/3:n.length/2,s=!1;e.accumulatedMeanSquares=n.slice(0,r).map(o=>({originalName:o.name,variable:o.tensor.variable(s)})),e.accumulatedMoments=n.slice(r,2*r).map(o=>({originalName:o.name,variable:o.tensor.variable(s)})),e.centered&&(e.accumulatedMeanGrads=n.slice(2*r,3*r).map(o=>({originalName:o.name,variable:o.tensor.variable(s)})))})()}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(n,e){return new n(e.learningRate,e.decay,e.momentum,e.epsilon,e.centered)}}const aQ=[TP,kP,EP,NP,AP,RP,l1];function FP(t){return new Promise(n=>setTimeout(n)).then(t)}let u1=(()=>{class t{constructor(e){if(!pe().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(t.URL_SCHEME)&&(e=e.slice(t.URL_SCHEME.length)),(null==e||0===e.length)&&(e="model"),this.modelJsonFileName=e+".json",this.weightDataFileName=e+".weights.bin"}save(e){var r=this;return $e(function*(){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const s=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const i=gP(e,[{paths:["./"+r.weightDataFileName],weights:e.weightSpecs}]),a=window.URL.createObjectURL(new Blob([JSON.stringify(i)],{type:"application/json"})),l=null==r.modelJsonAnchor?document.createElement("a"):r.modelJsonAnchor;if(l.download=r.modelJsonFileName,l.href=a,yield FP(()=>l.dispatchEvent(new MouseEvent("click"))),null!=e.weightData){const u=null==r.weightDataAnchor?document.createElement("a"):r.weightDataAnchor;u.download=r.weightDataFileName,u.href=s,yield FP(()=>u.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:Qy(e)}}})()}}return t.URL_SCHEME="downloads://",t})();function OP(t,n,e,r){(function i(l){R(null!=l&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")})(t),function a(l,u){R(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),R(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${u}`),R(u>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${u}`)}(e=e??0,r=r??1);let s=0;return Promise.all(t.map(l=>(l.then(u=>{const c=e+ ++s/t.length*(r-e);return n(c),u}),l)))}function PP(t,n){return c1.apply(this,arguments)}function c1(){return(c1=$e(function*(t,n){null==n&&(n={});const e=null==n.fetchFunc?pe().platform.fetch:n.fetchFunc,r=t.map(d=>e(d,n.requestInit,{isBinary:!0})),a=(null==n.onProgress?yield Promise.all(r):yield OP(r,n.onProgress,0,.5)).map(d=>d.arrayBuffer());return null==n.onProgress?yield Promise.all(a):yield OP(a,n.onProgress,.5,1)})).apply(this,arguments)}Zn.registerSaveRouter(t=>pe().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(u1.URL_SCHEME)?function fQ(t="model"){return new u1(t)}(t.slice(u1.URL_SCHEME.length)):null);let MP=(()=>{class t{constructor(e,r){if(this.DEFAULT_METHOD="POST",null==r&&(r={}),this.weightPathPrefix=r.weightPathPrefix,this.onProgress=r.onProgress,this.weightUrlConverter=r.weightUrlConverter,null!=r.fetchFunc?(R("function"==typeof r.fetchFunc,()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=r.fetchFunc):this.fetch=pe().platform.fetch,R(null!=e&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&R(2===e.length,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,null!=r.requestInit&&null!=r.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=r.requestInit||{}}save(e){var r=this;return $e(function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const s=Object.assign({method:r.DEFAULT_METHOD},r.requestInit);s.body=new FormData;const i=gP(e,[{paths:["./model.weights.bin"],weights:e.weightSpecs}]);s.body.append("model.json",new Blob([JSON.stringify(i)],{type:"application/json"}),"model.json"),null!=e.weightData&&s.body.append("model.weights.bin",new Blob([e.weightData],{type:"application/octet-stream"}),"model.weights.bin");const a=yield r.fetch(r.path,s);if(a.ok)return{modelArtifactsInfo:Qy(e),responses:[a]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${a.status}.`)})()}load(){var e=this;return $e(function*(){const r=yield e.fetch(e.path,e.requestInit);if(!r.ok)throw new Error(`Request to ${e.path} failed with status code ${r.status}. Please verify this URL points to the model JSON of the model to load.`);let s;try{s=yield r.json()}catch{let l=`Failed to parse model JSON of response from ${e.path}.`;throw e.path.endsWith(".pb")?l+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":l+=" Please make sure the server is serving valid JSON for this request.",new Error(l)}if(null==s.modelTopology&&null==s.weightsManifest)throw new Error(`The JSON from HTTP path ${e.path} contains neither model topology or manifest for weights.`);return yP(s,a=>e.loadWeights(a))})()}loadWeights(e){var r=this;return $e(function*(){const s=Array.isArray(r.path)?r.path[1]:r.path,[o,i]=function vQ(t){const n=t.lastIndexOf("/"),e=t.lastIndexOf("?");return[t.substring(0,n)+"/",e>n?t.substring(e):""]}(s),a=r.weightPathPrefix||o,l=function SZ(t){const n=[];for(const e of t)n.push(...e.weights);return n}(e),u=[],c=[];for(const h of e)for(const p of h.paths)null!=r.weightUrlConverter?c.push(r.weightUrlConverter(p)):u.push(a+p+i);return r.weightUrlConverter&&u.push(...yield Promise.all(c)),[l,YC(yield PP(u,{requestInit:r.requestInit,fetchFunc:r.fetch,onProgress:r.onProgress}))]})()}}return t.URL_SCHEME_REGEX=/^https?:\/\//,t})();function $P(t){return null!=t.match(MP.URL_SCHEME_REGEX)}const LP=(t,n)=>{if(typeof fetch>"u"&&(null==n||null==n.fetchFunc))return null;{let e=!0;if(e=Array.isArray(t)?t.every(r=>$P(r)):$P(t),e)return VP(t,n)}return null};function VP(t,n){return new MP(t,n)}let Zl;Zn.registerSaveRouter(LP),Zn.registerLoadRouter(LP);const TQ=te({fromPixels_:function zP(t,n=3){if(n>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==t)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let e=!1,r=!1,s=!1,o=!1,i=!1,a=!1;if(t.data instanceof Uint8Array)e=!0;else if(typeof ImageData<"u"&&t instanceof ImageData)r=!0;else if(typeof HTMLVideoElement<"u"&&t instanceof HTMLVideoElement)s=!0;else if(typeof HTMLImageElement<"u"&&t instanceof HTMLImageElement)o=!0;else if(null!=t.getContext)i=!0;else{if(!(typeof ImageBitmap<"u"&&t instanceof ImageBitmap))throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${t.constructor.name}`);a=!0}if(null!=LC(MC,J.backendName))return J.runKernel(MC,{pixels:t},{numChannels:n});const[u,c]=s?[t.videoWidth,t.videoHeight]:[t.width,t.height];let d,h;if(i)d=t.getContext("2d").getImageData(0,0,u,c).data;else if(r||e)d=t.data;else if(o||s||a){if(null==Zl)if(typeof document>"u"){if(!(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u"))throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");Zl=new OffscreenCanvas(1,1).getContext("2d")}else Zl=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});Zl.canvas.width=u,Zl.canvas.height=c,Zl.drawImage(t,0,0,u,c),d=Zl.getImageData(0,0,u,c).data}if(4===n)h=new Int32Array(d);else{const f=u*c;h=new Int32Array(f*n);for(let g=0;g<f;g++)for(let m=0;m<n;++m)h[g*n+m]=d[4*g+m]}return function _Q(t,n,e){if(P_(t),null!=n&&3!==n.length)throw new Error("tensor3d() requires shape to have three numbers");const r=Op(t,e);if(3!==r.length&&1!==r.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===r.length&&null==n)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Pp(t,n,r,e)}(h,[c,u,n],"int32")}}),m1=-2,kQ=-1;function g1(t,n,e){const r=t.shape.length;R(r===n.length,()=>`Error in slice${r}D: Length of begin ${n} must match the rank of the array (${r}).`),R(r===e.length,()=>`Error in slice${r}D: Length of size ${e} must match the rank of the array (${r}).`);for(let s=0;s<r;++s)R(n[s]+e[s]<=t.shape[s],()=>`Error in slice${r}D: begin[${s}] + size[${s}] (${n[s]+e[s]}) would overflow input.shape[${s}] (${t.shape[s]})`)}function EQ(t){const n=[];let e=0;for(;t>0;)1&t&&n.push(e),t/=2,e++;return n}function y1(t,n,e){const r=[];for(let s=0;s<t.length;s++)r[s]=Math.ceil((n[s]-t[s])/e[s]);return r}function UP(t,n,e,r){const s=[...t];for(let o=s.length;o<r.length;o++)s.push(1);for(let o=0;o<e;o++)0===o?s[n]=1:(s.splice(n,0,1),s.pop());return s}function WP(t,n,e){return e<=t?e:e-(n-1)}function GP(t,n){const e=[];for(let r=0;r<t;r++)e.push(n+r);return e}function NQ(t,n,e,r,s,o,i,a,l){const u=t.length;let c=new Array(u),d=new Array(u),h=new Array(u);if(n.length&&e>0){const p=n[0],f=e+1;c=HP(i,p,f,r,t),d=jP(a,p,f,s,t),h=UP(o,p,f,t)}else for(let p=0;p<u;p++)c[p]=KP(i,r,o,t,p,l),d[p]=XP(a,s,o,t,p,l),h[p]=qP(o,p,l);return{begin:c,end:d,strides:h}}function HP(t,n,e,r,s){const o=[...s],i=GP(e,n);for(let a=0;a<o.length;a++)if(i.indexOf(a)>-1)o[a]=0;else{const l=WP(n,e,a);let u=r[l];t&1<<l&&(u=0),o[a]=u}return o}function jP(t,n,e,r,s){const o=[...s],i=GP(e,n);for(let a=0;a<o.length;a++)if(i.indexOf(a)>-1)o[a]=Number.MAX_SAFE_INTEGER;else{const l=WP(n,e,a);let u=r[l];t&1<<l&&(u=Number.MAX_SAFE_INTEGER),o[a]=u}for(let a=0;a<o.length;a++)o[a]<0&&(o[a]+=s[a]),o[a]=Ul(0,o[a],s[a]);return o}function qP(t,n,e){let r=t[n];return(e&1<<n||null==r)&&(r=1),r}function KP(t,n,e,r,s,o){let i=n[s];(t&1<<s||o&1<<s||null==i)&&(i=(e[s]||1)>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const l=r[s];return i<0&&(i+=l),i=Ul(0,i,l-1),i}function XP(t,n,e,r,s,o){let i=n[s];const a=e[s]||1;(t&1<<s||o&1<<s||null==i)&&(i=a>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const l=r[s];return i<0&&(i+=l),i=a>0?Ul(0,i,l):Ul(-1,i,l-1),i}function v1(t,n,e){let r=e.length;for(let s=0;s<e.length;s++)if(e[s]>1){r=s;break}for(let s=r+1;s<e.length;s++)if(n[s]>0||e[s]!==t[s])return!1;return!0}function b1(t,n){let e=t.length>0?t[t.length-1]:1;for(let r=0;r<t.length-1;r++)e+=t[r]*n[r];return e}function nv(t,n,e){let r;const s=t.shape.length;let o;return r="number"==typeof n?[n,...new Array(s-1).fill(0)]:n.length<s?n.concat(new Array(s-n.length).fill(0)):n.slice(),r.forEach(i=>{R(-1!==i,()=>"slice() does not support negative begin indexing.")}),o=null==e?new Array(s).fill(-1):"number"==typeof e?[e,...new Array(s-1).fill(-1)]:e.length<s?e.concat(new Array(s-e.length).fill(-1)):e,o=o.map((i,a)=>i>=0?i:(R(-1===i,()=>`Negative size values should be exactly -1 but got ${i} for the slice() size at index ${a}.`),t.shape[a]-r[a])),[r,o]}function x1(t,n,e,r,s,o,i,a,l){let u;if(null==r?(u=new Array(n.length),u.fill(1)):u=r,null!=i&&i&i-1)throw new Error("Multiple ellipses in slice is not allowed.");let c=!1;const d={dims:u.length,numAddAxisAfterEllipsis:0,begin:n.slice(),end:e.slice(),strides:u.slice(),beginMask:s,endMask:o,ellipsisMask:i,newAxisMask:a,shrinkAxisMask:l};for(let b=0;b<d.dims;b++)c&&1<<b&a&&d.numAddAxisAfterEllipsis++,1<<b&i&&(c=!0);c||(d.ellipsisMask|=1<<d.dims,d.dims++);const h={dims:t.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function AQ(t,n){n.beginMask=0,n.endMask=0,n.shrinkAxisMask=0;let e=0;n.beginValid=null!=t.begin,n.endValid=null!=t.end,n.begin=new Array(n.dims),n.end=new Array(n.dims),n.strides=new Array(n.dims),n.finalShapeGatherIndices=[],n.finalShapeGatherIndicesSparse=[],n.inputShapeGatherIndicesSparse=new Array(n.dims);for(let r=0;r<t.dims;r++)if(1<<r&t.ellipsisMask){const s=Math.min(n.dims-(t.dims-r)+1+t.numAddAxisAfterEllipsis,n.dims);for(;e<s;e++)n.begin[e]=0,n.end[e]=0,n.strides[e]=1,n.beginMask|=1<<e,n.endMask|=1<<e,n.finalShapeGatherIndices.push(e),n.finalShapeGatherIndicesSparse.push(-1),n.inputShapeGatherIndicesSparse[e]=r}else if(1<<r&t.newAxisMask)n.finalShapeGatherIndices.push(m1),n.finalShapeGatherIndicesSparse.push(-1);else{if(e===n.begin.length)throw Error(`Index out of range using input dim ${e}; input has only ${n.dims} dims, ${n.begin.length}.`);null!=t.begin&&(n.begin[e]=t.begin[r]),null!=t.end&&(n.end[e]=t.end[r]),n.strides[e]=t.strides[r],t.beginMask&1<<r&&(n.beginMask|=1<<e),t.endMask&1<<r&&(n.endMask|=1<<e),t.shrinkAxisMask&1<<r?(n.finalShapeGatherIndices.push(kQ),n.finalShapeGatherIndicesSparse.push(-1),n.shrinkAxisMask|=1<<e):(n.finalShapeGatherIndices.push(e),n.finalShapeGatherIndicesSparse.push(r)),n.inputShapeGatherIndicesSparse[e]=r,e++}}(d,h);let p=!0,f=!0,g=!0;const m=[],y=[];for(let b=0;b<t.length;++b){if(0===h.strides[b])throw Error(`strides[${b}] must be non-zero`);const x=!!(h.shrinkAxisMask&1<<b),w=t[b];if(-1===w){m.push(x?1:-1);continue}const k=[h.beginMask&1<<b,h.endMask&1<<b],V=[h.strides[b]>0?0:-1,h.strides[b]>0?w:w-1];if(x&&h.strides[b]<=0)throw Error("only stride 1 allowed on non-range indexing.");g=g&&1===h.strides[b];const z=!!(h.beginMask&1<<b&&h.endMask&1<<b);if(h.beginValid&&h.endValid){if(x){const fe=h.begin[b]<0?w+h.begin[b]:h.begin[b];if(h.begin[b]=fe,h.end[b]=h.begin[b]+1,fe<0||fe>=w)throw Error(`slice index ${h.begin[b]} of dimension ${b} out of bounds.`)}else h.begin[b]=YP(h.begin[b],0,h.strides[b],w,k,V),h.end[b]=YP(h.end[b],1,h.strides[b],w,k,V);const se=1===h.strides[b]&&0===h.begin[b]&&h.end[b]===w;p=p&&se,f=f&&(0===b&&1===h.strides[b]||se)}else p=p&&1===h.strides[b]&&z,f=f&&(0===b&&1===h.strides[b]||z);let K,Y=!1;if(h.beginValid&&h.endValid?(K=h.end[b]-h.begin[b],Y=!0):x?(K=1,Y=!0):z&&w>=0&&(K=h.strides[b]<0?-w:w,Y=!0),Y){let se;se=0===K||K<0!=h.strides[b]<0?0:Math.trunc(K/h.strides[b])+(K%h.strides[b]!=0?1:0),m.push(se)}else m.push(-1)}for(let b=0;b<h.finalShapeGatherIndices.length;++b){const x=h.finalShapeGatherIndices[b];x>=0?y.push(m[x]):x===m1&&y.push(1)}return{finalShapeSparse:y.filter((b,x)=>h.finalShapeGatherIndices[x]!==m1),finalShape:y,isIdentity:p,sliceDim0:f,isSimpleSlice:g,begin:h.begin,end:h.end,strides:h.strides}}function YP(t,n,e,r,s,o){if(s[n])return e>0?o[n]:o[n+1&1];{const i=t<0?r+t:t;return i<o[0]?o[0]:i>o[1]?o[1]:i}}const ZP=te({all_:function FQ(t,n=null,e=!1){const s={x:$(t,"x","all","bool")};return J.runKernel("All",s,{axis:n,keepDims:e})}}),w1=te({any_:function OQ(t,n=null,e=!1){const s={x:$(t,"x","any","bool")};return J.runKernel("Any",s,{axis:n,keepDims:e})}}),Lp=te({argMax_:function PQ(t,n=0){const r={x:$(t,"x","argMax")};return J.runKernel(Bg,r,{axis:n})}});function Vp(t,n,e,r,s="NHWC",o){return Mr(t,[...n,t[3]],e,o,r,null,null,da(s))}function Ro(t,n,e,r,s,o,i="channelsLast"){const[a,l]=Bp(n);let u;if("channelsLast"===i)u=[a,l,t[3],t[3]];else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);u=[a,l,t[1],t[1]]}return Mr(t,u,e,r,s,o,!1,i)}function ca(t,n,e,r,s,o,i="NDHWC"){const[a,l,u]=C1(n);let c,d;if("NDHWC"===i)d="channelsLast",c=[a,l,u,t[4],t[4]];else{if("NCDHW"!==i)throw new Error(`Unknown dataFormat ${i}`);d="channelsFirst",c=[a,l,u,t[1],t[1]]}return ja(t,c,e,r,s,!1,d,o)}function Mr(t,n,e,r,s,o,i=!1,a="channelsLast"){let[l,u,c,d]=[-1,-1,-1,-1];if("channelsLast"===a)[l,u,c,d]=t;else{if("channelsFirst"!==a)throw new Error(`Unknown dataFormat ${a}`);[l,d,u,c]=t}const[h,p,,f]=n,[g,m]=Bp(e),[y,v]=Bp(r),b=$c(h,y),x=$c(p,v),{padInfo:w,outHeight:k,outWidth:V}=function LQ(t,n,e,r,s,o,i,a,l){let u,c,d;if("number"==typeof t){u={top:t,bottom:t,left:t,right:t,type:0===t?"VALID":"NUMBER"};const p=function MQ(t,n,e,r,s){null==r&&(r=_1(t,n,e));const i=t[1];return[zp((t[0]-n+2*r)/e+1,s),zp((i-n+2*r)/e+1,s)]}([n,e],o,r,t,a);c=p[0],d=p[1]}else if("same"===t){c=Math.ceil(n/r),d=Math.ceil(e/s);const h=Math.max(0,(c-1)*r+o-n),p=Math.max(0,(d-1)*s+i-e),f=Math.floor(h/2),g=h-f,m=Math.floor(p/2);u={top:f,bottom:g,left:m,right:p-m,type:"SAME"}}else if("valid"===t)u={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((n-o+1)/r),d=Math.ceil((e-i+1)/s);else{if("object"!=typeof t)throw Error(`Unknown padding parameter: ${t}`);{const h="channelsLast"===l?t[1][0]:t[2][0],p="channelsLast"===l?t[1][1]:t[2][1],f="channelsLast"===l?t[2][0]:t[3][0],g="channelsLast"===l?t[2][1]:t[3][1];u={top:h,bottom:p,left:f,right:g,type:0===h&&0===p&&0===f&&0===g?"VALID":"EXPLICIT"},c=zp((n-o+h+p)/r+1,a),d=zp((e-i+f+g)/s+1,a)}}return{padInfo:u,outHeight:c,outWidth:d}}(s,u,c,g,m,b,x,o,a),z=i?f*d:f;let K;return"channelsFirst"===a?K=[l,z,k,V]:"channelsLast"===a&&(K=[l,k,V,z]),{batchSize:l,dataFormat:a,inHeight:u,inWidth:c,inChannels:d,outHeight:k,outWidth:V,outChannels:z,padInfo:w,strideHeight:g,strideWidth:m,filterHeight:h,filterWidth:p,effectiveFilterHeight:b,effectiveFilterWidth:x,dilationHeight:y,dilationWidth:v,inShape:t,outShape:K,filterShape:n}}function ja(t,n,e,r,s,o=!1,i="channelsLast",a){let[l,u,c,d,h]=[-1,-1,-1,-1,-1];if("channelsLast"===i)[l,u,c,d,h]=t;else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);[l,h,u,c,d]=t}const[p,f,g,,m]=n,[y,v,b]=C1(e),[x,w,k]=C1(r),V=$c(p,x),z=$c(f,w),K=$c(g,k),{padInfo:Y,outDepth:se,outHeight:fe,outWidth:ve}=function VQ(t,n,e,r,s,o,i,a,l,u,c){let d,h,p,f;if("valid"===t&&(t=0),"number"==typeof t){d={top:t,bottom:t,left:t,right:t,front:t,back:t,type:0===t?"VALID":"NUMBER"};const m=function $Q(t,n,e,r,s,o){null==s&&(s=_1(t,n[0],r[0]));const i=[0,0,0,e];for(let a=0;a<3;a++)t[a]+2*s>=n[a]&&(i[a]=zp((t[a]-n[a]+2*s)/r[a]+1,o));return i}([n,e,r,1],[a,l,u],1,[s,o,i],t,c);h=m[0],p=m[1],f=m[2]}else{if("same"!==t)throw Error(`Unknown padding parameter: ${t}`);{h=Math.ceil(n/s),p=Math.ceil(e/o),f=Math.ceil(r/i);const g=(h-1)*s+a-n,m=(p-1)*o+l-e,y=(f-1)*i+u-r,v=Math.floor(g/2),b=g-v,x=Math.floor(m/2),w=m-x,k=Math.floor(y/2);d={top:x,bottom:w,left:k,right:y-k,front:v,back:b,type:"SAME"}}}return{padInfo:d,outDepth:h,outHeight:p,outWidth:f}}(s,u,c,d,y,v,b,V,z,K,a),be=o?m*h:m;let xe;return"channelsFirst"===i?xe=[l,be,se,fe,ve]:"channelsLast"===i&&(xe=[l,se,fe,ve,be]),{batchSize:l,dataFormat:i,inDepth:u,inHeight:c,inWidth:d,inChannels:h,outDepth:se,outHeight:fe,outWidth:ve,outChannels:be,padInfo:Y,strideDepth:y,strideHeight:v,strideWidth:b,filterDepth:p,filterHeight:f,filterWidth:g,effectiveFilterDepth:V,effectiveFilterHeight:z,effectiveFilterWidth:K,dilationDepth:x,dilationHeight:w,dilationWidth:k,inShape:t,outShape:xe,filterShape:n}}function _1(t,n,e,r=1){const s=$c(n,r);return Math.floor((t[0]*(e-1)-e+s)/2)}function Bp(t){return"number"==typeof t?[t,t,t]:2===t.length?[t[0],t[1],1]:t}function C1(t){return"number"==typeof t?[t,t,t]:t}function $c(t,n){return n<=1?t:t+(t-1)*(n-1)}function zp(t,n){if(!n)return Math.trunc(t);switch(n){case"round":return Math.round(t);case"ceil":return Math.ceil(t);case"floor":return Math.floor(t);default:throw new Error(`Unknown roundingMode ${n}`)}}function qa(t){const[n,e,r]=Bp(t);return 1===n&&1===e&&1===r}function Gr(t,n){return qa(t)||qa(n)}function Ql(t){return Bp(t).every(n=>n>0)}function da(t){if("NHWC"===t)return"channelsLast";if("NCHW"===t)return"channelsFirst";throw new Error(`Unknown dataFormat ${t}`)}function gs(t,n,e){if(null!=e){if("string"==typeof n)throw Error(`Error in ${t}: pad must be an integer when using dimRoundingMode ${e} but got pad ${n}.`);if("number"==typeof n)R(_c(n),()=>`Error in ${t}: pad must be an integer when using dimRoundingMode ${e} but got pad ${n}.`);else{if("object"!=typeof n)throw Error(`Error in ${t}: Unknown padding parameter: ${n}`);n.forEach(r=>{r.forEach(s=>{R(_c(s),()=>`Error in ${t}: pad must be an integer when using dimRoundingMode ${e} but got pad ${s}.`)})})}}}const re=te({reshape_:function BQ(t,n){const r={x:$(t,"x","reshape","string_or_numeric")};return J.runKernel(Dy,r,{shape:n})}}),S1=te({avgPool_:function zQ(t,n,e,r,s){const o=$(t,"x","avgPool","float32");R(Gr(e,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${e} and dilations '1'`);let a=o,l=!1;3===o.rank&&(l=!0,a=re(o,[1,o.shape[0],o.shape[1],o.shape[2]])),R(4===a.rank,()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`),gs("avgPool",r,s);let d=J.runKernel(Ug,{x:a},{filterSize:n,strides:e,pad:r,dimRoundingMode:s});return d=it(d,o.dtype),l?re(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),WQ=te({avgPool3d_:function UQ(t,n,e,r,s,o="NDHWC"){const i=$(t,"x","avgPool3d","float32");let a=i,l=!1;4===i.rank&&(l=!0,a=re(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),R(5===a.rank,()=>`Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`),R("NDHWC"===o,()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`),R("number"==typeof e&&e>0||Array.isArray(e)&&e[0]>0&&e[1]>0&&e[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${e}'`),gs("avgPool3d",r,s);let d=J.runKernel(Wg,{x:a},{filterSize:n,strides:e,pad:r,dimRoundingMode:s,dataFormat:o});return d=it(d,a.dtype),l?re(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});function GQ(t){let n;return n=0===t.rank||1===t.rank?re(t,[1,1,1,t.size]):2===t.rank?re(t,[1,1,t.shape[0],t.shape[1]]):3===t.rank?re(t,[1,t.shape[0],t.shape[1],t.shape[2]]):t,n}const rv=te({batchNorm_:function HQ(t,n,e,r,s,o){null==o&&(o=.001);const i=$(t,"x","batchNorm"),a=$(n,"mean","batchNorm"),l=$(e,"variance","batchNorm");let u,c;null!=s&&(u=$(s,"scale","batchNorm")),null!=r&&(c=$(r,"offset","batchNorm")),R(a.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),R(null==c||a.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),R(null==u||a.rank===u.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const h={x:GQ(i),scale:u,offset:c,mean:a,variance:l},f=J.runKernel(ny,h,{varianceEpsilon:o});return re(f,i.shape)}}),qQ=te({batchNorm2d_:function jQ(t,n,e,r,s,o){const i=$(t,"x","batchNorm"),a=$(n,"mean","batchNorm"),l=$(e,"variance","batchNorm");let u,c;return null!=s&&(u=$(s,"scale","batchNorm")),null!=r&&(c=$(r,"offset","batchNorm")),R(2===i.rank,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`),R(2===a.rank||1===a.rank,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${a.rank}.`),R(2===l.rank||1===l.rank,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),null!=u&&R(2===u.rank||1===u.rank,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`),null!=c&&R(2===c.rank||1===c.rank,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`),rv(i,a,l,c,u,o)}}),XQ=te({batchNorm3d_:function KQ(t,n,e,r,s,o){const i=$(t,"x","batchNorm"),a=$(n,"mean","batchNorm"),l=$(e,"variance","batchNorm");let u,c;return null!=s&&(u=$(s,"scale","batchNorm")),null!=r&&(c=$(r,"offset","batchNorm")),R(3===i.rank,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`),R(3===a.rank||1===a.rank,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${a.rank}.`),R(3===l.rank||1===l.rank,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),null!=u&&R(3===u.rank||1===u.rank,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`),null!=c&&R(3===c.rank||1===c.rank,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`),rv(i,a,l,c,u,o)}}),ZQ=te({batchNorm4d_:function YQ(t,n,e,r,s,o){const i=$(t,"x","batchNorm"),a=$(n,"mean","batchNorm"),l=$(e,"variance","batchNorm");let u,c;return null!=s&&(u=$(s,"scale","batchNorm")),null!=r&&(c=$(r,"offset","batchNorm")),R(4===i.rank,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`),R(4===a.rank||1===a.rank,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${a.rank}.`),R(4===l.rank||1===l.rank,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),null!=u&&R(4===u.rank||1===u.rank,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`),null!=c&&R(4===c.rank||1===c.rank,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`),rv(i,a,l,c,u,o)}}),Up=te({broadcastTo_:function QQ(t,n){let e=$(t,"broadcastTo","x");const r=e.shape;if(la(n),n.length<e.rank)throw new Error(`broadcastTo(): shape.length=${n.length} < input.rank=${e.rank}.`);if(n.length>e.rank){const u=e.shape.slice();for(;u.length<n.length;)u.unshift(1);e=re(e,u)}const s=e.shape,o=Array.from(n);for(let u=n.length-1;u>=0;u--)if(s[u]===n[u])o[u]=1;else if(1!==e.shape[u])throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${n}].`);return 0===o.map((u,c)=>u>1?c:-1).filter(u=>u>=0).length?Yl(e):J.runKernel(kp,{x:e},{reps:o})}}),uo=te({clipByValue_:function JQ(t,n,e){const r=$(t,"x","clipByValue");return R(n<=e,()=>`Error in clip: min (${n}) must be less than or equal to max (${e}).`),n===e?$p(r.shape,n,r.dtype):J.runKernel(Gh,{x:r},{clipValueMin:n,clipValueMax:e})}}),rs=te({concat_:function eJ(t,n=0){R(t.length>=1,()=>"Pass at least one tensor to concat");const e=dP(t,"tensors","concat","string_or_numeric");return"complex64"===e[0].dtype&&e.forEach(o=>{if("complex64"!==o.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${o.dtype}. `)}),1===e.length?Yl(e[0]):J.runKernel(qg,e,{axis:n})}}),nJ=te({concat1d_:function tJ(t){return rs(t,0)}}),sJ=te({concat2d_:function rJ(t,n){return rs(t,n)}}),iJ=te({concat3d_:function oJ(t,n){return rs(t,n)}}),lJ=te({concat4d_:function aJ(t,n){return rs(t,n)}}),Jl=te({conv2d_:function uJ(t,n,e,r,s="NHWC",o=[1,1],i){const a=$(t,"x","conv2d","float32"),l=$(n,"filter","conv2d","float32");let u=a,c=!1;3===a.rank&&(c=!0,u=re(a,[1,a.shape[0],a.shape[1],a.shape[2]])),R(4===u.rank,()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`),R(4===l.rank,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),gs("conv2d",r,i);const d="NHWC"===s?u.shape[3]:u.shape[1];R(d===l.shape[2],()=>`Error in conv2d: depth of input (${d}) must match input depth for filter ${l.shape[2]}.`),R(Gr(e,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${o}'`),R(Ql(o),()=>"Error in conv2D: Dilated rates should be larger than 0."),R(Ql(e),()=>"Error in conv2D: Strides should be larger than 0.");const f=J.runKernel(Kg,{x:u,filter:l},{strides:e,pad:r,dataFormat:s,dilations:o,dimRoundingMode:i});return c?re(f,[f.shape[1],f.shape[2],f.shape[3]]):f}}),QP=te({conv1d_:function cJ(t,n,e,r,s="NWC",o=1,i){const a=$(t,"x","conv1d"),l=$(n,"filter","conv1d");let u=a,c=!1;2===a.rank&&(c=!0,u=re(a,[1,a.shape[0],a.shape[1]])),R(3===u.rank,()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`),R(3===l.rank,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),gs("conv1d",r,i),R(u.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`),R(Gr(e,o),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${e} and dilation '${o}'`),R(Ql(o),()=>"Error in conv1D: Dilated rates should be larger than 0."),R(Ql(e),()=>"Error in conv1D: Stride should be larger than 0."),R("NWC"===s,()=>`Error in conv1d: got dataFormat of ${s} but only NWC is currently supported.`);const d=re(l,[1,l.shape[0],l.shape[1],l.shape[2]]),h=re(u,[u.shape[0],1,u.shape[1],u.shape[2]]),m=Jl(h,d,[1,e],r,"NHWC",[1,o],i);return re(m,c?[m.shape[2],m.shape[3]]:[m.shape[0],m.shape[2],m.shape[3]])}}),I1=te({conv2DBackpropInput_:function dJ(t,n,e,r,s,o="NHWC",i){R(t.length===n.rank,()=>`Length of inShape (${t.length}) and rank of dy (${n.rank}) must match`);let a=t,l=n,u=!1;3===n.rank&&(u=!0,l=re(n,[1,n.shape[0],n.shape[1],n.shape[2]]),a=[1,t[0],t[1],t[2]]),R(4===a.length,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`),R(4===l.rank,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),R(4===e.rank,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${e.rank}`);const c="NHWC"===o?a[3]:a[1],d="NHWC"===o?l.shape[3]:l.shape[1];R(c===e.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${e.shape[2]}.`),R(d===e.shape[3],()=>`Error in conv2dDerInput: depth of output (${d}) must match output depth for filter ${e.shape[3]}.`),gs("conv2dDerInput",s,i);const f=J.runKernel(Xg,{dy:l,filter:e},{strides:r,pad:s,dataFormat:o,dimRoundingMode:i,inputShape:a});return u?re(f,[f.shape[1],f.shape[2],f.shape[3]]):f}}),JP=te({conv2dTranspose_:function hJ(t,n,e,r,s,o){const i=$(t,"x","conv2dTranspose"),a=$(n,"filter","conv2dTranspose");return I1(e,i,a,r,s,"NHWC",o)}}),fJ=te({conv3d_:function pJ(t,n,e,r,s="NDHWC",o=[1,1,1]){const i=$(t,"x","conv3d"),a=$(n,"filter","conv3d");let l=i,u=!1;4===i.rank&&(u=!0,l=re(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),R(5===l.rank,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),R(5===a.rank,()=>`Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`),R(l.shape[4]===a.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${a.shape[3]}.`),R(Gr(e,o),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${e} and dilations '${o}'`),R("NDHWC"===s,()=>`Error in conv3d: got dataFormat of ${s} but only NDHWC is currently supported.`),R(Ql(o),()=>"Error in conv3D: Dilated rates should be larger than 0."),R(Ql(e),()=>"Error in conv3D: Strides should be larger than 0.");const h=J.runKernel(Yg,{x:l,filter:a},{strides:e,pad:r,dataFormat:s,dilations:o});return u?re(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}}),eM=te({conv3DBackpropInput_:function mJ(t,n,e,r,s){R(t.length===n.rank,()=>`Length of inShape (${t.length}) and rank of dy (${n.rank}) must match`);let o=t,i=n,a=!1;4===n.rank&&(a=!0,i=re(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]]),o=[1,t[0],t[1],t[2],t[3]]);const l=o[4],u=i.shape[4];R(5===o.length,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${o.length}.`),R(5===i.rank,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`),R(5===e.rank,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${e.rank}`),R(l===e.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${e.shape[3]}.`),R(u===e.shape[4],()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${e.shape[4]}.`);const h=J.runKernel(J_,{dy:i,filter:e},{pad:s,strides:r,inputShape:o});return a?re(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}}),yJ=te({conv3dTranspose_:function gJ(t,n,e,r,s){const o=$(t,"x","conv3dTranspose"),i=$(n,"filter","conv3dTranspose");return eM(e,o,i,r,s)}}),tM=te({denseBincount_:function vJ(t,n,e,r=!1){const s=$(t,"x","denseBincount"),o=$(n,"weights","denseBincount");return R("int32"===s.dtype,()=>`Error in denseBincount: input dtype must be int32, but got ${s.dtype}`),R(s.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${s.rank}.`),R(e>=0,()=>`size must be non-negative, but got ${e}.`),R(o.size===s.size||0===o.size,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${s.shape}, weights shape: ${o.shape}.`),J.runKernel(nC,{x:s,weights:o},{size:e,binaryOutput:r})}}),sv=te({depthwiseConv2d_:function bJ(t,n,e,r,s="NHWC",o=[1,1],i){const a=$(t,"x","depthwiseConv2d","float32"),l=$(n,"filter","depthwiseConv2d","float32");let u=a,c=!1;3===a.rank&&(c=!0,u=re(a,[1,a.shape[0],a.shape[1],a.shape[2]])),R(4===u.rank,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`),R(4===l.rank,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);const d="NHWC"===s?u.shape[3]:u.shape[1];R(d===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${d}) must match the inChannels dimension in filter ${l.shape[2]}.`),gs("depthwiseConv2d",r,i);const f=J.runKernel(Qg,{x:u,filter:l},{strides:e,pad:r,dataFormat:s,dilations:o,dimRoundingMode:i});return c?re(f,[f.shape[1],f.shape[2],f.shape[3]]):f}}),ov=te({elu_:function xJ(t){const e={x:$(t,"x","elu","float32")};return J.runKernel(Kh,e)}}),Ni=te({equal_:function wJ(t,n){let e=$(t,"a","equal","string_or_numeric"),r=$(n,"b","equal","string_or_numeric");return[e,r]=rr(e,r),Vt(e.shape,r.shape),J.runKernel(ey,{a:e,b:r})}}),Fo=te({exp_:function _J(t){const e={x:$(t,"x","exp")};return J.runKernel(Yh,e)}}),Gs=te({expandDims_:function CJ(t,n=0){const e=$(t,"x","expandDims","string_or_numeric");return R(n<=e.rank,()=>"Axis must be <= rank of the tensor"),J.runKernel(ty,{input:e},{dim:n})}}),ti=te({tile_:function SJ(t,n){const e=$(t,"x","tile","string_or_numeric");return R(e.rank===n.length,()=>`Error in transpose: rank of input ${e.rank} must match length of reps ${n}.`),J.runKernel(kp,{x:e},{reps:n})}}),nM=te({eye_:function IJ(t,n,e,r="float32"){null==n&&(n=t);const s=en([t,n],r),o=t<=n?t:n;for(let a=0;a<o;++a)s.set(1,a,a);const i=re(s.toTensor(),[t,n]);if(null==e)return i;if(1===e.length)return ti(Gs(i,0),[e[0],1,1]);if(2===e.length)return ti(Gs(Gs(i,0),0),[e[0],e[1],1,1]);if(3===e.length)return ti(Gs(Gs(Gs(i,0),0),0),[e[0],e[1],e[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${e.length}D.`)}}),iv=te({floor_:function DJ(t){const e={x:$(t,"x","floor","float32")};return J.runKernel(Qh,e)}}),D1=te({gather_:function TJ(t,n,e=0,r=0){const s=$(t,"x","gather"),o=$(n,"indices","gather","int32");return J.runKernel(ry,{x:s,indices:o},{axis:e,batchDims:r})}}),co=te({greater_:function kJ(t,n){let e=$(t,"a","greater","string_or_numeric"),r=$(n,"b","greater","string_or_numeric");return[e,r]=rr(e,r),Vt(e.shape,r.shape),J.runKernel(sy,{a:e,b:r})}}),eu=te({greaterEqual_:function EJ(t,n){let e=$(t,"a","greaterEqual","string_or_numeric"),r=$(n,"b","greaterEqual","string_or_numeric");return[e,r]=rr(e,r),Vt(e.shape,r.shape),J.runKernel(ep,{a:e,b:r})}}),T1=te({leakyRelu_:function NJ(t,n=.2){const r={x:$(t,"x","leakyRelu")};return J.runKernel(oy,r,{alpha:n})}}),Oo=te({log_:function AJ(t){const e={x:$(t,"x","log","float32")};return J.runKernel(op,e)}}),k1=te({log1p_:function RJ(t){const e={x:$(t,"x","log1p")};return J.runKernel(ip,e)}}),ni=te({max_:function FJ(t,n=null,e=!1){const s={x:$(t,"x","max")};return J.runKernel(hy,s,{reductionIndices:n,keepDims:e})}}),yt=te({sum_:function OJ(t,n=null,e=!1){let r=$(t,"x","sum");return"bool"===r.dtype&&(r=it(r,"int32")),J.runKernel(Ry,{x:r},{axis:n,keepDims:e})}}),rM=te({logSoftmax_:function PJ(t,n=-1){const e=$(t,"logits","logSoftmax");if(-1===n&&(n=e.rank-1),n!==e.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and axis was ${n}`);return ua((s,o)=>{const a=ni(s,n,!0),l=gt(s,a),u=gt(it(l,"float32"),Oo(yt(Fo(l),n,!0)));return o([u]),{value:u,gradFunc:(d,h)=>{const[p]=h,g=Fo(p);return gt(d,Q(yt(d,n,!0),g))}}})(e)}}),ha=te({logicalAnd_:function MJ(t,n){const e=$(t,"a","logicalAnd","bool"),r=$(n,"b","logicalAnd","bool");return Vt(e.shape,r.shape),J.runKernel(ly,{a:e,b:r})}}),yn=te({matMul_:function $J(t,n,e=!1,r=!1){let s=$(t,"a","matMul"),o=$(n,"b","matMul");return[s,o]=rr(s,o),J.runKernel(Gg,{a:s,b:o},{transposeA:e,transposeB:r})}}),E1=te({maxPool_:function LJ(t,n,e,r,s){const o=$(t,"x","maxPool");let a=o,l=!1;3===o.rank&&(l=!0,a=re(o,[1,o.shape[0],o.shape[1],o.shape[2]])),R(4===a.rank,()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`),R(Gr(e,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${e} and dilations '1'`),gs("maxPool",r,s);const d=J.runKernel(py,{x:a},{filterSize:n,strides:e,pad:r,dimRoundingMode:s});return l?re(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),BJ=te({maxPool3d_:function VJ(t,n=[1,1,1],e,r,s,o="NDHWC"){const i=$(t,"x","maxPool3d");let a=i,l=!1;4===i.rank&&(l=!0,a=re(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),R(5===a.rank,()=>`Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`),R("NDHWC"===o,()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`),gs("maxPool3d",r,s);const d=J.runKernel(fy,{x:a},{filterSize:n,strides:e,pad:r,dimRoundingMode:s,dataFormat:o});return l?re(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}}),hr=te({mean_:function zJ(t,n=null,e=!1){const s={x:$(t,"x","mean")};return J.runKernel(my,s,{axis:n,keepDims:e})}}),av=te({min_:function UJ(t,n=null,e=!1){const s={x:$(t,"x","min")};return J.runKernel(gy,s,{axis:n,keepDims:e})}}),Lc=te({minimum_:function WJ(t,n){let e=$(t,"a","minimum"),r=$(n,"b","minimum");return[e,r]=rr(e,r),"bool"===e.dtype&&(e=it(e,"int32"),r=it(r,"int32")),Vt(e.shape,r.shape),J.runKernel(lp,{a:e,b:r})}});function N1(t,n){for(let e=0;e<t.length;++e)if(t[t.length-e-1]!==n-1-e)return!1;return!0}function sM(t,n,e){const r=t.length+n.length,s=[];let o=0,i=0;for(let a=0;a<r;a++)-1===e.indexOf(a)?s.push(t[o++]):s.push(n[i++]);return s}function $r(t,n){const e=[],r=t.length;for(let o=0;o<r;o++)-1===n.indexOf(o)&&e.push(t[o]);return[e,n.map(o=>t[o])]}function pr(t,n){return sM(t,n.map(r=>1),n)}function Hr(t,n,e){R(N1(n,e),()=>`${t} supports only inner-most axes for now. Got axes ${n} and rank-${e} input.`)}function Qn(t,n){if(N1(t,n))return null;const e=[];for(let r=0;r<n;++r)-1===t.indexOf(r)&&e.push(r);return t.forEach(r=>e.push(r)),e}function Ka(t){return t.map((n,e)=>[e,n]).sort((n,e)=>n[1]-e[1]).map(n=>n[0])}function fr(t,n){const e=[];for(let r=n-t;r<n;++r)e.push(r);return e}const A1=te({moments_:function GJ(t,n=null,e=!1){const r=Jt(n,(t=$(t,"x","moments")).shape),s=hr(t,r,e);let o=s.shape;e||(o=pr(s.shape,r));const i=Pn(gt(it(t,"float32"),re(s,o)));return{mean:s,variance:hr(i,r,e)}}}),Hn=te({neg_:function HJ(t){const e={x:$(t,"x","neg")};return J.runKernel(vy,e)}}),Wp=te({notEqual_:function jJ(t,n){let e=$(t,"a","notEqual","string_or_numeric"),r=$(n,"b","notEqual","string_or_numeric");return[e,r]=rr(e,r),Vt(e.shape,r.shape),J.runKernel(by,{a:e,b:r})}}),oM=te({oneHot_:function qJ(t,n,e=1,r=0,s="int32"){if(n<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${n}`);const i={indices:$(t,"indices","oneHot","int32")};return J.runKernel(wy,i,{dtype:s,depth:n,onValue:e,offValue:r})}});function Lr(t,n="float32"){if(la(t),"complex64"===n){const r=Lr(t,"float32"),s=Lr(t,"float32");return ql(r,s)}const e=ns(_e(t),n);return J.makeTensor(e,t,n)}function Xa(t,n="float32"){if(la(t),"complex64"===n){const r=Xa(t,"float32"),s=Lr(t,"float32");return ql(r,s)}const e=B_(_e(t),n);return J.makeTensor(e,t,n)}const Po=te({onesLike_:function KJ(t){const e={x:$(t,"x","onesLike")};return J.runKernel(xy,e)}}),R1=te({pad_:function XJ(t,n,e=0){const r=$(t,"x","pad");if(0===r.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");return J.runKernel(Cy,{x:r},{paddings:n,constantValue:e})}}),F1=te({prelu_:function YJ(t,n){const e=$(t,"x","prelu"),r=$(n,"alpha","prelu");return J.runKernel(Sy,{x:e,alpha:r})}});var O1=ne(340);class P1{constructor(n,e,r,s,o){this.mean=n,this.stdDev=e,this.dtype=r,this.nextVal=NaN,this.truncated=s,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const i=o||Math.random();this.random=O1.alea(i.toString())}nextValue(){if(!isNaN(this.nextVal)){const s=this.nextVal;return this.nextVal=NaN,s}let n,e,r=!1;for(;!r;){let s,o,i;do{s=2*this.random()-1,o=2*this.random()-1,i=s*s+o*o}while(i>=1||0===i);const a=Math.sqrt(-2*Math.log(i)/i);n=this.mean+this.stdDev*s*a,e=this.mean+this.stdDev*o*a,(!this.truncated||this.isValidTruncated(n))&&(r=!0)}return(!this.truncated||this.isValidTruncated(e))&&(this.nextVal=this.convertValue(e)),this.convertValue(n)}convertValue(n){return null==this.dtype||"float32"===this.dtype?n:Math.round(n)}isValidTruncated(n){return n<=this.upper&&n>=this.lower}}class ZJ{constructor(n=0,e=1,r,s){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=n,this.range=e-n,this.dtype=r,null==s&&(s=Math.random()),"number"==typeof s&&(s=s.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${n} - ${e} <= 1 and dtype is not float`);this.random=O1.alea(s)}convertValue(n){return this.canReturnFloat()?n:Math.round(n)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const nee=te({randomNormal_:function tee(t,n=0,e=1,r,s){if(la(t),null!=r&&"bool"===r)throw new Error(`Unsupported data type ${r}`);const o=new P1(n,e,r,!1,s),i=en(t,r);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}}),lv=te({randomUniform_:function ree(t,n=0,e=1,r="float32",s){la(t);const o=en(t,r),i=new ZJ(n,e,null,s);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}});function Gp(t,n,e=1,r="float32"){if(0===e)throw new Error("Cannot have a step of zero");return J.runKernel(xC,{},{start:t,stop:n,step:e,dtype:r})}const pa=te({relu_:function see(t){const e={x:$(t,"x","relu")};return J.runKernel(pp,e)}}),tu=te({reverse_:function oee(t,n){const r={x:$(t,"x","reverse")};return J.runKernel(Ey,r,{dims:n})}}),iM=te({selu_:function iee(t){const e={x:$(t,"x","selu")};return J.runKernel(yp,e)}}),aM=te({separableConv2d_:function aee(t,n,e,r,s,o=[1,1],i="NHWC"){const a=$(t,"x","separableConv2d"),l=$(n,"depthwiseFilter","separableConv2d"),u=$(e,"pointwiseFilter","separableConv2d");let c=a,d=!1;if(3===a.rank&&(d=!0,c=re(a,[1,a.shape[0],a.shape[1],a.shape[2]])),"NCHW"===i)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");R(4===c.rank,()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`),R(4===l.rank,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),R(4===u.rank,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),R(1===u.shape[0],()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`),R(1===u.shape[1],()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`);const h=l.shape[2],p=l.shape[3];R(u.shape[2]===h*p,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${h*p}, but got ${u.shape[2]}.`);const f=sv(c,l,r,s,i,o),m=Jl(f,u,1,"valid",i);return d?re(m,[m.shape[1],m.shape[2],m.shape[3]]):m}}),Vc=te({sigmoid_:function lee(t){const e={x:$(t,"x","sigmoid","float32")};return J.runKernel(wp,e)}}),Tn=te({slice_:function uee(t,n,e){const r=$(t,"x","slice","string_or_numeric");if(0===r.rank)throw new Error("Slicing scalar is not possible");return J.runKernel(Ay,{x:r},{begin:n,size:e})}}),$1=te({slice1d_:function cee(t,n,e){const r=$(t,"x","slice1d");return R(1===r.rank,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),Tn(r,[n],[e])}}),lM=te({slice2d_:function dee(t,n,e){const r=$(t,"x","slice2d");return R(2===r.rank,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),Tn(r,n,e)}}),L1=te({slice3d_:function hee(t,n,e){const r=$(t,"x","slice3d");return R(3===r.rank,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),Tn(r,n,e)}}),uv=te({slice4d_:function pee(t,n,e){const r=$(t,"x","slice4d");return R(4===r.rank,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),Tn(r,n,e)}}),V1=te({softmax_:function fee(t,n=-1){const e=$(t,"logits","softmax","float32");if(-1===n&&(n=e.rank-1),n!==e.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and dim was ${n}`);return J.runKernel(Py,{logits:e},{dim:n})}}),Hp=te({softplus_:function mee(t){const e={x:$(t,"x","softplus")};return J.runKernel(_p,e)}}),ho=te({split_:function gee(t,n,e=0){const s={x:$(t,"x","split")};return J.runKernel(Oy,s,{numOrSizeSplits:n,axis:e})}}),jp=te({squeeze_:function yee(t,n){const e=$(t,"x","squeeze","string_or_numeric");return re(e,La(e.shape,n).newShape)}}),Ya=te({stack_:function vee(t,n=0){const e=dP(t,"tensors","stack","string_or_numeric");return R(e.length>=1,()=>"Pass at least one tensor to tf.stack"),e.length>0&&R(n<=e[0].rank,()=>"Axis must be <= rank of the tensor"),J.runKernel(_y,e,{axis:n})}}),B1=te({tanh_:function bee(t){const e={x:$(t,"x","tanh","float32")};return J.runKernel(Tp,e)}});function Hs(t,n){P_(t);const e=Op(t,n);if(1!==e.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Pp(t,null,e,n)}const uM=te({truncatedNormal_:function xee(t,n=0,e=1,r,s){if(la(t),null!=r&&"bool"===r)throw new Error("Unsupported data type $ { dtype }");const o=new P1(n,e,r,!0,s),i=en(t,r);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}}),nu=te({unstack_:function wee(t,n=0){const e=$(t,"x","unstack","string_or_numeric");return R(n>=-e.shape.length&&n<e.shape.length,()=>`Axis = ${n} is not in [-${e.shape.length}, ${e.shape.length})`),J.runKernel($y,{value:e},{axis:n})}}),ys=te({where_:function Cee(t,n,e){const r=$(n,"a","where"),s=$(e,"b","where"),o=$(t,"condition","where","bool"),i=Vt(Vt(o.shape,r.shape),s.shape),a=Up(o,i),l=Up(r,i),u=Up(s,i);return J.runKernel(Ny,{condition:a,t:l,e:u})}}),z1=te({imag_:function See(t){const e={input:$(t,"input","imag")};return J.runKernel(pC,e)}}),cv=te({real_:function Iee(t){const e={input:$(t,"input","real")};return J.runKernel(wC,e)}}),hn=te({transpose_:function Dee(t,n,e){const r=$(t,"x","transpose");if(null==n&&(n=r.shape.map((i,a)=>a).reverse()),R(r.rank===n.length,()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${n}.`),n.forEach(i=>{R(i>=0&&i<r.rank,()=>`All entries in 'perm' must be between 0 and ${r.rank-1} but got ${n}`)}),r.rank<=1)return r.clone();const s={x:r},o={perm:n};return"complex64"===r.dtype?he(()=>{let i=cv(r),a=z1(r);return i=J.runKernel(Tc,{x:i},o),a=J.runKernel(Tc,{x:a},o),e&&(a=Hn(a)),ql(i,a)}):J.runKernel(Tc,s,o)}}),Eee=te({dropout_:function kee(t,n,e,r){const s=$(t,"x","dropout");if(R("float32"===s.dtype,()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${s.dtype} tensor instead.`),R(n>=0&&n<1,()=>`rate must be a float in the range [0, 1), but got ${n}.`),0===n)return t instanceof dr?s.clone():s;const o=function Tee(t,n){if(null==n)return t.shape.slice();if(gn(t.shape,n))return n;if(t.shape.length===n.length){const e=[];for(let r=0;r<t.shape.length;r++)e.push(null==n[r]&&null!=t.shape[r]?t.shape[r]:n[r]);return e}return n}(s,e),i=1-n,a=wt(iv(Ge(lv(o,0,1,"float32",r),i)),i);return Q(s,a)}}),U1=te({fft_:function Nee(t){return R("complex64"===t.dtype,()=>`The dtype for tf.spectral.fft() must be complex64 but got ${t.dtype}.`),J.runKernel("FFT",{input:t})}}),W1=te({rfft_:function Aee(t,n){R("float32"===t.dtype,()=>`The dtype for rfft() must be real value but got ${t.dtype}`);let e=t.shape[t.shape.length-1];const r=t.size/e;let s;if(null!=n&&n<e){const f=t.shape.map(m=>0),g=t.shape.map(m=>m);g[t.shape.length-1]=n,s=Tn(t,f,g),e=n}else if(null!=n&&n>e){const f=t.shape.map(g=>g);f[t.shape.length-1]=n-e,s=rs([t,Lr(f)],t.shape.length-1),e=n}else s=t;const o=dn(s),i=re(ql(s,o),[r,e]),a=U1(i),l=Math.floor(e/2)+1,u=cv(a),c=z1(a),d=ho(u,[l,e-l],u.shape.length-1),h=ho(c,[l,e-l],c.shape.length-1),p=s.shape.slice();return p[s.shape.length-1]=l,re(ql(d[0],h[0]),p)}}),dv=te({ifft_:function Ree(t){return R("complex64"===t.dtype,()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${t.dtype}.`),J.runKernel(hC,{input:t})}}),cM=te({irfft_:function Fee(t){const n=t.shape[t.shape.length-1],e=t.size/n;let r;if(n<=2){const s=re(t,[e,n]);r=dv(s)}else{const s=[e,2*(n-1)],o=re(cv(t),[e,n]),i=re(z1(t),[e,n]),a=tu(Tn(o,[0,1],[e,n-2]),1),l=Q(tu(Tn(i,[0,1],[e,n-2]),1),Lt(-1)),u=rs([o,a],1),c=rs([i,l],1),d=re(ql(u,c),[s[0],s[1]]);r=dv(d)}if(r=cv(r),3===t.rank&&0!==t.shape[0]){const s=r,o=t.shape[0];r=re(r,[o,r.shape[0]/o,r.shape[1]]),s.dispose()}return r}}),G1=te({conv2DBackpropFilter_:function Oee(t,n,e,r,s,o="NHWC",i){let a=t;3===t.rank&&(a=re(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l=n;3===l.rank&&(l=re(n,[1,n.shape[0],n.shape[1],n.shape[2]])),R(4===a.rank,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`),R(4===l.rank,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),R(4===e.length,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${e}.`);const u="NHWC"===o?a.shape[3]:a.shape[1],c="NHWC"===o?l.shape[3]:l.shape[1];return R(u===e[2],()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${e[2]}.`),R(c===e[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${e[3]}).`),gs("conv2dDerFilter",s,i),J.runKernel(Z_,{x:a,dy:l},{strides:r,pad:s,dataFormat:o,dimRoundingMode:i,filterShape:e})}}),dM=te({relu6_:function Pee(t){const e={x:$(t,"x","relu6")};return J.runKernel(fp,e)}}),qp=te({step_:function Mee(t,n=0){const r={x:$(t,"x","step")};return J.runKernel(Ep,r,{alpha:n})}});function hv(t,n,e){if(null==e||"linear"===e)return t;if("relu"===e)return Q(t,qp(n));throw new Error(`Cannot compute gradient for fused activation ${e}.`)}function pv(t,n){let e=n;const r=Dr(t.shape,n.shape);return r.length>0&&(e=yt(e,r)),re(e,t.shape)}function fv(t,n,e,r){if("linear"===n)return t;if("relu"===n)return pa(t);if("elu"===n)return ov(t);if("relu6"===n)return dM(t);if("prelu"===n)return F1(t,e);if("leakyrelu"===n)return T1(t,r);if("sigmoid"===n)return Vc(t);throw new Error(`Unknown fused activation ${n}.`)}const mv=(t,n)=>!(t>0)||"linear"===n,Lee=te({fusedConv2d_:function $ee({x:t,filter:n,strides:e,pad:r,dataFormat:s="NHWC",dilations:o=[1,1],dimRoundingMode:i,bias:a,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(!1===mv(J.state.gradientDepth,l=l||"linear")){R("NHWC"===s,()=>`Error in fused conv2d: got dataFormat of ${s} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let k=Jl(t,n,e,r,s,o,i);return null!=a&&(k=Ge(k,a)),fv(k,l,u,c)}const d=$(t,"x","conv2d","float32"),h=$(n,"filter","conv2d","float32");let p=d,f=!1;3===d.rank&&(f=!0,p=re(d,[1,d.shape[0],d.shape[1],d.shape[2]])),R(4===p.rank,()=>`Error in fused conv2d: input must be rank 4, but got rank ${p.rank}.`),R(4===h.rank,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${h.rank}.`),gs("fused conv2d",r,i);const g="NHWC"===s?p.shape[3]:p.shape[1];R(h.shape[2]===g,()=>`Error in conv2d: depth of input (${g}) must match input depth for filter ${h.shape[2]}.`),R(Gr(e,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${o}'`);const m=Mr(p.shape,h.shape,e,o,r,i);let y,v;if(null!=a&&(y=$(a,"bias","fused conv2d"),[y]=rr(y,d),"NHWC"===s?Vt(m.outShape,y.shape):(R(y.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${y.shape.length}.`),R(0===y.shape.length||y.shape[0]===m.outChannels||1===y.shape[0],()=>`Error in fused conv2d: bias shape (${y.shape}) is not compatible with the number of output channels (${m.outChannels})`))),null!=u){const k=u.shape;if(R(k.length<=1||3===k.length,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${k.length}.`),1===k.length)R(1===k[0]||k[0]===m.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${k}) is not compatible with the number of output channels (${m.outChannels}).`);else if(3===k.length)try{Vt(k,m.outShape)}catch{throw Error(`Error in fused conv2d: PReLU activation weights (${k}) is not compatible with the output shape of the conv2d (${m.outShape}).`)}v=$(u,"prelu weights","fused conv2d")}const b=(k,V)=>{R("NHWC"===s,()=>`Error in gradient of fused conv2D: got dataFormat of ${s} but only NHWC is currently supported.`);const[z,K,Y,se]=V,fe=hv(k,Y,l);R(qa(o),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${o}'`);const xe=[I1(K.shape,fe,z,e,r),G1(K,fe,z.shape,e,r)];if(null!=se){const De=pv(se,fe);xe.push(De)}return xe},x={x:p,filter:h,bias:y,preluActivationWeights:v},w={strides:e,pad:r,dataFormat:s,dilations:o,dimRoundingMode:i,activation:l,leakyreluAlpha:c};return null==a?ua((V,z,K)=>{let Y=J.runKernel(zy,x,w);return K([z,V,Y]),f&&(Y=re(Y,[Y.shape[1],Y.shape[2],Y.shape[3]])),{value:Y,gradFunc:b}})(p,h):ua((V,z,K,Y)=>{let se=J.runKernel(zy,x,w);return Y([z,V,se,K]),f&&(se=re(se,[se.shape[1],se.shape[2],se.shape[3]])),{value:se,gradFunc:b}})(p,h,y)}}),hM=te({depthwiseConv2dNativeBackpropFilter_:function Vee(t,n,e,r,s,o=[1,1],i){let a=t;3===t.rank&&(a=re(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l=n;return 3===l.rank&&(l=re(n,[1,n.shape[0],n.shape[1],n.shape[2]])),J.runKernel(sC,{x:a,dy:l},{strides:r,pad:s,dimRoundingMode:i,dilations:o,filterShape:e})}}),pM=te({depthwiseConv2dNativeBackpropInput_:function Bee(t,n,e,r,s,o=[1,1],i){let a=n,l=!1;3===n.rank&&(l=!0,a=re(n,[1,n.shape[0],n.shape[1],n.shape[2]]));const d=J.runKernel(oC,{dy:a,filter:e},{strides:r,pad:s,dimRoundingMode:i,dilations:o,inputShape:t});return l?re(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),fM=te({fusedMatMul_:function Uee({a:t,b:n,transposeA:e=!1,transposeB:r=!1,bias:s,activation:o="linear",preluActivationWeights:i,leakyreluAlpha:a=.2}){if(!1===mv(J.state.gradientDepth,o)){let se=yn(t,n,e,r);return null!=s&&(se=Ge(se,s)),fv(se,o,i,a)}let l=$(t,"a","fused matMul"),u=$(n,"b","fused matMul");[l,u]=rr(l,u);const c=e?l.shape[l.rank-2]:l.shape[l.rank-1],d=r?u.shape[u.rank-1]:u.shape[u.rank-2],h=e?l.shape[l.rank-1]:l.shape[l.rank-2],p=r?u.shape[u.rank-2]:u.shape[u.rank-1],f=l.shape.slice(0,-2),g=u.shape.slice(0,-2),m=_e(f),y=_e(g);R(c===d,()=>`Error in fused matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${l.shape} and ${u.shape} and transposeA=${e} and transposeB=${r} must match.`);const b=Vt(l.shape.slice(0,-2),u.shape.slice(0,-2)).concat([h,p]),x=re(l,e?[m,c,h]:[m,h,c]),w=re(u,r?[y,p,d]:[y,d,p]);let k,V;null!=s&&(k=$(s,"bias","fused matMul"),[k]=rr(k,l),Vt(b,k.shape)),null!=i&&(V=$(i,"prelu weights","fused matMul"));const z=(se,fe)=>{const[ve,be,xe,De]=fe,Ne=hv(re(se,xe.shape),xe,o);let we,Ae;return e||r?!e&&r?(we=yn(Ne,be,!1,!1),Ae=yn(Ne,ve,!0,!1)):e&&!r?(we=yn(be,Ne,!1,!0),Ae=yn(ve,Ne,!1,!1)):(we=yn(be,Ne,!0,!0),Ae=yn(Ne,ve,!0,!0)):(we=yn(Ne,be,!1,!0),Ae=yn(ve,Ne,!0,!1)),null!=s?[we,Ae,pv(De,Ne)]:[we,Ae]},K={a:x,b:w,bias:k,preluActivationWeights:V},Y={transposeA:e,transposeB:r,activation:o,leakyreluAlpha:a};return null==s?ua((fe,ve,be)=>{const xe=J.runKernel(By,K,Y);return be([fe,ve,xe]),{value:re(xe,b),gradFunc:z}})(x,w):ua((fe,ve,be,xe)=>{const De=J.runKernel(By,K,Y);return xe([fe,ve,De,be]),{value:re(De,b),gradFunc:z}})(x,w,k)}});function gv(t,n,e){if(P_(t),null!=n&&2!==n.length)throw new Error("tensor2d() requires shape to have two numbers");const r=Op(t,e);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==n)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Pp(t,n,r,e)}const Zee=te({cropAndResize_:function Yee(t,n,e,r,s="bilinear",o=0){const i=$(t,"image","cropAndResize"),a=$(n,"boxes","cropAndResize","float32"),l=$(e,"boxInd","cropAndResize","int32"),u=a.shape[0];return R(4===i.rank,()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`),R(2===a.rank&&4===a.shape[1],()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${a.shape}.`),R(1===l.rank&&l.shape[0]===u,()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${a.shape}.`),R(2===r.length,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),R(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),R("bilinear"===s||"nearest"===s,()=>`method must be bilinear or nearest, but was ${s}`),J.runKernel(tC,{image:i,boxes:a,boxInd:l},{method:s,extrapolationValue:o,cropSize:r})}}),Jee=te({flipLeftRight_:function Qee(t){const n=$(t,"image","flipLeftRight","float32");return R(4===n.rank,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${n.rank}.`),J.runKernel(dC,{image:n},{})}}),tte=te({grayscaleToRGB_:function ete(t){const n=$(t,"image","grayscaleToRGB"),e=n.rank-1,r=n.shape[e];R(n.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${n.rank}.`),R(1===r,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);const s=new Array(n.rank);return s.fill(1,0,e),s[e]=3,ti(n,s)}}),rte=te({rotateWithOffset_:function nte(t,n,e=0,r=.5){const s=$(t,"image","rotateWithOffset","float32");return R(4===s.rank,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${s.rank}.`),J.runKernel($C,{image:s},{radians:n,fillValue:e,center:r})}});function Bc(t,n,e,r,s,o){null==r&&(r=.5),null==s&&(s=Number.NEGATIVE_INFINITY),null==o&&(o=0);const i=t.shape[0];return e=Math.min(e,i),R(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),R(2===t.rank,()=>`boxes must be a 2D tensor, but was of rank '${t.rank}'`),R(4===t.shape[1],()=>`boxes must have 4 columns, but 2nd dimension was ${t.shape[1]}`),R(1===n.rank,()=>"scores must be a 1D tensor"),R(n.shape[0]===i,()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${n.shape[0]}`),R(0<=o&&o<=1,()=>`softNmsSigma must be in [0, 1], but was '${o}'`),{maxOutputSize:e,iouThreshold:r,scoreThreshold:s,softNmsSigma:o}}const ote=te({nonMaxSuppression_:function ste(t,n,e,r=.5,s=Number.NEGATIVE_INFINITY){const o=$(t,"boxes","nonMaxSuppression","float32"),i=$(n,"scores","nonMaxSuppression","float32"),a=Bc(o,i,e,r,s);return J.runKernel(yC,{boxes:o,scores:i},{maxOutputSize:e=a.maxOutputSize,iouThreshold:r=a.iouThreshold,scoreThreshold:s=a.scoreThreshold})}});function ite(t,n,e){const r=function ate(t,n,e){return function ute(t,n,e){let r=0,s=t.length,o=0,i=!1;for(;r<s;){o=r+(s-r>>>1);const a=e(n,t[o]);a>0?r=o+1:(s=o,i=!a)}return i?r:-r-1}(t,n,e||lte)}(t,n,e);t.splice(r<0?-(r+1):r,0,n)}function lte(t,n){return t>n?1:t<n?-1:0}function H1(t,n,e,r,s){return K1(t,n,e,r,s,0)}function j1(t,n,e,r,s,o){return K1(t,n,e,r,s,0,!1,o,!0)}function q1(t,n,e,r,s,o){return K1(t,n,e,r,s,o,!0)}function K1(t,n,e,r,s,o,i=!1,a=!1,l=!1){const u=[];for(let m=0;m<n.length;m++)n[m]>s&&u.push({score:n[m],boxIndex:m,suppressBeginIndex:0});u.sort(vM);const c=o>0?-.5/o:0,d=[],h=[];for(;d.length<e&&u.length>0;){const m=u.pop(),{score:y,boxIndex:v,suppressBeginIndex:b}=m;if(y<s)break;let x=!1;for(let w=d.length-1;w>=b;--w){const k=cte(t,v,d[w]);if(k>=r){x=!0;break}if(m.score=m.score*dte(r,c,k),m.score<=s)break}m.suppressBeginIndex=d.length,x||(m.score===y?(d.push(v),h.push(m.score)):m.score>s&&ite(u,m,vM))}const p=d.length,f=e-p;a&&f>0&&(d.push(...new Array(f).fill(0)),h.push(...new Array(f).fill(0)));const g={selectedIndices:d};return i&&(g.selectedScores=h),l&&(g.validOutputs=p),g}function cte(t,n,e){const r=t.subarray(4*n,4*n+4),s=t.subarray(4*e,4*e+4),o=Math.min(r[0],r[2]),i=Math.min(r[1],r[3]),a=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),u=Math.min(s[0],s[2]),c=Math.min(s[1],s[3]),d=Math.max(s[0],s[2]),h=Math.max(s[1],s[3]),p=(a-o)*(l-i),f=(d-u)*(h-c);if(p<=0||f<=0)return 0;const g=Math.max(o,u),m=Math.max(i,c),y=Math.min(a,d),v=Math.min(l,h),b=Math.max(y-g,0)*Math.max(v-m,0);return b/(p+f-b)}function dte(t,n,e){const r=Math.exp(n*e*e);return e<=t?r:0}function vM(t,n){return t.score-n.score||t.score===n.score&&n.boxIndex-t.boxIndex}function X1(){return(X1=$e(function*(t,n,e,r=.5,s=Number.NEGATIVE_INFINITY){const o=$(t,"boxes","nonMaxSuppressionAsync"),i=$(n,"scores","nonMaxSuppressionAsync"),a=Bc(o,i,e,r,s);e=a.maxOutputSize,r=a.iouThreshold,s=a.scoreThreshold;const l=yield Promise.all([o.data(),i.data()]),u=l[0],c=l[1],{selectedIndices:d}=H1(u,c,e,r,s);return o!==t&&o.dispose(),i!==n&&i.dispose(),Hs(d,"int32")})).apply(this,arguments)}const mte=te({nonMaxSuppressionWithScore_:function fte(t,n,e,r=.5,s=Number.NEGATIVE_INFINITY,o=0){const i=$(t,"boxes","nonMaxSuppression"),a=$(n,"scores","nonMaxSuppression"),l=Bc(i,a,e,r,s,o),d=J.runKernel(bC,{boxes:i,scores:a},{maxOutputSize:e=l.maxOutputSize,iouThreshold:r=l.iouThreshold,scoreThreshold:s=l.scoreThreshold,softNmsSigma:o=l.softNmsSigma});return{selectedIndices:d[0],selectedScores:d[1]}}});function Y1(){return(Y1=$e(function*(t,n,e,r=.5,s=Number.NEGATIVE_INFINITY,o=0){const i=$(t,"boxes","nonMaxSuppressionAsync"),a=$(n,"scores","nonMaxSuppressionAsync"),l=Bc(i,a,e,r,s,o);e=l.maxOutputSize,r=l.iouThreshold,s=l.scoreThreshold,o=l.softNmsSigma;const u=yield Promise.all([i.data(),a.data()]),c=u[0],d=u[1],{selectedIndices:h,selectedScores:p}=q1(c,d,e,r,s,o);return i!==t&&i.dispose(),a!==n&&a.dispose(),{selectedIndices:Hs(h,"int32"),selectedScores:Hs(p)}})).apply(this,arguments)}const bte=te({nonMaxSuppressionPadded_:function vte(t,n,e,r=.5,s=Number.NEGATIVE_INFINITY,o=!1){const i=$(t,"boxes","nonMaxSuppression"),a=$(n,"scores","nonMaxSuppression"),l=Bc(i,a,e,r,s,null),f=J.runKernel(vC,{boxes:i,scores:a},{maxOutputSize:l.maxOutputSize,iouThreshold:l.iouThreshold,scoreThreshold:l.scoreThreshold,padToMaxOutputSize:o});return{selectedIndices:f[0],validOutputs:f[1]}}});function Z1(){return(Z1=$e(function*(t,n,e,r=.5,s=Number.NEGATIVE_INFINITY,o=!1){const i=$(t,"boxes","nonMaxSuppressionAsync"),a=$(n,"scores","nonMaxSuppressionAsync"),l=Bc(i,a,e,r,s,null),u=l.maxOutputSize,c=l.iouThreshold,d=l.scoreThreshold,[h,p]=yield Promise.all([i.data(),a.data()]),{selectedIndices:f,validOutputs:g}=j1(h,p,u,c,d,o);return i!==t&&i.dispose(),a!==n&&a.dispose(),{selectedIndices:Hs(f,"int32"),validOutputs:Lt(g,"int32")}})).apply(this,arguments)}const bM=te({resizeBilinear_:function _te(t,n,e=!1,r=!1){const s=$(t,"images","resizeBilinear");R(3===s.rank||4===s.rank,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${s.rank}.`),R(2===n.length,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${n}.`),R(!1===r||!1===e,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let o=s,i=!1;3===s.rank&&(i=!0,o=re(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const[]=n,u=J.runKernel(ky,{images:o},{alignCorners:e,halfPixelCenters:r,size:n});return i?re(u,[u.shape[1],u.shape[2],u.shape[3]]):u}}),xM=te({resizeNearestNeighbor_:function Cte(t,n,e=!1,r=!1){const s=$(t,"images","resizeNearestNeighbor");R(3===s.rank||4===s.rank,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${s.rank}.`),R(2===n.length,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${n}.`),R("float32"===s.dtype||"int32"===s.dtype,()=>"`images` must have `int32` or `float32` as dtype"),R(!1===r||!1===e,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let o=s,i=!1;3===s.rank&&(i=!0,o=re(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const[]=n,u=J.runKernel(Ty,{images:o},{alignCorners:e,halfPixelCenters:r,size:n});return i?re(u,[u.shape[1],u.shape[2],u.shape[3]]):u}}),Ite=te({bincount_:function Ste(t,n,e){const r=$(t,"x","bincount"),s=$(n,"weights","bincount");return R("int32"===r.dtype,()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),R(e>=0,()=>`size must be non-negative, but got ${e}.`),R(s.size===r.size||0===s.size,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${s.shape}.`),J.runKernel(X_,{x:r,weights:s},{size:e})}}),zc=te({lessEqual_:function Dte(t,n){let e=$(t,"a","lessEqual","string_or_numeric"),r=$(n,"b","lessEqual","string_or_numeric");return[e,r]=rr(e,r),Vt(e.shape,r.shape),J.runKernel(ay,{a:e,b:r})}}),wM=te({round_:function Tte(t){const e={x:$(t,"x","round")};return J.runKernel(mp,e)}}),Nte=te({threshold_:function kte(t,n="binary",e=!1,r=.5){const s=$(t,"image","threshold"),l=s.shape[0]*s.shape[1];let c,d,h,p,u=Q(Hs([r]),255);if(R(3===s.rank,()=>`Error in threshold: image must be rank 3,but got rank ${s.rank}.`),R(3===s.shape[2]||1===s.shape[2],()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${s.shape[2]}.`),R("int32"===s.dtype||"float32"===s.dtype,()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${s.dtype}.`),R("otsu"===n||"binary"===n,()=>`Method must be binary or otsu, but was ${n}`),3===s.shape[2]){[c,d,h]=ho(s,[1,1,1],-1);const m=Q(c,.2989),y=Q(d,.587),v=Q(h,.114);p=Ge(Ge(m,y),v)}else p=t;"otsu"===n&&(u=function Ete(t,n){let o,i,a,l,u,c,e=Hs([-1]),r=Hs([0]),s=Hs([0]);for(let d=0;d<t.size-1;d++){o=Tn(t,0,d+1),i=Tn(t,d+1),u=wt(yt(o),n),c=wt(yt(i),n);const h=yt(Q(o,Gp(0,o.size)));a=wt(h,yt(o));const p=$p(i.shape,o.size),f=Ge(Gp(0,i.size),p),g=Q(i,f);l=wt(yt(g),yt(i));const m=gt(a,l),y=gt(a,l),v=Q(u,c);s=Q(Q(v,m),y);const b=co(s,r);r=ys(b,s,r),e=ys(b,Hs([d]),e)}return e}(Ite(it(wM(p),"int32"),Mp([]),256),l));const f=e?zc(p,u):co(p,u);return it(Q(f,255),"int32")}}),Rte=te({transform_:function Ate(t,n,e="nearest",r="constant",s=0,o){const i=$(t,"image","transform","float32"),a=$(n,"transforms","transform","float32");return R(4===i.rank,()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`),R(2===a.rank&&(a.shape[0]===i.shape[0]||1===a.shape[0])&&8===a.shape[1],()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),R(null==o||2===o.length,()=>`Error in transform: outputShape must be [height, width] or null, but got ${o}.`),J.runKernel(OC,{image:i,transforms:a},{interpolation:e,fillMode:r,fillValue:s,outputShape:o})}}),yv=te({less_:function Fte(t,n){let e=$(t,"a","less","string_or_numeric"),r=$(n,"b","less","string_or_numeric");return[e,r]=rr(e,r),Vt(e.shape,r.shape),J.runKernel(iy,{a:e,b:r})}}),Pte=te({bandPart_:function Ote(t,n,e){const r=$(t,"a","bandPart");R(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);const s=r.shape,[o,i]=r.shape.slice(-2);let a,l;"number"==typeof n?(R(n%1==0,()=>`bandPart(): numLower must be an integer, got ${n}.`),R(n<=o,()=>`bandPart(): numLower (${n}) must not be greater than the number of rows (${o}).`),a=$(n<0?o:n,"numLower","bandPart")):(R("int32"===n.dtype,()=>"bandPart(): numLower's dtype must be an int32."),a=ys(yv(n,0),o,Lc(n,o))),"number"==typeof e?(R(e%1==0,()=>`bandPart(): numUpper must be an integer, got ${e}.`),R(e<=i,()=>`bandPart(): numUpper (${e}) must not be greater than the number of columns (${i}).`),l=$(e<0?i:e,"numUpper","bandPart")):(R("int32"===e.dtype,()=>"bandPart(): numUpper's dtype must be an int32."),l=ys(yv(e,0),i,Lc(e,i)));const u=re(Gp(0,o,1,"int32"),[-1,1]),c=Gp(0,i,1,"int32"),d=gt(u,c),h=ha(zc(d,a),eu(d,Hn(l))),p=Lr([o,i],r.dtype);return re(Ya(nu(re(r,[-1,o,i])).map(f=>ys(h,f,p))),s)}});function _M(t,n,e=null){if(0===t.rank)return Pr(t);if(1!==t.rank&&null===e)return _M(re(t,[-1]),n,e);if(1===t.rank||"number"==typeof e||Array.isArray(e)&&1===e.length){if(1===n)return yt(Pr(t),e);if(n===1/0)return ni(Pr(t),e);if(n===-1/0)return av(Pr(t),e);if("euclidean"===n||2===n)return ms(yt(Pc(Pr(t),Lt(2,"int32")),e));throw new Error(`Error in norm: invalid ord value: ${n}`)}if(Array.isArray(e)&&2===e.length){if(1===n)return ni(yt(Pr(t),e[0]),e[1]-1);if(n===1/0)return ni(yt(Pr(t),e[1]),e[0]);if(n===-1/0)return av(yt(Pr(t),e[1]),e[0]);if("fro"===n||"euclidean"===n)return ms(yt(Pn(t),e));throw new Error(`Error in norm: invalid ord value: ${n}`)}throw new Error(`Error in norm: invalid axis: ${e}`)}const vv=te({norm_:function Mte(t,n="euclidean",e=null,r=!1){const s=_M(t=$(t,"x","norm"),n,e);let o=s.shape;if(r){const i=Jt(e,t.shape);o=pr(s.shape,i)}return re(s,o)}}),Lte=te({gramSchmidt_:function $te(t){let n;if(Array.isArray(t)){n=!1,R(null!=t&&t.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const s=t[0].shape[0];for(let o=1;o<t.length;++o)R(t[o].shape[0]===s,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${t[o].shape[0]} vs. ${s})`)}else n=!0,t=ho(t,t.shape[0],0).map(s=>jp(s,[0]));R(t.length<=t[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${t.length}) exceeds number of dimensions (${t[0].shape[0]}).`);const e=[],r=t;for(let s=0;s<t.length;++s)e.push(J.tidy(()=>{let o=r[s];if(s>0)for(let i=0;i<s;++i){const a=Q(yt(Q(e[i],o)),e[i]);o=gt(o,a)}return wt(o,vv(o,"euclidean"))}));return n?Ya(e,0):e}});function CM(t,n=!1){return J.tidy(()=>{R(2===t.shape.length,()=>`qr2d() requires a 2D Tensor, but got a ${t.shape.length}D Tensor.`);const e=t.shape[0],r=t.shape[1];let s=nM(e),o=Yl(t);const i=gv([[1]],[1,1]);let a=Yl(i);const l=e>=r?r:e;for(let u=0;u<l;++u){const c=o,d=a,h=s;[a,o,s]=J.tidy(()=>{const p=Tn(o,[u,u],[e-u,1]),f=vv(p),g=Tn(o,[u,u],[1,1]),m=ys(co(g,0),gv([[-1]]),gv([[1]])),y=gt(g,Q(m,f)),v=wt(p,y);a=1===v.shape[0]?Yl(i):rs([i,Tn(v,[1,0],[v.shape[0]-1,v.shape[1]])],0);const b=Hn(wt(yn(m,y),f)),x=Tn(o,[u,0],[e-u,r]),w=Q(b,a),k=hn(a);if(0===u)o=gt(x,yn(w,yn(k,x)));else{const K=gt(x,yn(w,yn(k,x)));o=rs([Tn(o,[0,0],[u,r]),K],0)}const V=hn(w),z=Tn(s,[0,u],[e,s.shape[1]-u]);if(0===u)s=gt(z,yn(yn(z,a),V));else{const K=gt(z,yn(yn(z,a),V));s=rs([Tn(s,[0,0],[e,u]),K],1)}return[a,o,s]}),Xt([c,d,h])}return!n&&e>r&&(s=Tn(s,[0,0],[e,r]),o=Tn(o,[0,0],[r,r])),[s,o]})}const Bte=te({qr_:function Vte(t,n=!1){if(R(t.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${t.rank}`),2===t.rank)return CM(t,n);{const e=t.shape.slice(0,t.shape.length-2).reduce((l,u)=>l*u),r=nu(re(t,[e,t.shape[t.shape.length-2],t.shape[t.shape.length-1]]),0),s=[],o=[];return r.forEach(l=>{const[u,c]=CM(l,n);s.push(u),o.push(c)}),[re(Ya(s,0),t.shape),re(Ya(o,0),t.shape)]}}}),SM=te({squaredDifference_:function Qte(t,n){let e=$(t,"a","squaredDifference"),r=$(n,"b","squaredDifference");return[e,r]=rr(e,r),Vt(e.shape,r.shape),J.runKernel(Sp,{a:e,b:r},{})}}),IM=te({logSumExp_:function sne(t,n=null,e=!1){const r=$(t,"x","logSumExp"),s=Jt(n,r.shape),o=ni(r,s,!0),i=gt(r,o),a=Fo(i),l=yt(a,s),u=Oo(l),c=Ge(re(o,u.shape),u);if(e){const d=pr(c.shape,s);return re(c,d)}return c}}),Za={flipLeftRight:Jee,grayscaleToRGB:tte,resizeNearestNeighbor:xM,resizeBilinear:bM,rotateWithOffset:rte,cropAndResize:Zee,nonMaxSuppression:ote,nonMaxSuppressionAsync:function hte(t,n,e){return X1.apply(this,arguments)},nonMaxSuppressionWithScore:mte,nonMaxSuppressionWithScoreAsync:function gte(t,n,e){return Y1.apply(this,arguments)},nonMaxSuppressionPadded:bte,nonMaxSuppressionPaddedAsync:function xte(t,n,e){return Z1.apply(this,arguments)},threshold:Nte,transform:Rte},Sne={bandPart:Pte,gramSchmidt:Lte,qr:Bte},Uc=class Ine{static sgd(n){return new l1(n)}static momentum(n,e,r=!1){return new AP(n,e,r)}static rmsprop(n,e=.9,r=0,s=null,o=!1){return new RP(n,e,r,s,o)}static adam(n=.001,e=.9,r=.999,s=null){return new EP(n,e,r,s)}static adadelta(n=.001,e=.95,r=null){return new TP(n,e,r)}static adamax(n=.002,e=.9,r=.999,s=null,o=0){return new NP(n,e,r,s,o)}static adagrad(n,e=.1){return new kP(n,e)}},Dne=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:t=>t();function DM(){return new Promise(t=>Dne(()=>t()))}function Q1(t,n){const e=t[0].length;t.forEach((s,o)=>{R(s.length===e,()=>`Error in concat${e}D: rank of tensors[${o}] must be the same as the rank of the rest (${e})`)}),R(n>=0&&n<e,()=>`Error in concat${e}D: axis must be between 0 and ${e-1}.`);const r=t[0];t.forEach((s,o)=>{for(let i=0;i<e;i++)R(i===n||s[i]===r[i],()=>`Error in concat${e}D: Shape of tensors[${o}] (${s}) does not match the shape of the rest (${r}) along the non-concatenated axis ${o}.`)})}function Ai(t,n){const e=t[0].slice();for(let r=1;r<t.length;r++)e[n]+=t[r][n];return e}var Mo=(()=>{return(t=Mo||(Mo={}))[t.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",t[t.VALUE_ROWIDS=1]="VALUE_ROWIDS",t[t.ROW_LENGTHS=2]="ROW_LENGTHS",t[t.ROW_SPLITS=3]="ROW_SPLITS",t[t.ROW_LIMITS=4]="ROW_LIMITS",t[t.ROW_STARTS=5]="ROW_STARTS",Mo;var t})();function TM(t,n,e){let r=new Array;if(null==e&&null==n)return r;if(null==n)for(;r.length<t+e.length;)r.push(-1);else r=n.slice();if(null==e)return r;if(t+e.length!==r.length)throw new Error(`rt input.shape and shape=${n} are incompatible: rt input.rank = ${t+e.length}, but shape.rank = ${r.length}`);for(let s=1;s<e.length;++s){const o=e[s],i=r[r.length-e.length+s],a=r[i];if(o>=0)if(a>=0){if(a!==o)throw new Error(`rt input.shape and shape=${n} are incompatible: rt input.shape[${s+t}] = ${o} but shape[${s+t}] = ${a}`)}else r[i]=o}return r}function kM(t){const n={FIRST_DIM_SIZE:Mo.FIRST_DIM_SIZE,VALUE_ROWIDS:Mo.VALUE_ROWIDS,ROW_LENGTHS:Mo.ROW_LENGTHS,ROW_SPLITS:Mo.ROW_SPLITS,ROW_LIMITS:Mo.ROW_LIMITS,ROW_STARTS:Mo.ROW_STARTS},e=[];for(const r of t){if(!(r in n))break;e.push(n[r])}return e}function EM(t){return 0===t.length?0:t[0]===Mo.FIRST_DIM_SIZE?t.length-1:t.length}function NM(t,n){if(null==t||null==n)return;const e=t.length,r=n.length;if(e>=r)throw new Error(`defaultValue.shape=${t} and ragged tensor flatValues.shape=${n}, are incompatible: defaultValue.rank = ${e} must be less than ragged tensor input flatValues.rank = ${r})`);for(let s=0;s<Math.min(e,r-1);++s){const o=t[s],i=n[s+1];if(o>=0&&i>=0&&1!==o&&o!==i)throw new Error(`defaultValue.shape=${t}, and ragged tensor input flatValues.shape=${n} are incompatible: defaultValue.shape[${s-t.length}] = ${o} but ragged tensor input.flatValues.shape[${s-t.length}] = ${i}`)}}const J1=30;function bv(t){return t<=J1?t:V_(t,Math.floor(Math.sqrt(t)))}function eS(t,n,e){return[e*("number"==typeof t?t:t[0]),n*("number"==typeof t?t:t[1])]}function Kp(t,n,e,r=!0){let s=[];if(r)s=s.concat(n.slice(0)),s.push(t[0]/e),s=s.concat(t.slice(1));else{s=s.concat(t[0]);const o=n.length;for(let i=0;i<o;++i)s=s.concat([t[i+1]/n[i],n[i]]);s=s.concat(t.slice(o+1))}return s}function Xp(t,n,e=!0){const r=[];if(e){r.push(n);for(let s=n+1;s<t;++s)s<=2*n?(r.push(s),r.push(s-(n+1))):r.push(s)}else{const s=[],o=[];for(let i=1;i<t;++i)i>=2*n+1||i%2==1?o.push(i):s.push(i);r.push(...s),r.push(0),r.push(...o)}return r}function Yp(t,n,e,r=!0){const s=[];s.push(r?t[0]/e:t[0]*e);for(let o=1;o<t.length;++o)s.push(o<=n.length?r?n[o-1]*t[o]:t[o]/n[o-1]:t[o]);return s}function tS(t,n){const e=[0];for(let r=0;r<n;++r)e.push(t[r][0]);return e}function nS(t,n,e){const r=t.slice(0,1);for(let s=0;s<e;++s)r.push(t[s+1]-n[s][0]-n[s][1]);return r}function rS(t,n){const e=t.shape.length,r=n.shape.length;if(e<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${e}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if("int32"!==n.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${n.dtype}.`);if(n.shape[r-1]>e)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${n.shape[r-1]} vs. ${e}`);if(0===_e(t.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${t.shape}.`);const s=n.shape,o=s[s.length-1];let i=1;for(let d=0;d<s.length-1;++d)i*=s[d];const a=t.shape,l=s.slice();l.pop();let u=1;for(let d=o;d<e;++d)u*=a[d],l.push(a[d]);const c=[...xt(t.shape).map(d=>d/u),1].slice(0,o);return[l,i,u,c]}function AM(t,n,e){const r=n.rank>1?n.shape[n.rank-1]:1,s=n.rank>1?n.rank-1:1,o=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${e.shape}, indices.shape: ${n.shape}, shape: ${t}, sliceDim: ${r}, and batchDim: ${s}.`;if(e.rank<s)throw new Error(o+` update.rank < ${s}. `);if(t.length<r+(e.rank-s))throw new Error(o+` Output shape length < ${r+(e.rank-s)}`);if(e.rank!==s+t.length-r)throw new Error(o+" update.rank != "+(s+t.length-r));for(let i=0;i<s;++i)if(e.shape[i]!==n.shape[i])throw new Error(o+` updates.shape[${i}] (${e.shape[i]}) != indices.shape[${i}] (${n.shape[i]}).`);for(let i=0;i<e.rank-s;++i)if(e.shape[i+s]!==t[i+r])throw new Error(o+` updates.shape[${i+s}] (${e.shape[i+s]}) != shape[${i+s}] (${t[i+s]})`)}function Tne(t,n,e){if(n.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${n.rank}.`);if(t.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${t.rank}.`);if("int32"!==n.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${n.dtype}`);if(e.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${e}`);if(0===e.length){if(0===n.size)throw new Error(`Indices specified for empty output. indices shape: ${n.shape}`);if(0===t.size)throw new Error(`Updates specified for empty output. updates shape: ${t.shape}`)}AM(e,n,t)}function ru(t,n,e){const r=n.shape.length,s=r>1?n.shape[r-1]:1,o=e.length;let i=1;for(let d=s;d<o;++d)i*=e[d];const a=s<1?1:s;return{sliceRank:s,numUpdates:_e(n.shape)/a,sliceSize:i,strides:[...xt(e.slice(0,s)),1],outputSize:_e(e)}}const xv=1.7580993408473768,wv=1.0507009873554805,sS=.3275911,oS=.254829592,iS=-.284496736,aS=1.421413741,lS=-1.453152027,uS=1.061405429;function ma(t,n){if(t.length!==n.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${t.length}, imag: ${n.length}.`);const e=new Float32Array(2*t.length);for(let r=0;r<e.length;r+=2)e[r]=t[r/2],e[r+1]=n[r/2];return e}function RM(t){const n=new Float32Array(t.length/2),e=new Float32Array(t.length/2);for(let r=0;r<t.length;r+=2)n[r/2]=t[r],e[r/2]=t[r+1];return{real:n,imag:e}}function FM(t){const n=Math.ceil(t.length/4),e=new Float32Array(n),r=new Float32Array(n);for(let s=0;s<t.length;s+=4)e[Math.floor(s/4)]=t[s],r[Math.floor(s/4)]=t[s+1];return{real:e,imag:r}}function OM(t){const n=Math.floor(t.length/4),e=new Float32Array(n),r=new Float32Array(n);for(let s=2;s<t.length;s+=4)e[Math.floor(s/4)]=t[s],r[Math.floor(s/4)]=t[s+1];return{real:e,imag:r}}function cS(t,n){return{real:t[2*n],imag:t[2*n+1]}}function PM(t,n,e,r){t[2*r]=n,t[2*r+1]=e}function MM(t,n){const e=new Float32Array(t/2),r=new Float32Array(t/2);for(let s=0;s<Math.ceil(t/2);s++){const o=(n?2:-2)*Math.PI*(s/t);e[s]=Math.cos(o),r[s]=Math.sin(o)}return{real:e,imag:r}}function $M(t,n,e){const r=(e?2:-2)*Math.PI*(t/n);return{real:Math.cos(r),imag:Math.sin(r)}}const dS="->",kne=/->/g,LM=",",VM="...";function hS(t,n){const e=((t=t.replace(/\s/g,"")).length-t.replace(kne,"").length)/dS.length;if(e<1)throw new Error("Equations without an arrow are not supported.");if(e>1)throw new Error(`Equation must contain exactly one arrow ("${dS}").`);const[r,s]=t.split(dS);R(-1===r.indexOf(VM),()=>`The ellipsis notation ("${VM}") is not supported yet.`);const o=r.split(LM),i=o.length;if(n!==i)throw new Error(`Expected ${i} input tensors, received ${n}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const a=[];for(let h=0;h<s.length;++h){const p=s[h];if(!o.some(f=>-1!==f.indexOf(p)))throw new Error(`Output subscripts contain the label ${p} not present in the input subscripts.`);-1===a.indexOf(p)&&a.push(p)}for(let h=0;h<r.length;++h){const p=r[h];-1===a.indexOf(p)&&p!==LM&&a.push(p)}const l=new Array(o.length);for(let h=0;h<i;++h){if(new Set(o[h].split("")).size!==o[h].length)throw new Error(`Found duplicate axes in input component ${o[h]}. Support for duplicate axes in input is not implemented yet.`);l[h]=[];for(let p=0;p<o[h].length;++p)l[h].push(a.indexOf(o[h][p]))}const u=a.length,d=[];for(let h=s.length;h<u;++h)d.push(h);return{allDims:a,summedDims:d,idDims:l}}function pS(t,n){let e=new Array(t);e.fill(-1);for(let s=0;s<n.length;++s)e[n[s]]=s;const r=[];for(let s=0;s<t;++s)-1===e[s]&&r.push(s);return e=e.filter(s=>-1!==s),{permutationIndices:e,expandDims:r}}function fS(t,n,e){const r=new Array(t);for(let s=0;s<e.length;++s){const o=e[s].shape;for(let i=0;i<n[s].length;++i)void 0===r[n[s][i]]?r[n[s][i]]=o[i]:R(r[n[s][i]]===o[i],()=>`Expected dimension ${r[n[s][i]]} at axis ${i} of input shaped ${JSON.stringify(o)}, but got dimension ${o[i]}`)}}function mS(t,n){const e=t,r=[];let s=0;0===t.length&&e.push(-1),s=t.length+1;for(let i=0;i<s;++i)r.push([]);const o=[];for(let i=0;i<e.length;++i){const l=Ene(n,e[i]);for(const u of l)-1===o.indexOf(u)&&(r[i].push(u),o.push(u))}return{path:e,steps:r}}function gS(t){return t.every((n,e)=>n===e)}function Ene(t,n){const e=[];for(let r=0;r<t.length;++r)(0===t[r].length||-1!==t[r].indexOf(n)||-1===n)&&e.push(r);return e}function yS(t,n,e=0){let r=[];if("number"==typeof n)R(t.shape[e]%n==0,()=>"Number of splits must evenly divide the axis."),r=new Array(n).fill(t.shape[e]/n);else{R(n.reduce((i,a)=>(-1===a&&(i+=1),i),0)<=1,()=>"There should be only one negative value in split array.");const o=n.indexOf(-1);if(-1!==o){const i=n.reduce((a,l)=>l>0?a+l:a);n[o]=t.shape[e]-i}R(t.shape[e]===n.reduce((i,a)=>i+a),()=>"The sum of sizes must match the size of the axis dimension."),r=n}return r}function BM(t){return`Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ${t}`}function zM(t,n){return`indices(${t}, 0) is invalid: ${n} < 0`}function UM(t,n,e){return`indices(${t}, 0) is invalid: ${n} >= ${e}`}function WM(t,n){return`only one output dimension may be -1, not both ${t} and ${n}`}function GM(t,n){return`size ${t} must be non-negative, not ${n}`}function HM(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function jM(t,n){return`Input to reshape is a SparseTensor with ${_e(t)}\n  dense values, but the requested shape requires a multiple of ${_e(n)}. inputShape=${t} outputShape= ${n}`}function qM(t,n){return`Input to reshape is a tensor with ${_e(t)} dense values, but the requested shape has ${_e(n)}. inputShape=${t} outputShape=${n}`}function vS(){return"segment ids must be >= 0"}function KM(){return"segment ids are not increasing"}function XM(t,n){return`Segment id ${t} out of range [0, ${n}), possibly because segmentIds input is not sorted.`}function YM(t,n,e){return`Bad: indices[${t}] == ${n} out of range [0, ${e})`}function ZM(t,n){let r,e=!1;for(t<=J1?(r=t,e=!0):r=V_(t,Math.floor(Math.sqrt(t)));!e;)r>n||r===t?e=!0:r=V_(t,r+1);return r}function QM(t,n,e){const r=[],s=t.length;for(let o=0;o<s;o++)r.push(o!==n?t[o]:e);return r}function bS(t,n,e,r){const s=n.shape.length,o=t.shape.length;if(0!==r&&(r<-s||r>s))throw new Error(`Expect batchDims in the range of [-${s}, ${s}], but got ${r}`);if(r<0&&(r+=s),r>o)throw new Error(`batchDims (${r}) must be less than rank(x) (\n    ${o}).`);if(e<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${e}).`);for(let d=0;d<r;++d)if(t.shape[d]!==n.shape[d])throw new Error(`x.shape[${d}]: ${t.shape[d]} should be equal to indices.shape[${d}]: ${n.shape[d]}.`);const i=t.shape[e],a=[];let l=1,u=1,c=1;for(let d=0;d<r;++d)a.push(t.shape[d]),l*=t.shape[d];for(let d=r;d<e;d++)a.push(t.shape[d]),u*=t.shape[d];for(let d=r;d<s;d++)a.push(n.shape[d]);for(let d=e+1;d<o;d++)a.push(t.shape[d]),c*=t.shape[d];return{batchSize:l,sliceSize:c,outerSize:u,dimSize:i,outputShape:a}}function ga(t){try{return t.map(n=>Ua(n))}catch(n){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${n}`)}}function JM(t){return t.map(n=>za(n))}function e$(t,n){const e=[];for(let o=0;o<n.length;o++)n[o]&&e.push(o);const r=en(t,"int32"),s=en([e.length,t.length],"int32");for(let o=0;o<e.length;o++){const i=r.indexToLoc(e[o]);s.values.set(i,o*t.length)}return s.toTensor()}!function lQ(){for(const t of aQ)Ue(t)}();const t$={kernelName:Vg,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>Q(t,qp(it(e,"float32"),-1))}}},Nne={kernelName:Ph,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>{const r=Pn(it(e,"float32")),s=ms(gt(Lt(1),r));return Hn(wt(t,s))}}}},Ane={kernelName:Mh,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>{const r=ms(gt(Pn(it(e,"float32")),1));return wt(t,r)}}}},Rne={kernelName:Dc,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,r]=n,s=Vt(e.shape,r.shape);return{a:()=>{let a=t;const l=Dr(e.shape,s);return l.length>0&&(a=yt(a,l)),re(a,e.shape)},b:()=>{let a=t;const l=Dr(r.shape,s);return l.length>0&&(a=yt(a,l)),re(a,r.shape)}}}},Fne={kernelName:G_,saveAllInputs:!0,gradFunc:(t,n)=>{const e={};return n.forEach((r,s)=>{e[s]=()=>t.clone()}),e}},One={kernelName:Bg,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>dn(e)}}},Pne={kernelName:zg,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>dn(e)}}},Mne={kernelName:$h,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>wt(t,ms(gt(Lt(1),Pn(it(e,"float32")))))}}},$ne={kernelName:Lh,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>{const r=ms(Ge(Lt(1),Pn(it(e,"float32"))));return wt(t,r)}}}},Lne={kernelName:zh,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,r]=n,s=Vt(e.shape,r.shape);return{a:()=>{const a=Ge(Pn(e),Pn(r));let l=Q(t,wt(r,a));const u=Dr(e.shape,s);return u.length>0&&(l=yt(l,u)),re(l,e.shape)},b:()=>{const a=Ge(Pn(e),Pn(r));let l=Hn(Q(t,wt(e,a)));const u=Dr(r.shape,s);return u.length>0&&(l=yt(l,u)),re(l,r.shape)}}}},Vne={kernelName:Vh,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>wt(t,Ge(Pn(it(e,"float32")),1))}}},Bne={kernelName:Bh,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>wt(t,gt(Lt(1),Pn(it(e,"float32"))))}}},Une=te({avgPool3dGrad_:function zne(t,n,e,r,s,o){const i=$(t,"dy","avgPool3dGrad"),a=$(n,"input","avgPool3dGrad");let l=i,u=a,c=!1;4===a.rank&&(c=!0,l=re(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),u=re(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),R(5===l.rank,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),R(5===u.rank,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`),gs("avgPool3dGrad",s,o);const p=J.runKernel(K_,{dy:l,input:u},{filterSize:e,strides:r,pad:s,dimRoundingMode:o});return c?re(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}}),Wne={kernelName:Wg,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[r]=n,{filterSize:s,strides:o,pad:i,dimRoundingMode:a}=e;return{x:()=>Une(t,r,s,o,i,a)}}},Hne=te({avgPoolGrad_:function Gne(t,n,e,r,s){const o=$(t,"dy","avgPoolGrad"),i=$(n,"input","avgPoolGrad");R(i.rank===o.rank,()=>`Rank of input (${i.rank}) does not match rank of dy (${o.rank})`);let a=i,l=o,u=!1;3===i.rank&&(u=!0,a=re(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=re(o,[1,o.shape[0],o.shape[1],o.shape[2]])),R(4===l.rank,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),R(4===a.rank,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${a.rank}.`);const h=J.runKernel(q_,{dy:l,input:a},{filterSize:e,strides:r,pad:s});return u?re(h,[h.shape[1],h.shape[2],h.shape[3]]):h}}),jne={kernelName:Ug,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[r]=n,{filterSize:s,strides:o,pad:i}=e;return{x:()=>Hne(t,r,s,o,i)}}},qne={kernelName:Gg,inputsToSave:["a","b"],gradFunc:(t,n,e)=>{const[r,s]=n,{transposeA:o,transposeB:i}=e;return o||i?!o&&i?{a:()=>yn(t,s,!1,!1),b:()=>yn(t,r,!0,!1)}:o&&!i?{a:()=>yn(s,t,!1,!0),b:()=>yn(r,t,!1,!1)}:{a:()=>yn(s,t,!0,!0),b:()=>yn(t,r,!0,!0)}:{a:()=>yn(t,s,!1,!0),b:()=>yn(r,t,!0,!1)}}},xS=te({spaceToBatchND_:function Kne(t,n,e){const r=$(t,"x","spaceToBatchND");return R(r.rank>=1+n.length,()=>`input rank ${r.rank} should be > than [blockShape] ${n.length}`),R(e.length===n.length,()=>`paddings.shape[0] ${e.length} must be equal to [blockShape] ${n.length}`),R(r.shape.reduce((i,a,l)=>l>0&&l<=n.length?i&&(a+e[l-1][0]+e[l-1][1])%n[l-1]==0:i,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${e.toString()} must be divisible by blockShapes ${n.toString()}`),J.runKernel(Fy,{x:r},{blockShape:n,paddings:e})}}),Xne={kernelName:Hg,gradFunc:(t,n,e)=>{const{blockShape:r,crops:s}=e;return{x:()=>xS(t,r,s)}}},Yne={kernelName:"BroadcastTo",gradFunc:(t,n,e)=>{const s=e.inputShape,o=e.shape,i=Array.from(o);for(let l=s.length-1;l>=0;l--)if(s[l]===o[l])i[l]=1;else if(1!==s[l])throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${o}].`);const a=[];for(let l=0;l<i.length;l++)i[l]>1&&a.push(l);return{x:()=>yt(t,a,!0)}}},Zne={kernelName:Uh,gradFunc:t=>({x:()=>t.clone()})},Qne={kernelName:Wh,gradFunc:t=>({x:()=>dn(t)})},Jne={kernelName:Gh,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[r]=n,{clipValueMin:s,clipValueMax:o}=e;return{x:()=>ys(ha(eu(r,s),zc(r,o)),t,dn(t))}}},ere={kernelName:jg,inputsToSave:["x"],gradFunc:t$.gradFunc},tre={kernelName:qg,saveAllInputs:!0,gradFunc:(t,n,e)=>{const r=n.map(l=>l.shape),{axis:s}=e,o=Jt(s,n[0].shape)[0],i=r.map(l=>l[o]);return ho(t,i,o).map(l=>()=>l)}},nre={kernelName:Kg,inputsToSave:["x","filter"],gradFunc:(t,n,e)=>{const[r,s]=n,{dilations:o,strides:i,pad:a,dataFormat:l}=e;return R(qa(o),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${o}'`),{x:()=>I1(r.shape,t,s,i,a,l),filter:()=>G1(r,t,s.shape,i,a,l)}}},rre={kernelName:Xg,inputsToSave:["dy","filter"],gradFunc:(t,n,e)=>{const[r,s]=n,{strides:o,pad:i,dataFormat:a,dimRoundingMode:l}=e;return{dy:()=>Jl(t,s,o,i,a,1,l),filter:()=>G1(t,r,s.shape,o,i,a,l)}}},ore=te({conv3DBackpropFilter_:function sre(t,n,e,r,s){let o=t;4===t.rank&&(o=re(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]));let i=n;return 4===i.rank&&(i=re(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]])),R(5===o.rank,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${o.shape}.`),R(5===i.rank,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`),R(5===e.length,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${e}.`),R(o.shape[4]===e[3],()=>`Error in conv3dDerFilter: depth of input ${o.shape[4]}) must match input depth in filter (${e[3]}.`),R(i.shape[4]===e[4],()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${e[4]}).`),J.runKernel(Q_,{x:o,dy:i},{strides:r,pad:s,filterShape:e})}}),ire={kernelName:Yg,inputsToSave:["x","filter"],gradFunc:(t,n,e)=>{const{dilations:r,strides:s,pad:o}=e;R(qa(r),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`);const[i,a]=n;return{x:()=>eM(i.shape,t,a,s,o),filter:()=>ore(i,t,a.shape,s,o)}}},n$=te({sin_:function are(t){const e={x:$(t,"x","sin","float32")};return J.runKernel(vp,e)}}),lre={kernelName:Hh,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>Q(Hn(n$(it(e,"float32"))),t)}}},r$=te({sinh_:function ure(t){const e={x:$(t,"x","sinh")};return J.runKernel(bp,e)}}),cre={kernelName:jh,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>Q(r$(it(e,"float32")),t)}}},s$=te({cumsum_:function dre(t,n=0,e=!1,r=!1){const o={x:$(t,"x","cumsum")};return J.runKernel(Zg,o,{axis:n,exclusive:e,reverse:r})}}),hre={kernelName:Zg,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[r]=n,{axis:s,exclusive:o,reverse:i}=e;return{x:()=>{const a=Qn([s],r.rank);let l=s$(t,s,o,!i);return null!=a&&(l=hn(l,a)),l}}}},pre={kernelName:Qg,inputsToSave:["x","filter"],gradFunc:(t,n,e)=>{const{dilations:r,strides:s,pad:o,dimRoundingMode:i}=e,a=r??[1,1];R(qa(a),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);const[l,u]=n;return R(4===l.rank,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),R(4===u.rank,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`),R(l.shape[3]===u.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`),R(Gr(s,a),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${s} and dilations '${a}'.`),gs("depthwiseConv2d",o,i),{x:()=>pM(l.shape,t,u,s,o,a,i),filter:()=>hM(l,t,u.shape,s,o,a,i)}}},fre={kernelName:Jg,inputsToSave:["x","filter"],gradFunc:(t,n,e)=>{const[r,s]=n,o={x:r,filter:s,dy:t},i={x:r,filter:s,dy:t};return{x:()=>J.runKernel(iC,o,e),filter:()=>J.runKernel(aC,i,e)}}},mre={kernelName:Kh,outputsToSave:[!0],gradFunc:(t,n)=>{const[e]=n,r={dy:t,y:e};return{x:()=>J.runKernel(lC,r)}}},gre={kernelName:Xh,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n,r=Q(Fo(Hn(Pn(e))),2/Math.sqrt(Math.PI));return{x:()=>Q(t,r)}}},yre={kernelName:Yh,outputsToSave:[!0],gradFunc:(t,n)=>{const[e]=n;return{x:()=>Q(t,e)}}},vre={kernelName:ty,inputsToSave:["input"],gradFunc:(t,n)=>{const[e]=n;return{input:()=>re(t,e.shape)}}},bre={kernelName:Zh,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>Q(t,Fo(e))}}},xre={kernelName:Qh,gradFunc:t=>({x:()=>dn(t)})},wre={kernelName:Jh,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,r]=n,s=Vt(e.shape,r.shape);return{a:()=>{const a=wt(t,it(r,"float32")),l=Dr(e.shape,s);return l.length>0?re(yt(a,l),e.shape):a},b:()=>{let a=Q(t,it(e,"float32"));const l=Dr(r.shape,s);l.length>0&&(a=re(yt(a,l),r.shape));const u=Pn(r);return Hn(wt(a,it(u,"float32")))}}}},o$=te({rsqrt_:function _re(t){const e={x:$(t,"x","rsqrt","float32")};return J.runKernel(gp,e)}}),Cre={kernelName:ny,inputsToSave:["x","mean","variance","scale"],gradFunc:(t,n,e)=>{const{varianceEpsilon:r}=e,[s,o,i,a]=n,l=a??Lt(1),u=Dr(o.shape,s.shape),c=[];if(1===o.rank){for(let x=0;x<s.shape.length-1;++x)c.push(s.shape[x]);c.push(1)}const d=gt(s,o),h=Q(t,l),p=o$(Ge(i,Lt(r))),f=Q(Q(Q(p,p),p),Lt(-.5));return{x:()=>re(Q(Q(t,1===o.rank?ti(re(p,[1,1,1,o.shape[0]]),c):p),l),s.shape),mean:()=>{let x=Q(Q(p,Lt(-1)),h);return 1===o.rank&&(x=yt(x,u)),re(x,o.shape)},variance:()=>{let x=Q(Q(f,d),h);return 1===o.rank&&(x=yt(x,u)),re(x,o.shape)},scale:()=>{const x=Q(d,p);let w=Q(t,x);return 1===o.rank&&(w=yt(w,u)),re(w,o.shape)},offset:()=>{let x=t;return 1===o.rank&&(x=yt(x,u)),re(x,o.shape)}}}},i$=te({unsortedSegmentSum_:function Sre(t,n,e){const r=$(t,"x","unsortedSegmentSum"),s=$(n,"segmentIds","unsortedSegmentSum","int32");return R(_c(e),()=>"numSegments must be of dtype int"),J.runKernel(Ly,{x:r,segmentIds:s},{numSegments:e})}}),Ire={kernelName:ry,inputsToSave:["x","indices"],gradFunc:(t,n,e)=>{const[r,s]=n,{axis:o}=e,i=Jt(o,r.shape)[0];return{x:()=>{const l=r.shape,u=s.size,c=l.slice(0,i),d=c.length,h=l.slice(o,l.length).slice(1),p=h.length,f=a$(0,d),g=a$(d+1,d+1+p),m=l$([c,[u],h]),y=re(t,m),v=re(s,[u]),b=l$([[d],f,g]),x=hn(y,b);let w=i$(x,v,r.shape[i]);const k=Ka(b);return w=hn(w,k),w},indices:()=>s}}};function a$(t,n){const e=[];for(let r=t;r<n;++r)e.push(r);return e}function l$(t){const n=[];for(let e=0;e<t.length;++e)for(let r=0;r<t[e].length;++r)n.push(t[e][r]);return n}const Dre={kernelName:ep,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,r]=n;return{a:()=>dn(e),b:()=>dn(r)}}},Tre={kernelName:tp,gradFunc:t=>({x:()=>it(t,"float32")})},kre={kernelName:np,gradFunc:t=>({x:()=>dn(t)})},Ere={kernelName:rp,gradFunc:t=>({x:()=>dn(t)})},Nre={kernelName:sp,gradFunc:t=>({x:()=>dn(t)})},Are={kernelName:oy,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[r]=n,{alpha:s}=e,o=co(r,0);return{x:()=>ys(o,t,Q(t,s))}}},Rre={kernelName:ip,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>wt(t,Ge(e,1))}}},Fre={kernelName:op,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>wt(t,it(e,"float32"))}}},Ore={kernelName:"LogSoftmax",inputsToSave:[],outputsToSave:[!0],gradFunc:(t,n,e)=>{const[r]=n,{axis:s}=e;return{logits:()=>{const i=Fo(r);return gt(t,Q(yt(t,s,!0),i))}}}},Mre=te({localResponseNormalizationBackprop_:function Pre(t,n,e,r=5,s=1,o=1,i=.5){return J.runKernel(fC,{x:t,y:n,dy:e},{depthRadius:r,bias:s,alpha:o,beta:i})}}),$re={kernelName:dy,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,n,e)=>{const[r,s]=n,{depthRadius:o,bias:i,alpha:a,beta:l}=e;return{x:()=>Mre(r,s,t,o,i,a,l)}}};function u$(t,n,e,r){return n.rank<e.rank&&(n=re(n,pr(n.shape,r))),t.rank<e.rank&&(t=re(t,pr(t.shape,r))),{x:()=>Q(t,it(Ni(e,n),t.dtype))}}const c$={kernelName:hy,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,n,e)=>{const r=e,{reductionIndices:s}=r,o=n[0],l=u$(t,n[1],o,Jt(s,o.shape));return{x:()=>l.x()}}},Lre={kernelName:ap,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,r]=n;return{a:()=>Q(t,it(eu(e,r),"float32")),b:()=>Q(t,it(yv(e,r),"float32"))}}},Bre=te({maxPool3dGrad_:function Vre(t,n,e,r,s,o,i){const a=$(t,"dy","maxPool3dGrad"),l=$(n,"input","maxPool3dGrad"),u=$(e,"output","maxPool3dGrad");let c=a,d=l,h=u,p=!1;4===l.rank&&(p=!0,c=re(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),d=re(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),h=re(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),R(5===c.rank,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`),R(5===d.rank,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${d.rank}.`),R(5===h.rank,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${h.rank}.`),gs("maxPool3dGrad",o,i);const m=J.runKernel(gC,{dy:c,input:d,output:h},{filterSize:r,strides:s,pad:o,dimRoundingMode:i});return p?re(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}}),zre={kernelName:fy,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,n,e)=>{const[r,s]=n,{filterSize:o,strides:i,pad:a,dimRoundingMode:l}=e;return{x:()=>Bre(t,r,s,o,i,a,l)}}},Wre=te({maxPoolGrad_:function Ure(t,n,e,r,s,o,i){const a=$(t,"dy","maxPoolGrad"),l=$(n,"input","maxPoolGrad"),u=$(e,"output","maxPoolGrad");return R(l.rank===a.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${a.rank})`),R(4===a.rank,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${a.rank}.`),R(4===l.rank,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),gs("maxPoolGrad",o,i),J.runKernel(mC,{dy:a,input:l,output:u},{filterSize:r,strides:s,pad:o,dimRoundingMode:i})}}),Gre={kernelName:py,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,n,e)=>{const[r,s]=n,{filterSize:o,strides:i,pad:a}=e;return{x:()=>Wre(t,r,s,o,i,a)}}},Hre={kernelName:my,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[r]=n,{axis:s}=e,o=Jt(s,r.shape),l=_e($r(r.shape,o)[1]);return{x:()=>{const c=r.shape.slice();o.forEach(p=>{c[p]=1});const d=re(t,c);return wt(Q(d,Xa(r.shape,"float32")),l)}}}},jre={kernelName:gy,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,n,e)=>{const r=e,{axis:s}=r,[o,i]=n,l=u$(t,i,o,Jt(s,o.shape));return{x:()=>l.x()}}},qre={kernelName:lp,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,r]=n;return{a:()=>Q(t,it(zc(e,r),"float32")),b:()=>Q(t,it(co(e,r),"float32"))}}},Kre={kernelName:yy,inputsToSave:["x"],gradFunc:(t,n,e)=>{const r=n[0],{paddings:s}=e,o=s.map(i=>i[0]);return{x:()=>Tn(t,o,r.shape)}}},Xre={kernelName:up,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,r]=n,s=Vt(e.shape,r.shape);return{a:()=>{const a=Dr(e.shape,s);return a.length>0?re(yt(t,a),e.shape):t},b:()=>{const a=Q(t,Hn(iv(wt(e,r)))),l=Dr(r.shape,s);return l.length>0?re(yt(a,l),r.shape):a}}}},Yre={kernelName:cp,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,r]=n,s=Vt(e.shape,r.shape);return{a:()=>{const a=Q(t,it(r,"float32")),l=Dr(e.shape,s);return l.length>0?re(yt(a,l),e.shape):a},b:()=>{const a=Q(t,it(e,"float32")),l=Dr(r.shape,s);return l.length>0?re(yt(a,l),r.shape):a}}}},Zre={kernelName:vy,gradFunc:t=>({x:()=>Hn(t)})},Qre={kernelName:wy,inputsToSave:["indices"],gradFunc:(t,n)=>{const e=n[0];return{indices:()=>Lr(e.shape,"float32")}}},Jre={kernelName:xy,gradFunc:t=>({x:()=>dn(t)})},ese={kernelName:_y,saveAllInputs:!0,gradFunc:(t,n,e)=>{const{axis:r}=e;return nu(t,r).map(o=>()=>o)}},d$={kernelName:Cy,inputsToSave:["x"],gradFunc:(t,n,e)=>{const r=n[0],{paddings:s}=e,o=s.map(i=>i[0]);return{x:()=>Tn(t,o,r.shape)}}},tse={kernelName:dp,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(t,n)=>{const[e,r,s]=n,o=e,i=r,a=Vt(o.shape,i.shape);return{a:()=>{const c=it(i,"float32");let d=Q(t,Q(c,Pc(o,gt(c,Lt(1)))));const h=Dr(o.shape,a);return h.length>0&&(d=yt(d,h)),re(d,o.shape)},b:()=>{const c=co(o,0),d=ys(c,Oo(o),dn(o));let h=Q(t,Q(s,d));const p=Dr(i.shape,a);return p.length>0&&(h=yt(h,p)),re(h,i.shape)}}}},nse={kernelName:Sy,inputsToSave:["x","alpha"],gradFunc:(t,n)=>{const[e,r]=n,s=co(e,0);return{x:()=>ys(s,t,Q(t,r)),alpha:()=>{let o=ys(s,dn(t),Q(t,e));const i=Dr(r.shape,t.shape);return i.length>0&&(o=yt(o,i)),re(o,r.shape)}}}},wS=te({cumprod_:function rse(t,n=0,e=!1,r=!1){const o={x:$(t,"x","cumprod")};return J.runKernel(eC,o,{axis:n,exclusive:e,reverse:r})}});const ise={kernelName:Iy,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[r]=n,{axis:s}=e;let o=[];return o=null==s?r.shape.map((i,a)=>a):"number"==typeof s?[s]:s,{x:()=>function ose(t,n,e){const r=t.shape.length,s=r-e.length,o=Qn(e,r);let i=t;null!=o&&(i=hn(t,o));const a=i.shape.slice(),u=a.splice(r-e.length,e.length).reduce((h,p)=>h*p,1);a.push(u);let d=function sse(t,n,e){const r=t.shape.slice();r[e]=1;const s=re(n,r),o=wS(t,e,!0,!1),i=wS(t,e,!0,!0),a=Q(o,i);return Q(s,a)}(i.reshape(a),n,s);if(d=d.reshape(i.shape),null!=o){const h=Ka(o);d=hn(d,h)}return d}(r,t,o)}}},ase={kernelName:qh,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,r]=n,s=Vt(e.shape,r.shape);return{a:()=>{const a=wt(t,it(r,"float32")),l=Dr(e.shape,s);return l.length>0?re(yt(a,l),e.shape):a},b:()=>{let a=Q(t,it(e,"float32"));const l=Dr(r.shape,s);l.length>0&&(a=re(yt(a,l),r.shape));const u=Pn(r);return Hn(wt(a,it(u,"float32")))}}}},lse={kernelName:hp,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>wt(t,Hn(Pn(e)))}}},use={kernelName:fp,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n,r=Q(zc(e,6),qp(e));return{x:()=>Q(t,it(r,"float32"))}}},cse={kernelName:pp,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>Q(t,it(qp(e),"float32"))}}},dse={kernelName:Dy,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>re(t,e.shape)}}},hse={kernelName:ky,inputsToSave:["images"],gradFunc:(t,n,e)=>{const[r]=n,s={dy:t,images:r};return{images:()=>J.runKernel(CC,s,e)}}},pse={kernelName:Ty,inputsToSave:["images"],gradFunc:(t,n,e)=>{const[r]=n,s={dy:t,images:r};return{images:()=>J.runKernel(_C,s,e)}}},fse={kernelName:Ey,gradFunc:(t,n,e)=>{const{dims:r}=e,s=Jt(r,t.shape);return{x:()=>tu(t,s)}}},mse={kernelName:mp,gradFunc:t=>({x:()=>dn(t)})},gse={kernelName:gp,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>Hn(wt(t,Q(Pc(e,1.5),2)))}}},_S=te({logicalNot_:function yse(t){const e={x:$(t,"x","logicalNot","bool")};return J.runKernel(uy,e)}}),vse={kernelName:Ny,inputsToSave:["condition"],gradFunc:(t,n)=>{const[e]=n;return{condition:()=>it(dn(e),"float32"),t:()=>Q(t,it(e,t.dtype)),e:()=>Q(t,it(_S(e),t.dtype))}}},bse={kernelName:yp,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>{const r=co(e,Lt(0)),s=Lt(xv),o=Lt(wv),i=Q(t,o),a=Q(Q(t,s),Fo(it(e,"float32")));return ys(r,i,a)}}}},xse={kernelName:wp,outputsToSave:[!0],gradFunc:(t,n)=>{const[e]=n;return{x:()=>Q(t,Q(e,gt(Lt(1),e)))}}},wse={kernelName:xp,gradFunc:t=>({x:()=>dn(t)})},CS=te({cos_:function _se(t){const e={x:$(t,"x","cos","float32")};return J.runKernel(Hh,e)}}),Cse={kernelName:vp,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>Q(CS(it(e,"float32")),t)}}},h$=te({cosh_:function Sse(t){const e={x:$(t,"x","cosh","float32")};return J.runKernel(jh,e)}}),Ise={kernelName:bp,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>Q(h$(it(e,"float32")),t)}}},Dse={kernelName:Ay,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[r]=n,{begin:s,size:o}=e,i=r.shape,[a,l]=nv(r,s,o),u=[];for(let c=0;c<t.rank;c++)u.push([a[c],i[c]-a[c]-l[c]]);return{x:()=>R1(t,u)}}},Tse={kernelName:Py,outputsToSave:[!0],gradFunc:(t,n,e)=>{const[r]=n,{dim:s}=e,i=Q(t,r);return{logits:()=>gt(i,Q(yt(i,[s],!0),r))}}},kse={kernelName:_p,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>Q(t,Vc(e))}}},SS=te({batchToSpaceND_:function Ese(t,n,e){const r=$(t,"x","batchToSpaceND"),s=n.reduce((a,l)=>a*l);return R(r.rank>=1+n.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${n.length}`),R(e.length===n.length,()=>`crops.length is ${e.length} but should be equal to blockShape.length  ${n.length}`),R(r.shape[0]%s==0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${n.join(" * ")} === ${s}`),J.runKernel(Hg,{x:r},{blockShape:n,crops:e})}}),p$={kernelName:Fy,gradFunc:(t,n,e)=>{const{blockShape:r,paddings:s}=e;return{x:()=>SS(t,r,s)}}},f$={kernelName:Oy,gradFunc:(t,n,e)=>{const{axis:r}=e;return{x:()=>rs(t,r)}}},Gse=[t$,Nne,Ane,Rne,Fne,One,Pne,Mne,$ne,Lne,Vne,Bne,Wne,jne,qne,Xne,Yne,Zne,Qne,Jne,ere,tre,rre,nre,ire,lre,cre,hre,pre,fre,ase,mre,gre,yre,vre,bre,wre,xre,Cre,Ire,Dre,Tre,kre,Ere,Nre,Are,Rre,Fre,Ore,$re,c$,c$,Lre,zre,Gre,Hre,jre,qre,Kre,Xre,Yre,Zre,Qre,Jre,ese,d$,d$,tse,nse,ise,lse,use,cse,dse,hse,pse,fse,mse,gse,vse,bse,xse,wse,Cse,Ise,Dse,Tse,kse,p$,p$,f$,f$,{kernelName:Cp,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>wt(t,Q(ms(it(e,"float32")),2))}}},{kernelName:Sp,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,r]=n,s=Lt(2);return{a:()=>Q(t,Q(s,gt(e,r))),b:()=>Q(t,Q(s,gt(r,e)))}}},{kernelName:kC,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>Q(t,Q(it(e,"float32"),2))}}},{kernelName:Ep,gradFunc:t=>({x:()=>dn(t)})},{kernelName:Ip,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,r]=n,s=Vt(e.shape,r.shape);return{a:()=>{let a=t;const l=Dr(e.shape,s);return l.length>0&&(a=yt(a,l)),re(a,e.shape)},b:()=>{let a=t;const l=Dr(r.shape,s);return l.length>0&&(a=yt(a,l)),re(Hn(a),r.shape)}}}},{kernelName:Ry,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[r]=n,s=r.shape.slice(),{axis:o}=e;Jt(o,r.shape).forEach(u=>{s[u]=1});const a=re(t,s),l=Q(a,Xa(r.shape,"float32"));return{x:()=>l}}},{kernelName:Dp,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>wt(t,Pn(CS(e)))}}},{kernelName:Tp,outputsToSave:[!0],gradFunc:(t,n)=>{const[e]=n;return{x:()=>Q(gt(Lt(1),Pn(e)),t)}}},{kernelName:kp,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[r]=n,{reps:s}=e;return{x:()=>{let i=dn(r);if(1===r.rank)for(let a=0;a<s[0];++a)i=Ge(i,Tn(t,[a*r.shape[0]],[r.shape[0]]));else if(2===r.rank)for(let a=0;a<s[0];++a)for(let l=0;l<s[1];++l)i=Ge(i,Tn(t,[a*r.shape[0],l*r.shape[1]],[r.shape[0],r.shape[1]]));else if(3===r.rank)for(let a=0;a<s[0];++a)for(let l=0;l<s[1];++l)for(let u=0;u<s[2];++u)i=Ge(i,Tn(t,[a*r.shape[0],l*r.shape[1],u*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else{if(4!==r.rank)throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);for(let a=0;a<s[0];++a)for(let l=0;l<s[1];++l)for(let u=0;u<s[2];++u)for(let c=0;c<s[3];++c)i=Ge(i,Tn(t,[a*r.shape[0],l*r.shape[1],u*r.shape[2],c*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]))}return i}}}},{kernelName:Tc,gradFunc:(t,n,e)=>{const r=e,{perm:s}=r,o=Ka(s);return{x:()=>hn(t,o)}}},{kernelName:$y,gradFunc:(t,n,e)=>{const r=e,{axis:s}=r;return{value:()=>Ya(t,s)}}},{kernelName:Ly,inputsToSave:["segmentIds"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>function Use(t,n){const e=Ha(n,dn(n)),r=D1(t,e);let s=eu(n,Lt(0,"int32"));const o=r.rank-s.rank;for(let a=0;a<o;++a)s=Gs(s,a+1);s=ha(s,Xa(r.shape,"bool"));const i=dn(r);return ys(s,r,i)}(t,e)}}},{kernelName:Vy,gradFunc:t=>({x:()=>dn(t)})}];for(const t of Gse)KY(t);Ce().prototype.abs=function(){return this.throwIfDisposed(),Pr(this)};const jse=te({acos_:function Hse(t){const e={x:$(t,"x","acos")};return J.runKernel(Ph,e)}});Ce().prototype.acos=function(){return this.throwIfDisposed(),jse(this)};const Kse=te({acosh_:function qse(t){const e={x:$(t,"x","acosh")};return J.runKernel(Mh,e)}});Ce().prototype.acosh=function(){return this.throwIfDisposed(),Kse(this)},Ce().prototype.add=function(t){return this.throwIfDisposed(),Ge(this,t)},Ce().prototype.all=function(t,n){return this.throwIfDisposed(),ZP(this,t,n)},Ce().prototype.any=function(t,n){return this.throwIfDisposed(),w1(this,t,n)},Ce().prototype.argMax=function(t){return this.throwIfDisposed(),Lp(this,t)};const Yse=te({argMin_:function Xse(t,n=0){const r={x:$(t,"x","argMin")};return J.runKernel(zg,r,{axis:n})}});Ce().prototype.argMin=function(t){return this.throwIfDisposed(),Yse(this,t)},Ce().prototype.asScalar=function(){return this.throwIfDisposed(),R(1===this.size,()=>"The array must have only 1 element."),re(this,[])},Ce().prototype.asType=function(t){return this.throwIfDisposed(),it(this,t)},Ce().prototype.as1D=function(){return this.throwIfDisposed(),re(this,[this.size])},Ce().prototype.as2D=function(t,n){return this.throwIfDisposed(),re(this,[t,n])},Ce().prototype.as3D=function(t,n,e){return this.throwIfDisposed(),re(this,[t,n,e])},Ce().prototype.as4D=function(t,n,e,r){return this.throwIfDisposed(),re(this,[t,n,e,r])},Ce().prototype.as5D=function(t,n,e,r,s){return this.throwIfDisposed(),re(this,[t,n,e,r,s])};const Qse=te({asin_:function Zse(t){const e={x:$(t,"x","asin")};return J.runKernel($h,e)}});Ce().prototype.asin=function(){return this.throwIfDisposed(),Qse(this)};const eoe=te({asinh_:function Jse(t){const e={x:$(t,"x","asinh")};return J.runKernel(Lh,e)}});Ce().prototype.asinh=function(){return this.throwIfDisposed(),eoe(this)};const noe=te({atan_:function toe(t){const e={x:$(t,"x","atan")};return J.runKernel(Vh,e)}});Ce().prototype.atan=function(){return this.throwIfDisposed(),noe(this)};const soe=te({atan2_:function roe(t,n){let e=$(t,"a","atan2"),r=$(n,"b","atan2");return[e,r]=rr(e,r),J.runKernel(zh,{a:e,b:r})}});Ce().prototype.atan2=function(t){return this.throwIfDisposed(),soe(this,t)};const ioe=te({atanh_:function ooe(t){const e={x:$(t,"x","atanh")};return J.runKernel(Bh,e)}});Ce().prototype.atanh=function(){return this.throwIfDisposed(),ioe(this)},Ce().prototype.avgPool=function(t,n,e,r){return this.throwIfDisposed(),S1(this,t,n,e,r)},Ce().prototype.batchToSpaceND=function(t,n){return this.throwIfDisposed(),SS(this,t,n)},Ce().prototype.batchNorm=function(t,n,e,r,s){return this.throwIfDisposed(),rv(this,t,n,e,r,s)},Ce().prototype.broadcastTo=function(t){return this.throwIfDisposed(),Up(this,t)},Ce().prototype.cast=function(t){return this.throwIfDisposed(),it(this,t)};const loe=te({ceil_:function aoe(t){const e={x:$(t,"x","ceil","float32")};return J.runKernel(Wh,e)}});Ce().prototype.ceil=function(){return this.throwIfDisposed(),loe(this)},Ce().prototype.clipByValue=function(t,n){return this.throwIfDisposed(),uo(this,t,n)},Ce().prototype.concat=function(t,n){return this.throwIfDisposed(),t instanceof dr&&(t=[t]),rs([this,...t],n)},Ce().prototype.conv1d=function(t,n,e,r,s,o){return this.throwIfDisposed(),QP(this,t,n,e,r,s,o)},Ce().prototype.conv2dTranspose=function(t,n,e,r,s){return this.throwIfDisposed(),JP(this,t,n,e,r,s)},Ce().prototype.conv2d=function(t,n,e,r,s,o){return this.throwIfDisposed(),Jl(this,t,n,e,r,s,o)},Ce().prototype.cos=function(){return this.throwIfDisposed(),CS(this)},Ce().prototype.cosh=function(){return this.throwIfDisposed(),h$(this)},Ce().prototype.cumprod=function(t,n,e){return this.throwIfDisposed(),wS(this,t,n,e)},Ce().prototype.cumsum=function(t,n,e){return this.throwIfDisposed(),s$(this,t,n,e)};const coe=te({depthToSpace_:function uoe(t,n,e="NHWC"){const r=$(t,"x","depthToSpace","float32"),s="NHWC"===e?r.shape[1]:r.shape[2],o="NHWC"===e?r.shape[2]:r.shape[3],i="NHWC"===e?r.shape[3]:r.shape[1];return R(n>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${n}`),R(s*n>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${s} and ${n}  for depthToSpace with input shape\n    ${r.shape}`),R(o*n>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${o} and ${n} for depthToSpace with input shape\n        ${r.shape}`),R(i%(n*n)==0,()=>`Dimension size must be evenly divisible by ${n*n} but is ${i} for depthToSpace with input shape ${r.shape}`),J.runKernel(rC,{x:r},{blockSize:n,dataFormat:e})}});Ce().prototype.depthToSpace=function(t,n){return this.throwIfDisposed(),coe(this,t,n)},Ce().prototype.depthwiseConv2d=function(t,n,e,r,s,o){return this.throwIfDisposed(),sv(this,t,n,e,r,s,o)};const hoe=te({dilation2d_:function doe(t,n,e,r,s=[1,1],o="NHWC"){const i=$(t,"x","dilation2d"),a=$(n,"filter","dilation2d");R(3===i.rank||4===i.rank,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`),R(3===a.rank,()=>`Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`),R("NHWC"===o,()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${o}`);let l=i,u=!1;3===i.rank&&(l=re(i,[1,i.shape[0],i.shape[1],i.shape[2]]),u=!0),R(l.shape[3]===a.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${a.shape[2]}`);const h=J.runKernel(Jg,{x:l,filter:a},{strides:e,pad:r,dilations:s});return u?re(h,[h.shape[1],h.shape[2],h.shape[3]]):h}});Ce().prototype.dilation2d=function(t,n,e,r,s){return this.throwIfDisposed(),hoe(this,t,n,e,r,s)};const foe=te({divNoNan_:function poe(t,n){let e=$(t,"a","div"),r=$(n,"b","div");[e,r]=rr(e,r);const s=wt(e,r),o=dn(s),i=Ni(r,o);return ys(i,o,s)}});Ce().prototype.divNoNan=function(t){return this.throwIfDisposed(),foe(this,t)},Ce().prototype.div=function(t){return this.throwIfDisposed(),wt(this,t)};const goe=te({dot_:function moe(t,n){const e=$(t,"t1","dot"),r=$(n,"t2","dot");R(!(1!==e.rank&&2!==e.rank||1!==r.rank&&2!==r.rank),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${e.rank} and ${r.rank}.`);const s=1===e.rank?e.size:e.shape[1],o=1===r.rank?r.size:r.shape[0];if(R(s===o,()=>`Error in dot: inner dimensions of inputs must match, but got ${s} and ${o}.`),1===e.rank&&1===r.rank){const i=re(e,[1,-1]),a=re(r,[-1,1]),l=yn(i,a);return re(l,[])}if(1===e.rank&&2===r.rank){const i=re(e,[1,-1]),a=re(r,[r.shape[0],r.shape[1]]),l=yn(i,a);return re(l,[l.size])}if(2===e.rank&&1===r.rank){const i=re(r,[-1,1]),a=yn(e,i);return re(a,[a.size])}{const i=re(r,[r.shape[0],r.shape[1]]);return yn(e,i)}}});Ce().prototype.dot=function(t){return this.throwIfDisposed(),goe(this,t)},Ce().prototype.elu=function(){return this.throwIfDisposed(),ov(this)},Ce().prototype.equal=function(t){return this.throwIfDisposed(),Ni(this,t)};const voe=te({erf_:function yoe(t){let n=$(t,"x","erf");return R("int32"===n.dtype||"float32"===n.dtype,()=>"Input dtype must be `int32` or `float32`."),"int32"===n.dtype&&(n=it(n,"float32")),J.runKernel(Xh,{x:n})}});Ce().prototype.erf=function(){return this.throwIfDisposed(),voe(this)};const xoe=te({euclideanNorm_:function boe(t,n=null,e=!1){return vv(t,"euclidean",n,e)}});Ce().prototype.euclideanNorm=function(t,n){return this.throwIfDisposed(),xoe(this,t,n)},Ce().prototype.exp=function(){return this.throwIfDisposed(),Fo(this)},Ce().prototype.expandDims=function(t){return this.throwIfDisposed(),Gs(this,t)};const _oe=te({expm1_:function woe(t){const e={x:$(t,"x","expm1")};return J.runKernel(Zh,e)}});Ce().prototype.expm1=function(){return this.throwIfDisposed(),_oe(this)},Ce().prototype.fft=function(){return this.throwIfDisposed(),U1(this)},Ce().prototype.flatten=function(){return this.throwIfDisposed(),re(this,[this.size])},Ce().prototype.floor=function(){return this.throwIfDisposed(),iv(this)},Ce().prototype.floorDiv=function(t){return this.throwIfDisposed(),DP(this,t)},Ce().prototype.gather=function(t,n,e){return this.throwIfDisposed(),D1(this,t,n,e)},Ce().prototype.greaterEqual=function(t){return this.throwIfDisposed(),eu(this,t)},Ce().prototype.greater=function(t){return this.throwIfDisposed(),co(this,t)},Ce().prototype.ifft=function(){return this.throwIfDisposed(),dv(this)},Ce().prototype.irfft=function(){return this.throwIfDisposed(),cM(this)};const Soe=te({isFinite_:function Coe(t){const e={x:$(t,"x","isFinite")};return J.runKernel(np,e)}});Ce().prototype.isFinite=function(){return this.throwIfDisposed(),Soe(this)};const Doe=te({isInf_:function Ioe(t){const e={x:$(t,"x","isInf")};return J.runKernel(rp,e)}});Ce().prototype.isInf=function(){return this.throwIfDisposed(),Doe(this)};const koe=te({isNaN_:function Toe(t){const e={x:$(t,"x","isNaN")};return J.runKernel(sp,e)}});Ce().prototype.isNaN=function(){return this.throwIfDisposed(),koe(this)},Ce().prototype.leakyRelu=function(t){return this.throwIfDisposed(),T1(this,t)},Ce().prototype.lessEqual=function(t){return this.throwIfDisposed(),zc(this,t)},Ce().prototype.less=function(t){return this.throwIfDisposed(),yv(this,t)};const Noe=te({localResponseNormalization_:function Eoe(t,n=5,e=1,r=1,s=.5){const o=$(t,"x","localResponseNormalization");R(4===o.rank||3===o.rank,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${o.rank}.`),R(_c(n),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${n}.`);let i=o,a=!1;3===o.rank&&(a=!0,i=re(o,[1,o.shape[0],o.shape[1],o.shape[2]]));const c=J.runKernel(dy,{x:i},{depthRadius:n,bias:e,alpha:r,beta:s});return a?re(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});Ce().prototype.localResponseNormalization=function(t,n,e,r){return this.throwIfDisposed(),Noe(this,t,n,e,r)};const Roe=te({logSigmoid_:function Aoe(t){const n=$(t,"x","logSigmoid");return ua(r=>({value:Hn(Hp(Hn(r))),gradFunc:i=>Q(i,Vc(Hn(r)))}))(n)}});Ce().prototype.logSigmoid=function(){return this.throwIfDisposed(),Roe(this)},Ce().prototype.logSoftmax=function(t){return this.throwIfDisposed(),rM(this,t)},Ce().prototype.logSumExp=function(t,n){return this.throwIfDisposed(),IM(this,t,n)},Ce().prototype.log=function(){return this.throwIfDisposed(),Oo(this)},Ce().prototype.log1p=function(){return this.throwIfDisposed(),k1(this)},Ce().prototype.logicalAnd=function(t){return this.throwIfDisposed(),ha(this,t)},Ce().prototype.logicalNot=function(){return this.throwIfDisposed(),_S(this)};const m$=te({logicalOr_:function Foe(t,n){const e=$(t,"a","logicalOr","bool"),r=$(n,"b","logicalOr","bool");return Vt(e.shape,r.shape),J.runKernel(cy,{a:e,b:r})}});Ce().prototype.logicalOr=function(t){return this.throwIfDisposed(),m$(this,t)};const Poe=te({logicalXor_:function Ooe(t,n){const e=$(t,"a","logicalXor","bool"),r=$(n,"b","logicalXor","bool");return Vt(e.shape,r.shape),ha(m$(t,n),_S(ha(t,n)))}});Ce().prototype.logicalXor=function(t){return this.throwIfDisposed(),Poe(this,t)},Ce().prototype.matMul=function(t,n,e){return this.throwIfDisposed(),yn(this,t,n,e)},Ce().prototype.maxPool=function(t,n,e,r){return this.throwIfDisposed(),E1(this,t,n,e,r)},Ce().prototype.max=function(t,n){return this.throwIfDisposed(),ni(this,t,n)},Ce().prototype.maximum=function(t){return this.throwIfDisposed(),Ha(this,t)},Ce().prototype.mean=function(t,n){return this.throwIfDisposed(),hr(this,t,n)},Ce().prototype.min=function(t,n){return this.throwIfDisposed(),av(this,t,n)},Ce().prototype.minimum=function(t){return this.throwIfDisposed(),Lc(this,t)};const $oe=te({mirrorPad_:function Moe(t,n,e){R("reflect"===e||"symmetric"===e,()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${e}.`);const r=$(t,"x","mirrorPad");if(0===r.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");R(n.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${n.length}.`);const s="reflect"===e?1:0;for(let a=0;a<r.rank;a++)R(2===n[a].length,()=>"Invalid number of paddings. Must be length of 2 each."),R(n[a][0]>=0&&n[a][0]<=r.shape[a]-s&&n[a][1]>=0&&n[a][1]<=r.shape[a]-s,()=>`Padding in dimension ${a} cannot be greater than or equal to ${r.shape[a]-s} or less than 0 for input of shape ${r.shape}`);return J.runKernel(yy,{x:r},{paddings:n,mode:e})}});Ce().prototype.mirrorPad=function(t,n){return this.throwIfDisposed(),$oe(this,t,n)};const Voe=te({mod_:function Loe(t,n){let e=$(t,"a","mod"),r=$(n,"b","mod");return[e,r]=rr(e,r),J.runKernel(up,{a:e,b:r})}});Ce().prototype.mod=function(t){return this.throwIfDisposed(),Voe(this,t)},Ce().prototype.mul=function(t){return this.throwIfDisposed(),Q(this,t)},Ce().prototype.neg=function(){return this.throwIfDisposed(),Hn(this)},Ce().prototype.norm=function(t,n,e){return this.throwIfDisposed(),vv(this,t,n,e)},Ce().prototype.notEqual=function(t){return this.throwIfDisposed(),Wp(this,t)},Ce().prototype.oneHot=function(t,n=1,e=0){return this.throwIfDisposed(),oM(this,t,n,e)},Ce().prototype.onesLike=function(){return this.throwIfDisposed(),Po(this)},Ce().prototype.pad=function(t,n){return this.throwIfDisposed(),R1(this,t,n)};const Woe=te({pool_:function Boe(t,n,e,r,s,o,i){null==s&&(s=[1,1]),null==o&&(o=1),0===r&&(r="valid");const a=$(t,"x","maxPool");let l=a,u=!1;3===a.rank&&(u=!0,l=re(a,[1,a.shape[0],a.shape[1],a.shape[2]])),R(Gr(o,s),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${o} and dilations '${s}'`);const c=Ro(l.shape,n,o,s,r),d=[c.dilationHeight,c.dilationWidth];let h;h="same"===r?function Uoe(t,n){const r=t.map((i,a)=>i+(i-1)*(n[a]-1)).map(i=>i-1),s=r.map(i=>Math.floor(i/2)),o=r.map((i,a)=>i-s[a]);return r.map((i,a)=>[s[a],o[a]])}([c.filterHeight,c.filterWidth],d):[[0,0],[0,0]];const p=1===d[0]&&1===d[1],[f,g]=function zoe(t,n,e){const r=e.map(c=>c[0]),s=e.map(c=>c[1]),o=t.concat(r,s),i=n.map((c,d)=>(c-o[d]%c)%c),a=s.map((c,d)=>c+i[d]),l=n.map((c,d)=>[r[d],a[d]]),u=n.map((c,d)=>[0,i[d]]);return[l,u]}([c.inHeight,c.inWidth],d,h),m=p?r:"valid",y=p?l:xS(l,d,f),b=("avg"===e?()=>S1(y,n,o,m,i):()=>E1(y,n,o,m,i))(),x=p?b:SS(b,d,g);return u?re(x,[x.shape[1],x.shape[2],x.shape[3]]):x}});Ce().prototype.pool=function(t,n,e,r,s,o){return this.throwIfDisposed(),Woe(this,t,n,e,r,s,o)},Ce().prototype.pow=function(t){return this.throwIfDisposed(),Pc(this,t)},Ce().prototype.prelu=function(t){return this.throwIfDisposed(),F1(this,t)};const Hoe=te({prod_:function Goe(t,n=null,e=!1){let r=$(t,"x","prod");return"bool"===r.dtype&&(r=it(r,"int32")),J.runKernel(Iy,{x:r},{axis:n,keepDims:e})}});Ce().prototype.prod=function(t,n){return this.throwIfDisposed(),Hoe(this,t,n)};const qoe=te({reciprocal_:function joe(t){const e={x:$(t,"x","reciprocal")};return J.runKernel(hp,e)}});Ce().prototype.reciprocal=function(){return this.throwIfDisposed(),qoe(this)},Ce().prototype.relu=function(){return this.throwIfDisposed(),pa(this)},Ce().prototype.relu6=function(){return this.throwIfDisposed(),dM(this)},Ce().prototype.reshapeAs=function(t){return this.throwIfDisposed(),re(this,t.shape)},Ce().prototype.reshape=function(t){return this.throwIfDisposed(),re(this,t)},Ce().prototype.resizeBilinear=function(t,n,e){return this.throwIfDisposed(),bM(this,t,n,e)},Ce().prototype.resizeNearestNeighbor=function(t,n,e){return this.throwIfDisposed(),xM(this,t,n,e)},Ce().prototype.reverse=function(t){return this.throwIfDisposed(),tu(this,t)},Ce().prototype.rfft=function(){return this.throwIfDisposed(),W1(this)},Ce().prototype.round=function(){return this.throwIfDisposed(),wM(this)},Ce().prototype.rsqrt=function(){return this.throwIfDisposed(),o$(this)},Ce().prototype.selu=function(){return this.throwIfDisposed(),iM(this)},Ce().prototype.separableConv2d=function(t,n,e,r,s,o){return this.throwIfDisposed(),aM(this,t,n,e,r,s,o)},Ce().prototype.sigmoid=function(){return this.throwIfDisposed(),Vc(this)};const Xoe=te({sign_:function Koe(t){const e={x:$(t,"x","sign")};return J.runKernel(xp,e)}});Ce().prototype.sign=function(){return this.throwIfDisposed(),Xoe(this)},Ce().prototype.sin=function(){return this.throwIfDisposed(),n$(this)},Ce().prototype.sinh=function(){return this.throwIfDisposed(),r$(this)},Ce().prototype.slice=function(t,n){return this.throwIfDisposed(),Tn(this,t,n)},Ce().prototype.softmax=function(t){return this.throwIfDisposed(),V1(this,t)},Ce().prototype.softplus=function(){return this.throwIfDisposed(),Hp(this)},Ce().prototype.spaceToBatchND=function(t,n){return this.throwIfDisposed(),xS(this,t,n)},Ce().prototype.split=function(t,n){return this.throwIfDisposed(),ho(this,t,n)},Ce().prototype.sqrt=function(){return this.throwIfDisposed(),ms(this)},Ce().prototype.square=function(){return this.throwIfDisposed(),Pn(this)},Ce().prototype.squaredDifference=function(t){return this.throwIfDisposed(),SM(this,t)},Ce().prototype.squeeze=function(t){return this.throwIfDisposed(),jp(this,t)},Ce().prototype.stack=function(t,n){this.throwIfDisposed();const e=t instanceof dr?[this,t]:[this,...t];return Ya(e,n)},Ce().prototype.step=function(t){return this.throwIfDisposed(),qp(this,t)};const Zoe=te({stridedSlice_:function Yoe(t,n,e,r,s=0,o=0,i=0,a=0,l=0){const c={x:$(t,"x","stridedSlice","string_or_numeric")};return J.runKernel(EC,c,{begin:n,end:e,strides:r,beginMask:s,endMask:o,ellipsisMask:i,newAxisMask:a,shrinkAxisMask:l})}});Ce().prototype.stridedSlice=function(t,n,e,r,s,o,i,a){return this.throwIfDisposed(),Zoe(this,t,n,e,r,s,o,i,a)},Ce().prototype.sub=function(t){return this.throwIfDisposed(),gt(this,t)},Ce().prototype.sum=function(t,n){return this.throwIfDisposed(),yt(this,t,n)};const Joe=te({tan_:function Qoe(t){const e={x:$(t,"x","tan","float32")};return J.runKernel(Dp,e)}});Ce().prototype.tan=function(){return this.throwIfDisposed(),Joe(this)},Ce().prototype.tanh=function(){return this.throwIfDisposed(),B1(this)},Ce().prototype.tile=function(t){return this.throwIfDisposed(),ti(this,t)},Ce().prototype.toBool=function(){return this.throwIfDisposed(),it(this,"bool")},Ce().prototype.toFloat=function(){return this.throwIfDisposed(),it(this,"float32")},Ce().prototype.toInt=function(){return this.throwIfDisposed(),it(this,"int32")};const tie=te({topk_:function eie(t,n=1,e=!0){const r=$(t,"x","topk");if(0===r.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const s=r.shape[r.shape.length-1];if(n<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${n}`);if(n>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got ${n}`);const o={x:r},i={k:n,sorted:e},[a,l]=J.runKernel(FC,o,i);return{values:a,indices:l}}});Ce().prototype.topk=function(t,n){return this.throwIfDisposed(),tie(this,t,n)},Ce().prototype.transpose=function(t){return this.throwIfDisposed(),hn(this,t)};const rie=te({unique_:function nie(t,n=0){const e=$(t,"x","unique","string_or_numeric");R(e.rank>0,()=>"The input tensor must be at least 1D");const r={x:e},s={axis:n},[o,i]=J.runKernel(PC,r,s);return{values:o,indices:i}}});Ce().prototype.unique=function(t){return this.throwIfDisposed(),rie(this,t)},Ce().prototype.unsortedSegmentSum=function(t,n){return this.throwIfDisposed(),i$(this,t,n)},Ce().prototype.unstack=function(t){return this.throwIfDisposed(),nu(this,t)},Ce().prototype.where=function(t,n){return this.throwIfDisposed(),ys(t,this,n)},Ce().prototype.zerosLike=function(){return this.throwIfDisposed(),dn(this)};class Ri extends Error{constructor(n){super(n),Object.setPrototypeOf(this,Ri.prototype)}}class $o extends Error{constructor(n){super(n),Object.setPrototypeOf(this,$o.prototype)}}class ee extends Error{constructor(n){super(n),Object.setPrototypeOf(this,ee.prototype)}}class Wt extends Error{constructor(n){super(n),Object.setPrototypeOf(this,Wt.prototype)}}class IS extends Error{constructor(n){super(n),Object.setPrototypeOf(this,IS.prototype)}}class g$ extends Error{constructor(n){super(n),Object.setPrototypeOf(this,g$.prototype)}}class y${constructor(n){this.maxEntries=n||100,this.cache=new Map}get(n){let e;return this.cache.has(n)&&(e=this.cache.get(n),this.cache.delete(n),this.cache.set(n,e)),e}put(n,e){if(this.cache.has(n))this.cache.delete(n);else if(this.cache.size>=this.maxEntries){const r=this.cache.keys().next().value;this.cache.delete(r)}this.cache.set(n,e)}getMaxEntries(){return this.maxEntries}setMaxEntries(n){if(n<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${n}.`);if(this.maxEntries>n)for(let e=0;e<this.maxEntries-n;e++){const r=this.cache.keys().next().value;this.cache.delete(r)}this.maxEntries=n}}function su(t,n){if(Array.isArray(t)){let e=[];for(let r=0;r<n;r++)e=e.concat(t);return e}{const e=new Array(n);return e.fill(t),e}}function po(t,n){if(!t)throw new IS(n)}function v$(t,n){let e=0;for(const r of t)r===n&&e++;return e}function Os(t){return 1===t.length?t[0]:t}function Mn(t){return Array.isArray(t)?t:[t]}function ya(t){const e=t.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==e[0]?e:"private"+e}function ou(t){return t.length<=1||-1===t.indexOf("_")?t:t.replace(/[_]+(\w|$)/g,(n,e)=>e.toUpperCase())}let Lo={};function DS(t){if(null==t)return null;const n={};return n.className=t.getClassName(),n.config=t.getConfig(),n}function TS(t){if(null!=t&&"object"==typeof t)if(Array.isArray(t))t.forEach(n=>TS(n));else{const n=Object.keys(t);for(const e of n){const r=t[e];null!=r&&"object"==typeof r&&(Array.isArray(r)||"ndarray"!==r.type||"number"!=typeof r.value?TS(r):t[e]=r.value)}}}function Zp(t,n={},e={},r="object",s=!1){if("string"==typeof t){let i;if(t in e)i=e[t];else if(t in Lo)i=Lo[t];else if(i=n[t],null==i)throw new ee(`Unknown ${r}: ${t}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return i}{const o=t;if(null==o.className||null==o.config)throw new ee(`${r}: Improper config format: ${JSON.stringify(o)}.\n'className' and 'config' must set.`);const i=o.className;let a,l;if(i in e?[a,l]=e[i]:i in Lo?[a,l]=Lo.className:i in n&&([a,l]=n[i]),null==a)throw new ee(`Unknown ${r}: ${i}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(null!=l){const u={};for(const p of Object.keys(Lo))u[p]=Lo[p];for(const p of Object.keys(e))u[p]=e[p];o.config.customObjects=u;const d=Object.assign({},Lo);for(const p of Object.keys(e))Lo[p]=e[p];TS(o.config);const h=l(a,o.config,e,s);return Lo=Object.assign({},d),h}{const u=Object.assign({},Lo);for(const d of Object.keys(e))Lo[d]=e[d];const c=new a(o.config);return Lo=Object.assign({},u),c}}}function _v(t,n){return-1*function sie(t,n){return t<n?-1:t>n?1:0}(t,n)}function Qa(t){if(null==t)return t;const n=[];for(const e of t)-1===n.indexOf(e)&&n.push(e);return n}function oie(t){if(null==t)throw new ee(`Invalid value in obj: ${JSON.stringify(t)}`);for(const n in t)if(t.hasOwnProperty(n))return!1;return!0}function iu(t,n,e){if(null!=e&&t.indexOf(e)<0)throw new ee(`${e} is not a valid ${n}.  Valid values are ${t} or null/undefined.`)}function kS(t,n,e=0,r=1/0){return po(e>=0),po(r>=e),Array.isArray(t)&&t.length>=e&&t.length<=r&&t.every(s=>typeof s===n)}function Vr(t,n){Array.isArray(t)?(R(t.length>0,()=>`${n} is unexpectedly an empty array.`),t.forEach((e,r)=>Vr(e,`element ${r+1} of ${n}`))):R(Number.isInteger(t)&&t>0,()=>`Expected ${n} to be a positive integer, but got ${b$(t)}.`)}function b$(t){return null===t?"null":Array.isArray(t)?"["+t.map(n=>b$(n)).join(",")+"]":"string"==typeof t?`"${t}"`:`${t}`}function x$(t){return"relu"===t?"relu":"linear"===t?"linear":"elu"===t?"elu":null}let aie=0;function w$(){return aie++}const Cv={};function Sv(t=""){return t in Cv||(Cv[t]=0),Cv[t]+=1,t+Cv[t].toString()}const lie=["channelsFirst","channelsLast"],uie=["nearest","bilinear"],cie=["valid","same","causal"],die=["max","avg"],hie=["sum","mul","concat","ave"],Wc=new Map;function mr(t){iu(lie,"DataFormat",t)}function fo(t){iu(cie,"PaddingMode",t)}function _$(t){iu(die,"PoolMode",t)}const Qp=[],C$="/";function au(t,n){Qp.push(t);try{const e=n();return Qp.pop(),e}catch(e){throw Qp.pop(),e}}function S$(t){if(!D$(t))throw new Error("Not a valid tensor name: '"+t+"'");return function fie(){return 0===Qp.length?"":Qp.join(C$)+C$}()+t}function I$(t){if(!D$(t))throw new Error("Not a valid tensor name: '"+t+"'");Wc.has(t)||Wc.set(t,0);const n=Wc.get(t);if(Wc.set(t,Wc.get(t)+1),n>0){const e=`${t}_${n}`;return Wc.set(e,1),e}return t}const mie=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function D$(t){return!!t.match(mie)}function gie(t){return t===parseInt(t.toString(),10)}function Ja(t,n,e){null==n&&(n=0),null==e&&(e=t.length);let r=1;for(let s=n;s<e;++s)r*=t[s];return r}function Gc(t){if(0===t.length)return Number.NaN;let n=Number.POSITIVE_INFINITY;for(let e=0;e<t.length;e++){const r=t[e];r<n&&(n=r)}return n}function el(t){if(0===t.length)return Number.NaN;let n=Number.NEGATIVE_INFINITY;for(let e=0;e<t.length;e++){const r=t[e];r>n&&(n=r)}return n}function ri(t,n){if(n<t)throw new ee(`end (${n}) < begin (${t}) is forbidden.`);const e=[];for(let r=t;r<n;++r)e.push(r);return e}let Iv;function Tr(){return null==Iv&&(Iv=function KZ(){return J.backend}().epsilon()),Iv}function Fi(t,n){return it(t,n)}function Jp(t,n=-1){const e=t.shape.slice();return n<0&&(n=e.length+n+1),e.splice(n,0,1),re(t,e)}function lu(t,n,e){return he(()=>{switch(t.rank){case 1:return $1(t,n,e);case 2:return lM(t,[n,0],[e,t.shape[1]]);case 3:return L1(t,[n,0,0],[e,t.shape[1],t.shape[2]]);case 4:return uv(t,[n,0,0,0],[e,t.shape[1],t.shape[2],t.shape[3]]);case 5:return Tn(t,[n,0,0,0,0],[e,t.shape[1],t.shape[2],t.shape[3],t.shape[4]]);case 6:return Tn(t,[n,0,0,0,0,0],[e,t.shape[1],t.shape[2],t.shape[3],t.shape[4],t.shape[5]]);default:throw new ee(`sliceAlongFirstAxis() received an unsupported tensor rank: ${t.rank}`)}})}function ES(t,n,e){return he(()=>{switch(t.rank){case 1:return $1(t,n,e);case 2:return lM(t,[0,n],[t.shape[0],e]);case 3:return L1(t,[0,0,n],[t.shape[0],t.shape[1],e]);case 4:return uv(t,[0,0,0,n],[t.shape[0],t.shape[1],t.shape[2],e]);default:throw new ee(`sliceAlongLastAxis() received an unsupported tensor rank: ${t.rank}`)}})}function Dv(t,n,e,r){return he(()=>{switch(t.rank){case 1:return $1(t,n,e);case 2:switch(r){case 1:return lu(t,n,e);case 2:return ES(t,n,e);default:throw new ee(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return lu(t,n,e);case 2:return L1(t,[0,n,0],[t.shape[0],e,t.shape[2]]);case 3:return ES(t,n,e);default:throw new ee(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return lu(t,n,e);case 2:return uv(t,[0,n,0,0],[t.shape[0],e,t.shape[2],t.shape[3]]);case 3:return uv(t,[0,0,n,0],[t.shape[0],t.shape[1],e,t.shape[3]]);case 4:return ES(t,n,e);default:throw new ee(`The axis is not within the rank of the tensor ${r}`)}default:throw new ee(`sliceAlongLastAxis() received an unsupported tensor rank: ${t.rank}`)}})}function NS(t,n=-1){let e;return n<0&&(e=t[0].rank,n=0!==e?e:0),n===t[0].rank&&(n=-1),rs(t,n)}function k$(t,n){switch(t.rank){case 1:return nJ([t,n]);case 2:return sJ([t,n],0);case 3:return iJ([t,n],0);case 4:return lJ([t,n],0);default:throw new ee(`concatAlongFirstAxis() received an unsupported tensor rank: ${t.rank}`)}}function AS(t,n){if(Array.isArray(n)||(n=[n]),t.rank!==n.length)throw new ee(`The length of input n (${n.length}) does not match the number of dimensions in input x (${t.rank})`);return ti(t,n)}function Tv(t,n=0,e=1,r,s){return nee(t,n,e,r,s)}function Oi(t,n,e,r){if(t.rank<2||n.rank<2)throw new Wt(`dot requires both inputs to be rank >= 2 but got x shape = ${t.shape} and y shape = ${n.shape}`);if(n.rank>=3&&t.shape.slice(-1)[0]!==n.shape.slice(-2)[0])throw new Wt(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${t.shape} and  y shape = ${n.shape}`);if(2===t.rank&&2===n.rank)return fM({a:t,b:n,transposeA:!1,transposeB:!1,bias:r?RS(t.rank,r,"channelsLast"):null,activation:e});{const s=t.shape.slice(),o=s.pop();t=re(t,[-1,o]);const i=n.shape.slice(),a=i.pop(),l=i.pop(),u=[...i,a],c=Array.from({length:n.rank},(f,g)=>0===g?n.rank-2:g<=n.rank-2?g-1:g);n=re(hn(n,c),[l,-1]);const d=[...s,...u];return re(fM({a:t,b:n,transposeA:!1,transposeB:!1,bias:r?RS(t.rank,r,"channelsLast"):null,activation:e}),d)}}function E$(t,n,e){return he(()=>(n=Array.isArray(n)?Hs(n,"int32"):it(n,"int32"),D1(t,n,e)))}function ef(t){return Q(t,t)}function RS(t,n,e){const r=n.shape;if(1!==n.rank&&n.rank!==t)throw new ee(`Unexpected bias dimensions: ${n.rank}; expected it to be 1 or ${t}`);if(5===t){if("channelsFirst"===e)return re(n,1===r.length?[1,r[0],1,1,1]:[1,r[3],r[0],r[1],r[2]]);if("channelsLast"===e)return re(n,1===r.length?[1,1,1,1,r[0]]:[1].concat(r))}else if(4===t){if("channelsFirst"===e)return re(n,1===r.length?[1,r[0],1,1]:[1,r[2],r[0],r[1]]);if("channelsLast"===e)return re(n,1===r.length?[1,1,1,r[0]]:[1].concat(r))}else if(3===t){if("channelsFirst"===e)return re(n,1===r.length?[1,r[0],1]:[1,r[1],r[0]]);if("channelsLast"===e)return re(n,1===r.length?[1,1,r[0]]:[1].concat(r))}else if(t<3)return n;throw new ee(`Unsupported input rank by biasAdd: ${n.rank}`)}function oi(t,n,e){return he(()=>(null==e&&(e="channelsLast"),mr(e),Ge(t,RS(t.rank,n,e))))}function N$(t,n,e,r){return he(()=>Eee(t,n,e,r))}function nf(t,n,e=!1){return e?t():n()}const Iie=["fanIn","fanOut","fanAvg"],Die=["normal","uniform","truncatedNormal"];class Vo extends Oc{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}Ue((()=>{class t extends Vo{apply(e,r){return Lr(e,r)}}return t.className="Zeros",t})());let A$=(()=>{class t extends Vo{apply(e,r){return Xa(e,r)}}return t.className="Ones",t})();Ue(A$),Ue((()=>{class t extends Vo{constructor(e){if(super(),"object"!=typeof e)throw new ee(`Expected argument of type ConstantConfig but got ${e}`);if(void 0===e.value)throw new ee(`config must have value set but got ${e}`);this.value=e.value}apply(e,r){return he(()=>Q(Lt(this.value),Xa(e,r)))}getConfig(){return{value:this.value}}}return t.className="Constant",t})()),Ue((()=>{class t extends Vo{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,r){return lv(e,this.minval,this.maxval,r,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}return t.className="RandomUniform",t})()),Ue((()=>{class t extends Vo{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,r){if("float32"!==(r=r||"float32")&&"int32"!==r)throw new Wt(`randomNormal does not support dType ${r}.`);return Tv(e,this.mean,this.stddev,r,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}return t.className="RandomNormal",t})()),Ue((()=>{class t extends Vo{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,r){if("float32"!==(r=r||"float32")&&"int32"!==r)throw new Wt(`truncatedNormal does not support dType ${r}.`);return uM(e,this.mean,this.stddev,r,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}return t.className="TruncatedNormal",t})()),Ue((()=>{class t extends Vo{constructor(e){super(),this.gain=null!=e.gain?e.gain:1}apply(e,r){return he(()=>{if(2!==e.length||e[0]!==e[1])throw new ee("Identity matrix initializer can only be used for 2D square matrices.");return Q(this.gain,nM(e[0]))})}getConfig(){return{gain:this.gain}}}return t.className="Identity",t})());let mo=(()=>{class t extends Vo{constructor(e){if(super(),e.scale<0)throw new ee(`scale must be a positive float. Got: ${e.scale}`);this.scale=null==e.scale?1:e.scale,this.mode=null==e.mode?"fanIn":e.mode,function Tie(t){iu(Iie,"FanMode",t)}(this.mode),this.distribution=null==e.distribution?"normal":e.distribution,function kie(t){iu(Die,"Distribution",t)}(this.distribution),this.seed=e.seed}apply(e,r){const s=function Eie(t,n="channelsLast"){let e,r;if(mr(n),2===t.length)e=t[0],r=t[1];else if(-1!==[3,4,5].indexOf(t.length)){if("channelsFirst"===n){const s=Ja(t,2);e=t[1]*s,r=t[0]*s}else if("channelsLast"===n){const s=Ja(t,0,t.length-2);e=t[t.length-2]*s,r=t[t.length-1]*s}}else{const s=Ja(t);e=Math.sqrt(s),r=Math.sqrt(s)}return[e,r]}(e),o=s[0],i=s[1];let a=this.scale;if(a/="fanIn"===this.mode?Math.max(1,o):"fanOut"===this.mode?Math.max(1,i):Math.max(1,(o+i)/2),"normal"===this.distribution){const l=Math.sqrt(a);if("float32"!==(r=r||"float32")&&"int32"!==r)throw new Wt(`${this.getClassName()} does not support dType ${r}.`);return uM(e,0,l,r,this.seed)}{const l=Math.sqrt(3*a);return lv(e,-l,l,r,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}return t.className="VarianceScaling",t})();Ue(mo);let R$=(()=>{class t extends mo{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return mo.className}}return t.className="GlorotUniform",t})();Ue(R$);let F$=(()=>{class t extends mo{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return mo.className}}return t.className="GlorotNormal",t})();Ue(F$);let O$=(()=>{class t extends mo{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return mo.className}}return t.className="HeNormal",t})();Ue(O$);let P$=(()=>{class t extends mo{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return mo.className}}return t.className="HeUniform",t})();Ue(P$);let M$=(()=>{class t extends mo{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return mo.className}}return t.className="LeCunNormal",t})();Ue(M$);let $$=(()=>{class t extends mo{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return mo.className}}return t.className="LeCunUniform",t})();Ue($$),Ue((()=>{class t extends Vo{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=null==e.gain?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,r){return he(()=>{if(e.length<2)throw new Wt("Shape must be at least 2D.");if("int32"!==r&&"float32"!==r&&void 0!==r)throw new TypeError(`Unsupported data type ${r}.`);const s=_e(e.slice(0,-1)),o=e[e.length-1],i=s*o;i>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${i}) elements: Slowness may result.`);const l=Tv([Math.max(o,s),Math.min(o,s)],0,1,r,this.seed),u=Sne.qr(l,!1);let c=u[0];const h=u[1].flatten().stridedSlice([0],[Math.min(o,s)*Math.min(o,s)],[Math.min(o,s)+1]);return c=Q(c,h.sign()),s<o&&(c=c.transpose()),Q(Lt(this.gain),c.reshape(e))})}getConfig(){return{gain:this.gain,seed:this.seed}}}return t.className="Orthogonal",t})());const L$={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function V$(t,n={}){return Zp(t,Ao.getMap().classNameMap,n,"initializer")}function Jn(t){return DS(t)}function jn(t){if("string"==typeof t){const n=t in L$?L$[t]:t;if("GlorotNormal"===n)return new F$;if("GlorotUniform"===n)return new R$;if("HeNormal"===n)return new O$;if("HeUniform"===n)return new P$;if("LeCunNormal"===n)return new M$;if("LeCunUniform"===n)return new $$;{const e={};return e.className=n,e.config={},V$(e)}}return t instanceof Vo?t:V$(t)}function FS(t){return Array.isArray(t)&&Array.isArray(t[0])}function kv(t){return 0===t.length?[]:Array.isArray(t[0])?t:[t]}function $t(t){let n;if(Array.isArray(t)){if(1!==t.length)throw new ee(`Expected Tensor length to be 1; got ${t.length}`);n=t[0]}else n=t;return n}function mn(t){if(Array.isArray(t)&&Array.isArray(t[0])){if(1===t.length)return t[0];throw new ee(`Expected exactly 1 Shape; got ${t.length}`)}return t}function Ev(t){let n=0;for(const e of t)n+=0===e.shape.length?1:e.shape.reduce((r,s)=>r*s);return n}const B$="Variable";class Pi{constructor(n,e="float32",r=B$,s=!0,o=null){this.dtype=e??"float32",this.shape=n.shape,this.id=w$(),this.originalName=S$(r=r??B$),this.name=I$(this.originalName),this.trainable_=s,this.constraint=o,this.val=function _ee(t,n=!0,e,r){return J.makeVariable(t,n,e,r)}(n,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(n){return this.assertNotDisposed(),function Nie(t,n){if(t.shape.toString()!==n.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(t.shape)+" vs. "+JSON.stringify(n.shape))}(this.val,n),this.val.id!==n.id&&(this.val.assign(n),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(n){this.trainable_=n,this.val.trainable=n}}function OS(t){return t.map(n=>n.read())}function PS(t){t.forEach(n=>{n[0].write(n[1])})}class kr{constructor(n){this.dtype=n.dtype,this.shape=n.shape,this.ndim=null!=n.shape?n.shape.length:n.ndim,this.maxNDim=n.maxNDim,this.minNDim=n.minNDim,this.axes=n.axes||{}}}class Mi{constructor(n,e,r,s,o,i,a){this.dtype=n,this.shape=e,this.sourceLayer=r,this.inputs=s,this.callArgs=o,this.outputTensorIndex=a,this.id=w$(),null!=i&&(this.originalName=S$(i),this.name=I$(this.originalName)),this.rank=e.length}}let Aie=0;class Nv{constructor(n,e){this.callArgs=e,this.id=Aie++,this.outboundLayer=n.outboundLayer,this.inboundLayers=n.inboundLayers,this.nodeIndices=n.nodeIndices,this.tensorIndices=n.tensorIndices,this.inputTensors=n.inputTensors,this.outputTensors=n.outputTensors,this.inputMasks=n.inputMasks,this.outputMasks=n.outputMasks,this.inputShapes=n.inputShapes,this.outputShapes=n.outputShapes;for(const r of n.inboundLayers)r?.outboundNodes.push(this);n.outboundLayer.inboundNodes.push(this)}getConfig(){const n=[];for(const e of this.inboundLayers)n.push(null!=e?e.name:null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:n,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let Rie=0;class tn extends Oc{constructor(n={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=Rie++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let e=n.name;if(!e){const r=this.getClassName();e=ya(r)+"_"+Sv(r)}if(this.name=e,this.trainable_=null==n.trainable||n.trainable,null!=n.inputShape||null!=n.batchInputShape){let r;if(null!=n.batchInputShape)r=n.batchInputShape;else if(null!=n.inputShape){let o=null;null!=n.batchSize&&(o=n.batchSize),r=[o].concat(n.inputShape)}this.batchInputShape=r;let s=n.dtype;null==s&&(s=n.inputDType),null==s&&(s="float32"),this.dtype=s}this.initialWeights=null!=n.weights?n.weights:null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(n,e){return n.name+"_ib-"+e.toString()}getNodeAtIndex(n,e){if(0===this.inboundNodes.length)throw new $o(`The layer has never been called and thus has no defined ${e}.`);if(this.inboundNodes.length<=n)throw new ee(`Asked to get ${e} at node ${n}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[n]}getInputAt(n){return Os(this.getNodeAtIndex(n,"input").inputTensors)}getOutputAt(n){return Os(this.getNodeAtIndex(n,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new Ri(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(0===this.inboundNodes.length)throw new Ri(`Layer ${this.name} is not connected, no input to return.`);return Os(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new Ri(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new Ri(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return Os(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(n=>n())}get updates(){return this._updates}get built(){return this._built}set built(n){this._built=n}get trainable(){return this.trainable_}set trainable(n){this._trainableWeights.forEach(e=>e.trainable=n),this.trainable_=n}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(n=>n.trainable):[]}set trainableWeights(n){this._trainableWeights=n}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(n=>!n.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(n){this._nonTrainableWeights=n}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(n){if(n=Mn(n),null==this.inputSpec||0===this.inputSpec.length)return;const e=Mn(this.inputSpec);if(n.length!==e.length)throw new ee(`Layer ${this.name} expects ${e.length} inputs, but it received ${n.length} input tensors. Input received: ${n}`);for(let r=0;r<n.length;r++){const s=n[r],o=e[r];if(null==o)continue;const i=s.rank;if(null!=o.ndim&&i!==o.ndim)throw new ee(`Input ${r} is incompatible with layer ${this.name}: expected ndim=${o.ndim}, found ndim=${i}`);if(null!=o.maxNDim&&i>o.maxNDim)throw new ee(`Input ${r} is incompatible with layer ${this.name}: expected max_ndim=${o.maxNDim}, found ndim=${i}`);if(null!=o.minNDim&&i<o.minNDim)throw new ee(`Input ${r} is incompatible with layer ${this.name}: expected min_ndim=${o.minNDim}, found ndim=${i}.`);if(null!=o.dtype&&s.dtype!==o.dtype)throw new ee(`Input ${r} is incompatible with layer ${this.name} : expected dtype=${o.dtype}, found dtype=${s.dtype}.`);if(o.axes){const a=s.shape;for(const l in o.axes){const u=Number(l),c=o.axes[l];if(null!=c&&-1===[c,null].indexOf(u>=0?a[u]:a[a.length+u]))throw new ee(`Input ${r} is incompatible with layer ${this.name}: expected axis ${u} of input shape to have value ${c} but got shape ${a}.`)}}if(null!=o.shape)for(let a=0;a<o.shape.length;++a){const l=o.shape[a],u=s.shape[a];if(null!=l&&null!=u&&l!==u)throw new ee(`Input ${r} is incompatible with layer ${this.name}: expected shape=${o.shape}, found shape=${s.shape}.`)}}}call(n,e){return n}invokeCallHook(n,e){null!=this._callHook&&this._callHook(n,e)}setCallHook(n){this._callHook=n}clearCallHook(){this._callHook=null}apply(n,e){e=e||{},this.assertNotDisposed();const r=Mn(n);let s=!0;for(const i of r)if(!(i instanceof Mi)){s=!1;break}let o=!0;for(const i of r)if(i instanceof Mi){o=!1;break}if(s===o)throw new ee("Arguments to apply() must be all SymbolicTensors or all Tensors");return au(this.name,()=>{if(!this.built){this.assertInputCompatibility(n);const i=[];for(const a of Mn(n))i.push(a.shape);this.build(Os(i)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&o&&(this._refCount=1)}if(this.assertInputCompatibility(n),o){let i=this.call(n,e);const a=Mn(i),l=[];for(let u of a)-1!==r.indexOf(u)&&(u=u.clone()),l.push(u);if(i=Os(l),null!=this.activityRegularizer)throw new Wt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return i}{const i=function Fie(t){t=Mn(t);const n=[];for(const e of t)n.push(e.shape);return Os(n)}(n),a=this.computeOutputShape(i);let l;const u="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(n)?i[0]:i),l=null!=a&&a.length>0&&Array.isArray(a[0])?a.map((c,d)=>new Mi(u,c,this,Mn(n),e,this.name,d)):new Mi(u,a,this,Mn(n),e,this.name),this.addInboundNode(n,l,null,null,i,a,e),this._refCount++,null!=this.activityRegularizer)throw new Wt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return l}})}warnOnIncompatibleInputShape(n){if(null!=this.batchInputShape)if(n.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(n)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let e=!1;this.batchInputShape.forEach((r,s)=>{null!=r&&null!=n[s]&&n[s]!==r&&(e=!0)}),e&&console.warn(`The shape of the input tensor (${JSON.stringify(n)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new Ri(`The layer ${this.name} has never been called and thus has no defined output shape.`);const n=[];for(const e of this.inboundNodes){const r=JSON.stringify(e.outputShapes);-1===n.indexOf(r)&&n.push(r)}if(1===n.length){const e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&1===e.length?e[0]:e}throw new Ri(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new $o(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return Ev(this.weights)}build(n){this.built=!0}getWeights(n=!1){return OS(n?this.trainableWeights:this.weights)}setWeights(n){he(()=>{const e=this.weights;if(e.length!==n.length)throw new ee(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${n.length}, but the layer was expecting ${e.length} weights. Provided weights: ${n}...`);if(0===e.length)return;const r=[],s=OS(e);for(let o=0;o<s.length;++o){const i=s[o],a=e[o],l=n[o];if(!gn(i.shape,l.shape))throw new ee(`Layer weight shape ${i.shape} not compatible with provided weight shape ${l.shape}`);r.push([a,l])}PS(r)})}addWeight(n,e,r,s,o,i,a,l){if(-1!==this._addedWeightNames.indexOf(n))throw new ee(`Duplicate weight name ${n} for layer ${this.name}`);this._addedWeightNames.push(n),null==r&&(r="float32"),this.fastWeightInitDuringBuild&&(s=null!=l?l():jn("zeros"));const u=s.apply(e,r),c=new Pi(u,r,n,i,a);return u.dispose(),null!=o&&this.addLoss(()=>o.apply(c.read())),null==i&&(i=!0),i?this._trainableWeights.push(c):this._nonTrainableWeights.push(c),c}setFastWeightInitDuringBuild(n){this.fastWeightInitDuringBuild=n}addLoss(n){null==n||Array.isArray(n)&&0===n.length||(n=Mn(n),null!=this._losses&&this.losses.push(...n))}computeOutputShape(n){return n}computeMask(n,e){if(!this.supportsMasking){if(null!=e){if(!Array.isArray(e))throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);e.forEach(r=>{if(null!=r)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)})}return null}return e}addInboundNode(n,e,r,s,o,i,a=null){const l=Mn(n);e=Mn(e),r=Mn(r),s=Mn(s),o=kv(o),i=kv(i);const u=[],c=[],d=[];for(const h of l)u.push(h.sourceLayer),c.push(h.nodeIndex),d.push(h.tensorIndex);new Nv({outboundLayer:this,inboundLayers:u,nodeIndices:c,tensorIndices:d,inputTensors:l,outputTensors:e,inputMasks:r,outputMasks:s,inputShapes:o,outputShapes:i},a);for(let h=0;h<e.length;h++)e[h].sourceLayer=this,e[h].nodeIndex=this.inboundNodes.length-1,e[h].tensorIndex=h}getConfig(){const n={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(n.batchInputShape=this.batchInputShape),null!=this.dtype&&(n.dtype=this.dtype),n}disposeWeights(){return this.weights.forEach(n=>n.dispose()),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(null===this._refCount)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let n=0;return 0==--this._refCount&&(n=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:n}}}function z$(t,n,e){if((null==n||null!=e&&e>0)&&(n=t.sourceLayer,e=t.nodeIndex),0===n.inboundNodes.length)return[t];{const r=n.inboundNodes[e];if(0===r.inboundLayers.length)return r.inputTensors;{const s=[];for(let o=0;o<r.inboundLayers.length;o++){const u=z$(r.inputTensors[o],r.inboundLayers[o],r.nodeIndices[o]);for(const c of u)-1===s.indexOf(c)&&s.push(c)}return s}}}let Av=(()=>{class t extends tn{constructor(e){if(super({dtype:e.dtype,name:null!=e.name?e.name:Sv("input").toString()}),null==e.batchSize&&(e.batchSize=null),null==e.sparse&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,null!=e.inputShape&&null!=e.batchInputShape)throw new ee("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let r=e.batchInputShape;if(null==r){if(null==e.inputShape)throw new ee("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");r=[e.batchSize].concat(e.inputShape)}else if(null!=e.batchSize)throw new ee("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const s=e.dtype||"float32";this.batchInputShape=r,this.dtype=s,this.inputSpec=[{shape:r}];const o=new Mi(this.dtype,this.batchInputShape,this,[],{},this.name);o.nodeIndex=0,o.tensorIndex=0,new Nv({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[o],outputTensors:[o],inputMasks:[null],outputMasks:[null],inputShapes:[r],outputShapes:[r]})}apply(e,r){throw new ee(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}return t.className="InputLayer",t})();Ue(Av);class tl{constructor(n){if(this.id2Value={},this.id2Mask={},this.name2Id={},n instanceof tl)for(const e in n.id2Value)this.id2Value[e]=n.id2Value[e],e in n.id2Mask&&(this.id2Mask[e]=n.id2Mask[e]);else{if(null==n)return;for(const e of n)this.add(e.key,e.value)}}add(n,e,r){if(null!=this.id2Value[n.id])throw new ee(`Duplicate key: name=${n.name}, id=${n.id}`);return this.id2Value[n.id]=function Mie(t,n){if(null==t.dtype||t.dtype===n.dtype)return n;try{return it(n,t.dtype)}catch{throw new ee(`The dtype of the feed (${n.dtype}) can not be cast to the dtype of the key '${t.name}' (${t.dtype}).`)}}(n,e),this.name2Id[n.name]=n.id,null!=r&&(this.id2Mask[n.id]=r),this}addFeed(n){this.add(n.key,n.value)}hasKey(n){return null!=this.id2Value[n.id]}names(){return Object.keys(this.name2Id)}getValue(n){if(n instanceof Mi){if(null==this.id2Value[n.id])throw new ee(`Nonexistent key: ${n.name}`);return this.id2Value[n.id]}{const e=this.name2Id[n];if(null==e)throw new ee(`Feed dict has no SymbolicTensor name: ${n}`);return this.id2Value[e]}}getMask(n){if(n instanceof Mi){if(null==this.id2Value[n.id])throw new ee(`Nonexistent key: ${n.name}`);return this.id2Mask[n.id]}{const e=this.name2Id[n];if(null==e)throw new ee(`Feed dict has no SymbolicTensor name: ${n}`);return this.id2Mask[e]}}disposeMasks(){null!=this.id2Mask&&Xt(this.id2Mask)}}const Rv=new y$,Fv=new y$;function rf(t,n,e,r){const s=null!=e&&e.training,o=Array.isArray(t),i=o?t:[t],a=i.map(f=>f.name),l=[],u=n.names();for(const f of a)-1!==u.indexOf(f)?l.push(n.getValue(f)):l.push(null);null!=r&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);const c=a.join(",")+"|"+n.names().sort().join(",");let h,d=Rv.get(c);if(null==d){const f=function Lie(t,n){R(null!=t&&t.length>0,()=>"Expected at least one fetch, got none");let e=[],r={};if(1===t.length){const s=U$(t[0],n);e=s.sorted,r=s.recipientMap}else{const s=new Set;for(const o of t){const{sorted:i,recipientMap:a}=U$(o,n);for(const l of i)s.has(l.name)||(e.push(l),s.add(l.name));for(const l in a)null==r[l]&&(r[l]=new Set),a[l].forEach(u=>r[l].add(u))}}return{sorted:e,recipientCounts:Vie(r)}}(i,n);d=f.sorted,h=f.recipientCounts,Rv.put(c,d),Fv.put(c,h)}h={},s||Object.assign(h,Fv.get(c));const p=new tl(n);for(let f=0;f<d.length;++f){if(null!=r){const K=a1().numTensors;K>r.maxNumTensors&&(r.maxNumTensors=K),K<r.minNumTensors&&(r.minNumTensors=K)}const g=d[f],m=g.sourceLayer;if(m instanceof Av)continue;const y=[],v=[],b=[];let x=!1;for(const K of g.inputs){const Y=p.getValue(K),se=p.getMask(K);y.push(Y),v.push(se),null!=se&&(x=!0),s||(h[K.name]--,0===h[K.name]&&!n.hasKey(K)&&-1===a.indexOf(K.name)&&!Y.isDisposed&&!0!==K.sourceLayer.stateful&&b.push(Y))}x&&((e=e||{}).mask=v[0]);const w=Mn(m.apply(y,e));let k=null;m.supportsMasking&&(k=m.computeMask(y,v));const V=Bie(g),z=Array.isArray(V)?V:[V];for(let K=0;K<z.length;++K){p.hasKey(z[K])||p.add(z[K],w[K],Array.isArray(k)?k[0]:k);const Y=a.indexOf(z[K].name);-1!==Y&&(l[Y]=w[K])}s||Xt(b)}return p.disposeMasks(),o?l:l[0]}function Vie(t){const n={};for(const e in t)n[e]=t[e].size;return n}function U$(t,n){const e=new Set,r=[],s={};for(const a of n.names())e.add(a);const o=[],i=[];for(o.push(t);o.length>0;){const a=o[o.length-1];if(e.has(a.name)){o.pop();continue}const l=i[i.length-1]===o.length-1;if(0===a.inputs.length||l)o.pop(),r.push(a),e.add(a.name),l&&i.pop();else{i.push(o.length-1);for(const u of a.inputs)null==s[u.name]&&(s[u.name]=new Set),s[u.name].add(a.name),!e.has(u.name)&&o.push(u)}}return{sorted:r,recipientMap:s}}function Bie(t){let n;if(1===t.sourceLayer.inboundNodes.length)n=t.sourceLayer.output;else{let e=null;for(let r=0;r<t.sourceLayer.inboundNodes.length;++r)for(const s of t.sourceLayer.inboundNodes[r].outputTensors)if(s.id===t.id){e=r;break}n=t.sourceLayer.getOutputAt(e)}return n}function MS(t,n){return he(()=>ms(yt(Q(t,t),n,!0)))}pe().registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,function $ie(t){Rv?.setMaxEntries(t),Fv?.setMaxEntries(t)});class sf extends Oc{getConfig(){return{}}}Ue((()=>{class t extends sf{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return he(()=>{const r=MS(e,this.axis),s=uo(r,0,this.maxValue);return Q(e,wt(s,Ge(Tr(),r)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}return t.className="MaxNorm",t})()),Ue((()=>{class t extends sf{constructor(e){super(),this.defaultAxis=0,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return he(()=>wt(e,Ge(Tr(),MS(e,this.axis))))}getConfig(){return{axis:this.axis}}}return t.className="UnitNorm",t})()),Ue((()=>{class t extends sf{apply(e){return pa(e)}}return t.className="NonNeg",t})()),Ue((()=>{class t extends sf{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=e.minValue?e.minValue:this.defaultMinValue,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.rate=null!=e.rate?e.rate:this.defaultRate,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return he(()=>{const r=MS(e,this.axis),s=Ge(Q(this.rate,uo(r,this.minValue,this.maxValue)),Q(1-this.rate,r));return Q(e,wt(s,Ge(Tr(),r)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}return t.className="MinMaxNorm",t})());const W$={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function Er(t){return DS(t)}function G$(t,n={}){return Zp(t,Ao.getMap().classNameMap,n,"constraint")}function Nr(t){return null==t?null:"string"==typeof t?G$({className:t in W$?W$[t]:t,config:{}}):t instanceof sf?t:G$(t)}function nl(t){return $S.apply(this,arguments)}function $S(){return($S=$e(function*(t){if(null==t)return;const n=[],e=[],r=[];for(const s in t){const o=t[s];if("number"!=typeof o){const i=o;n.push(i.data()),e.push(s),r.push(i)}}if(n.length>0){const s=yield Promise.all(n);for(let o=0;o<s.length;++o)t[e[o]]=s[o][0];Xt(r)}})).apply(this,arguments)}function H$(t){if(null!=t)for(const n in t){const e=t[n];"number"!=typeof e&&e.dispose()}}class Hc{constructor(){this.validationData=null}setParams(n){this.params=n}onEpochBegin(n,e){return $e(function*(){})()}onEpochEnd(n,e){return $e(function*(){})()}onBatchBegin(n,e){return $e(function*(){})()}onBatchEnd(n,e){return $e(function*(){})()}onTrainBegin(n){return $e(function*(){})()}onTrainEnd(n){return $e(function*(){})()}setModel(n){}}class Uie{constructor(n,e=10){null==n&&(n=[]),this.callbacks=n,this.queueLength=e}append(n){this.callbacks.push(n)}setParams(n){for(const e of this.callbacks)e.setParams(n)}setModel(n){for(const e of this.callbacks)e.setModel(n)}onEpochBegin(n,e){var r=this;return $e(function*(){null==e&&(e={});for(const s of r.callbacks)yield s.onEpochBegin(n,e)})()}onEpochEnd(n,e){var r=this;return $e(function*(){null==e&&(e={});for(const s of r.callbacks)yield s.onEpochEnd(n,e)})()}onBatchBegin(n,e){var r=this;return $e(function*(){null==e&&(e={});for(const s of r.callbacks)yield s.onBatchBegin(n,e)})()}onBatchEnd(n,e){var r=this;return $e(function*(){null==e&&(e={});for(const s of r.callbacks)yield s.onBatchEnd(n,e)})()}onTrainBegin(n){var e=this;return $e(function*(){null==n&&(n={});for(const r of e.callbacks)yield r.onTrainBegin(n)})()}onTrainEnd(n){var e=this;return $e(function*(){null==n&&(n={});for(const r of e.callbacks)yield r.onTrainEnd(n)})()}}class Wie extends Hc{constructor(){super()}onEpochBegin(n){var e=this;return $e(function*(){e.seen=0,e.totals={}})()}onBatchEnd(n,e){var r=this;return $e(function*(){null==e&&(e={});const s=null==e.size?0:e.size;r.seen+=s;for(const o in e){const i=e[o];if("number"==typeof i)r.totals.hasOwnProperty(o)||(r.totals[o]=0),r.totals[o]=r.totals[o]+i*s;else{let a;o in r.totals?a=r.totals[o]:r.totals[o]=0;const l=he(()=>Ge(r.totals[o],Q(i,s)));r.totals[o]=l,a?.dispose()}}})()}onEpochEnd(n,e){var r=this;return $e(function*(){if(null!=e)for(const s of r.params.metrics)null!=r.totals[s]&&("number"==typeof r.totals[s]?e[s]=r.totals[s]/r.seen:he(()=>{const o=Q(wt(1,r.seen),r.totals[s]);e[s]=o,r.totals[s].dispose(),Ei(e[s])}))})()}}class Gie extends Hc{onTrainBegin(n){var e=this;return $e(function*(){e.epoch=[],e.history={}})()}onEpochEnd(n,e){var r=this;return $e(function*(){null==e&&(e={}),r.epoch.push(n);for(const s in e)null==r.history[s]&&(r.history[s]=[]),r.history[s].push(e[s])})()}syncData(){var n=this;return $e(function*(){const e=[],r=[],s=[];for(const i in n.history){const a=n.history[i];for(let l=0;l<a.length;++l)"number"!=typeof a[l]&&(e.push(a[l].data()),r.push(i),s.push(l))}const o=yield Promise.all(e);for(let i=0;i<o.length;++i)n.history[r[i]][s[i]].dispose(),n.history[r[i]][s[i]]=o[i][0]})()}}class Hie extends Hc{constructor(n,e){if(super(),this.currentEpoch=0,this.nowFunc=n.nowFunc,this.nextFrameFunc=n.nextFrameFunc||DM,this.yieldEvery=e||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=n.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");$_(this.yieldEvery)&&(this.maybeWait=function iie(t,n,e){let s,r=null!=e?e():Rs();return(...i)=>{const a=null!=e?e():Rs();return a-r<n||(r=a,s=t(...i)),s}}(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=n.onTrainBegin,this.trainEnd=n.onTrainEnd,this.epochBegin=n.onEpochBegin,this.epochEnd=n.onEpochEnd,this.batchBegin=n.onBatchBegin,this.batchEnd=n.onBatchEnd,this.yield=n.onYield}maybeWait(n,e,r){var s=this;return $e(function*(){const o=[];null!=s.yield&&(yield nl(r),o.push(s.yield(n,e,r))),o.push(s.nextFrameFunc()),yield Promise.all(o)})()}onEpochBegin(n,e){var r=this;return $e(function*(){r.currentEpoch=n,null!=r.epochBegin&&(yield nl(e),yield r.epochBegin(n,e))})()}onEpochEnd(n,e){var r=this;return $e(function*(){const s=[];null!=r.epochEnd&&(yield nl(e),s.push(r.epochEnd(n,e))),"epoch"===r.yieldEvery&&s.push(r.nextFrameFunc()),yield Promise.all(s)})()}onBatchBegin(n,e){var r=this;return $e(function*(){null!=r.batchBegin&&(yield nl(e),yield r.batchBegin(n,e))})()}onBatchEnd(n,e){var r=this;return $e(function*(){const s=[];null!=r.batchEnd&&(yield nl(e),s.push(r.batchEnd(n,e))),"batch"===r.yieldEvery?s.push(r.nextFrameFunc()):$_(r.yieldEvery)&&s.push(r.maybeWait(r.currentEpoch,n,e)),yield Promise.all(s)})()}onTrainBegin(n){var e=this;return $e(function*(){null!=e.trainBegin&&(yield nl(n),yield e.trainBegin(n))})()}onTrainEnd(n){var e=this;return $e(function*(){null!=e.trainEnd&&(yield nl(n),yield e.trainEnd(n))})()}}function j$(t,n){return null==t&&(t={}),t instanceof Hc?[t]:Array.isArray(t)&&t[0]instanceof Hc?t:Mn(t).map(r=>new Hie(r,n))}let jie=(()=>{class t{constructor(){}static registerCallbackConstructor(e,r){R(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),t.checkForDuplicate(r),null==t.constructors[e]&&(t.constructors[e]=[]),t.constructors[e].push(r)}static checkForDuplicate(e){for(const r in t.constructors)t.constructors[+r].forEach(o=>{if(o===e)throw new ee("Duplicate callback constructor.")})}static clear(){t.constructors={}}static createCallbacks(e){const r=[];for(const s in t.constructors){const o=+s;e>=o&&r.push(...t.constructors[o])}return r.map(s=>new s)}}return t.constructors={},t})();function q$(t,n,e,r,s,o,i,a,l){const u=new Gie,c=[new Wie,...jie.createCallbacks(n)];null!=t&&c.push(...t),c.push(u);const d=new Uie(c);return d.setParams({epochs:e,initialEpoch:r,samples:s,steps:o,batchSize:i,verbose:n,doValidation:a,metrics:l}),{callbackList:d,history:u}}function $i(t,n={},e=!1){return Zp(t,Ao.getMap().classNameMap,n,"layer",e)}function Ov(t,n){return he(()=>{"float32"!==t.dtype&&(t=it(t,"float32"));const e=yt(ef(t),n,!0),r=$p(e.shape,Tr()),s=ms(Ha(e,r));return wt(t,s)})}function Pv(t,n){return he(()=>hr(ef(gt(n,t)),-1))}function LS(t,n){return he(()=>hr(Pr(gt(n,t)),-1))}function VS(t,n){return he(()=>{const e=gt(t,n),r=uo(Pr(t),Tr(),Number.MAX_VALUE),s=Pr(wt(e,r));return Q(100,hr(s,-1))})}function af(t,n,e=!1){return he(()=>{if(e)n=V1(n);else{const r=yt(n,n.shape.length-1,!0);n=wt(n,r)}return n=uo(n,Tr(),1-Tr()),Hn(yt(Q(it(t,"float32"),Oo(n)),n.shape.length-1))})}function Mv(t,n,e=!1){return he(()=>{const r=it(iv(function xie(t){const n=[Ja(t.shape)];return re(t,n)}(t)),"int32"),s=(n=uo(n,Tr(),1-Tr())).shape;return af(re(oM(r,s[s.length-1]),s),n,e)})}function $v(t,n){return he(()=>{let e;return e=uo(n,Tr(),1-Tr()),e=Oo(wt(e,gt(1,e))),hr(function Qie(t,n){if(!gn(t.shape,n.shape))throw new ee(`logits and labels must have the same shape, but got shapes ${JSON.stringify(t.shape)} and ${JSON.stringify(n.shape)}`);return he(()=>{const e=pa(n),r=Hn(Pr(n));return Ge(gt(e,Q(n,t)),k1(Fo(r)))})}(t,e),-1)})}function K$(t,n){return he(()=>{const e=Ov(t,-1),r=Ov(n,-1),s=Q(e,r);return Hn(yt(s,-1))})}const Lv={meanSquaredError:Pv,meanAbsoluteError:LS,meanAbsolutePercentageError:VS,meanSquaredLogarithmicError:function qie(t,n){return he(()=>{const e=uo(n,Tr(),Number.MAX_VALUE),r=Oo(Ge(1,e)),s=uo(t,Tr(),Number.MAX_VALUE),o=Oo(Ge(1,s));return hr(ef(gt(r,o)),-1)})},squaredHinge:function Kie(t,n){return he(()=>{const e=Ha(0,gt(1,Q(t,n)));return hr(ef(e),-1)})},hinge:function Xie(t,n){return he(()=>{const e=Ha(0,gt(1,Q(t,n)));return hr(e,-1)})},categoricalHinge:function Yie(t,n){return he(()=>{const e=yt(Q(t,n),-1),r=ni(Q(gt(1,t),n),-1);return Ha(0,Ge(1,gt(r,e)))})},logcosh:function Zie(t,n){return he(()=>{const e=Math.log(2),r=gt(n,t),s=gt(Ge(r,Hp(Q(-2,r))),e);return hr(s,-1)})},categoricalCrossentropy:af,sparseCategoricalCrossentropy:Mv,binaryCrossentropy:$v,kullbackLeiblerDivergence:function Jie(t,n){return he(()=>{const e=uo(t,Tr(),1),r=uo(n,Tr(),1);return yt(Q(t,Oo(wt(e,r))),-1)})},poisson:function eae(t,n){return he(()=>{const e=Oo(Ge(Tr(),n));return hr(gt(n,Q(t,e)),-1)})},cosineProximity:K$};function BS(t){if("string"==typeof t){if(t in Lv)return Lv[t];let n=`Unknown loss ${t}`;throw t.toLowerCase().includes("softmaxcrossentropy")&&(n=`Unknown loss ${t}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new ee(n)}return t}function X$(t,n){return he(()=>{const e=Q(.5,Po(n)),r=Fi(co(n,e),t.dtype);return hr(Ni(t,r),-1)})}function Y$(t,n){return he(()=>Fi(Ni(Lp(t,-1),Lp(n,-1)),"float32"))}function sae(t,n){return $v(t,n)}function oae(t,n){return t.rank===n.rank&&(t=jp(t,[t.rank-1])),(n=Lp(n,-1)).dtype!==t.dtype&&(n=it(n,t.dtype)),it(Ni(t,n),"float32")}const Q$=af,J$=Mv,Vv={binaryAccuracy:X$,categoricalAccuracy:Y$,precision:function rae(t,n){return he(()=>{const e=function Z$(t,n){return he(()=>it(yt(ha(Ni(t,1),Ni(n,1))),"float32"))}(t,n),r=function nae(t,n){return he(()=>it(yt(ha(Ni(t,0),Ni(n,1))),"float32"))}(t,n),s=Ge(e,r);return it(ys(co(s,0),wt(e,s),0),"float32")})},categoricalCrossentropy:Q$,sparseCategoricalCrossentropy:J$,mse:Pv,MSE:Pv,mae:LS,MAE:LS,mape:VS,MAPE:VS,cosine:K$};function pae(t){if("string"==typeof t&&t in Vv)return Vv[t];if("string"!=typeof t&&null!=t)return t;throw new ee(`Unknown metric ${t}`)}function Bv(t){if(po(null!==t,`Unknown LossOrMetricFn ${t}`),"string"==typeof t)return t;{let n;for(const e of Object.keys(Lv))if(Lv[e]===t){n=e;break}if(void 0!==n)return n;for(const e of Object.keys(Vv))if(Vv[e]===t){n=e;break}return void 0!==n?n:t.name}}const eL=1048576;function tL(t,n,e=!1){if(null==t||"object"!=typeof t||Object.getPrototypeOf(t)!==Object.prototype||!zS(t))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(e){const r=JSON.stringify(t);r.length>eL&&console.warn(`User-defined metadata of model "${n}" is too large in size (length=${r.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${eL}.`)}}function zS(t){if(null===t)return!0;if("object"==typeof t){if(Object.getPrototypeOf(t)===Object.prototype){const n=Object.keys(t);for(const e of n)if("string"!=typeof e||!zS(t[e]))return!1;return!0}if(Array.isArray(t)){for(const n of t)if(!zS(n))return!1;return!0}return!1}{const n=typeof t;return"string"===n||"number"===n||"boolean"===n}}function zv(t,n,e=console.log){let r="";for(let s=0;s<t.length;++s)s>0&&(r=r.slice(0,r.length-1)+" "),r+=t[s],r=r.slice(0,n[s]),r+=" ".repeat(n[s]-r.length);e(r)}function vae(t,n,e){let r,s;try{s=t.inboundNodes.map(l=>JSON.stringify(l.inputShapes)).join(",")}catch{s="multiple"}try{r=JSON.stringify(t.outputShape)}catch{r="multiple"}zv([`${t.name} (${t.getClassName()})`,s,r,t.countParams().toString()],n,e)}function bae(t,n,e,r){let s,o;try{o=t.inboundNodes.map(d=>JSON.stringify(d.inputShapes)).join(",")}catch{o="multiple"}try{s=JSON.stringify(t.outputShape)}catch{s="multiple"}const i=[];for(const d of t.inboundNodes)if(!(null!=e&&e.length>0&&-1===e.indexOf(d)))for(let h=0;h<d.inboundLayers.length;++h)i.push(`${d.inboundLayers[h].name}[${d.nodeIndices[h]}][${d.tensorIndices[h]}]`);const a=t.name,l=t.getClassName(),u=0===i.length?"":i[0];zv([`${a} (${l})`,o,s,t.countParams().toString(),u],n,r);for(let d=1;d<i.length;++d)zv(["","","","",i[d]],n,r)}function nL(t,n,e){return("inboundNodes"===t||"outputLayers"===t||"inputLayers"===t)&&0===n&&"string"==typeof e}function Uv(t,n){if(null===t)return null;if("string"==typeof t)return ou(t);if("number"==typeof t||"boolean"==typeof t)return t;if(t instanceof Array){const e=[],r=t.length;for(let s=0;s<r;++s){const o=t[s];nL(n,s,o)?e.push(o):e.push(Uv(o,n))}return e}{const e={};for(const r of Object.keys(t)){const s=t[r];if("name"===r&&"string"==typeof s)e[r]=s;else{const o=ou(r);e[o]=Uv(s,o)}}return e}}function US(t,n){if(null==t)return null;if("string"==typeof t)return ya(t);if("number"==typeof t||"boolean"==typeof t)return t;if(t instanceof Array){const e=[],r=t.length;for(let s=0;s<r;++s){const o=t[s];nL(n,s,o)?e.push(o):e.push(US(o,n))}return e}{const e={};for(const r of Object.keys(t)){const s=t[r];e[ya(r)]="name"!==r&&"className"!==r||"string"!=typeof s?US(s,r):s}return e}}class ii extends tn{constructor(n){if(super({}),this.containerNodes=new Set,this.name=n.name,null==this.name){const v=this.getClassName().toLowerCase();this.name=Sv(v)}if(this.supportsMasking=!1,this.trainable_=!0,this.inputs=Array.isArray(n.inputs)?n.inputs.slice():[n.inputs],this.outputs=Array.isArray(n.outputs)?n.outputs.slice():[n.outputs],Qa(this.inputs).length!==this.inputs.length)throw new ee(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(v=>v.name)}`);Qa(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(v=>v.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const v of this.outputs){const x=v.nodeIndex,w=v.tensorIndex;this.outputLayers.push(v.sourceLayer),this.outputLayersNodeIndices.push(x),this.outputLayersTensorIndices.push(w)}for(const v of this.inputs){const b=v.sourceLayer,x=v.nodeIndex,w=v.tensorIndex;po(0===x,"input layer has >1 nodes"),po(0===w,"input layer has >1 tensors"),this.inputLayers.push(b),this.inputLayersNodeIndices.push(x),this.inputLayersTensorIndices.push(w)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let v=0;v<this.inputLayers.length;v++){const b=this.inputLayers[v];if(!(b instanceof Av))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${n.inputs}. Input ${v} (0-based) originates from layer type ${b.getClassName()}.`);this.inputNames.push(b.name),this.feedInputShapes.push(b.batchInputShape),this.feedInputNames.push(b.name)}for(const v of this.outputLayers)this.outputNames.push(v.name);this.internalInputShapes=this.inputs.map(v=>v.shape),this.internalOutputShapes=this.outputs.map(v=>v.shape);const e={},r={},s={},o={},i={},a=[],l=(v,b,x,w,k,V)=>{(null==w||null==k||null==V)&&(w=v.sourceLayer,k=v.nodeIndex,V=v.tensorIndex);const z=w.inboundNodes[k];if(-1!==x.indexOf(z))throw new $o(`The tensor ${v.name} at layer "${w.name}" is part of a cycle.`);if(-1!==b.indexOf(z))return;this.containerNodes.add(ii.nodeKey(w,k)),w.id in i||(i[w.id]=Object.keys(i).length),-1===x.indexOf(z)&&x.push(z);const K=z.inboundLayers.length;for(let Y=0;Y<K;Y++)l(z.inputTensors[Y],b,x,z.inboundLayers[Y],z.nodeIndices[Y],z.tensorIndices[Y]);for(b.push(z);x.indexOf(z)>=0;)x.splice(x.indexOf(z),1);a.push(z)},u=[],c=[];for(const v of this.outputs)l(v,u,c);const d=a.slice().reverse();for(const v of d){r[v.id]=v,v.id in e||(e[v.id]=0);let b=e[v.id];b=Math.max(b,null==s[v.outboundLayer.id]?0:s[v.outboundLayer.id]),s[v.outboundLayer.id]=b,o[v.outboundLayer.id]=v.outboundLayer,e[v.id]=b;for(let w=0;w<v.inboundLayers.length;w++){const z=v.inboundLayers[w].inboundNodes[v.nodeIndices[w]];e[z.id]=Math.max(b+1,null==e[z.id]?0:e[z.id]),r[z.id]=z}}const h={};for(const v in e){const b=e[v];b in h||(h[b]=[]),h[b].push(r[v])}const p={};for(const v in s){const b=s[v];b in p||(p[b]=[]),p[b].push(o[v])}let f=Object.keys(p).map(v=>parseInt(v,10)).sort(_v);this.layers=[];for(const v of f){const b=p[v];b.sort((x,w)=>{const k=i[x.id],V=i[w.id];return k<V?-1:k>V?1:0});for(const x of b)x instanceof ii&&this.internalContainerRefs.push(x),this.layers.push(x)}this.layersByDepth=p,f=Object.keys(h).map(v=>parseInt(v,10)).sort(_v);const g=this.inputs.slice(),m=[];for(const v of f)for(const b of h[v]){const x=b.outboundLayer;if(null!=x){for(const w of b.inputTensors)if(-1===g.indexOf(w))throw new $o(`Graph disconnected: cannot obtain value for tensor ${w} at layer "${x.name}". The following previous layers were accessed without issue: ${m}`);for(const w of b.outputTensors)g.push(w);m.push(x.name)}}this.nodesByDepth=h;const y=this.layers.map(v=>v.name);for(const v of y){const b=y.filter(x=>x===v).length;if(1!==b)throw new $o(`The name "${v}" is used ${b} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(y))}this.outboundNodes=[],this.inboundNodes=[],new Nv({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(v=>null),outputMasks:this.outputs.map(v=>null),inputShapes:this.inputs.map(v=>v.shape),outputShapes:this.outputs.map(v=>v.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const n={refCountAfterDispose:null,numDisposedVariables:0};if(0==--this._refCount){for(const e of this.layers)n.numDisposedVariables+=e.dispose().numDisposedVariables;for(const e of this.internalContainerRefs)n.numDisposedVariables+=e.dispose().numDisposedVariables}return n.refCountAfterDispose=this._refCount,n}get trainable(){return this.trainable_}set trainable(n){this.layers.forEach(e=>{e._trainableWeights.forEach(r=>r.trainable=n)}),this.trainable_=n}get trainableWeights(){if(this._trainableWeights.length>0)throw new ee("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let n=[];for(const e of this.layers)n=n.concat(e.trainableWeights);return n}get nonTrainableWeights(){const n=[];for(const e of this.layers)n.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const r of this.layers)e.push(...r.trainableWeights);return e.concat(n)}return n}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(n,e=!0){const r={};let s=0;for(const i of this.layers)for(const a of i.weights){if(null!=r[a.originalName])throw new ee(`Duplicate weight name: ${a.originalName}`);r[a.originalName]=a,s++}const o=[];for(const i in n){let a=i;if(null==r[i]){const l=i.split("/");a=l.slice(0,-2).concat([l[l.length-1]]).join("/")}if(null!=r[a])o.push([r[a],n[i]]);else if(e)throw new ee(`Provided weight data has no target variable: ${i}`);delete r[a]}if(e){const i=[];for(const a in r)i.push(a);if(i.length>0)throw new ee(`${i.length} of ${s} weights are not set: ${i}`)}PS(o)}updatedConfig(){const n=this.getConfig(),e={};return e.className=this.getClassName(),e.config=n,e.kerasVersion="tfjs-layers 4.3.0",e.backend="TensorFlow.js",e}toJSON(n,e=!0){const r=US(this.updatedConfig());return e?JSON.stringify(r):r}call(n,e){return he(()=>{n=Mn(n);const r=new tl;for(let s=0;s<this.inputs.length;++s)r.add(this.inputs[s],n[s]);return rf(this.outputs,r,e)})}computeMask(n,e){return he(()=>{let r;return n=Mn(n),r=null==e?su(null,n.length):Mn(e),this.runInternalGraph(n,r)[1]})}computeOutputShape(n){const e=kv(n);if(e.length!==this.inputLayers.length)throw new ee(`Invalid inputShape argument ${n}: model has ${this.inputLayers.length} tensor inputs.`);const r={};for(let a=0;a<e.length;a++)r[this.inputLayers[a].name+"_0_0"]=e[a];const s=Object.keys(this.nodesByDepth).map(a=>parseInt(a,10)).sort(_v);if(s.length>1)for(const a of s){const l=this.nodesByDepth[a];for(const u of l){const c=u.outboundLayer;if(-1!==this.inputLayers.map(g=>g.id).indexOf(c.id))continue;const d=[];for(let g=0;g<u.inboundLayers.length;g++)d.push(r[`${u.inboundLayers[g].name}_${u.nodeIndices[g]}_${u.tensorIndices[g]}`]);const p=kv(c.computeOutputShape(Os(d))),f=c.inboundNodes.indexOf(u);for(let g=0;g<p.length;g++)r[`${c.name}_${f}_${g}`]=p[g]}}const o=[],i=[];for(let a=0;a<this.outputLayers.length;a++)i.push(`${this.outputLayers[a].name}_${this.outputLayersNodeIndices[a]}_${this.outputLayersTensorIndices[a]}`);for(let a=0;a<i.length;a++){const l=i[a];po(l in r),o.push(r[l])}return Os(o)}runInternalGraph(n,e){null==e&&(e=su(null,n.length));const r={};for(let l=0;l<this.inputs.length;++l)r[this.inputs[l].id]=[n[l],e[l]];const s=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(_v);for(const l of s){const u=this.nodesByDepth[l];for(const c of u){const d=c.outboundLayer,h=c.inputTensors,p=c.outputTensors,f=new Array;for(const g of h)g.id in r&&f.push(r[g.id]);if(f.length===h.length){let m,y,v,b,g={};if(null!=c.callArgs&&(g=c.callArgs),1===f.length){const[x,w]=f[0];null==g.mask&&(g.mask=w),v=Mn(d.call(x,g)),b=Mn(d.computeMask(x,w)),m=[x],y=[w]}else m=f.map(x=>x[0]),y=f.map(x=>x[1]),null==g.mask&&(g.mask=y),v=Mn(d.call(m,g)),b=Mn(d.computeMask(m,y));if(d.activityRegularizer)throw new Wt("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let x=0;x<p.length;++x)r[p[x].id]=[v[x],b[x]]}}}const o=[],i=[],a=[];for(const l of this.outputs){po(l.id in r,`Could not compute output ${l.name} : ${l.id}`);const[u,c]=r[l.id];a.push(u.shape),o.push(u),i.push(c)}return[o,i,a]}buildNodeConversionMap(n){const e={};let r;for(const s of this.layers){r=s instanceof ii?1:0;for(let o=0;o<s.inboundNodes.length;o++){const i=ii.nodeKey(s,o);this.containerNodes.has(i)&&(e[i]=r,r+=1)}}return e}getLayer(n,e){if(null!=e){if(this.layers.length<=e)throw new ee(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}if(null==n)throw new ee("Provide either a layer name or layer index");for(const r of this.layers)if(r.name===n)return r;throw new ee(`No such layer: ${n}`)}calculateLosses(){return he(()=>{const n=[];for(const e of this.layers)for(let r=0;r<e.inboundNodes.length;++r){const s=ii.nodeKey(e,r);this.containerNodes.has(s)&&n.push(...e.calculateLosses())}return n})}getConfig(){const n={name:this.name},e=this.buildNodeConversionMap(this.layers),r=[];for(const i of this.layers){const a=i.getClassName(),l=i.getConfig(),u=[];for(let d=0;d<i.inboundNodes.length;d++){const h=i.inboundNodes[d],p=ii.nodeKey(i,d);let f={};if(this.containerNodes.has(p)){if(h.callArgs)try{JSON.stringify(h.callArgs),f=h.callArgs}catch{console.warn(`Layer ${i.name} was passed non-serializable keyword arguments: ${h.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),f={}}if(h.inboundLayers.length>0){const g=[];for(let m=0;m<h.inboundLayers.length;m++){const y=h.inboundLayers[m],b=h.tensorIndices[m];let w=e[ii.nodeKey(y,h.nodeIndices[m])];null==w&&(w=0),g.push([y.name,w,b,f])}u.push(g)}}}const c={};c.name=i.name,c.className=a,c.config=l,c.inboundNodes=u,r.push(c)}n.layers=r;const s=[];for(let i=0;i<this.inputLayers.length;i++){const a=this.inputLayers[i],u=ii.nodeKey(a,this.inputLayersNodeIndices[i]);if(!this.containerNodes.has(u))continue;let c=e[u];null==c&&(c=0),s.push([a.name,c,this.inputLayersTensorIndices[i]])}n.inputLayers=s;const o=[];for(let i=0;i<this.outputLayers.length;i++){const a=this.outputLayers[i],u=ii.nodeKey(a,this.outputLayersNodeIndices[i]);if(!this.containerNodes.has(u))continue;let c=e[u];null==c&&(c=0),o.push([a.name,c,this.outputLayersTensorIndices[i]])}return n.outputLayers=o,n}static fromConfig(n,e,r={},s=!1){const o={},i={};function a(m,y){m.name in i?i[m.name].push(y):i[m.name]=[y]}function l(m,y){const v=[];let b;for(const x of y){const w=x[0],k=x[1],V=x[2];if(b=null==x[3]?{}:x[3],!(w in o))return void a(m,y);const z=o[w];if(z.inboundNodes.length<=k)return void a(m,y);v.push(z.inboundNodes[k].outputTensors[V])}v.length>0&&m.apply(Os(v),b)}function u(m){const y=m.name,v=$i(m,null!=e.customObjects?e.customObjects:{});v.setFastWeightInitDuringBuild(s),o[y]=v,m.inboundNodes.forEach(x=>{if(!(x instanceof Array))throw new ee(`Corrupted configuration, expected array for nodeData: ${x}`);a(v,x)})}const c=e.name,d=e.layers;for(const m of d)u(m);for(;!oie(i);)for(const m of d){const y=o[m.name];if(y.name in i){const v=i[y.name];delete i[y.name];for(const b of v)l(y,b)}}const h=[],p=[],f=e.inputLayers;for(const m of f){const y=m[0],v=m[1],b=m[2];po(y in o),h.push(o[y].inboundNodes[v].outputTensors[b])}const g=e.outputLayers;for(const m of g){const y=m[0],v=m[1],b=m[2];po(y in o),p.push(o[y].inboundNodes[v].outputTensors[b])}return new n({inputs:h,outputs:p,name:c})}get stateful(){if(this._stateful)throw new ee("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const n of this.layers)if(n.stateful)return!0;return!1}resetStates(){he(()=>{this.layers.forEach(n=>{n.stateful&&n.resetStates()})})}}function sL(t,n){return function rL(t,n,e){const r=n.length;if(null==t||Array.isArray(t)&&0===t.length)return n.map(s=>null);if(1===r)return Array.isArray(t)&&1===t.length?t:"object"==typeof t&&n[0]in t?[t[n[0]]]:[t];if(Array.isArray(t)){if(t.length!==r)throw new Error(`Provided ${e} is an array of ${t.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return t}if("object"==typeof t&&Object.keys(t).length>0&&"object"==typeof t[Object.keys(t)[0]]){const s=[];return n.forEach(o=>{s.push(o in t?t[o]:null)}),s}throw new Error(`The model has multiple (${r}) outputs, so ${e} must be either an array with ${r} elements or an object with ${n} keys. Provided ${e} not understood: ${JSON.stringify(t)}`)}(t,n,"classWeight")}function oL(t,n,e,r){return GS.apply(this,arguments)}function GS(){return(GS=$e(function*(t,n,e,r){if(null!=n||null!=r)throw new Error("Support sampleWeight is not implemented yet");if(null!=e){const s=he(()=>{if(1===t.shape.length)return Yl(t);if(2===t.shape.length){if(t.shape[1]>1)return Lp(t,1);if(1===t.shape[1])return re(t,[t.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${t.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}throw new Error(`Unexpected rank of target (y) tensor (${t.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),o=Array.from(yield s.data());Xt(s);const i=[];return o.forEach(a=>{if(null==e[a])throw new Error(`classWeight must contain all classes in the training data. The class ${a} exists in the data but not in classWeight`);i.push(e[a])}),Hs(i,"float32")}return null})).apply(this,arguments)}function xae(t,n){return Q(t,n)}const wae=32;function iL(t,n){let e,r;e=n.xs,r=n.ys,R(null!=e&&null!=r,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${n}`);const o=aL("input",t.inputNames,e),i=aL("output",t.outputNames,r),a=o[0].shape[0];R(o.length===t.inputs.length,()=>`LayersModel has ${t.inputs.length} inputs, but the dataset provides ${o.length} inputs.  (Expected input keys: ${JSON.stringify(t.inputNames)})`),R(i.length===t.outputs.length,()=>`LayersModel has ${t.outputs.length} outputs, but the dataset provides ${i.length} outputs.  (Expected output keys: ${JSON.stringify(t.outputNames)})`);for(let l=0;l<o.length;l++)R(o[l].shape[0]===a,()=>`Batch size mismatch: input ${t.inputNames[l]} has ${o[l].shape[0]}; expected  ${a} based on input ${t.inputNames[0]}.`);for(let l=0;l<i.length;l++)R(i[l].shape[0]===a,()=>`Batch size mismatch: output ${t.outputNames[l]} has ${i[l].shape[0]}; expected  ${a} based on input ${t.inputNames[0]}.`);return{xs:o,ys:i}}function aL(t,n,e){if(e instanceof dr)return[e];if(Array.isArray(e))return R(e.length===n.length,()=>`Received an array of ${e.length} Tensors, but expected ${n.length} to match the ${t} keys ${n}.`),e;{const r=[];for(const s of n){if(null==e[s])throw new ee(`The feature data generated by the dataset lacks the required ${t} key '${s}'.`);r.push(e[s])}return r}}function HS(){return(HS=$e(function*(t,n,e){const r=null!=e.batchesPerEpoch;if(R(null!=t.optimizer,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),R(null!=e,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),R(null!=e.epochs&&e.epochs>0&&Number.isInteger(e.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${e.epochs}`),R(!r||e.batchesPerEpoch>0&&Number.isInteger(e.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${e.batchesPerEpoch}`),R(null==e.validationSplit,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),t.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");t.isTraining=!0;try{const s=null!=e.validationData;let o,i;if(s)if(lL(e.validationData))R(null==e.validationBatches||e.validationBatches>0&&Number.isInteger(e.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${e.validationBatches}`);else{const m=function _ae(t){if(3===t.length)throw new Wt("Validation with sample weights is not implemented yet.");return{xs:t[0],ys:t[1]}}(e.validationData);o=m.xs,i=m.ys}const a=t.makeTrainFunction(),l=t.getDedupedMetricsNames();let u;u=s?l.slice().concat(l.map(m=>"val_"+m)):l.slice();const c=j$(e.callbacks,e.yieldEvery),d=null==e.verbose?1:e.verbose,{callbackList:h,history:p}=q$(c,d,e.epochs,null,null,function Sae(t,n){let e=null;return null!=n.batchesPerEpoch?e=n.batchesPerEpoch:Number.isFinite(t.size)&&(e=t.size),e}(n,e),null,s,u);h.setModel(t),t.history=p,yield h.onTrainBegin(),t.stopTraining_=!1;let f=null==e.initialEpoch?0:e.initialEpoch,g=yield n.iterator();for(;f<e.epochs;){const m={};yield h.onEpochBegin(f);let y=0,v=0;for(r||(g=yield n.iterator());!r||y<e.batchesPerEpoch;){const b=yield g.next();if(r&&b.done){console.warn(`You provided \`batchesPerEpoch\` as ${e.batchesPerEpoch}, but your dataset iterator ran out of data after ${y} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${e.batchesPerEpoch*e.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(null!=b.value){const{xs:x,ys:w}=iL(t,b.value),k={};k.batch=v,k.size=x[0].shape[0],yield h.onBatchBegin(v,k);const V=[];if(null!=e.classWeight){const Y=sL(e.classWeight,t.outputNames);for(let se=0;se<Y.length;++se)V.push(yield oL(w[se],null,Y[se]))}const z=x.concat(w).concat(V),K=a(z);Xt(z);for(let Y=0;Y<l.length;++Y){const fe=K[Y];k[l[Y]]=fe,Ei(fe)}yield h.onBatchEnd(v,k),H$(k),v++,y++}if(r?y>=e.batchesPerEpoch:b.done){if(s){let x;x=lL(e.validationData)?Mn(yield t.evaluateDataset(e.validationData,{batches:e.validationBatches})):Mn(t.evaluate(o,i,{batchSize:null==e.validationBatchSize?wae:e.validationBatchSize,verbose:0}));for(let w=0;w<t.metricsNames.length;++w)m[`val_${t.metricsNames[w]}`]=x[w]}break}if(t.stopTraining_)break}if(yield h.onEpochEnd(f,m),f++,t.stopTraining_)break}return yield h.onTrainEnd(),yield t.history.syncData(),t.history}finally{t.isTraining=!1}})).apply(this,arguments)}function lL(t){return"function"==typeof t.iterator}function jS(){return(jS=$e(function*(t,n,e){const r=null!=(e=e||{}).batches,s=t.testFunction;let o=[];if(e.verbose>0)throw new Wt("Verbose mode is not implemented yet.");R(!r||e.batches>0&&Number.isInteger(e.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(e.batches)}`);const i=function Iae(t){return"function"==typeof t.next}(n)?n:yield n.iterator();let a=0,l=0;for(;!r||l<e.batches;){const u=yield i.next();if(o=he(()=>{if(u.value){const{xs:c,ys:d}=iL(t,u.value),h=c.concat(d),p=he(()=>s(h));if(Xt(h),0===l)for(let g=0;g<p.length;++g)o.push(Lt(0));const f=h[0].shape[0];for(let g=0;g<p.length;++g){const m=p[g],y=o[g];o[g]=he(()=>Ge(o[g],Q(f,m))),l>0&&Xt(y)}Xt(p),a+=f,++l}return o}),u.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${e.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let u=0;u<o.length;++u){const c=o[u];o[u]=wt(o[u],a),Xt(c)}return Os(o)})).apply(this,arguments)}function qS(t){R(t>0&&Number.isInteger(t),()=>`batchSize is required to be a positive integer, but got ${t}`)}function lf(t,n,e){return null==t?[null]:Array.isArray(t)?t.map(r=>lu(r,n,e-n)):lu(t,n,e-n)}function KS(t,n){return he(()=>null==t?null:Array.isArray(t)?t.map(e=>KS(e,n)):E$(t,"int32"===n.dtype?n:it(n,"int32")))}function XS(t,n){const e=[];let r=0,s=null;for(;r<t;)s=r+n,s>=t&&(s=t),e.push([r,s]),r=s;return e}function uL(t){const n=[];t instanceof dr&&(t=[t]);for(let e=0;e<t.length;++e){const r=t[e];if(1===r.rank)n.push(Jp(r,1));else{if(0===r.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");n.push(r)}}return n}function ai(t,n){if(null==t)return;const e=[];if(n instanceof dr)e.push(n.id);else if(Array.isArray(n))n.forEach(s=>e.push(s.id));else if(null!=n)for(const s in n)e.push(n[s].id);const r=[];if(t instanceof dr)-1===e.indexOf(t.id)&&r.push(t);else if(Array.isArray(t))t.forEach(s=>{-1===e.indexOf(s.id)&&r.push(s)});else if(null!=t)for(const s in t){const o=t[s];-1===e.indexOf(o.id)&&r.push(o)}r.forEach(s=>{s.isDisposed||s.dispose()})}function YS(t){return Array.isArray(t)}function cL(t){return!function Tae(t){return t instanceof dr}(t)&&!YS(t)}function dL(t,n,e,r=!0,s=""){if(null==n||0===n.length){if(null!=t){let i=!1;if(YS(t)&&t.length>0)i=!0;else if(cL(t)){for(const a in t)if(t.hasOwnProperty(a)){i=!0;break}}else i=!0;if(i)throw new ee(`Error when checking model ${s} expected no data, but got ${t}`)}return[]}if(null==t)return n.map(i=>null);let o;if(cL(t)){o=[];for(const i of n){if(null==t[i])throw new ee(`No data provided for "${i}". Need data for each key in: ${n}`);o.push(t[i])}}else if(YS(t)){if(t.length!==n.length)throw new ee(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${n.length} Tensor(s), but instead got the following list of Tensor(s): ${t}`);o=t}else{if(n.length>1)throw new ee(`The model ${s} expects ${n.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${t.shape}`);o=[t]}if(o=uL(o),null!=e)for(let i=0;i<n.length;++i){if(null==e[i])continue;const a=o[i];if(a.shape.length!==e[i].length)throw new ee(`Error when checking ${s}: expected ${n[i]} to have ${e[i].length} dimension(s). but got array with shape ${a.shape}`);for(let l=0;l<e[i].length;++l){if(0===l&&!r)continue;const c=e[i][l];if(null!=c&&c>=0&&a.shape[l]!==c)throw new ee(`${s} expected a batch of elements where each example has shape [${e[i].slice(1,e[i].length)}] (i.e.,tensor shape [*,${e[i].slice(1,e[i].length)}]) but the ${s} received an input with ${a.shape[0]} examples, each with shape [${a.shape.slice(1,a.shape.length)}] (tensor shape [${a.shape}])`)}}return o}function hL(t,n,e,r=!0,s=""){let o;if(Array.isArray(t)){if(t.length!==n.length)throw new ee(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${n.length} Tensor(s), but instead got ${t.length} Tensors(s).`);o=t}else{if(n.length>1)throw new ee(`The model expects ${n.length} ${s} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(t.shape)}.`);o=[t]}if(null!=e)for(let i=0;i<n.length;++i){if(null==e[i])continue;const a=o[i];if(a.shape.length!==e[i].length)throw new ee(`Error when checking ${s}: expected ${n[i]} to have ${e[i].length} dimension(s), but got array with shape ${JSON.stringify(a.shape)}`);for(let l=0;l<e[i].length;++l){if(0===l&&!r)continue;const c=e[i][l];if(null!=c&&c!==a.shape[l])throw new ee(`Error when checking ${s}: expected ${n[i]} to have shape ${JSON.stringify(e[i])} but got array with shape ${JSON.stringify(a.shape)}.`)}}}let jc=(()=>{class t extends ii{constructor(e){super(e),this.isTraining=!1}summary(e,r,s=console.log){if(!this.built)throw new ee("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");!function mae(t,n,e,r=console.log){const s=function yae(t){let n=!0;const e=[],r=[];for(const s in t.nodesByDepth)e.push(t.nodesByDepth[s]);for(const s of e){if(s.length>1||1===s.length&&s[0].inboundLayers.length>1){n=!1;break}r.push(...s)}if(n)for(const s of t.layers){let o=!1;for(const i of s.inboundNodes)if(-1!==r.indexOf(i)){if(o){n=!1;break}o=!0}if(!n)break}return n}(t),o=["Layer (type)","Input Shape","Output shape","Param #"];let i;if(s?(n=n||90,e=e||[.32,.61,.89,1]):(n=n||115,e=e||[.24,.48,.7,.8,1]),e[e.length-1]<=1&&(e=e.map(c=>Math.floor(n*c))),!s){o.push("Receives inputs"),i=[];for(const c in t.nodesByDepth)i.push(...t.nodesByDepth[c])}r("_".repeat(n)),zv(o,e,r),r("=".repeat(n));const a=t.layers;for(let c=0;c<a.length;++c)s?vae(a[c],e,r):bae(a[c],e,i,r),r((c===a.length-1?"=":"_").repeat(n));t.checkTrainableWeightsConsistency();const l=function gae(t){let n;return n=Ev(null!=t.collectedTrainableWeights?t.collectedTrainableWeights:t.trainableWeights),n}(t),u=Ev(t.nonTrainableWeights);r(`Total params: ${l+u}`),r(`Trainable params: ${l}`),r(`Non-trainable params: ${u}`),r("_".repeat(n))}(this,e,r,s)}compile(e){if(null==e.loss&&(e.loss=[]),this.loss=e.loss,"string"==typeof e.optimizer)this.optimizer_=function fae(t){const n={Adagrad:()=>Uc.adagrad(.01),Adadelta:()=>Uc.adadelta(1,.95,Tr()),Adam:()=>Uc.adam(.001,.9,.999,Tr()),Adamax:()=>Uc.adamax(.002,.9,.999,Tr(),0),RMSProp:()=>Uc.rmsprop(.001,.9,0,Tr()),SGD:()=>Uc.sgd(.01)};if(n.adagrad=n.Adagrad,n.adadelta=n.Adadelta,n.adam=n.Adam,n.adamax=n.Adamax,n.rmsprop=n.RMSProp,n.sgd=n.SGD,t in n)return n[t]();throw new ee(`Unknown Optimizer ${t}`)}(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof Ga))throw new ee("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let r=[];if(Array.isArray(e.loss)||"string"==typeof e.loss||"function"==typeof e.loss)if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new ee(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);r=e.loss.map(l=>BS(l))}else{const a=BS(e.loss);this.outputs.forEach(l=>{r.push(a)})}else{e.loss=e.loss;for(const a in e.loss)if(-1===this.outputNames.indexOf(a))throw new ee(`Unknown entry in loss dictionary: "${a}". Only expected the following keys: ${this.outputNames}`);for(const a of this.outputNames)null==e.loss[a]&&console.warn(`Output "${a}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${a} during training`),r.push(BS(e.loss[a]))}this.lossFunctions=r,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let a=0;a<this.outputs.length;++a){const l=this.internalOutputShapes[a];this.feedOutputNames.push(this.outputNames[a]),this.feedOutputShapes.push(l),this.feedLossFns.push(this.lossFunctions[a])}const s=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],au("loss",()=>{for(let a=0;a<this.outputs.length;++a)-1===s.indexOf(a)&&this.outputs.length>1&&(this.metricsTensors.push([this.lossFunctions[a],a]),this.metricsNames.push(this.outputNames[a]+"_loss"))});const o=function Nae(t,n){if(null==t||Array.isArray(t)&&0===t.length)return n.map(r=>[]);let e;if("string"==typeof t||"function"==typeof t)e=[t];else{if(!Array.isArray(t)&&"object"!=typeof t)throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${t}`);e=t}if(Array.isArray(e))return n.map(r=>e);{const r=[];for(const s of n){let o=e.hasOwnProperty(s)?e[s]:[];Array.isArray(o)||(o=[o]),r.push(o)}return r}}(e.metrics,this.outputNames),i=(a,l,u)=>{this.outputNames.length>1&&(l=this.outputNames[a]+"_"+l),this.metricsNames.push(l),this.metricsTensors.push([u,a])};au("metric",()=>{for(let a=0;a<this.outputs.length;++a)-1===s.indexOf(a)&&(c=>{let h,p,f;for(const g of c){if("string"==typeof g&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(g)){const y=this.internalOutputShapes[a];let v;1===y[y.length-1]||this.lossFunctions[a]===$v?-1!==["accuracy","acc"].indexOf(g)?p=X$:-1!==["crossentropy","ce"].indexOf(g)&&(p=sae):this.lossFunctions[a]===Mv?-1!==["accuracy","acc"].indexOf(g)?p=oae:-1!==["crossentropy","ce"].indexOf(g)&&(p=J$):-1!==["accuracy","acc"].indexOf(g)?p=Y$:-1!==["crossentropy","ce"].indexOf(g)&&(p=Q$),-1!==["accuracy","acc"].indexOf(g)?v="acc":-1!==["crossentropy","ce"].indexOf(g)&&(v="ce"),f=p,h=""+v}else f=pae(g),h=""+Bv(g);let m;au(h,()=>{m=f}),i(a,h,m)}})(o[a])}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,r,s={}){const o=null==s.batchSize?32:s.batchSize;qS(o);const a=this.standardizeUserDataXY(e,r,!0,o);try{const l=a[0].concat(a[1]);return this.makeTestFunction(),Os(this.testLoop(this.testFunction,l,o,s.verbose,s.steps))}finally{ai(a[0],e),ai(a[1],r)}}evaluateDataset(e,r){var s=this;return $e(function*(){return s.makeTestFunction(),function Dae(t,n,e){return jS.apply(this,arguments)}(s,e,r)})()}checkNumSamples(e,r,s,o="steps"){let i;if(null!=s){if(i=null,null!=r)throw new ee(`If ${o} is set, batchSize must be null or undefined.Got batchSize = ${r}`)}else{if(null==e)throw new ee(`Either the input data should have a defined shape, or ${o} shoud be specified.`);i=Array.isArray(e)?e[0].shape[0]:e.shape[0]}return i}execute(e,r){if(Array.isArray(r)&&0===r.length)throw new ee("`outputs` is an empty Array, which is not allowed.");const s=Array.isArray(r),i=this.retrieveSymbolicTensors(s?r:[r]),a=new tl;if(e instanceof dr&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new ee(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let u=0;u<this.inputs.length;++u)a.add(this.inputs[u],e[u])}else for(const u of this.inputs){const c=e[u.name];if(null==c)throw new ee(`No value is provided for the model's input ${u.name}`);a.add(u,c)}const l=rf(i,a);return s?l:l[0]}retrieveSymbolicTensors(e){const r=su(null,e.length);let s=e.length;for(const o of this.layers){const i=Array.isArray(o.output)?o.output:[o.output],a=i.map(l=>l.name);for(let l=0;l<e.length;++l){const u=a.indexOf(e[l]);if(-1!==u&&(r[l]=i[u],s--),0===s)break}if(0===s)break}if(s>0){const o=[];throw r.forEach((i,a)=>{null==i&&o.push(e[a])}),new ee(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(o)}`)}return r}predictLoop(e,r=32,s=!1){return he(()=>{const o=this.checkNumSamples(e);if(s)throw new Wt("Verbose predictLoop() is not implemented yet.");const i=XS(o,r),a=this.outputs.map(l=>[]);for(let l=0;l<i.length;++l)he(()=>{const h=lf(e,i[l][0],i[l][1]),p=[];if(Array.isArray(h))for(let g=0;g<h.length;++g)p.push({key:this.inputs[g],value:h[g]});else p.push({key:this.inputs[0],value:h});const f=new tl(p);return rf(this.outputs,f)}).forEach((c,d)=>a[d].push(c));return Os(a.map(l=>rs(l,0)))})}predict(e,r={}){const s=uL(e);hL(s,this.inputNames,this.feedInputShapes,!1);try{const o=null==r.batchSize?32:r.batchSize;return qS(o),this.predictLoop(s,o)}finally{ai(s,e)}}predictOnBatch(e){hL(e,this.inputNames,this.feedInputShapes,!0);const r=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,r)}standardizeUserDataXY(e,r,s=!0,o){if(null==this.optimizer_)throw new $o("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const i=[];for(let a=0;a<this.feedOutputShapes.length;++a){const l=this.feedOutputShapes[a];i.push(this.feedLossFns[a]===Mv?l.slice(0,l.length-1).concat([1]):l)}if(function kae(t,n,e){const r=Qa(t.map(o=>o.shape[0]));r.sort();const s=Qa(n.map(o=>o.shape[0]));if(s.sort(),r.length>1)throw new ee(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(o=>o.shape))}`);if(s.length>1)throw new ee(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(n.map(o=>o.shape))}`);if(r.length>0&&s.length>0&&!gn(r,s))throw new ee(`Input Tensors should have the same number of samples as target Tensors. Found ${r[0]} input sample(s) and ${s[0]} target sample(s).`)}(e=dL(e,this.feedInputNames,this.feedInputShapes,!1,"input"),r=dL(r,this.feedOutputNames,i,!1,"target")),function Eae(t,n,e){const r=[Pv,$v,af];for(let s=0;s<t.length;++s){const o=t[s],i=n[s],a=e[s];if(null!=i){if(i===af&&1===o.shape[o.shape.length-1])throw new ee(`You are passing a target array of shape ${o.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(-1!==r.indexOf(i)){const l=o.shape.slice(1),u=a.slice(1);for(let c=0;c<l.length;++c){const h=u[c];if(null!=h&&l[c]!==h)throw new ee(`A target Tensor with shape ${o.shape} was passed for an output of shape ${a}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}(r,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=o&&o>0&&e[0].shape[0]%o!=0)throw new ee(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${o}. Found: ${e[0].shape[0]} sample(s).`);return[e,r]}standardizeUserData(e,r,s,o,i=!0,a){var l=this;return $e(function*(){const[u,c]=l.standardizeUserDataXY(e,r,i,a);if(null!=s)throw new Error("sample weight is not supported yet.");let d=null;if(null!=o){const h=sL(o,l.outputNames);d=[];for(let p=0;p<h.length;++p)d.push(yield oL(c[p],null,h[p]))}return[u,c,d]})()}testLoop(e,r,s,o=0,i){return he(()=>{const a=this.checkNumSamples(r,s,i,"steps"),l=[];if(o>0)throw new Wt("Verbose mode is not implemented yet.");if(null!=i)throw new Wt("steps mode in testLoop() is not implemented yet");{const u=XS(a,s),c=Hs(ri(0,a));for(let d=0;d<u.length;++d){const h=u[d][0],p=u[d][1],f=lu(c,h,p-h),g=KS(r,f),m=e(g);if(0===d)for(let y=0;y<m.length;++y)l.push(Lt(0));for(let y=0;y<m.length;++y)l[y]=Ge(l[y],Q(p-h,m[y]))}for(let d=0;d<l.length;++d)l[d]=wt(l[d],a)}return l})}getDedupedMetricsNames(){const e=this.metricsNames,r=[];for(let s=0;s<e.length;++s){const o=e[s];let i=o;v$(e,o)>1&&(i+=`_${v$(e.slice(0,s),o)}`),r.push(i)}return r}makeTrainFunction(){return e=>{const r=[],s=e.slice(0,this.inputs.length),o=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),a=[],u=this.collectedTrainableWeights.map(h=>h.read());return[this.optimizer_.minimize(()=>{const h=[];for(let m=0;m<this.inputs.length;++m)h.push({key:this.inputs[m],value:s[m]});const p=new tl(h),f=rf(this.outputs,p,{training:!0});let g;for(let m=0;m<this.lossFunctions.length;++m){let v=(0,this.lossFunctions[m])(o[m],f[m]);null!=i[m]&&(v=xae(v,i[m]));const b=hr(v);r.push(b),g=0===m?v:Ge(g,v)}for(let m=0;m<this.metricsTensors.length;++m){let y;if(this.outputs.length>1&&m<this.outputs.length)y=r[m];else{const b=this.metricsTensors[m][1];y=hr((0,this.metricsTensors[m][0])(o[b],f[b]))}Ei(y),a.push(y)}return g=hr(g),this.calculateLosses().forEach(m=>{g=Ge(g,m)}),g},!0,u)].concat(a)}}makeTestFunction(){this.testFunction=e=>he(()=>{const r=[];let s;const o=e.slice(0,this.inputs.length),i=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=[];for(let c=0;c<this.inputs.length;++c)a.push({key:this.inputs[c],value:o[c]});const l=new tl(a),u=rf(this.outputs,l);for(let c=0;c<this.lossFunctions.length;++c){const h=hr((0,this.lossFunctions[c])(i[c],u[c]));s=0===c?h:Ge(s,h),r.push(s)}for(let c=0;c<this.metricsTensors.length;++c){const h=this.metricsTensors[c][1],p=hr((0,this.metricsTensors[c][0])(i[h],u[h]));r.push(p)}return r})}fit(e,r,s={}){var o=this;return $e(function*(){if(o.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");let i,a,l,u,c,d,h,p,f;o.isTraining=!0;try{const g=null==s.batchSize?32:s.batchSize;qS(g);const m=!1,y=yield o.standardizeUserData(e,r,s.sampleWeight,s.classWeight,m,g);i=y[0],a=y[1],f=y[2];let b,v=!1;if(null!=s.validationData&&s.validationData.length>0){if(v=!0,2!==s.validationData.length)throw 3===s.validationData.length?new Wt("validationData including sample weights is not supported yet."):new ee(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${s.validationData} is invalid.`);c=s.validationData[0],d=s.validationData[1];const se=!0,fe=yield o.standardizeUserData(c,d,null,null,se,g);h=fe[0],p=fe[1],b=h.concat(p)}else if(null!=s.validationSplit&&s.validationSplit>0&&s.validationSplit<1){v=!0;const se=Math.floor(i[0].shape[0]*(1-s.validationSplit)),fe=i[0].shape[0];h=lf(i,se,fe),l=i,i=lf(i,0,se),p=lf(a,se,fe),u=a,a=lf(a,0,se),b=h.concat(p)}else null!=s.validationSteps&&(v=!0);const x=i.concat(a).concat(f);o.checkTrainableWeightsConsistency();const w=o.makeTrainFunction(),k=o.getDedupedMetricsNames();let V,z;v?(o.makeTestFunction(),V=o.testFunction,z=k.slice().concat(k.map(se=>"val_"+se))):(V=null,b=[],z=k.slice());const K=j$(s.callbacks,s.yieldEvery);return yield o.fitLoop(w,x,k,g,s.epochs,s.verbose,K,V,b,s.shuffle,z,s.initialEpoch,null,null)}finally{o.isTraining=!1,ai(i,e),ai(a,r),ai(l,e),ai(u,r),ai(h,c),ai(p,d),null!=f&&Xt(f)}})()}fitLoop(e,r,s,o,i,a,l,u,c,d,h,p,f,g){var m=this;return $e(function*(){null==o&&(o=32),null==i&&(i=1),null==d&&(d=!0),null==p&&(p=0);let y=!1;if(null!=u&&null!=c&&(y=!0),null!=g&&(y=!0,null==f))throw new ee("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const v=m.checkNumSamples(r,o,f,"steps_per_epoch");let b;null!=v&&(b=ri(0,v)),null==a&&(a=1);const{callbackList:x,history:w}=q$(l,a,i,p,v,f,o,y,h);x.setModel(m),m.history=w,yield x.onTrainBegin(),m.stopTraining_=!1;for(let k=p;k<i;++k){yield x.onEpochBegin(k);const V={};if(null!=f)throw new Wt("stepsPerEpoch mode is not implemented yet.");{if("batch"===d)throw new Wt("batch shuffling is not implemneted yet");d&&SO(b);const z=Hs(b),K=XS(v,o);for(let Y=0;Y<K.length;++Y){const se={};if(yield x.onBatchBegin(Y,se),he(()=>{const fe=K[Y][0],ve=K[Y][1],be=lu(z,fe,ve-fe);se.batch=Y,se.size=ve-fe;const xe=KS(r,be),De=e(xe);for(let Ne=0;Ne<s.length;++Ne){const Ae=De[Ne];se[s[Ne]]=Ae,Ei(Ae)}if(Y===K.length-1&&y){const Ne=m.testLoop(u,c,o);for(let we=0;we<s.length;++we){const Ae=s[we],ze=Ne[we];Ei(ze),V["val_"+Ae]=ze}}}),yield x.onBatchEnd(Y,se),H$(se),m.stopTraining_)break}z.dispose()}if(yield x.onEpochEnd(k,V),m.stopTraining_)break}return yield x.onTrainEnd(),yield m.history.syncData(),m.history})()}fitDataset(e,r){var s=this;return $e(function*(){return function Cae(t,n,e){return HS.apply(this,arguments)}(s,e,r)})()}trainOnBatch(e,r){var s=this;return $e(function*(){const o=yield s.standardizeUserData(e,r),i=o[0],a=o[1],u=s.makeTrainFunction()(i.concat(a)),c=[];for(const d of u){const h=yield d.data();c.push(h[0])}return Xt(u),ai(o[0],e),ai(o[1],r),Os(c)})()}getNamedWeights(e){const r=[],s=null!=e&&e.trainableOnly,o=s?this.trainableWeights:this.weights,i=this.getWeights(s);for(let a=0;a<o.length;++a)s&&!o[a].trainable||r.push({name:o[a].originalName,tensor:i[a]});return r}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(0===e.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const r=a1().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=r-a1().numTensors}return e}getLossIdentifiers(){let e;if("string"==typeof this.loss)e=ya(this.loss);else if(Array.isArray(this.loss)){for(const r of this.loss)if("string"!=typeof r)throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(r=>ya(r))}else{const r=Object.keys(this.loss);e={};const s=this.loss;for(const o of r){if("string"!=typeof s[o])throw new Error("Serialization of non-string loss is not supported.");e[o]=ya(s[o])}}return e}getMetricIdentifiers(){if("string"==typeof this.metrics||"function"==typeof this.metrics)return[ya(Bv(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>ya(Bv(e)));{const e={};for(const r in this.metrics)e[r]=ya(Bv(this.metrics[r]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(null!=e.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=e.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=e.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const s=$i(Uv(e.optimizer_config));let o,i;if("string"==typeof e.loss)o=ou(e.loss);else if(Array.isArray(e.loss))o=e.loss.map(a=>ou(a));else if(null!=e.loss){o={};for(const a in e.loss)o[a]=ou(e.loss[a])}if(Array.isArray(e.metrics))i=e.metrics.map(a=>ou(a));else if(null!=e.metrics){i={};for(const a in e.metrics)i[a]=ou(e.metrics[a])}this.compile({loss:o,metrics:i,optimizer:s})}save(e,r){var s=this;return $e(function*(){if("string"==typeof e){const d=(t=>Zn.getSaveHandlers(t))(e);if(0===d.length)throw new ee(`Cannot find any save handlers for URL '${e}'`);if(d.length>1)throw new ee(`Found more than one (${d.length}) save handlers for URL '${e}'`);e=d[0]}if(null==e.save)throw new ee("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const o=yield hP(s.getNamedWeights(r)),u={modelTopology:s.toJSON(null,!1),format:"layers-model",generatedBy:"TensorFlow.js tfjs-layers v4.3.0",convertedBy:null};if(null!=r&&r.includeOptimizer&&null!=s.optimizer){u.trainingConfig=s.getTrainingConfig();const d="optimizer",{data:h,specs:p}=yield hP(yield s.optimizer.getWeights(),d);o.specs.push(...p),o.data=YC([o.data,h])}return null!=s.userDefinedMetadata&&(tL(s.userDefinedMetadata,s.name,!0),u.userDefinedMetadata=s.userDefinedMetadata),u.weightData=o.data,u.weightSpecs=o.specs,e.save(u)})()}setUserDefinedMetadata(e){tL(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}return t.className="Model",t})();function QS(){return QS=$e(function*(t,n){if(null==n&&(n={}),"string"==typeof t){const e=NZ(t,n);if(0===e.length)e.push(function bQ(t,n){return VP(t,n)}(t,n));else if(e.length>1)throw new ee(`Found more than one (${e.length}) load handlers for URL '${t}'`);t=e[0]}return function Fae(t,n,e){return JS.apply(this,arguments)}(t,void 0,n)}),QS.apply(this,arguments)}function JS(){return(JS=$e(function*(t,n,e){if(null==e&&(e={}),null==t.load)throw new ee("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const r=yield t.load();let s=r.modelTopology;null!=s.model_config&&(s=s.model_config);const o=null==e.strict||e.strict,i=null!=r.weightData&&null!=r.weightSpecs&&o,a=$i(Uv(s),n,i),l=r.trainingConfig;if(null!=l&&a.loadTrainingConfig(l),null!=r.userDefinedMetadata&&a.setUserDefinedMetadata(r.userDefinedMetadata),null!=r.weightData){if(null==r.weightSpecs)throw new ee("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");const{modelWeights:u,optimizerWeights:c}=function Oae(t,n){const e=function pP(t,n){const e={};let r,s=0;for(const o of n){const i=o.name,a=o.dtype,l=o.shape,u=_e(l);let c;if("quantization"in o){const d=o.quantization;if("uint8"===d.dtype||"uint16"===d.dtype){if(!("min"in d)||!("scale"in d))throw new Error(`Weight ${o.name} with quantization ${d.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==d.dtype)throw new Error(`Weight ${o.name} has unknown quantization dtype ${d.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==a)throw new Error(`Weight ${o.name} is quantized with ${d.dtype} which only supports weights of type float32 not ${a}.`)}const h=qC[d.dtype],p=t.slice(s,s+u*h),f="uint8"===d.dtype?new Uint8Array(p):new Uint16Array(p);if("float32"===a)if("uint8"===d.dtype||"uint16"===d.dtype){c=new Float32Array(f.length);for(let g=0;g<f.length;g++)c[g]=f[g]*d.scale+d.min}else{if("float16"!==d.dtype)throw new Error(`Unsupported quantization type ${d.dtype} for weight type float32.`);void 0===r&&(r=kZ()),c=r(f)}else{if("int32"!==a)throw new Error(`Unsupported dtype in weight '${i}': ${a}`);if("uint8"!==d.dtype&&"uint16"!==d.dtype)throw new Error(`Unsupported quantization type ${d.dtype} for weight type int32.`);c=new Int32Array(f.length);for(let g=0;g<f.length;g++)c[g]=Math.round(f[g]*d.scale+d.min)}s+=u*h}else if("string"===a){const d=_e(o.shape);c=[];for(let h=0;h<d;h++){const p=new Uint32Array(t.slice(s,s+Zy))[0];s+=Zy;const f=new Uint8Array(t.slice(s,s+p));c.push(f),s+=p}}else{const d=qC[a],h=t.slice(s,s+u*d);if("float32"===a)c=new Float32Array(h);else if("int32"===a)c=new Int32Array(h);else if("bool"===a)c=new Uint8Array(h);else{if("complex64"!==a)throw new Error(`Unsupported dtype in weight '${i}': ${a}`);{c=new Float32Array(h);const p=new Float32Array(c.length/2),f=new Float32Array(c.length/2);for(let y=0;y<p.length;y++)p[y]=c[2*y],f[y]=c[2*y+1];const g=Mp(p,l,"float32"),m=Mp(f,l,"float32");e[i]=ql(g,m),g.dispose(),m.dispose()}}s+=u*d}"complex64"!==a&&(e[i]=Mp(c,l,a))}return e}(t,n),r={},s=[];return n.forEach(o=>{"optimizer"===o.group?s.push({name:o.name,tensor:e[o.name]}):r[o.name]=e[o.name]}),{modelWeights:r,optimizerWeights:s}}(r.weightData,r.weightSpecs);a.loadWeights(u,o),null!=a.optimizer&&c.length>0&&(yield a.optimizer.setWeights(c)),Xt(u),Xt(c.map(d=>d.tensor))}return a})).apply(this,arguments)}Ue(jc),Ue((()=>{class t extends jc{}return t.className="Functional",t})()),Ue((()=>{class t extends jc{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=null!=e.name?e.name:Sv("sequential_"),null!=e.layers)for(const r of e.layers)this.add(r)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(s=>s<0))throw new ee(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const r=e instanceof t||e instanceof jc;let s;if(r){if(s=e,1!==s.outputs.length)throw new ee("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==s.inputs.length)throw new ee("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===e.inboundNodes.length){if(null==e.batchInputShape)throw new ee("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const o=function Pie(t){if(null==t.batchShape&&null==t.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=t.batchShape&&null!=t.shape)throw new ee("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let n=t.batchShape;null!=t.shape&&null==n&&(n=[null].concat(t.shape));let e=t.dtype;return null==e&&(e="float32"),new Av({batchInputShape:n,name:t.name,dtype:e,sparse:t.sparse}).inboundNodes[0].outputTensors[0]}({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(o)}if(r)this.outputs=s.outputs,this.inputs=s.inputs;else{if(1!==e.inboundNodes.length)throw new ee(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(1!==e.inboundNodes[0].outputTensors.length)throw new ee("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=z$(this.outputs[0])}this.inboundNodes=[],new Nv({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:su(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(o=>o.shape),outputShapes:this.outputs[0].shape})}else{const o=e.apply(this.outputs[0]);if(Array.isArray(o))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[o],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,r){return null==this.model&&this.build(),this.model.call(e,r)}build(e){if(mn(e),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new jc({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,r,s=console.log){this.built||this.build(),super.summary(e,r,s)}setWeights(e){null==this.model&&this.build(),this.model.setWeights(e)}evaluate(e,r,s={}){if(!this.built)throw new $o("The model needs to be compiled before being used.");return this.model.evaluate(e,r,s)}evaluateDataset(e,r){var s=this;return $e(function*(){if(!s.built)throw new $o("The model needs to be compiled before being used.");return s.model.evaluateDataset(e,r)})()}predict(e,r={}){return null==this.model&&this.build(),this.model.predict(e,r)}predictOnBatch(e){return null==this.model&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}fit(e,r,s={}){var o=this;return $e(function*(){if(!o.built)throw new $o("The model needs to be compiled before being used.");return o.model.fit(e,r,s)})()}fitDataset(e,r){var s=this;return $e(function*(){if(!s.built)throw new $o("The model needs to be compiled before being used.");return s.model.fitDataset(e,r)})()}trainOnBatch(e,r){var s=this;return $e(function*(){return s.model.trainOnBatch(e,r)})()}static fromConfig(e,r,s={},o=!1){let i,a={};if(r instanceof Array){if(null==r[0].className||"Merge"===r[0].className)throw new ee("Legacy serialization format not supported yet.");i=r}else R(null!=r.layers,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),i=r.layers,delete r.layers,a=r;const l=new e(a);if(!(l instanceof t))throw new Wt(`Sequential.fromConfig called on non-Sequential input: ${l}`);for(const u of i){const d=$i(u,void 0,o);o&&d.setFastWeightInitDuringBuild(!0),l.add(d)}return l}set stopTraining(e){if(null==this.model)throw new ee("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(null==this.model)throw new ee("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const r of this.layers){const s={};s.className=r.getClassName(),s.config=r.getConfig(),e.push(s)}return{name:this.name,layers:e}}}return t.className="Sequential",t})());class Ps extends Oc{getConfig(){return{}}}Ue((()=>{class t extends Ps{apply(e,r=1){return function _ie(t,n=1){if(1!==n)throw new Wt(`Support for alpha values other than 1 (${n}) is not implemented yet.`);return ov(t)}(e,r)}}return t.className="elu",t})()),Ue((()=>{class t extends Ps{apply(e){return iM(e)}}return t.className="selu",t})()),Ue((()=>{class t extends Ps{apply(e){return pa(e)}}return t.className="relu",t})()),Ue((()=>{class t extends Ps{apply(e){return he(()=>Lc(6,pa(e)))}}return t.className="relu6",t})()),Ue((()=>{class t extends Ps{apply(e){return e}}return t.className="linear",t})()),Ue((()=>{class t extends Ps{apply(e){return Vc(e)}}return t.className="sigmoid",t})()),Ue((()=>{class t extends Ps{apply(e){return function Sie(t){return he(()=>{const n=Ge(.5,Q(.2,t));return uo(n,0,1)})}(e)}}return t.className="hardSigmoid",t})()),Ue((()=>{class t extends Ps{apply(e){return Hp(e)}}return t.className="softplus",t})()),Ue((()=>{class t extends Ps{apply(e){return function Cie(t){return he(()=>wt(t,Ge(Pr(t),1)))}(e)}}return t.className="softsign",t})()),Ue((()=>{class t extends Ps{apply(e){return B1(e)}}return t.className="tanh",t})());let pL=(()=>{class t extends Ps{apply(e,r=-1){return V1(e,r)}}return t.className="softmax",t})();function rl(t){return t.getClassName()}function eI(t,n={}){return Zp(t,Ao.getMap().classNameMap,n,"activation")}function sl(t){if(null==t){return eI({className:"linear",config:{}})}if("string"==typeof t){const n={};return n.className=t,n.config={},eI(n)}return t instanceof Ps?t:eI(t)}Ue(pL),Ue((()=>{class t extends Ps{apply(e,r=-1){return rM(e,r)}}return t.className="logSoftmax",t})()),Ue((()=>{class t extends Ps{apply(e,r=1){return he(()=>Q(Vc(Q(e,r)),e))}}return t.className="swish",t})()),Ue((()=>{class t extends Ps{apply(e){return he(()=>Q(e,B1(Hp(e))))}}return t.className="mish",t})());class fL extends Oc{}Ue((()=>{class t extends fL{constructor(e){super(),function tI(t){if(null!=t&&"object"!=typeof t)throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${t}`)}(e),this.l1=null==e||null==e.l1?.01:e.l1,this.l2=null==e||null==e.l2?.01:e.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(e){return he(()=>{let r=Lr([1]);return this.hasL1&&(r=Ge(r,yt(Q(this.l1,Pr(e))))),this.hasL2&&(r=Ge(r,yt(Q(this.l2,ef(e))))),re(r,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,r){return new e({l1:r.l1,l2:r.l2})}}return t.className="L1L2",t})());const mL={l1l2:"L1L2"};function Rn(t){return DS(t)}function gL(t,n={}){return Zp(t,Ao.getMap().classNameMap,n,"regularizer")}function qn(t){return null==t?null:"string"==typeof t?gL({className:t in mL?mL[t]:t,config:{}}):t instanceof fL?t:gL(t)}function qc(t,n,e){if("number"==typeof t)return su(t,n);if(t.length!==n)throw new ee(`The ${e} argument must be an integer or tuple of ${n} integers. Received: ${t.length} elements.`);for(let r=0;r<n;++r){const s=t[r];if(!gie(s))throw new ee(`The ${e} argument must be an integer or tuple of ${n} integers. Received: ${JSON.stringify(t)} including a non-integer number ${s}`)}return t}function li(t,n,e,r,s=1){if(null==t)return t;let i;return i="same"===e?t:t-(n+(n-1)*(s-1))+1,Math.floor((i+r-1)/r)}function Li(t,n,e,r){if(null==t)return null;if("valid"===r)t=t*n+el([e-n,0]);else{if("same"!==r)throw new ee(`Unsupport padding mode: ${r}.`);t*=n}return t}function rI(t,n){return he(()=>(mr(n),"channelsFirst"===n?hn(t,[0,2,3,1]):t))}function yL(t,n){return he(()=>(mr(n),"channelsFirst"===n?hn(t,[0,2,3,4,1]):t))}function sI(t,n,e,r=[1,1],s="valid",o,i,a=null){return he(()=>{if(null==o&&(o="channelsLast"),mr(o),3!==t.rank&&4!==t.rank)throw new ee(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${t.rank}.`);if(3!==n.rank&&4!==n.rank)throw new ee(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${t.rank}.`);let l=rI(t,o);if("causal"===s)throw new Wt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=Lee({x:l,filter:n,strides:r,pad:"same"===s?"same":"valid",dilations:i,dataFormat:"NHWC",bias:e,activation:a}),"channelsFirst"===o&&(l=hn(l,[0,3,1,2])),l})}Ue((()=>{class t extends tn{constructor(e){super(e??{}),this.supportsMasking=!0,null!=e&&(this.maxValue=e.maxValue)}call(e,r){e=$t(e);let s=pa(e);return null!=this.maxValue&&(s=uo(s,0,this.maxValue)),s}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},r=super.getConfig();return Object.assign(e,r),e}}return t.className="ReLU",t})()),Ue((()=>{class t extends tn{constructor(e){super(e??{}),this.DEFAULT_ALPHA=.3,null==e&&(e={}),this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,r){const s=$t(e);return T1(s,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},r=super.getConfig();return Object.assign(e,r),e}}return t.className="LeakyReLU",t})()),Ue((()=>{class t extends tn{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==e&&(e={}),this.supportsMasking=!0,this.alphaInitializer=jn(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=qn(e.alphaRegularizer),this.alphaConstraint=Nr(e.alphaConstraint),null==e.sharedAxes)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else{if("number"!=typeof e.sharedAxes)throw new ee(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`);this.sharedAxes=[e.sharedAxes]}}build(e){const r=(e=mn(e)).slice(1);if(null!=this.sharedAxes)for(const o of this.sharedAxes)r[o-1]=1;this.alpha=this.addWeight("alpha",r,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const s={};if(null!=this.sharedAxes)for(let o=1;o<e.length;++o)s[o]=e[o];this.inputSpec=[new kr({ndim:e.length,axes:s})],this.built=!0}call(e,r){return e=$t(e),F1(e,this.alpha.read())}getConfig(){const e={alphaInitializer:Jn(this.alphaInitializer),alphaRegularizer:Rn(this.alphaRegularizer),alphaConstraint:Er(this.alphaConstraint),sharedAxes:this.sharedAxes},r=super.getConfig();return Object.assign(e,r),e}}return t.className="PReLU",t})()),Ue((()=>{class t extends tn{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA=1,null==e&&(e={}),null!=e.alpha&&e.alpha!==this.DEFAULT_ALPHA)throw new Wt(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,r){const s=$t(e);return ov(s)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},r=super.getConfig();return Object.assign(e,r),e}}return t.className="ELU",t})()),Ue((()=>{class t extends tn{constructor(e){super(e??{}),this.DEFAULT_THETA=1,null==e&&(e={}),this.theta=null==e.theta?this.DEFAULT_THETA:e.theta}call(e,r){const s=$t(e);return Q(s,it(co(s,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},r=super.getConfig();return Object.assign(e,r),e}}return t.className="ThresholdedReLU",t})()),Ue((()=>{class t extends tn{constructor(e){super(e??{}),this.DEFAULT_AXIS=1,null==e&&(e={}),this.softmax=(new pL).apply,this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis}call(e,r){const s=$t(e);return this.softmax(s,this.axis)}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},r=super.getConfig();return Object.assign(e,r),e}}return t.className="Softmax",t})());class Wv extends tn{constructor(n,e){if(super(e),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",Wv.verifyArgs(e),this.rank=n,Vr(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new Wt(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=qc(e.kernelSize,n,"kernelSize"),this.strides=qc(null==e.strides?1:e.strides,n,"strides"),this.padding=null==e.padding?"valid":e.padding,fo(this.padding),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,mr(this.dataFormat),this.activation=sl(e.activation),this.useBias=null==e.useBias||e.useBias,this.biasInitializer=jn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=Nr(e.biasConstraint),this.biasRegularizer=qn(e.biasRegularizer),this.activityRegularizer=qn(e.activityRegularizer),this.dilationRate=qc(null==e.dilationRate?1:e.dilationRate,n,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new ee(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(2===this.rank){if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new ee(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(3===this.rank)if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new ee(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}static verifyArgs(n){if(po("kernelSize"in n,"required key 'kernelSize' not in config"),"number"!=typeof n.kernelSize&&!kS(n.kernelSize,"number",1,3))throw new ee(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(n.kernelSize)}.`)}getConfig(){const n={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:rl(this.activation),useBias:this.useBias,biasInitializer:Jn(this.biasInitializer),biasRegularizer:Rn(this.biasRegularizer),activityRegularizer:Rn(this.activityRegularizer),biasConstraint:Er(this.biasConstraint)},e=super.getConfig();return Object.assign(n,e),n}}class Kc extends Wv{constructor(n,e){super(n,e),this.kernel=null,Kc.verifyArgs(e),this.filters=e.filters,Vr(this.filters,"filters"),this.kernelInitializer=jn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=Nr(e.kernelConstraint),this.kernelRegularizer=qn(e.kernelRegularizer)}build(n){n=mn(n);const e="channelsFirst"===this.dataFormat?1:n.length-1;if(null==n[e])throw new ee(`The channel dimension of the input should be defined. Found ${n[e]}`);const r=n[e],s=this.kernelSize.concat([r,this.filters]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[e]:r}}],this.built=!0}call(n,e){return he(()=>{let r;n=$t(n);const s=null==this.bias?null:this.bias.read(),o=x$(this.activation.getClassName());if(null!=o&&2===this.rank)r=sI(n,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate,o);else{if(1===this.rank)r=function vL(t,n,e,r=1,s="valid",o,i=1){return he(()=>{if(null==o&&(o="channelsLast"),mr(o),3!==t.shape.length)throw new ee(`The input of a conv1dWithBias operation should be 3, but is ${t.shape.length} instead.`);if(3!==n.shape.length)throw new ee(`The kernel for a conv1dWithBias operation should be 3, but is ${n.shape.length} instead`);if(null!=e&&1!==e.shape.length)throw new ee(`The bias for a conv1dWithBias operation should be 1, but is ${n.shape.length} instead`);if("channelsFirst"===o&&(t=hn(t,[0,2,1])),"causal"===s)throw new Wt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let a=QP(t,n,r,"same"===s?"same":"valid","NWC",i);return null!=e&&(a=oi(a,e)),a})}(n,this.kernel.read(),s,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)r=sI(n,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new Wt("convolutions greater than 3D are not implemented yet.");r=function bL(t,n,e,r=[1,1,1],s="valid",o,i){return he(()=>{if(null==o&&(o="channelsLast"),mr(o),4!==t.rank&&5!==t.rank)throw new ee(`conv3dWithBias expects input to be of rank 4 or 5, but received ${t.rank}.`);if(4!==n.rank&&5!==n.rank)throw new ee(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${t.rank}.`);let a=yL(t,o);if("causal"===s)throw new Wt("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return a=fJ(a,n,r,"same"===s?"same":"valid","NDHWC",i),null!=e&&(a=oi(a,e)),"channelsFirst"===o&&(a=hn(a,[0,4,1,2,3])),a})}(n,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(r=this.activation.apply(r))}return r})}computeOutputShape(n){n=mn(n);const e=[],r="channelsLast"===this.dataFormat?n.slice(1,n.length-1):n.slice(2);for(let o=0;o<r.length;++o){const i=li(r[o],this.kernelSize[o],this.padding,this.strides[o],"number"==typeof this.dilationRate?this.dilationRate:this.dilationRate[o]);e.push(i)}let s=[n[0]];return"channelsLast"===this.dataFormat?(s=s.concat(e),s.push(this.filters)):(s.push(this.filters),s=s.concat(e)),s}getConfig(){const n={filters:this.filters,kernelInitializer:Jn(this.kernelInitializer),kernelRegularizer:Rn(this.kernelRegularizer),kernelConstraint:Er(this.kernelConstraint)},e=super.getConfig();return Object.assign(n,e),n}static verifyArgs(n){if(!("filters"in n)||"number"!=typeof n.filters||n.filters<1)throw new ee(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(n.filters)}`)}}let xL=(()=>{class t extends Kc{constructor(e){super(2,e),t.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!kS(e.kernelSize,"number",1,2))throw new ee(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}return t.className="Conv2D",t})();Ue(xL);let wL=(()=>{class t extends Kc{constructor(e){super(3,e),t.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&(!Array.isArray(e.kernelSize)||1!==e.kernelSize.length&&3!==e.kernelSize.length))throw new ee(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}return t.className="Conv3D",t})();Ue(wL),Ue((()=>{class t extends xL{constructor(e){if(super(e),this.inputSpec=[new kr({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new ee(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(4!==(e=mn(e)).length)throw new ee("Input should have rank 4; Received input shape: "+JSON.stringify(e));const r="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[r])throw new ee("The channel dimension of the inputs should be defined. Found `None`.");const s=e[r],o=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",o,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new kr({ndim:4,axes:{[r]:s}})],this.built=!0}call(e,r){return he(()=>{let s=$t(e);if(4!==s.shape.length)throw new ee(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const o=s.shape;let a,l;"channelsFirst"===this.dataFormat?(a=2,l=3):(a=1,l=2);const c=o[l],h=this.kernelSize[1],f=this.strides[1],y=[o[0],Li(o[a],this.strides[0],this.kernelSize[0],this.padding),Li(c,f,h,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(s=hn(s,[0,2,3,1]));let v=JP(s,this.kernel.read(),y,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(v=hn(v,[0,3,1,2])),null!=this.bias&&(v=oi(v,this.bias.read(),this.dataFormat)),null!=this.activation&&(v=this.activation.apply(v)),v})}computeOutputShape(e){const r=(e=mn(e)).slice();let s,o,i;"channelsFirst"===this.dataFormat?(s=1,o=2,i=3):(s=3,o=1,i=2);const a=this.kernelSize[0],l=this.kernelSize[1],u=this.strides[0],c=this.strides[1];return r[s]=this.filters,r[o]=Li(r[o],u,a,this.padding),r[i]=Li(r[i],c,l,this.padding),r}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}return t.className="Conv2DTranspose",t})()),Ue((()=>{class t extends wL{constructor(e){if(super(e),this.inputSpec=[new kr({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new ee(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(5!==(e=mn(e)).length)throw new ee("Input should have rank 5; Received input shape: "+JSON.stringify(e));const r="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[r])throw new ee("The channel dimension of the inputs should be defined. Found `None`.");const s=e[r],o=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",o,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new kr({ndim:5,axes:{[r]:s}})],this.built=!0}call(e,r){return he(()=>{let s=$t(e);if(5!==s.shape.length)throw new ee(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const o=s.shape;let a,l,u;"channelsFirst"===this.dataFormat?(u=2,a=3,l=4):(u=1,a=2,l=3);const d=o[a],h=o[l],f=this.kernelSize[1],g=this.kernelSize[2],y=this.strides[1],v=this.strides[2],k=[o[0],Li(o[u],this.strides[0],this.kernelSize[0],this.padding),Li(d,y,f,this.padding),Li(h,v,g,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(s=hn(s,[0,2,3,4,1]));let V=yJ(s,this.kernel.read(),k,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(V=hn(V,[0,4,1,2,3])),null!==this.bias&&(V=oi(V,this.bias.read(),this.dataFormat)),null!==this.activation&&(V=this.activation.apply(V)),V})}computeOutputShape(e){const r=(e=mn(e)).slice();let s,o,i,a;"channelsFirst"===this.dataFormat?(s=1,o=2,i=3,a=4):(s=4,o=1,i=2,a=3);const l=this.kernelSize[0],u=this.kernelSize[1],c=this.kernelSize[2],d=this.strides[0],h=this.strides[1],p=this.strides[2];return r[s]=this.filters,r[o]=Li(r[o],d,l,this.padding),r[i]=Li(r[i],h,u,this.padding),r[a]=Li(r[a],p,c,this.padding),r}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}return t.className="Conv3DTranspose",t})());let Pae=(()=>{class t extends Kc{constructor(e,r){if(super(e,r),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==r.filters)throw new ee("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=r.kernelInitializer||null!=r.kernelRegularizer||null!=r.kernelConstraint)throw new ee("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=r.padding&&"same"!==r.padding&&"valid"!==r.padding)throw new ee(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(r.padding)}`);this.depthMultiplier=null==r.depthMultiplier?1:r.depthMultiplier,this.depthwiseInitializer=jn(r.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=qn(r.depthwiseRegularizer),this.depthwiseConstraint=Nr(r.depthwiseConstraint),this.pointwiseInitializer=jn(r.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=qn(r.pointwiseRegularizer),this.pointwiseConstraint=Nr(r.pointwiseConstraint)}build(e){if((e=mn(e)).length<this.rank+2)throw new ee(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const r="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[r]||e[r]<0)throw new ee(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[r])}`);const s=e[r],o=this.kernelSize.concat([s,this.depthMultiplier]),i=[];for(let l=0;l<this.rank;++l)i.push(1);i.push(s*this.depthMultiplier,this.filters);const a=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",o,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,a,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",i,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,a,this.pointwiseConstraint),this.bias=this.useBias?this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,a,this.biasConstraint):null,this.inputSpec=[new kr({ndim:this.rank+2,axes:{[r]:s}})],this.built=!0}call(e,r){return he(()=>{let s;if(e=$t(e),1===this.rank)throw new Wt("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(e=hn(e,[0,2,3,1])),s=aM(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(s=oi(s,this.bias.read(),this.dataFormat)),null!=this.activation&&(s=this.activation.apply(s)),"channelsFirst"===this.dataFormat&&(s=hn(s,[0,3,1,2])),s})}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=Jn(this.depthwiseInitializer),e.pointwiseInitializer=Jn(this.pointwiseInitializer),e.depthwiseRegularizer=Rn(this.depthwiseRegularizer),e.pointwiseRegularizer=Rn(this.pointwiseRegularizer),e.depthwiseConstraint=Er(this.depthwiseConstraint),e.pointwiseConstraint=Er(this.pointwiseConstraint),e}}return t.className="SeparableConv",t})();function _L(t,n,e,r){if(Array.isArray(t)){if(null!=n||null!=e)throw new ee("When inputs is an array, neither initialState or constants should be provided");null!=r&&(e=t.slice(t.length-r,t.length),t=t.slice(0,t.length-r)),t.length>1&&(n=t.slice(1,t.length)),t=t[0]}function s(o){return null==o||Array.isArray(o)?o:[o]}return{inputs:t,initialState:n=s(n),constants:e=s(e)}}function CL(t,n,e,r=!1,s,o,i=!1,a=!1){return he(()=>{const l=n.shape.length;if(l<3)throw new ee(`Input should be at least 3D, but is ${l}D.`);const u=[1,0].concat(ri(2,l));if(n=hn(n,u),null!=o)throw new Wt("The rnn() functoin of the deeplearn.js backend does not support constants yet.");i&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=s&&((s=it(it(s,"bool"),"float32")).rank===l-1&&(s=Gs(s,-1)),s=hn(s,u)),r&&(n=tu(n,0),null!=s&&(s=tu(s,0)));const c=[];let d,h=e;const p=n.shape[0],f=nu(n);let g,m;null!=s&&(g=nu(s));for(let y=0;y<p;++y){const v=f[y],b=he(()=>t(v,h));if(null==s)d=b[0],h=b[1];else{const x=he(()=>{const w=g[y],k=gt(Po(w),w);return{output:Ge(Q(b[0],w),Q(h[0],k)),newStates:h.map((K,Y)=>Ge(Q(b[1][Y],w),Q(K,k)))}});d=x.output,h=x.newStates}a&&c.push(d)}return a&&(m=Ya(c,1)),[d,m,h]})}Ue((()=>{class t extends Pae{constructor(e){super(2,e)}}return t.className="SeparableConv2D",t})()),Ue((()=>{class t extends Kc{constructor(e){super(1,e),t.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!kS(e.kernelSize,"number",1,1))throw new ee(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}return t.className="Conv1D",t})()),Ue((()=>{class t extends tn{constructor(e){super(e),this.cropping="number"==typeof e.cropping?[[e.cropping,e.cropping],[e.cropping,e.cropping]]:"number"==typeof e.cropping[0]?[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:e.cropping,this.dataFormat=void 0===e.dataFormat?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,r){return he(()=>{if(e=$t(e),"channelsLast"===this.dataFormat){const s=Dv(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return Dv(s,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const s=Dv(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return Dv(s,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},r=super.getConfig();return Object.assign(e,r),e}}return t.className="Cropping2D",t})()),Ue((()=>{class t extends tn{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==e.size?this.DEFAULT_SIZE:e.size,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,mr(this.dataFormat),this.interpolation=null==e.interpolation?"nearest":e.interpolation,function pie(t){iu(uie,"InterpolationFormat",t)}(this.interpolation)}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],null==e[2]?null:this.size[0]*e[2],null==e[3]?null:this.size[1]*e[3]]:[e[0],null==e[1]?null:this.size[0]*e[1],null==e[2]?null:this.size[1]*e[2],e[3]]}call(e,r){return he(()=>{let s=$t(e);const o=s.shape;if("channelsFirst"===this.dataFormat){s=hn(s,[0,2,3,1]);const i=this.size[0]*o[2],a=this.size[1]*o[3],l="nearest"===this.interpolation?Za.resizeNearestNeighbor(s,[i,a]):Za.resizeBilinear(s,[i,a]);return hn(l,[0,3,1,2])}{const i=this.size[0]*o[1],a=this.size[1]*o[2];return"nearest"===this.interpolation?Za.resizeNearestNeighbor(s,[i,a]):Za.resizeBilinear(s,[i,a])}})}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},r=super.getConfig();return Object.assign(e,r),e}}return t.className="UpSampling2D",t})()),Ue((()=>{class t extends Wv{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=jn(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=Nr(e.depthwiseConstraint),this.depthwiseRegularizer=qn(e.depthwiseRegularizer)}build(e){if((e=mn(e)).length<4)throw new ee(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const r="channelsFirst"===this.dataFormat?1:3;if(null==e[r]||e[r]<0)throw new ee(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[r]}).`);const s=e[r];this.depthwiseKernel=this.addWeight("depthwise_kernel",[this.kernelSize[0],this.kernelSize[1],s,this.depthMultiplier],null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.bias=this.useBias?this.addWeight("bias",[s*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(e,r){return he(()=>{let s=function Mae(t,n,e=[1,1],r="valid",s,o){return he(()=>{null==s&&(s="channelsLast"),mr(s);let i=rI(t,s);if(4!==t.rank)throw new ee(`Input for depthwiseConv2d is required to be 4-D, but is instead ${t.rank}-D`);if(4!==n.rank)throw new ee(`depthwiseKernel is required to be 4-D, but is instead ${n.rank}-D`);return i=sv(i,n,e,"same"===r?"same":"valid","NHWC",o),"channelsFirst"===s&&(i=hn(i,[0,3,1,2])),i})}(e=$t(e),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(s=oi(s,this.bias.read(),this.dataFormat)),null!=this.activation&&(s=this.activation.apply(s)),s})}computeOutputShape(e){e=mn(e);const s="channelsFirst"===this.dataFormat?e[3]:e[2],o="channelsFirst"===this.dataFormat?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,i=li("channelsFirst"===this.dataFormat?e[2]:e[1],this.kernelSize[0],this.padding,this.strides[0]),a=li(s,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[e[0],o,i,a]:[e[0],i,a,o]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=Jn(this.depthwiseInitializer),e.depthwiseRegularizer=Rn(this.depthwiseRegularizer),e.depthwiseConstraint=Er(this.depthwiseRegularizer),e}}return t.className="DepthwiseConv2D",t})());let uf=(()=>{class t extends tn{constructor(e){let r;if(super(e),null==e.cell)throw new ee("cell property is missing for the constructor of RNN.");if(r=Array.isArray(e.cell)?new DL({cells:e.cell}):e.cell,null==r.stateSize)throw new ee("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=r,this.returnSequences=null!=e.returnSequences&&e.returnSequences,this.returnState=null!=e.returnState&&e.returnState,this.goBackwards=null!=e.goBackwards&&e.goBackwards,this._stateful=null!=e.stateful&&e.stateful,this.unroll=null!=e.unroll&&e.unroll,this.supportsMasking=!0,this.inputSpec=[new kr({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){return null==this.states_?ri(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map(r=>null):this.states_}setStates(e){this.states_=e}computeOutputShape(e){FS(e)&&(e=e[0]);let r=this.cell.stateSize;Array.isArray(r)||(r=[r]);const s=r[0];let o;if(o=this.returnSequences?[e[0],e[1],s]:[e[0],s],this.returnState){const i=[];for(const a of r)i.push([e[0],a]);return[o].concat(i)}return o}computeMask(e,r){return he(()=>{Array.isArray(r)&&(r=r[0]);const s=this.returnSequences?r:null;if(this.returnState){const o=this.states.map(i=>null);return[s].concat(o)}return s})}get states(){if(null==this.states_){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,r=[];for(let s=0;s<e;++s)r.push(null);return r}return this.states_}set states(e){this.states_=e}build(e){if(null!=this.numConstants)throw new Wt("Constants support is not implemented in RNN yet.");FS(e)&&(e=e[0]);const s=this.stateful?e[0]:null,o=e.slice(2);this.inputSpec[0]=new kr({shape:[s,null,...o]});const i=[e[0]].concat(e.slice(2));let a;if(this.cell.build(i),a=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!gn(this.stateSpec.map(l=>l.shape[l.shape.length-1]),a))throw new ee(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=a.map(l=>new kr({shape:[null,l]}));this.stateful&&this.resetStates()}resetStates(e,r=!1){he(()=>{if(!this.stateful)throw new Ri("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape[0];if(null==s)throw new ee("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)this.states_=Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(o=>Lr([s,o])):[Lr([s,this.cell.stateSize])];else if(null==e)Xt(this.states_),null!=this.keptStates&&(Xt(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(o=>Lr([s,o])):this.states_[0]=Lr([s,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new ee(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);!0===r?this.keptStates.push(this.states_.slice()):Xt(this.states_);for(let o=0;o<this.states_.length;++o){const i=e[o],a=Array.isArray(this.cell.stateSize)?this.cell.stateSize[o]:this.cell.stateSize,l=[s,a];if(!gn(i.shape,l))throw new ee(`State ${o} is incompatible with layer ${this.name}: expected shape=${l}, received shape=${i.shape}`);this.states_[o]=i}}this.states_=this.states_.map(o=>Ei(o.clone()))})}apply(e,r){let s=null==r?null:r.initialState,o=null==r?null:r.constants;null==r&&(r={});const i=_L(e,s,o,this.numConstants);e=i.inputs,s=i.initialState,o=i.constants;let a=[],l=[];if(null!=s){r.initialState=s,a=a.concat(s),this.stateSpec=[];for(const c of s)this.stateSpec.push(new kr({shape:c.shape}));l=l.concat(this.stateSpec)}if(null!=o&&(r.constants=o,a=a.concat(o),this.numConstants=o.length),a[0]instanceof Mi){const c=[e].concat(a),d=this.inputSpec.concat(l),h=this.inputSpec;this.inputSpec=d;const p=super.apply(c,r);return this.inputSpec=h,p}return super.apply(e,r)}call(e,r){return he(()=>{const s=null==r?null:r.mask,o=null==r?null:r.training;let i=null==r?null:r.initialState;e=$t(e),null==i&&(i=this.stateful?this.states_:this.getInitialState(e));const a=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(i.length!==a)throw new ee(`RNN Layer has ${a} state(s) but was passed ${i.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const l={training:o},c=CL((g,m)=>{const y=this.cell.call([g].concat(m),l);return[y[0],y.slice(1)]},e,i,this.goBackwards,s,null,this.unroll,this.returnSequences),d=c[0],h=c[1],p=c[2];this.stateful&&this.resetStates(p,o);const f=this.returnSequences?h:d;return this.returnState?[f].concat(p):f})}getInitialState(e){return he(()=>{let r=Lr(e.shape);return r=yt(r,[1,2]),r=Jp(r),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(s=>s>1?AS(r,[1,s]):r):this.cell.stateSize>1?[AS(r,[1,this.cell.stateSize])]:[r]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),r={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(r.numConstants=this.numConstants);const s=this.cell.getConfig();return this.getClassName()===t.className&&(r.cell={className:this.cell.getClassName(),config:s}),Object.assign(Object.assign(Object.assign({},s),e),r)}static fromConfig(e,r,s={}){const i=$i(r.cell,s);return new e(Object.assign(r,{cell:i}))}}return t.className="RNN",t})();Ue(uf);class Gv extends tn{}let SL=(()=>{class t extends Gv{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Vr(this.units,"units"),this.activation=sl(null==e.activation?this.DEFAULT_ACTIVATION:e.activation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=jn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=jn(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=jn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=qn(e.kernelRegularizer),this.recurrentRegularizer=qn(e.recurrentRegularizer),this.biasRegularizer=qn(e.biasRegularizer),this.kernelConstraint=Nr(e.kernelConstraint),this.recurrentConstraint=Nr(e.recurrentConstraint),this.biasConstraint=Nr(e.biasConstraint),this.dropout=Gc([1,el([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=Gc([1,el([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=mn(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.bias=this.useBias?this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(e,r){return he(()=>{if(2!==e.length)throw new ee(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let s=e[1];e=e[0];const o=null!=r.training&&r.training;let i;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=ol({ones:()=>Po(e),rate:this.dropout,training:o,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=ol({ones:()=>Po(s),rate:this.recurrentDropout,training:o,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,l=this.recurrentDropoutMask;i=Oi(null!=a?Q(e,a):e,this.kernel.read()),null!=this.bias&&(i=oi(i,this.bias.read())),null!=l&&(s=Q(s,l));let u=Ge(i,Oi(s,this.recurrentKernel.read()));return null!=this.activation&&(u=this.activation.apply(u)),[u,u]})}getConfig(){const e=super.getConfig(),r={units:this.units,activation:rl(this.activation),useBias:this.useBias,kernelInitializer:Jn(this.kernelInitializer),recurrentInitializer:Jn(this.recurrentInitializer),biasInitializer:Jn(this.biasInitializer),kernelRegularizer:Rn(this.kernelRegularizer),recurrentRegularizer:Rn(this.recurrentRegularizer),biasRegularizer:Rn(this.biasRegularizer),activityRegularizer:Rn(this.activityRegularizer),kernelConstraint:Er(this.kernelConstraint),recurrentConstraint:Er(this.recurrentConstraint),biasConstraint:Er(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),r)}}return t.className="SimpleRNNCell",t})();Ue(SL),Ue((()=>{class t extends uf{constructor(e){e.cell=new SL(e),super(e)}call(e,r){return he(()=>(null!=this.cell.dropoutMask&&(Xt(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(Xt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(e,{mask:null==r?null:r.mask,training:null==r?null:r.training,initialState:null==r?null:r.initialState})))}static fromConfig(e,r){return new e(r)}}return t.className="SimpleRNN",t})());let IL=(()=>{class t extends Gv{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new ee("GRUCell does not support reset_after parameter set to true.");this.units=e.units,Vr(this.units,"units"),this.activation=sl(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=sl(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=jn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=jn(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=jn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=qn(e.kernelRegularizer),this.recurrentRegularizer=qn(e.recurrentRegularizer),this.biasRegularizer=qn(e.biasRegularizer),this.kernelConstraint=Nr(e.kernelConstraint),this.recurrentConstraint=Nr(e.recurrentConstraint),this.biasConstraint=Nr(e.biasConstraint),this.dropout=Gc([1,el([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=Gc([1,el([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=mn(e),this.kernel=this.addWeight("kernel",[e[e.length-1],3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.bias=this.useBias?this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(e,r){return he(()=>{if(2!==e.length)throw new ee(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const s=null!=r.training&&r.training;let o=e[1];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=ol({ones:()=>Po(e),rate:this.dropout,training:s,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=ol({ones:()=>Po(o),rate:this.recurrentDropout,training:s,count:3,dropoutFunc:this.dropoutFunc}));const a=this.recurrentDropoutMask;let l,u,c;0<this.dropout&&this.dropout<1&&(e=Q(e,this.dropoutMask[0]));let d=Oi(e,this.kernel.read());this.useBias&&(d=oi(d,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(o=Q(o,a[0]));const h=this.recurrentKernel.read(),[p,f]=ho(h,[2*this.units,this.units],h.rank-1),g=Oi(o,p),[m,y,v]=ho(d,3,d.rank-1),[b,x]=ho(g,2,g.rank-1);l=this.recurrentActivation.apply(Ge(m,b)),u=this.recurrentActivation.apply(Ge(y,x));const w=Oi(Q(u,o),f);c=this.activation.apply(Ge(v,w));const k=Ge(Q(l,o),Q(Ge(1,Hn(l)),c));return[k,k]})}getConfig(){const e=super.getConfig(),r={units:this.units,activation:rl(this.activation),recurrentActivation:rl(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Jn(this.kernelInitializer),recurrentInitializer:Jn(this.recurrentInitializer),biasInitializer:Jn(this.biasInitializer),kernelRegularizer:Rn(this.kernelRegularizer),recurrentRegularizer:Rn(this.recurrentRegularizer),biasRegularizer:Rn(this.biasRegularizer),activityRegularizer:Rn(this.activityRegularizer),kernelConstraint:Er(this.kernelConstraint),recurrentConstraint:Er(this.recurrentConstraint),biasConstraint:Er(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),r)}}return t.className="GRUCell",t})();Ue(IL),Ue((()=>{class t extends uf{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new IL(e),super(e)}call(e,r){return he(()=>(null!=this.cell.dropoutMask&&(Xt(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(Xt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(e,{mask:null==r?null:r.mask,training:null==r?null:r.training,initialState:null==r?null:r.initialState})))}static fromConfig(e,r){return 0===r.implmentation&&(r.implementation=1),new e(r)}}return t.className="GRU",t})());let oI=(()=>{class t extends Gv{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Vr(this.units,"units"),this.activation=sl(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=sl(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=jn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=jn(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=jn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=qn(e.kernelRegularizer),this.recurrentRegularizer=qn(e.recurrentRegularizer),this.biasRegularizer=qn(e.biasRegularizer),this.kernelConstraint=Nr(e.kernelConstraint),this.recurrentConstraint=Nr(e.recurrentConstraint),this.biasConstraint=Nr(e.biasConstraint),this.dropout=Gc([1,el([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=Gc([1,el([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var r;let o;if(e=mn(e),this.kernel=this.addWeight("kernel",[e[e.length-1],4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const i=this.biasInitializer,a=this.units;o=new((r=class extends Vo{apply(u,c){const d=i.apply([a]),h=(new A$).apply([a]),p=i.apply([2*a]);return k$(k$(d,h),p)}}).className="CustomInit",r)}else o=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,o,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,r){return he(()=>{const s=null!=r.training&&r.training;if(3!==e.length)throw new ee(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let o=e[1];const i=e[2];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=ol({ones:()=>Po(e),rate:this.dropout,training:s,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=ol({ones:()=>Po(o),rate:this.recurrentDropout,training:s,count:4,dropoutFunc:this.dropoutFunc}));const l=this.recurrentDropoutMask;let u,c,d,h;0<this.dropout&&this.dropout<1&&(e=Q(e,this.dropoutMask[0]));let p=Oi(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(o=Q(o,l[0])),p=Ge(p,Oi(o,this.recurrentKernel.read())),this.useBias&&(p=oi(p,this.bias.read()));const[f,g,m,y]=ho(p,4,p.rank-1);u=this.recurrentActivation.apply(f),c=this.recurrentActivation.apply(g),d=Ge(Q(c,i),Q(u,this.activation.apply(m))),h=this.recurrentActivation.apply(y);const v=Q(h,this.activation.apply(d));return[v,v,d]})}getConfig(){const e=super.getConfig(),r={units:this.units,activation:rl(this.activation),recurrentActivation:rl(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Jn(this.kernelInitializer),recurrentInitializer:Jn(this.recurrentInitializer),biasInitializer:Jn(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:Rn(this.kernelRegularizer),recurrentRegularizer:Rn(this.recurrentRegularizer),biasRegularizer:Rn(this.biasRegularizer),activityRegularizer:Rn(this.activityRegularizer),kernelConstraint:Er(this.kernelConstraint),recurrentConstraint:Er(this.recurrentConstraint),biasConstraint:Er(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),r)}}return t.className="LSTMCell",t})();Ue(oI),Ue((()=>{class t extends uf{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new oI(e),super(e)}call(e,r){return he(()=>(null!=this.cell.dropoutMask&&(Xt(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(Xt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(e,{mask:null==r?null:r.mask,training:null==r?null:r.training,initialState:null==r?null:r.initialState})))}static fromConfig(e,r){return 0===r.implmentation&&(r.implementation=1),new e(r)}}return t.className="LSTM",t})());let DL=(()=>{class t extends Gv{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const r of this.cells.slice().reverse())Array.isArray(r.stateSize)?e.push(...r.stateSize):e.push(r.stateSize);return e}call(e,r){return he(()=>{let s=e.slice(1);const o=[];for(const l of this.cells.slice().reverse())Array.isArray(l.stateSize)?o.push(s.splice(0,l.stateSize.length)):o.push(s.splice(0,1));o.reverse();const i=[];let a;for(let l=0;l<this.cells.length;++l){const u=this.cells[l];s=o[l],a=0===l?[e[0]].concat(s):[a[0]].concat(s),a=u.call(a,r),i.push(a.slice(1))}s=[];for(const l of i.slice().reverse())s.push(...l);return[a[0]].concat(s)})}build(e){let r;FS(e)&&(e=e[0]),this.cells.forEach((s,o)=>{au(`RNNCell_${o}`,()=>{s.build(e),r=Array.isArray(s.stateSize)?s.stateSize[0]:s.stateSize,e=[e[0],r]})}),this.built=!0}getConfig(){const e=super.getConfig(),o={cells:this.cells.map(i=>({className:i.getClassName(),config:i.getConfig()}))};return Object.assign(Object.assign({},e),o)}static fromConfig(e,r,s={}){const o=[];for(const i of r.cells)o.push($i(i,s));return new e({cells:o})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const r of this.cells)e.push(...r.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const r of this.cells)e.push(...r.nonTrainableWeights);if(!this.trainable){const r=[];for(const s of this.cells)r.push(...s.trainableWeights);return r.concat(e)}return e}getWeights(){const e=[];for(const r of this.cells)e.push(...r.weights);return OS(e)}setWeights(e){const r=[];for(const s of this.cells){const i=e.splice(s.weights.length);for(let a=0;a<s.weights.length;++a)r.push([s.weights[a],i[a]])}PS(r)}}return t.className="StackedRNNCells",t})();function ol(t){const{ones:n,rate:e,training:r=!1,count:s=1,dropoutFunc:o}=t,i=()=>null!=o?o(n(),e):N$(n(),e),a=()=>nf(i,n,r);return!s||s<=1?Ei(a().clone()):Array(s).fill(void 0).map(a).map(u=>Ei(u.clone()))}Ue(DL);let Lae=(()=>{class t extends uf{constructor(e){if(e.unroll)throw new Wt("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new Wt("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new kr({ndim:5})]}call(e,r){return he(()=>{if(null!=this.cell.dropoutMask&&(Xt(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(Xt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),r&&r.constants)throw new ee("ConvRNN2D cell does not support constants");return super.call(e,{mask:null==r?null:r.mask,training:null==r?null:r.training,initialState:null==r?null:r.initialState})})}computeOutputShape(e){let r=this.computeSingleOutputShape(e);return this.returnSequences||(r=[r[0],...r.slice(2)]),this.returnState&&(r=[r,...Array(2).fill([e[0],...r.slice(-3)])]),r}getInitialState(e){return he(()=>{const{stateSize:r}=this.cell,o=this.computeSingleOutputShape(e.shape),a=Lr([o[0],...o.slice(2)]);return Array.isArray(r)?Array(r.length).fill(a):[a]})}resetStates(e,r=!1){he(()=>{if(!this.stateful)throw new Ri("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape,o=this.computeSingleOutputShape(s),i=[o[0],...o.slice(2)];if(null==s[0])throw new ee("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())this.states_=Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(()=>Lr(i)):[Lr(i)];else if(null==e)Xt(this.states_),null!=this.keptStates&&(Xt(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Lr(i)):this.states_[0]=Lr(i);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new ee(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);r?this.keptStates.push(this.states_.slice()):Xt(this.states_);for(let l=0;l<this.states_.length;++l){const u=e[l],c=i;if(!gn(u.shape,c))throw new ee(`State ${l} is incompatible with layer ${this.name}: expected shape=${c}, received shape=${u.shape}`);this.states_[l]=u}}this.states_=this.states_.map(l=>Ei(l.clone()))})}computeSingleOutputShape(e){const{dataFormat:r,filters:s,kernelSize:o,padding:i,strides:a,dilationRate:l}=this.cell,u="channelsFirst"===r,d=e[u?4:3],h=li(e[u?3:2],o[0],i,a[0],l[0]),p=li(d,o[1],i,a[1],l[1]);return[...e.slice(0,2),...u?[s,h,p]:[h,p,s]]}}return t.className="ConvRNN2D",t})(),TL=(()=>{class t extends oI{constructor(e){const{filters:r,kernelSize:s,strides:o,padding:i,dataFormat:a,dilationRate:l}=e;super(Object.assign(Object.assign({},e),{units:r})),this.filters=r,Vr(this.filters,"filters"),this.kernelSize=qc(s,2,"kernelSize"),this.kernelSize.forEach(u=>Vr(u,"kernelSize")),this.strides=qc(o||1,2,"strides"),this.strides.forEach(u=>Vr(u,"strides")),this.padding=i||"valid",fo(this.padding),this.dataFormat=a||"channelsLast",mr(this.dataFormat),this.dilationRate=qc(l||1,2,"dilationRate"),this.dilationRate.forEach(u=>Vr(u,"dilationRate"))}build(e){var r;e=mn(e);const s="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[s])throw new ee(`The channel dimension of the input should be defined. Found ${e[s]}`);const a=this.kernelSize.concat([e[s],4*this.filters]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const l=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",l,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let u;if(this.unitForgetBias){const c=this.biasInitializer,d=this.filters;u=new((r=class extends Vo{apply(p,f){return NS([c.apply([d]),Xa([d]),c.apply([2*d])])}}).className="CustomInit",r)}else u=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,u,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,r){return he(()=>{if(3!==e.length)throw new ee(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const s=r.training||!1,o=e[0],i=e[1],a=e[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=ol({ones:()=>Po(o),rate:this.dropout,training:s,count:4,dropoutFunc:this.dropoutFunc}));const u=this.dropoutMask,c=(He,Ye,je)=>Ye&&Ye[je]?Q(Ye[je],He):He;let d=c(o,u,0),h=c(o,u,1),p=c(o,u,2),f=c(o,u,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=ol({ones:()=>Po(i),rate:this.recurrentDropout,training:s,count:4,dropoutFunc:this.dropoutFunc}));const g=this.recurrentDropoutMask;let m=c(i,g,0),y=c(i,g,1),v=c(i,g,2),b=c(i,g,3);const[w,k,V,z]=ho(this.kernel.read(),4,3),[K,Y,se,fe]=this.useBias?ho(this.bias.read(),4):[null,null,null,null];d=this.inputConv(d,w,K,this.padding),h=this.inputConv(h,k,Y,this.padding),p=this.inputConv(p,V,se,this.padding),f=this.inputConv(f,z,fe,this.padding);const[ve,be,xe,De]=ho(this.recurrentKernel.read(),4,3);m=this.recurrentConv(m,ve),y=this.recurrentConv(y,be),v=this.recurrentConv(v,xe),b=this.recurrentConv(b,De);const Ne=this.recurrentActivation.apply(Ge(d,m)),we=this.recurrentActivation.apply(Ge(h,y)),Ae=Ge(Q(we,a),Q(Ne,this.activation.apply(Ge(p,v)))),ze=Q(this.recurrentActivation.apply(Ge(f,b)),this.activation.apply(Ae));return[ze,ze,Ae]})}getConfig(){const s=function(t,n){var e={};for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&n.indexOf(r)<0&&(e[r]=t[r]);if(null!=t&&"function"==typeof Object.getOwnPropertySymbols){var s=0;for(r=Object.getOwnPropertySymbols(t);s<r.length;s++)n.indexOf(r[s])<0&&Object.prototype.propertyIsEnumerable.call(t,r[s])&&(e[r[s]]=t[r[s]])}return e}(super.getConfig(),["units"]),o={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},s),o)}inputConv(e,r,s,o){const i=Jl(e,r,this.strides,o||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return s?oi(i,s,this.dataFormat):i}recurrentConv(e,r){return Jl(e,r,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}return t.className="ConvLSTM2DCell",t})();Ue(TL),Ue((()=>{class t extends Lae{constructor(e){const r=new TL(e);super(Object.assign(Object.assign({},e),{cell:r}))}static fromConfig(e,r){return new e(r)}}return t.className="ConvLSTM2D",t})());let kL=(()=>{class t extends tn{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(null==this.noiseShape)return this.noiseShape;const r=e.shape,s=[];for(let o=0;o<this.noiseShape.length;++o)s.push(null==this.noiseShape[o]?r[o]:this.noiseShape[o]);return s}call(e,r){return he(()=>{this.invokeCallHook(e,r);const s=$t(e);if(0<this.rate&&this.rate<1){const o=null!=r.training&&r.training,i=this.getNoiseShape(s);return nf(()=>N$(s,this.rate,i,this.seed),()=>s,o)}return e})}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},r=super.getConfig();return Object.assign(e,r),e}dispose(){return super.dispose()}}return t.className="Dropout",t})();Ue(kL),Ue((()=>{class t extends kL{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const r=e.shape;return[r[0],1,r[2]]}}return t.className="SpatialDropout1D",t})()),Ue((()=>{class t extends tn{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==e.batchInputShape&&null==e.inputShape&&null!=e.inputDim){let r=null;null!=e.batchSize&&(r=e.batchSize),this.batchInputShape=[r,e.inputDim]}this.units=e.units,Vr(this.units,"units"),this.activation=sl(e.activation),null!=e.useBias&&(this.useBias=e.useBias),this.kernelInitializer=jn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=jn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Nr(e.kernelConstraint),this.biasConstraint=Nr(e.biasConstraint),this.kernelRegularizer=qn(e.kernelRegularizer),this.biasRegularizer=qn(e.biasRegularizer),this.activityRegularizer=qn(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){const r=(e=mn(e))[e.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[r,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:r}}],this.built=!0}computeOutputShape(e){const r=(e=mn(e)).slice();return r[r.length-1]=this.units,r}call(e,r){return he(()=>{this.invokeCallHook(e,r);const s=$t(e),o=x$(this.activation.getClassName());let i;return null!=o?i=Oi(s,this.kernel.read(),o,this.bias?this.bias.read():null):(i=Oi(s,this.kernel.read()),null!=this.bias&&(i=oi(i,this.bias.read())),null!=this.activation&&(i=this.activation.apply(i))),i})}getConfig(){const e={units:this.units,activation:rl(this.activation),useBias:this.useBias,kernelInitializer:Jn(this.kernelInitializer),biasInitializer:Jn(this.biasInitializer),kernelRegularizer:Rn(this.kernelRegularizer),biasRegularizer:Rn(this.biasRegularizer),activityRegularizer:Rn(this.activityRegularizer),kernelConstraint:Er(this.kernelConstraint),biasConstraint:Er(this.biasConstraint)},r=super.getConfig();return Object.assign(e,r),e}}return t.className="Dense",t})()),Ue((()=>{class t extends tn{constructor(e){super(e=e||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=mn(e);for(const r of e.slice(1))if(null==r)throw new ee(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],Ja(e,1)]}call(e,r){return he(()=>{this.invokeCallHook(e,r);let s=$t(e);if("channelsFirst"===this.dataFormat&&s.rank>1){const o=[0];for(let i=2;i<s.rank;++i)o.push(i);o.push(1),s=hn(s,o)}return function wie(t){if(t.rank<=1)throw new ee(`batchFlatten requires a minimum rank of 2. Got rank: ${t.rank}.`);const n=[t.shape[0],Ja(t.shape,1)];return re(t,n)}(s)})}getConfig(){const e={};null!=this.dataFormat&&(e.dataFormat=this.dataFormat);const r=super.getConfig();return Object.assign(e,r),e}}return t.className="Flatten",t})()),Ue((()=>{class t extends tn{constructor(e){super(e),this.supportsMasking=!0,this.activation=sl(e.activation)}call(e,r){return he(()=>{this.invokeCallHook(e,r);const s=$t(e);return this.activation.apply(s)})}getConfig(){const e={activation:rl(this.activation)},r=super.getConfig();return Object.assign(e,r),e}}return t.className="Activation",t})()),Ue((()=>{class t extends tn{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,r){return he(()=>function bie(t,n){return he(()=>{if(2!==t.shape.length)throw new ee(`repeat() expects a rank-2 tensor, but received a rank-${t.shape.length} tensor.`);return AS(Jp(t,1),[1,n,1])})}(e=$t(e),this.n))}getConfig(){const e={n:this.n},r=super.getConfig();return Object.assign(e,r),e}}return t.className="RepeatVector",t})()),Ue((()=>{class t extends tn{constructor(e){super(e),this.targetShape=e.targetShape;for(let r=0;r<this.targetShape.length;++r)this.isUnknown(this.targetShape[r])&&(this.targetShape[r]=null)}isUnknown(e){return e<0||null==e}fixUnknownDimension(e,r){const s="Total size of new array must be unchanged.",o=r.slice();let i=1,a=null;for(let u=0;u<o.length;++u){const c=o[u];if(this.isUnknown(c)){if(null!==a)throw new ee("Can only specifiy one unknown dimension.");a=u}else i*=c}const l=Ja(e);if(null!==a){if(0===i||l%i!=0)throw new ee(s);o[a]=l/i}else if(l!==i)throw new ee(s);return o}computeOutputShape(e){let r=!1;for(let s=0;s<e.length;++s)if(this.isUnknown(e[s])){r=!0;break}return r?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,r){return he(()=>{this.invokeCallHook(e,r);const s=$t(e),o=s.shape,i=o.slice(0,1).concat(this.fixUnknownDimension(o.slice(1),this.targetShape));return re(s,i)})}getConfig(){const e={targetShape:this.targetShape},r=super.getConfig();return Object.assign(e,r),e}}return t.className="Reshape",t})()),Ue((()=>{class t extends tn{constructor(e){if(super(e),null==e.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const r=ri(1,e.dims.length+1);if(!gn(e.dims.slice().sort(),r))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new kr({ndim:this.dims.length+1})]}computeOutputShape(e){const r=(e=mn(e)).slice();return this.dims.forEach((s,o)=>{r[o+1]=e[s]}),r}call(e,r){return hn($t(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},r=super.getConfig();return Object.assign(e,r),e}}return t.className="Permute",t})()),Ue((()=>{class t extends tn{constructor(e){super(e??{}),this.supportsMasking=!0,this.maskValue=null!=e?null==e.maskValue?0:e.maskValue:0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),r={maskValue:this.maskValue};return Object.assign(r,e),r}computeMask(e,r){const s=$t(e);return w1(Wp(s,this.maskValue),-1)}call(e,r){return he(()=>{this.invokeCallHook(e,r);const s=$t(e),a=w1(Wp(s,this.maskValue),-1,!0);return Q(s,it(a,s.dtype))})}}return t.className="Masking",t})()),Ue((()=>{class t extends tn{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==e.batchInputShape&&null==e.inputShape){let r=null;null!=e.batchSize&&(r=e.batchSize),this.batchInputShape=null==e.inputLength?[r,null]:[r].concat(Mn(e.inputLength))}this.inputDim=e.inputDim,Vr(this.inputDim,"inputDim"),this.outputDim=e.outputDim,Vr(this.outputDim,"outputDim"),this.embeddingsInitializer=jn(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=qn(e.embeddingsRegularizer),this.activityRegularizer=qn(e.activityRegularizer),this.embeddingsConstraint=Nr(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,r){return he(()=>this.maskZero?(e=$t(e),Wp(e,dn(e))):null)}computeOutputShape(e){if(e=mn(e),null==this.inputLength)return[...e,this.outputDim];const r=Mn(this.inputLength);if(r.length!==e.length-1)throw new ee(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let s=0;for(let o=0;o<r.length;++o){const i=r[o],a=e[o+1];if(null!=i&&null!=a&&i!==a)throw new ee(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);null==i&&(r[s]=a),s++}}return[e[0],...r,this.outputDim]}call(e,r){return he(()=>{this.invokeCallHook(e,r);let s=$t(e);"int32"!==s.dtype&&(s=Fi(s,"int32"));const o=E$(this.embeddings.read(),re(s,[s.size]));return re(o,mn(this.computeOutputShape(s.shape)))})}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:Jn(this.embeddingsInitializer),embeddingsRegularizer:Rn(this.embeddingsRegularizer),activityRegularizer:Rn(this.activityRegularizer),embeddingsConstraint:Er(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},r=super.getConfig();return Object.assign(e,r),e}}return t.className="Embedding",t})());class uu extends tn{constructor(n){super(n||{}),this.supportsMasking=!0}mergeFunction(n){throw new Wt}computeElementwiseOpOutputShape(n,e){if(null==n||null==e)return null;if(n.length<e.length)return this.computeElementwiseOpOutputShape(e,n);if(0===e.length)return n;const r=n.slice(0,n.length-e.length);for(let s=0;s<e.length;++s){const o=n[n.length-e.length+s],i=e[s];if(null==o||null==i||o<0||i<0)r.push(null);else if(1===o)r.push(i);else if(1===i)r.push(o);else{if(o!==i)throw new ee("Operands could not be broadcast together with shapes "+JSON.stringify(n)+" "+JSON.stringify(e));r.push(o)}}return r}build(n){if(Array.isArray(n)&&!Array.isArray(n[0])&&(n=[mn(n)]),n.length<2)throw new ee(`A merge layer should be called on an Array of at least 2 inputs. Got ${n.length} input(s).`);let e=[];for(const o of n)null!=o&&null!==o[0]&&e.push(o[0]);if(e=Qa(e),e.length>1)throw new ee(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(n)}.`);let r=null==n[0]?null:n[0].slice(1);for(let o=1;o<n.length;++o){const i=null==n[o]?null:n[o].slice(1);r=this.computeElementwiseOpOutputShape(r,i)}const s=n.map(o=>o.length);this.reshapeRequired=-1!==n.indexOf(null)||1!==Qa(s).length}call(n,e){return he(()=>{if(this.reshapeRequired){const r=[],s=n.map(o=>o.rank);if(-1===s.indexOf(null)){const o=el(s);for(let i of n){const a=i.rank;for(let l=0;l<o-a;++l)i=Jp(i,1);r.push(i)}return this.mergeFunction(r)}{let o=!1;for(const l of n){const u=l.rank;if(null==u){const c=l.shape,d=c[0],h=c.slice(1).concat([d]);let p=re(l,[d].concat(Ja(c.slice(1))));p=hn(p,[1,0]),p=re(p,h),r.push(p),o=!0}else if(u>1){const c=ri(1,u).concat([0]);r.push(hn(l,c)),o=!0}else r.push(l)}let i=this.mergeFunction(r);const a=i.rank;if(o)if(null==a){const l=i.shape,c=l[l.length-1],d=[c].concat(l.slice(0,l.length-1));i=re(hn(re(i,[-1,c]),[1,0]),d)}else if(a>1){const l=[a-1].concat(ri(0,a-1));i=hn(i,l)}return i}}return this.mergeFunction(n)})}computeOutputShape(n){let e;e=null==n[0]?null:n[0].slice(1);for(let s=1;s<n.length;++s){const o=null==n[s]?null:n[s].slice(1);e=this.computeElementwiseOpOutputShape(e,o)}let r=[];for(const s of n)null!=s&&null!==s[0]&&r.push(s[0]);return r=Qa(r),e=1===r.length?r.concat(e):[null].concat(e),e}computeMask(n,e){return he(()=>{if(null==e)return null;if(!Array.isArray(e))throw new ee("`mask` should be an Array");if(!Array.isArray(n))throw new ee("`inputs` should be an Array");if(e.length!==n.length)throw new ee(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${n.length} vs ${e.length})`);if(e.every(s=>null==s))return null;let r=(e=e.map(s=>null==s?s:Gs(s,0)))[0];for(let s=1;s<e.length-1;++s)r=ha(r,e[s]);return r})}}function cf(t,n){for(;t<0;)t+=n;return t}function df(t,n,e,r,s,o=.001){let i;if(2===t.rank)i=qQ(t,n,e,r,s,o);else if(3===t.rank)i=XQ(t,n,e,r,s,o);else{if(4!==t.rank)throw new Wt(`batchNormalization is not implemented for array of rank ${t.rank} yet`);i=ZQ(t,n,e,r,s,o)}return i}function Hv(t,n,e,r,s,o){return he(()=>{let i;mr(s),_$(o),fo(r),null==e&&(e=[1,1]),null==r&&(r="valid"),null==s&&(s="channelsLast"),null==o&&(o="max"),t=rI(t,s);const a="same"===r?"same":"valid";return i="max"===o?E1(t,n,e,a):S1(t,n,e,a),"channelsFirst"===s&&(i=hn(i,[0,3,1,2])),i})}function EL(t,n,e,r,s,o){return he(()=>{let i;mr(s),_$(o),fo(r),null==e&&(e=[1,1,1]),null==r&&(r="valid"),null==s&&(s="channelsLast"),null==o&&(o="max"),t=yL(t,s);const a="same"===r?"same":"valid";return i="max"===o?BJ(t,n,e,a):WQ(t,n,e,a),"channelsFirst"===s&&(i=hn(i,[0,4,1,2,3])),i})}Ue((()=>{class t extends uu{constructor(e){super(e)}mergeFunction(e){return he(()=>{let r=e[0].clone();for(let s=1;s<e.length;++s)r=Ge(r,e[s]);return r})}}return t.className="Add",t})()),Ue((()=>{class t extends uu{constructor(e){super(e)}mergeFunction(e){return he(()=>{let r=e[0].clone();for(let s=1;s<e.length;++s)r=Q(r,e[s]);return r})}}return t.className="Multiply",t})()),Ue((()=>{class t extends uu{constructor(e){super(e)}mergeFunction(e){return he(()=>{let r=e[0].clone();for(let s=1;s<e.length;++s)r=Ge(r,e[s]);return Q(1/e.length,r)})}}return t.className="Average",t})()),Ue((()=>{class t extends uu{constructor(e){super(e)}mergeFunction(e){return he(()=>{let r=e[0];for(let s=1;s<e.length;++s)r=Ha(r,e[s]);return r})}}return t.className="Maximum",t})()),Ue((()=>{class t extends uu{constructor(e){super(e)}mergeFunction(e){return he(()=>{let r=e[0];for(let s=1;s<e.length;++s)r=Lc(r,e[s]);return r})}}return t.className="Minimum",t})()),Ue((()=>{class t extends uu{constructor(e){super(e),this.DEFAULT_AXIS=-1,null==e&&(e={}),this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!Array.isArray(e)||!Array.isArray(e[0])||1===e.length)throw new ee("A `Concatenate` layer should be called on a list of at least 2 inputs");let r=!0;for(const o of e)if(null!=o){r=!1;break}if(r)return;const s=[];for(let o=0;o<e.length;++o){const i=e[o].slice();i.splice(this.axis,1);let a=!1;for(const l of s)if(gn(l,i)){a=!0;break}a||s.push(i)}if(s.length>1)throw new ee("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return he(()=>NS(e,this.axis))}computeOutputShape(e){if(!Array.isArray(e)||!Array.isArray(e[0]))throw new ee("A `Concatenate` layer should be called on a list of inputs.");const r=e,s=r[0].slice(),o=this.axis<0?s.length+this.axis:this.axis;for(const i of r.slice(1)){if(null==s[o]||null==i[o]){s[o]=null;break}s[o]+=i[o]}return s}computeMask(e,r){if(null==r)return null;if(!Array.isArray(r))throw new ee("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new ee("`inputs` should be an array for Concatenate");if(r.length!==e.length)throw new ee(`Mismatch in the length of mask (${r.length}) and the legnth of inputs (${e.length})`);return he(()=>{let s=!0;if(r.forEach(a=>{null==a||(s=!1)}),s)return null;const o=[];for(let a=0;a<e.length;++a)o.push(null==r[a]?it(Po(e[a]),"bool"):r[a].rank<e[a].rank?Gs(r[a],-1):r[a]);const i=rs(o,this.axis);return ZP(i,-1,!1)})}getConfig(){const e={axis:this.axis},r=super.getConfig();return Object.assign(e,r),e}}return t.className="Concatenate",t})()),Ue((()=>{class t extends uu{constructor(e){super(e),this.axes=e.axes,this.normalize=null!=e.normalize&&e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){R(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const r=e[0],s=e[1];if(r.length>3||s.length>3)throw new Wt("Dot layer does not support tensors of 4D or higher rank yet.");const o=this.interpretAxes(r,s);if(r[o[0]]!==s[o[1]])throw new ee(`Dimension incompatibility: ${r[o[0]]} !== ${s[o[1]]}`)}mergeFunction(e){if(2!==e.length)throw new ee(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let o,r=e[0],s=e[1];return o=Array.isArray(this.axes)?this.axes.map((i,a)=>cf(i,e[a].shape.length)):[cf(this.axes,r.shape.length),cf(this.axes,s.shape.length)],this.normalize&&(r=Ov(r,o[0]),s=Ov(s,o[1])),function Vae(t,n,e){if(t.shape.length>3||n.shape.length>3)throw new Wt("batchDot is not implemented for tensors of 4D or higher rank yet");if(R(t.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${t.shape.length}`),R(t.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${n.shape.length}`),"number"==typeof e&&(e=[e,e]),"complex64"===t.dtype||"complex64"===n.dtype)throw new Wt("batchDot is not implemented for complex64-type Tensors yet.");const r=t.shape.length,s=n.shape.length;null==e&&(e=[r-1,s-2]);const o=e;return he(()=>{let i,a;if(r>s){i=r-s;const l=[];for(let u=0;u<i;++u)l.push(1);n=re(n,n.shape.concat(l))}else if(s>r){i=s-r;const l=[];for(let u=0;u<i;++u)l.push(1);t=re(t,t.shape.concat(l))}else i=0;if(a=2===t.shape.length&&2===n.shape.length?o[0]===o[1]?yt(Q(t,n),o[0]):yt(Q(hn(t,[1,0]),n),o[1]):yn(t,n,o[0]!==t.shape.length-1,o[1]===n.shape.length-1),i>0){let l;l=r>s?r+s-3:r-1;const u=[];for(let c=l;c<l+i;++c)u.push(c);a=jp(a,u)}return 1===a.shape.length&&(a=Gs(a,1)),a})}(r,s,o)}interpretAxes(e,r){let s;return s=Array.isArray(this.axes)?this.axes:[cf(this.axes,e.length),cf(this.axes,r.length)],s}computeOutputShape(e){R(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const r=e[0].slice(),s=e[1].slice();if(r.length>3||s.length>3)throw new Wt("Dot layer does not support tensors of 4D or higher rank yet.");const o=this.interpretAxes(r,s);r.splice(o[0],1),s.splice(o[1],1),s.splice(0,1);const i=r.concat(s);return 1===i.length&&i.push(1),i}computeMask(e,r){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},r=super.getConfig();return Object.assign(e,r),e}}return t.className="Dot",t})()),Ue((()=>{class t extends tn{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),r={stddev:this.stddev};return Object.assign(r,e),r}call(e,r){return he(()=>{this.invokeCallHook(e,r);const s=$t(e);return nf(()=>Ge(Tv(s.shape,0,this.stddev),s),()=>s,r.training||!1)})}}return t.className="GaussianNoise",t})()),Ue((()=>{class t extends tn{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),r={rate:this.rate};return Object.assign(r,e),r}call(e,r){return he(()=>{this.invokeCallHook(e,r);const s=$t(e);return this.rate>0&&this.rate<1?nf(()=>{const i=Math.sqrt(this.rate/(1-this.rate));return Q(s,Tv(s.shape,1,i))},()=>s,r.training||!1):s})}}return t.className="GaussianDropout",t})()),Ue((()=>{class t extends tn{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||$t(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),r={rate:this.rate};return Object.assign(r,e),r}call(e,r){return he(()=>{if(this.rate<1&&this.rate>0){const s=this._getNoiseShape(e);return nf(()=>{const i=$t(e),u=-1.7580993408473766;let c=eu(lv(s),this.rate);c=Fi(c,"float32");const d=((1-this.rate)*(1+this.rate*u**2))**-.5,h=-d*u*this.rate,p=Ge(Q(i,c),Q(Ge(c,-1),u));return Ge(Q(p,d),h)},()=>$t(e),r.training||!1)}return e})}}return t.className="AlphaDropout",t})()),Ue((()=>{class t extends tn{constructor(e){null==e&&(e={}),super(e),this.supportsMasking=!0,this.axis=null==e.axis?-1:e.axis,this.momentum=null==e.momentum?.99:e.momentum,this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=jn(e.betaInitializer||"zeros"),this.gammaInitializer=jn(e.gammaInitializer||"ones"),this.movingMeanInitializer=jn(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=jn(e.movingVarianceInitializer||"ones"),this.betaConstraint=Nr(e.betaConstraint),this.gammaConstraint=Nr(e.gammaConstraint),this.betaRegularizer=qn(e.betaRegularizer),this.gammaRegularizer=qn(e.gammaRegularizer)}build(e){e=mn(e);const r=this.axis>=0?this.axis:this.axis+e.length,s=e[r];if(null==s)throw new ee(`Axis ${r} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new kr({ndim:e.length,axes:{[r]:s}})];const o=[s];this.scale&&(this.gamma=this.addWeight("gamma",o,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",o,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",o,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",o,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,r){return he(()=>{const s=null!=r.training&&r.training,o=$t(e),i=o.shape,a=i.length,l=ri(0,a),u=this.axis>=0?this.axis:this.axis+a;l.splice(u,1);const c=su(1,a);c[u]=i[u];const d=l.slice();d.sort();const h=!gn(d,ri(0,a).slice(0,a-1));if(!s)return(()=>{if(h){const b=re(this.movingMean.read(),c),x=re(this.movingVariance.read(),c),w=this.center?re(this.beta.read(),c):null,k=this.scale?re(this.gamma.read(),c):null;return df(o,b,x,w,k,this.epsilon)}return df(o,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[f,g,m]=function Uae(t,n,e,r,s=.001){return gn(r.slice().sort(),ri(0,t.rank-1))?function Bae(t,n,e,r,s=.001){return he(()=>{const o=A1(t,r),i=o.mean,a=o.variance;return[df(t,i,a,e,n,s),i,a]})}(t,n,e,r,s):function zae(t,n,e,r,s=.001){return he(()=>{const o=A1(t,r),i=o.mean,a=o.variance,l=[];for(const f of ri(0,t.rank))-1!==r.indexOf(f)?l.push(1):l.push(t.shape[f]);const u=re(i,l),c=re(a,l),d=null==n?null:re(n,l),h=null==e?null:re(e,l);return[df(t,u,c,h,d,s),i,a]})}(t,n,e,r,s)}(o,this.gamma.read(),this.beta.read(),l,this.epsilon),y=(b,x,w)=>{he(()=>{const k=1-w,V=b.read(),z=Q(gt(V,x),k);b.write(gt(V,z))})};return(()=>{y(this.movingMean,g,this.momentum),y(this.movingVariance,m,this.momentum)})(),f})}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Jn(this.betaInitializer),gammaInitializer:Jn(this.gammaInitializer),movingMeanInitializer:Jn(this.movingMeanInitializer),movingVarianceInitializer:Jn(this.movingVarianceInitializer),betaRegularizer:Rn(this.betaRegularizer),gammaRegularizer:Rn(this.gammaRegularizer),betaConstraint:Er(this.betaConstraint),gammaConstraint:Er(this.gammaConstraint)},r=super.getConfig();return Object.assign(e,r),e}}return t.className="BatchNormalization",t})()),Ue((()=>{class t extends tn{constructor(e){if(null==e&&(e={}),super(e),this.axis=null==e.axis?-1:e.axis,"number"==typeof this.axis){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else{if(!Array.isArray(this.axis))throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);for(const r of this.axis)if(!Number.isInteger(r))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=jn(e.betaInitializer||"zeros"),this.gammaInitializer=jn(e.gammaInitializer||"ones"),this.betaRegularizer=qn(e.betaRegularizer),this.gammaRegularizer=qn(e.gammaRegularizer),this.supportsMasking=!0}build(e){const r=(e=mn(e)).length;"number"==typeof this.axis&&(this.axis=[this.axis]);for(let i=0;i<this.axis.length;++i)this.axis[i]<0&&(this.axis[i]+=r);for(const i of this.axis)if(i<0||i>=r)throw new Error(`Invalid axis: ${i}`);if(this.axis.length!==Qa(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const s=this.axis.map(i=>e[i]);this.gamma=this.scale?this.addWeight("gamma",s,"float32",this.gammaInitializer,this.gammaRegularizer,!0):null,this.beta=this.center?this.addWeight("beta",s,"float32",this.betaInitializer,this.betaRegularizer,!0):null,this.built=!0}call(e,r){const s=$t(e),o=s.shape,i=o.length;return he(()=>{let{mean:l,variance:u}=A1(s,this.axis,!0);const c=su(1,i);for(const m of this.axis)c[m]=o[m];const d=m=>null!=m&&m.shape.length!==i?re(m,c):m;let h=this.scale?d(this.gamma.read()):null,p=this.center?d(this.beta.read()):null;const f=[],g=[];for(let m=0;m<i;++m)-1!==this.axis.indexOf(m)?(f.push(o[m]),g.push(1)):(f.push(1),g.push(o[m]));return l=ti(l,f),u=ti(u,f),null!=h&&(h=ti(h,g)),null!=p&&(p=ti(p,g)),df(s,l,u,p,h,this.epsilon)})}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Jn(this.betaInitializer),gammaInitializer:Jn(this.gammaInitializer),betaRegularizer:Rn(this.betaRegularizer),gammaRegularizer:Rn(this.gammaRegularizer)},r=super.getConfig();return Object.assign(e,r),e}}return t.className="LayerNormalization",t})()),Ue((()=>{class t extends tn{constructor(e){if(null==e&&(e={}),super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,null==e.padding)this.padding=[[1,1],[1,1]];else if("number"==typeof e.padding)this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,2!==e.padding.length)throw new ee(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let r,s;if("number"==typeof e.padding[0])r=[e.padding[0],e.padding[0]],s=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,2!==e.padding[0].length)throw new ee(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(r=e.padding[0],2!==e.padding[1].length)throw new ee(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);s=e.padding[1]}this.padding=[r,s]}this.inputSpec=[new kr({ndim:4})]}computeOutputShape(e){let r,s;return e=mn(e),"channelsFirst"===this.dataFormat?(r=null!=e[2]&&e[2]>=0?e[2]+this.padding[0][0]+this.padding[0][1]:null,s=null!=e[3]&&e[3]>=0?e[3]+this.padding[1][0]+this.padding[1][1]:null,[e[0],e[1],r,s]):(r=null!=e[1]&&e[1]>=0?e[1]+this.padding[0][0]+this.padding[0][1]:null,s=null!=e[2]&&e[2]>=0?e[2]+this.padding[1][0]+this.padding[1][1]:null,[e[0],r,s,e[3]])}call(e,r){return he(()=>function Wae(t,n,e){return he(()=>{if(4!==t.rank)throw new ee(`temporalPadding expects input tensor to be 4-D, but received a ${t.rank}-D tensor.`);if(null==n&&(n=[[1,1],[1,1]]),2!==n.length||2!==n[0].length||2!==n[1].length)throw new ee("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==e&&(e="channelsLast"),"channelsLast"!==e&&"channelsFirst"!==e)throw new ee(`Unknown data format: ${e}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let r;return r="channelsFirst"===e?[[0,0],[0,0],n[0],n[1]]:[[0,0],n[0],n[1],[0,0]],R1(t,r)})}($t(e),this.padding,this.dataFormat))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},r=super.getConfig();return Object.assign(e,r),e}}return t.className="ZeroPadding2D",t})());class NL extends tn{constructor(n){if(null==n.poolSize&&(n.poolSize=2),super(n),"number"==typeof n.poolSize)this.poolSize=[n.poolSize];else{if(!Array.isArray(n.poolSize)||1!==n.poolSize.length||"number"!=typeof n.poolSize[0])throw new ee(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(n.poolSize)}`);this.poolSize=n.poolSize}if(Vr(this.poolSize,"poolSize"),null==n.strides)this.strides=this.poolSize;else if("number"==typeof n.strides)this.strides=[n.strides];else{if(!Array.isArray(n.strides)||1!==n.strides.length||"number"!=typeof n.strides[0])throw new ee(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(n.strides)}`);this.strides=n.strides}Vr(this.strides,"strides"),this.padding=null==n.padding?"valid":n.padding,fo(this.padding),this.inputSpec=[new kr({ndim:3})]}computeOutputShape(n){const e=li((n=mn(n))[1],this.poolSize[0],this.padding,this.strides[0]);return[n[0],e,n[2]]}call(n,e){return he(()=>{this.invokeCallHook(n,e),n=Jp($t(n),2);const r=this.poolingFunction($t(n),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return jp(r,[2])})}getConfig(){const n={poolSize:this.poolSize,padding:this.padding,strides:this.strides},e=super.getConfig();return Object.assign(n,e),n}}Ue((()=>{class t extends NL{constructor(e){super(e)}poolingFunction(e,r,s,o,i){return mr(i),fo(o),Hv(e,r,s,o,i,"max")}}return t.className="MaxPooling1D",t})()),Ue((()=>{class t extends NL{constructor(e){super(e)}poolingFunction(e,r,s,o,i){return mr(i),fo(o),Hv(e,r,s,o,i,"avg")}}return t.className="AveragePooling1D",t})());class AL extends tn{constructor(n){if(null==n.poolSize&&(n.poolSize=[2,2]),super(n),this.poolSize=Array.isArray(n.poolSize)?n.poolSize:[n.poolSize,n.poolSize],null==n.strides)this.strides=this.poolSize;else if(Array.isArray(n.strides)){if(2!==n.strides.length)throw new ee(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${n.strides.length}.`);this.strides=n.strides}else this.strides=[n.strides,n.strides];Vr(this.poolSize,"poolSize"),Vr(this.strides,"strides"),this.padding=null==n.padding?"valid":n.padding,this.dataFormat=null==n.dataFormat?"channelsLast":n.dataFormat,mr(this.dataFormat),fo(this.padding),this.inputSpec=[new kr({ndim:4})]}computeOutputShape(n){n=mn(n);let e="channelsFirst"===this.dataFormat?n[2]:n[1],r="channelsFirst"===this.dataFormat?n[3]:n[2];return e=li(e,this.poolSize[0],this.padding,this.strides[0]),r=li(r,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[n[0],n[1],e,r]:[n[0],e,r,n[3]]}call(n,e){return he(()=>(this.invokeCallHook(n,e),this.poolingFunction($t(n),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const n={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(n,e),n}}Ue((()=>{class t extends AL{constructor(e){super(e)}poolingFunction(e,r,s,o,i){return mr(i),fo(o),Hv(e,r,s,o,i,"max")}}return t.className="MaxPooling2D",t})()),Ue((()=>{class t extends AL{constructor(e){super(e)}poolingFunction(e,r,s,o,i){return mr(i),fo(o),Hv(e,r,s,o,i,"avg")}}return t.className="AveragePooling2D",t})());class RL extends tn{constructor(n){if(null==n.poolSize&&(n.poolSize=[2,2,2]),super(n),this.poolSize=Array.isArray(n.poolSize)?n.poolSize:[n.poolSize,n.poolSize,n.poolSize],null==n.strides)this.strides=this.poolSize;else if(Array.isArray(n.strides)){if(3!==n.strides.length)throw new ee(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${n.strides.length}.`);this.strides=n.strides}else this.strides=[n.strides,n.strides,n.strides];Vr(this.poolSize,"poolSize"),Vr(this.strides,"strides"),this.padding=null==n.padding?"valid":n.padding,this.dataFormat=null==n.dataFormat?"channelsLast":n.dataFormat,mr(this.dataFormat),fo(this.padding),this.inputSpec=[new kr({ndim:5})]}computeOutputShape(n){n=mn(n);let e="channelsFirst"===this.dataFormat?n[2]:n[1],r="channelsFirst"===this.dataFormat?n[3]:n[2],s="channelsFirst"===this.dataFormat?n[4]:n[3];return e=li(e,this.poolSize[0],this.padding,this.strides[0]),r=li(r,this.poolSize[1],this.padding,this.strides[1]),s=li(s,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[n[0],n[1],e,r,s]:[n[0],e,r,s,n[4]]}call(n,e){return he(()=>(this.invokeCallHook(n,e),this.poolingFunction($t(n),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const n={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(n,e),n}}Ue((()=>{class t extends RL{constructor(e){super(e)}poolingFunction(e,r,s,o,i){return mr(i),fo(o),EL(e,r,s,o,i,"max")}}return t.className="MaxPooling3D",t})()),Ue((()=>{class t extends RL{constructor(e){super(e)}poolingFunction(e,r,s,o,i){return mr(i),fo(o),EL(e,r,s,o,i,"avg")}}return t.className="AveragePooling3D",t})());class FL extends tn{constructor(n){super(n),this.inputSpec=[new kr({ndim:3})]}computeOutputShape(n){return[n[0],n[2]]}call(n,e){throw new Wt}}Ue((()=>{class t extends FL{constructor(e){super(e||{})}call(e,r){return he(()=>{const s=$t(e);return hr(s,1)})}}return t.className="GlobalAveragePooling1D",t})()),Ue((()=>{class t extends FL{constructor(e){super(e||{})}call(e,r){return he(()=>{const s=$t(e);return ni(s,1)})}}return t.className="GlobalMaxPooling1D",t})());class OL extends tn{constructor(n){super(n),this.dataFormat=null==n.dataFormat?"channelsLast":n.dataFormat,mr(this.dataFormat),this.inputSpec=[new kr({ndim:4})]}computeOutputShape(n){return"channelsLast"===this.dataFormat?[n[0],n[3]]:[n[0],n[1]]}call(n,e){throw new Wt}getConfig(){const n={dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(n,e),n}}Ue((()=>{class t extends OL{call(e,r){return he(()=>{const s=$t(e);return hr(s,"channelsLast"===this.dataFormat?[1,2]:[2,3])})}}return t.className="GlobalAveragePooling2D",t})()),Ue((()=>{class t extends OL{call(e,r){return he(()=>{const s=$t(e);return ni(s,"channelsLast"===this.dataFormat?[1,2]:[2,3])})}}return t.className="GlobalMaxPooling2D",t})());class PL extends tn{constructor(n){super(n),this.layer=n.layer}build(n){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(n){null!=this.layer&&(this.layer.trainable=n)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(n){this.layer.setWeights(n)}getConfig(){const n={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},e=super.getConfig();return Object.assign(n,e),n}setFastWeightInitDuringBuild(n){super.setFastWeightInitDuringBuild(n),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(n)}static fromConfig(n,e,r={}){const o=$i(e.layer,r);delete e.layer;const i={layer:o};return Object.assign(i,e),new n(i)}}Ue((()=>{class t extends PL{constructor(e){super(e),this.supportsMasking=!0}build(e){if((e=mn(e)).length<3)throw new ee(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const r=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(r),this.layer.built=!0),super.build(e)}computeOutputShape(e){const r=[(e=mn(e))[0]].concat(e.slice(2)),s=this.layer.computeOutputShape(r);return[s[0],e[1]].concat(s.slice(1))}call(e,r){return he(()=>CL((a,l)=>[$t(this.layer.call(a,r)),[]],e=$t(e),[],!1,null,null,!1,!0)[1])}}return t.className="TimeDistributed",t})()),Ue((()=>{class t extends PL{constructor(e){super(e);const r=e.layer.getConfig(),s={};s.className=e.layer.getClassName(),s.config=r,this.forwardLayer=$i(s),r.goBackwards=!0!==r.goBackwards;const o={};if(o.className=e.layer.getClassName(),o.config=r,this.backwardLayer=$i(o),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===e.mergeMode?"concat":e.mergeMode,function Gae(t){iu(hie,"BidirectionalMergeMode",t)}(this.mergeMode),e.weights)throw new Wt("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,null!=this.forwardLayer&&(this.forwardLayer.trainable=e),null!=this.backwardLayer&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const s=Math.floor(e.length/2);this.forwardLayer.setWeights(e.slice(0,s)),this.backwardLayer.setWeights(e.slice(s))}computeOutputShape(e){let s,o,i,r=this.forwardLayer.computeOutputShape(e);return Array.isArray(r)&&Array.isArray(r[0])||(r=[r]),this.returnState&&(i=r.slice(1)),s=r[0],"concat"===this.mergeMode?(s[s.length-1]*=2,o=[s]):o=null==this.mergeMode?[s,s.slice()]:[s],this.returnState?null==this.mergeMode?o.concat(i).concat(i.slice()):[s].concat(i).concat(i.slice()):Os(o)}apply(e,r){let s=null==r?null:r.initialState,o=null==r?null:r.constants;null==r&&(r={});const i=_L(e,s,o,this.numConstants);if(e=i.inputs,s=i.initialState,o=i.constants,Array.isArray(e)&&(s=e.slice(1),e=e[0]),(null==s||0===s.length)&&null==o)return super.apply(e,r);const a=[],l=[];if(null!=s){const c=s.length;if(c%2>0)throw new ee("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");r.initialState=s,a.push(...s);const d=s.map(h=>new kr({shape:h.shape}));this.forwardLayer.stateSpec=d.slice(0,c/2),this.backwardLayer.stateSpec=d.slice(c/2),l.push(...d)}if(null!=o)throw new Wt("Support for constants in Bidirectional layers is not implemented yet.");const u=a[0]instanceof Mi;for(const c of a)if(c instanceof Mi!==u)throw new ee("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(u){const c=[e].concat(a),d=this.inputSpec.concat(l),h=this.inputSpec;this.inputSpec=d;const p=super.apply(c,r);return this.inputSpec=h,p}return super.apply(e,r)}call(e,r){return he(()=>{const s=r.initialState;let o,i,a,l;if(null==s)o=this.forwardLayer.call(e,r),i=this.backwardLayer.call(e,r);else{const u=s.slice(0,s.length/2),c=s.slice(s.length/2);o=this.forwardLayer.call(e,Object.assign(r,{initialState:u})),i=this.backwardLayer.call(e,Object.assign(r,{initialState:c}))}return this.returnState&&(Array.isArray(o)&&(a=o.slice(1).concat(i.slice(1))),o=o[0],i=i[0]),this.returnSequences&&(i=tu(i,1)),"concat"===this.mergeMode?l=NS([o,i]):"sum"===this.mergeMode?l=Ge(o,i):"ave"===this.mergeMode?l=Q(.5,Ge(o,i)):"mul"===this.mergeMode?l=Q(o,i):null==this.mergeMode&&(l=[o,i]),this.returnState?null==this.mergeMode?l.concat(a):[l].concat(a):l})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){au(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),au(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,r){let s;if(Array.isArray(r)&&(r=r[0]),s=this.returnSequences?null==this.mergeMode?[r,r]:r:null==this.mergeMode?[null,null]:null,this.returnState){const i=this.forwardLayer.states.map(a=>null);return Array.isArray(s)?s.concat(i).concat(i):[s].concat(i).concat(i)}return s}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(e),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},r=super.getConfig();return Object.assign(e,r),e}static fromConfig(e,r){const s=$i(r.layer);if(delete r.layer,null!=r.numConstants)throw new Wt("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const o=r;return o.layer=s,new e(o)}}return t.className="Bidirectional",t})()),Ue((()=>{class t extends tn{constructor(e){super(e),this.scale=e.scale,this.offset=e.offset?e.offset:0}getConfig(){const e={scale:this.scale,offset:this.offset},r=super.getConfig();return Object.assign(e,r),e}call(e,r){return he(()=>("float32"!==(e=$t(e)).dtype&&(e=Fi(e,"float32")),Ge(Q(e,this.scale),this.offset)))}}return t.className="Rescaling",t})());const{resizeBilinear:jae,cropAndResize:qae}=Za;Ue((()=>{class t extends tn{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,r,s,o,i,a,l,u){return he(()=>{let c,d=!1;const m=[r/a,s/l,(o+r)/a,(i+s)/l],y=[];3===e.rank?(d=!0,c=Ya([e])):c=e;for(let k=0;k<c.shape[0];k++)y.push(m);const v=Mp(y,[y.length,4]),b=Gp(0,y.length,1,"int32"),w=qae(c,v,b,[o,i],"nearest");return Fi(d?$t(nu(w)):w,u)})}upsize(e,r,s,o){return he(()=>Fi(jae(e,[r,s]),o))}call(e,r){return he(()=>{const s=$t(e),o=s.dtype,i=s.shape,a=i[i.length-3],l=i[i.length-2];let u=0;a!==this.height&&(u=Math.floor((a-this.height)/2));let c=0;return l!==this.width&&(c=Math.floor((l-this.width)/2),0===c&&(c=1)),u>=0&&c>=0?this.centerCrop(s,u,c,this.height,this.width,a,l,o):this.upsize(e,this.height,this.width,o)})}getConfig(){const e={height:this.height,width:this.width},r=super.getConfig();return Object.assign(e,r),e}computeOutputShape(e){const s=(e=mn(e)).length-2;return e[e.length-3]=this.height,e[s]=this.width,e}}return t.className="CenterCrop",t})()),Ue((()=>{class t extends tn{constructor(e){super(e),this.numTokens=e.numTokens,this.outputMode=e.outputMode?e.outputMode:"multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},r=super.getConfig();return Object.assign(e,r),e}computeOutputShape(e){return null==(e=mn(e))?[this.numTokens]:"oneHot"===this.outputMode&&1!==e[e.length-1]?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,r){return he(()=>{let s;if("int32"!==(e=$t(e)).dtype&&(e=Fi(e,"int32")),typeof r.countWeights<"u"){if("count"!==this.outputMode)throw new ee(`countWeights is not used when outputMode !== count.\n              Received countWeights=${r.countWeights}`);s=$t(r.countWeights)}const o=ni(e),i=av(e),a=co(this.numTokens,o).bufferSync().get(0),l=eu(i,0).bufferSync().get(0);if(!a||!l)throw new ee(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return function Kae(t,n,e,r){let s=$t(t);if("int32"!==s.dtype&&(s=Fi(s,"int32")),"int"===n)return s;const o=s.shape;if(0===s.rank&&(s=Gs(s,-1)),"oneHot"===n&&1!==s.shape[s.shape.length-1]&&(s=Gs(s,-1)),s.rank>2)throw new ee(`When outputMode is not int, maximum output rank is 2 Received outputMode ${n} and input shape ${o} which would result in output rank ${s.rank}.`);const i=["multiHot","oneHot"].includes(n);let l;if(l=tM(s,typeof r<"u"&&"count"===n?r:[],e,i),"tfIdf"!==n)return l;if(r)return Q(l,r);throw new ee("When outputMode is 'tfIdf', weights must be provided.")}(e,this.outputMode,this.numTokens,s)})}}return t.className="CategoryEncoding",t})());const ML=new Set(["bilinear","nearest"]);var zL;Ue((()=>{class t extends tn{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation){if(!ML.has(e.interpolation))throw new ee(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);this.interpolation=e.interpolation}else this.interpolation="bilinear";this.cropToAspectRatio=Boolean(e.cropToAspectRatio)}computeOutputShape(e){return e=mn(e),[this.height,this.width,e[2]]}getConfig(){const e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},r=super.getConfig();return Object.assign(e,r),e}call(e,r){return he(()=>{const s=[this.height,this.width];if("bilinear"===this.interpolation)return Za.resizeBilinear(e,s,!this.cropToAspectRatio);if("nearest"===this.interpolation)return Za.resizeNearestNeighbor(e,s,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...ML]} are supported`)})}}return t.className="Resizing",t})()),pe().registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,t=>{t&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")}),function(t){let n;var e;(e=n=t.CheckpointFormatVersion||(t.CheckpointFormatVersion={}))[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"}(zL||(zL={}));class Kv extends Error{constructor(n){super(`NodesExecutionOrderError: ${n}`)}}function mt(t,n){Array.isArray(t)||(t=[t]),t.forEach(e=>{null!=e&&R("complex64"!==e.dtype,()=>`${n} does not support complex64 tensors in the CPU backend.`)})}Symbol("out"),Symbol("field"),Symbol("quote"),Symbol("quoteafterquote"),Symbol("quoteinquote");const $le=e$;let Lle=(()=>{class t extends F_{nextDataId(){return t.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new CO(this,ki())}write(e,r,s){this.firstUse&&(this.firstUse=!1,pe().get("IS_NODE")&&lo("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));const o={id:this.nextDataId()};return this.data.set(o,{values:e,dtype:s,refCount:1}),o}makeTensorInfo(e,r,s){let o;if("string"===r&&null!=s&&s.length>0&&Oh(s[0])){const i=s.map(a=>za(a));o=this.write(i,e,r)}else o=this.write(s,e,r);return{dataId:o,shape:e,dtype:r}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){this.data.get(e).refCount++}decRef(e){this.data.has(e)&&this.data.get(e).refCount--}move(e,r,s,o,i){this.data.set(e,{values:r,dtype:o,refCount:i})}numDataIds(){return this.data.numDataIds()}read(e){var r=this;return $e(function*(){return r.readSync(e)})()}readSync(e){const{dtype:r,complexTensorInfos:s}=this.data.get(e);return"complex64"===r?ma(this.readSync(s.real.dataId),this.readSync(s.imag.dataId)):function LY(t,n){if(Array.isArray(t))return t;if("float32"===n)return t instanceof Float32Array?t:new Float32Array(t);if("int32"===n)return t instanceof Int32Array?t:new Int32Array(t);if("bool"===n||"string"===n)return Uint8Array.from(new Int32Array(t));throw new Error(`Unknown dtype ${n}`)}(this.data.get(e).values,r)}bufferSync(e){const r=this.readSync(e.dataId);if("string"===e.dtype)try{const s=r.map(o=>Ua(o));return en(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return en(e.shape,e.dtype,r)}makeOutput(e,r,s){return ki().makeTensorFromTensorInfo(this.makeTensorInfo(r,s,e),this)}disposeData(e,r=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!r&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:s}=this.data.get(e);null!=s&&(this.disposeData(s.real.dataId,!0),this.disposeData(s.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}time(e){return $e(function*(){const r=Rs();return e(),{kernelMs:Rs()-r}})()}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){mt([e],"where");const r=this.readSync(e.dataId);return $le(e.shape,r)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}return t.nextDataId=0,t})();function Vi(t){return(n,e,r)=>{const s=cr(e,n.length);for(let o=0;o<n.length;++o)s[o]=t(n[o],r);return s}}function Cn(t,n,e){return il(t,Vi(n),e)}function il(t,n,e){return({inputs:r,attrs:s,backend:o})=>{const{x:i}=r;mt(i,t);const a=o,l=a.data.get(i.dataId).values;let u;if("string"===i.dtype){if(!Array.isArray(l))throw new Error("String tensor's value was not an instance of Array");u=ga(l)}else u=l;const c=e||i.dtype,d=n(u,c,s);return a.makeTensorInfo(i.shape,c,d)}}IP("cpu",()=>new Lle,1);const bV=Cn(Kh,t=>t>=0?t:Math.exp(t)-1),Ble={kernelName:Kh,backendName:"cpu",kernelFunc:bV};function Bi(t){const{inputs:n,backend:e}=t,{x:r}=n;return e.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const zle={kernelName:tp,backendName:"cpu",kernelFunc:Bi};function xV(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{alpha:o}=r;mt([s],"leakyRelu");const i=_e(s.shape),a=e.data.get(s.dataId).values,l=ts("float32",i);for(let u=0;u<a.length;u++)l[u]=a[u]<0?o*a[u]:a[u];return e.makeTensorInfo(s.shape,"float32",l)}const Ule={kernelName:oy,backendName:"cpu",kernelFunc:xV};function wr(t){return(n,e,r,s,o)=>{const i=Vt(n,e),a=i.length,l=xt(i),c=ts(o,_e(i)),d=n.length,h=e.length,p=xt(n),f=xt(e),g=Mc(n,i),m=Mc(e,i);if(g.length+m.length===0)for(let y=0;y<c.length;++y)c[y]=t(r[y%r.length],s[y%s.length]);else for(let y=0;y<c.length;++y){const v=Ic(y,a,l),b=v.slice(-d);g.forEach(V=>b[V]=0);const x=Di(b,d,p),w=v.slice(-h);m.forEach(V=>w[V]=0);const k=Di(w,h,f);c[y]=t(r[x],s[k])}return[c,i]}}const Wle=wr((t,n)=>t<0?n*t:t);function wV(t){const{inputs:n,backend:e}=t,{x:r,alpha:s}=n;mt([r,s],"prelu");const o=e.data.get(r.dataId).values,i=e.data.get(s.dataId).values,[a,l]=Wle(r.shape,s.shape,o,i,"float32");return e.makeTensorInfo(l,"float32",a)}const Gle={kernelName:Sy,backendName:"cpu",kernelFunc:wV},_V=Cn(pp,t=>Math.max(0,t)),Hle={kernelName:pp,backendName:"cpu",kernelFunc:_V},CV=Cn(fp,t=>Math.min(Math.max(0,t),6)),jle={kernelName:fp,backendName:"cpu",kernelFunc:CV},qle=Vi(t=>1/(1+Math.exp(-t))),SV=Cn(wp,t=>1/(1+Math.exp(-t))),Kle={kernelName:wp,backendName:"cpu",kernelFunc:SV};function Qv(t,n,e,r,s){if("linear"===e)return Bi({inputs:{x:n},backend:t});if("relu"===e)return _V({inputs:{x:n},backend:t});if("elu"===e)return bV({inputs:{x:n},backend:t});if("relu6"===e)return CV({inputs:{x:n},backend:t});if("prelu"===e)return wV({inputs:{x:n,alpha:r},backend:t});if("leakyrelu"===e)return xV({inputs:{x:n},backend:t,attrs:{alpha:s}});if("sigmoid"===e)return SV({inputs:{x:n},backend:t});throw new Error(`Activation ${e} has not been implemented for the CPU backend.`)}function js(t){const{inputs:n,backend:e}=t,{real:r,imag:s}=n,o=e.data.get(r.dataId).values,i=e.data.get(s.dataId).values,a=e.makeTensorInfo(r.shape,"complex64");return e.data.get(a.dataId).complexTensorInfos={real:e.makeTensorInfo(r.shape,"float32",o),imag:e.makeTensorInfo(s.shape,"float32",i)},a}const Xle={kernelName:Y_,backendName:"cpu",kernelFunc:js};function Jv(t,n,e="float32"){if("complex64"===e)return js({inputs:{real:Jv(t,n,"float32"),imag:Jv(t,n,"float32")},backend:t});const r=ns(_e(n),e);return t.makeTensorInfo(n,e,r)}function du(t){const{inputs:n,backend:e}=t,{input:r}=n,s=e.data.get(r.dataId).complexTensorInfos.real,o=e.data.get(s.dataId).values;return e.makeTensorInfo(s.shape,s.dtype,o)}const Yle={kernelName:wC,backendName:"cpu",kernelFunc:du};function IV(t,n,e,r){if("int32"===r)return[n,"int32",Int32Array.from(t)];if("bool"===r){const s=Hl([0],e),[o,i]=wr((a,l)=>a!==l?1:0)(n,[],t,s,"bool");return[i,"bool",o]}throw new Error(`Error in Cast: failed to cast ${e} to ${r}`)}function al(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{dtype:o}=r;if("complex64"===o){if("complex64"===s.dtype)return Bi({inputs:{x:s},backend:e});const c=Jv(e,s.shape,s.dtype),d=al({inputs:{x:s},backend:e,attrs:{dtype:"float32"}}),h=js({inputs:{real:d,imag:c},backend:e});return e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(d),h}if("complex64"===s.dtype){const c=du({inputs:{input:s},backend:e}),d=al({inputs:{x:c},backend:e,attrs:{dtype:o}});return e.disposeIntermediateTensorInfo(c),d}if(!TO(s.dtype,o)){const c=Bi({inputs:{x:s},backend:e});return{dataId:c.dataId,shape:c.shape,dtype:o}}const i=e.data.get(s.dataId).values,[a,l,u]=IV(i,s.shape,s.dtype,o);return e.makeTensorInfo(a,l,u)}const Zle={kernelName:Uh,backendName:"cpu",kernelFunc:al};function Br(t,n,e,r){return null==e?({inputs:s,backend:o})=>{const{a:i,b:a}=s,l=o;mt([i,a],t);const u=l.data.get(i.dataId).values,c=l.data.get(a.dataId).values,d="string"===i.dtype?ga(u):u,h="string"===i.dtype?ga(c):c,p=r||i.dtype,[f,g]=n(i.shape,a.shape,d,h,p);return l.makeTensorInfo(g,p,f)}:({inputs:s,backend:o})=>{const{a:i,b:a}=s,l=o;if("complex64"===i.dtype||"complex64"===a.dtype){const u=al({inputs:{x:i},backend:l,attrs:{dtype:"complex64"}}),c=l.data.get(u.dataId),h=c.complexTensorInfos.imag,p=l.data.get(c.complexTensorInfos.real.dataId).values,f=l.data.get(h.dataId).values,g=al({inputs:{x:a},backend:l,attrs:{dtype:"complex64"}}),m=l.data.get(g.dataId),v=m.complexTensorInfos.imag,b=l.data.get(m.complexTensorInfos.real.dataId).values,x=l.data.get(v.dataId).values,[w,k,V]=e(i.shape,a.shape,p,f,b,x),z=l.makeTensorInfo(V,"float32",w),K=l.makeTensorInfo(V,"float32",k),Y=js({inputs:{real:z,imag:K},backend:l});return l.disposeIntermediateTensorInfo(u),l.disposeIntermediateTensorInfo(g),l.disposeIntermediateTensorInfo(z),l.disposeIntermediateTensorInfo(K),Y}{const u=l.data.get(i.dataId).values,c=l.data.get(a.dataId).values,d=r||i.dtype,[h,p]=n(i.shape,a.shape,u,c,d);return l.makeTensorInfo(p,d,h)}}}function _I(t){return(n,e,r,s,o,i)=>{const a=Vt(n,e),l=_e(a),u=a.length,c=xt(a),d=ts("float32",l),h=ts("float32",l),p=Mc(n,a),f=Mc(e,a),g=ma(r,s),m=ma(o,i),y=n.length,v=xt(n),b=e.length,x=xt(e);if(p.length+f.length===0)for(let w=0;w<d.length;w++){const k=w%g.length,V=w%m.length,z=t(g[2*k],g[2*k+1],m[2*V],m[2*V+1]);d[w]=z.real,h[w]=z.imag}else for(let w=0;w<d.length;w++){const k=Ic(w,u,c),V=k.slice(-y);p.forEach(fe=>V[fe]=0);const z=Di(V,y,v),K=k.slice(-b);f.forEach(fe=>K[fe]=0);const Y=Di(K,b,x),se=t(g[2*z],g[2*z+1],m[2*Y],m[2*Y+1]);d[w]=se.real,h[w]=se.imag}return[d,h,a]}}const DV=wr((t,n)=>t+n),Qle=_I((t,n,e,r)=>({real:t+e,imag:n+r})),Xc=Br(Dc,DV,Qle),Jle={kernelName:Dc,backendName:"cpu",kernelFunc:Xc};function $n(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{shape:o}=r,i=_e(s.shape),a=DO(o,i),l=_e(a);R(i===l,()=>`The new shape (${a}) has ${l} elements and the old shape (${s.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`),e.incRef(s.dataId);const u=e.data.get(s.dataId);if(null!=u.complexTensorInfos){const d=u.complexTensorInfos.imag;u.complexTensorInfos.real.shape=a,d.shape=a}return{dataId:s.dataId,shape:a,dtype:s.dtype}}const eue={kernelName:Dy,backendName:"cpu",kernelFunc:$n};function TV(t){const{inputs:n,backend:e,attrs:r}=t,{a:s,b:o}=n,{transposeA:i,transposeB:a}=r;mt([s,o],"matMul");const l=s.shape.length,u=o.shape.length,c=i?s.shape[l-2]:s.shape[l-1],d=a?o.shape[u-1]:o.shape[u-2],h=i?s.shape[l-1]:s.shape[l-2],p=a?o.shape[u-2]:o.shape[u-1],f=s.shape.slice(0,-2),g=o.shape.slice(0,-2),m=_e(f),y=_e(g),b=Vt(s.shape.slice(0,-2),o.shape.slice(0,-2)).concat([h,p]);R(c===d,()=>`Error in matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${s.shape} and ${o.shape} and transposeA=${i} and transposeB=${a} must match.`);const w=a?[y,p,d]:[y,d,p],k=$n({inputs:{x:s},backend:e,attrs:{shape:i?[m,c,h]:[m,h,c]}}),V=$n({inputs:{x:o},backend:e,attrs:{shape:w}}),z=i?k.shape[1]:k.shape[2],K=i?k.shape[2]:k.shape[1],Y=a?V.shape[1]:V.shape[2],se=Math.max(m,y),fe=e.data.get(k.dataId).values,ve=e.data.get(V.dataId).values,be=xt(k.shape),xe=xt(V.shape),[De,Ne,we]=i?[be[0],1,be[1]]:[be[0],be[1],1],[Ae,ze,He]=a?[1,xe[1],xe[0]]:[xe[1],1,xe[0]],Ye=K*Y,je=en([se,K,Y],k.dtype),st=je.values,Je=e.blockSize;for(let ct=0;ct<se;ct++){const _t=ct%m,Rt=ct%y;for(let Tt=0;Tt<K;Tt+=Je){const Ht=Math.min(Tt+Je,K);for(let Yt=0;Yt<Y;Yt+=Je){const Sn=Math.min(Yt+Je,Y);for(let Ln=0;Ln<z;Ln+=Je){const sr=Math.min(Ln+Je,z);for(let Vn=Tt;Vn<Ht;Vn++)for(let En=Yt;En<Sn;En++){let er=0;for(let Kn=Ln;Kn<sr;Kn++)er+=fe[_t*De+Vn*Ne+Kn*we]*ve[Kn*Ae+En*ze+Rt*He];st[ct*Ye+(Vn*Y+En)]+=er}}}}}return e.disposeIntermediateTensorInfo(k),e.disposeIntermediateTensorInfo(V),e.makeTensorInfo(b,je.dtype,je.values)}const tue={kernelName:Gg,backendName:"cpu",kernelFunc:TV},rue={kernelName:By,backendName:"cpu",kernelFunc:function nue(t){const{inputs:n,backend:e,attrs:r}=t,{a:s,b:o,bias:i,preluActivationWeights:a}=n,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:d}=r;let h,p,f;const g=[];h=TV({inputs:{a:s,b:o},attrs:{transposeA:l,transposeB:u},backend:e}),i&&(p=Xc({inputs:{a:h,b:i},backend:e}),g.push(h),h=p),c&&(f=Qv(e,h,c,a,d),g.push(h),h=f);for(const y of g)e.disposeIntermediateTensorInfo(y);return h}};function kV(t){const n=new Float32Array(t.length);for(let e=0;e<t.length;++e)n[e]=Math.abs(t[e]);return n}const sue={kernelName:Vg,backendName:"cpu",kernelFunc:t=>{const{x:n}=t.inputs,e=t.backend;mt(n,"abs");let r=new Float32Array(_e(n.shape));return r=kV(e.data.get(n.dataId).values),e.makeOutput(r,n.shape,n.dtype)}},oue=Cn(Ph,t=>Math.acos(t)),iue={kernelName:Ph,backendName:"cpu",kernelFunc:oue},aue=Cn(Mh,t=>Math.acosh(t)),lue={kernelName:Mh,backendName:"cpu",kernelFunc:aue},cue={kernelName:G_,backendName:"cpu",kernelFunc:function uue(t){const{inputs:n,backend:e}=t,r=n;mt(n,"addN");const s=r.map(a=>e.data.get(a.dataId).values),o=en(r[0].shape,r[0].dtype),i=o.values;for(let a=0;a<r.length;a++){const l=s[a];for(let u=0;u<i.length;u++)i[u]+=l[u]}return e.makeTensorInfo(o.shape,o.dtype,o.values)}};function CI(t,n,e,r,s){const o=n.length,i=_e(n),a=xt(n),l=xt(s),u=ts(e,_e(s));for(let c=0;c<i;++c){const d=Ic(c,o,a),h=new Array(d.length);for(let f=0;f<h.length;f++)h[f]=d[r[f]];u[Di(h,o,l)]=t[c]}return u}function Ms(t){const{inputs:n,attrs:e,backend:r}=t,{x:s}=n,{perm:o}=e;mt(s,"transpose");const a=new Array(s.shape.length);for(let d=0;d<a.length;d++)a[d]=s.shape[o[d]];const u=CI(r.data.get(s.dataId).values,s.shape,s.dtype,o,a);return{dataId:r.write(u,a,s.dtype),shape:a,dtype:s.dtype}}const due={kernelName:Tc,backendName:"cpu",kernelFunc:Ms},pue={kernelName:"All",backendName:"cpu",kernelFunc:function hue(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o,keepDims:i}=r;mt(s,"all");const a=Jt(o,s.shape);let l=a;const u=Qn(l,s.shape.length);let c=s;null!=u&&(c=Ms({inputs:{x:s},backend:e,attrs:{perm:u}}),l=fr(l.length,s.shape.length)),Hr("all",l,c.shape.length);const[d,h]=$r(c.shape,l),p=_e(h),f=ns(_e(d),c.dtype),g=e.data.get(c.dataId).values;for(let y=0;y<f.length;++y){const v=y*p;let b=g[v];for(let x=0;x<p;++x)b=b&&g[v+x];f[y]=b}null!=u&&e.disposeIntermediateTensorInfo(c);const m=e.makeTensorInfo(d,c.dtype,f);if(i){const v=$n({inputs:{x:m},backend:e,attrs:{shape:pr(d,a)}});return e.disposeIntermediateTensorInfo(m),v}return m}},mue={kernelName:"Any",backendName:"cpu",kernelFunc:function fue(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o,keepDims:i}=r;mt(s,"any");const a=Jt(o,s.shape);let l=a;const u=Qn(l,s.shape.length);let c=s;null!=u&&(c=Ms({inputs:{x:s},backend:e,attrs:{perm:u}}),l=fr(l.length,s.shape.length)),Hr("any",l,c.shape.length);const[d,h]=$r(c.shape,l),p=_e(h),f=ns(_e(d),c.dtype),g=e.data.get(c.dataId).values;for(let y=0;y<f.length;++y){const v=y*p;let b=g[v];for(let x=0;x<p;++x)b=b||g[v+x];f[y]=b}null!=u&&e.disposeIntermediateTensorInfo(c);const m=e.makeTensorInfo(d,c.dtype,f);if(i){const v=$n({inputs:{x:m},backend:e,attrs:{shape:pr(d,a)}});return e.disposeIntermediateTensorInfo(m),v}return m}},yue={kernelName:Bg,backendName:"cpu",kernelFunc:function gue(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o}=r;mt(s,"argMax");let i=Jt(o,s.shape);const a=Qn(i,s.shape.length);let l=s;const u=[];null!=a&&(l=Ms({inputs:{x:s},backend:e,attrs:{perm:a}}),u.push(l),i=fr(i.length,l.shape.length)),i=[i[0]],Hr("argMax",i,l.shape.length);const[c,d]=$r(l.shape,i),p=ns(_e(c),"int32"),f=_e(d),g=e.data.get(l.dataId).values;for(let m=0;m<p.length;++m){const y=m*f;let v=g[y],b=0;for(let x=0;x<f;++x){const w=g[y+x];w>v&&(v=w,b=x)}p[m]=b}return u.forEach(m=>e.disposeIntermediateTensorInfo(m)),e.makeTensorInfo(c,"int32",p)}},bue={kernelName:zg,backendName:"cpu",kernelFunc:function vue(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o}=r;mt(s,"argMin");let i=Jt(o,s.shape);const a=Qn(i,s.shape.length);let l=s;const u=[];null!=a&&(l=Ms({inputs:{x:s},backend:e,attrs:{perm:a}}),u.push(l),i=fr(i.length,l.shape.length)),i=[i[0]],Hr("argMin",i,l.shape.length);const[c,d]=$r(l.shape,i),p=ns(_e(c),"int32"),f=_e(d),g=e.data.get(l.dataId).values;for(let m=0;m<p.length;++m){const y=m*f;let v=g[y],b=0;for(let x=0;x<f;++x){const w=g[y+x];w<v&&(v=w,b=x)}p[m]=b}return u.forEach(m=>e.disposeIntermediateTensorInfo(m)),e.makeTensorInfo(c,"int32",p)}},xue=Cn($h,t=>Math.asin(t)),wue={kernelName:$h,backendName:"cpu",kernelFunc:xue},_ue=Cn(Lh,t=>Math.asinh(t)),Cue={kernelName:Lh,backendName:"cpu",kernelFunc:_ue},Sue=Cn(Vh,t=>Math.atan(t)),Iue={kernelName:Vh,backendName:"cpu",kernelFunc:Sue},Due=wr((t,n)=>Math.atan2(t,n)),Tue=Br(zh,Due),kue={kernelName:zh,backendName:"cpu",kernelFunc:Tue},Eue=Cn(Bh,t=>Math.atanh(t)),Nue={kernelName:Bh,backendName:"cpu",kernelFunc:Eue};function SI(t,n,e,r,s,o){const i=s.strideHeight,a=s.strideWidth,l=s.dilationHeight,u=s.dilationWidth,c=s.effectiveFilterHeight,d=s.effectiveFilterWidth,h=s.padInfo.top,p=s.padInfo.left,f="max"===o?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,g=en(s.outShape,e),m=g.values,y=s.outShape[1]*s.outShape[2]*s.outShape[3],v=s.outShape[2]*s.outShape[3],b=s.outShape[3];for(let x=0;x<s.batchSize;++x){const w=x*y,k=x*r[0];for(let V=0;V<s.inChannels;++V)for(let z=0;z<s.outHeight;++z){const K=z*i-h,Y=Math.max(0,K),se=Math.min(s.inHeight,c+K),fe=w+z*v;for(let ve=0;ve<s.outWidth;++ve){const be=ve*a-p,xe=Math.max(0,be),De=Math.min(s.inWidth,d+be);let Ne=f,we=0,Ae=0;for(let He=Y;He<se;He+=l){const Ye=k+He*r[1];for(let je=xe;je<De;je+=u){const Je=t[Ye+je*r[2]+V];"max"===o&&Je>Ne?Ne=Je:"avg"===o&&(we+=Je,Ae++)}if(isNaN(Ne))break}m[fe+ve*b+V]="avg"===o?we/Ae:Ne}}}return g}function EV(t,n,e,r,s=!1,o=!1){const i=en(r.outShape,"int32"),a=r.strideHeight,l=r.strideWidth,u=r.dilationHeight,c=r.dilationWidth,d=r.effectiveFilterHeight,h=r.effectiveFilterWidth,p=r.padInfo.top,f=r.padInfo.left,g=en(n,e,t);for(let m=0;m<r.batchSize;++m)for(let y=0;y<r.inChannels;++y)for(let v=0;v<r.outHeight;++v){const b=v*a-p;let x=b;for(;x<0;)x+=u;const w=Math.min(r.inHeight,d+b);for(let k=0;k<r.outWidth;++k){const V=k*l-f;let z=V;for(;z<0;)z+=c;const K=Math.min(r.inWidth,h+V);let Y=Number.NEGATIVE_INFINITY,se=-1;for(let fe=x;fe<w;fe+=u){const ve=fe-b;for(let be=z;be<K;be+=c){const xe=be-V,De=g.get(m,fe,be,y);De>Y&&(Y=De,se=s?o?((m*r.inHeight+fe)*r.inWidth+be)*r.inChannels+y:(fe*r.inWidth+be)*r.inChannels+y:ve*h+xe)}}i.set(se,m,v,k,y)}}return i}function NV(t,n,e,r,s,o){const i=s.strideDepth,a=s.strideHeight,l=s.strideWidth,u=s.dilationDepth,c=s.dilationHeight,d=s.dilationWidth,h=s.effectiveFilterDepth,p=s.effectiveFilterHeight,f=s.effectiveFilterWidth,g=s.padInfo.front,m=s.padInfo.top,y=s.padInfo.left,v="max"===o?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,b=en(s.outShape,e),x=b.values,w=s.outShape[1]*s.outShape[2]*s.outShape[3]*s.outShape[4],k=s.outShape[2]*s.outShape[3]*s.outShape[4],V=s.outShape[3]*s.outShape[4],z=s.outShape[4];for(let K=0;K<s.batchSize;++K){const Y=K*w,se=K*r[0];for(let fe=0;fe<s.inChannels;++fe)for(let ve=0;ve<s.outDepth;++ve){const be=ve*i-g;let xe=be;for(;xe<0;)xe+=u;const De=Math.min(s.inDepth,h+be),Ne=Y+ve*k;for(let we=0;we<s.outHeight;++we){const Ae=we*a-m;let ze=Ae;for(;ze<0;)ze+=c;const He=Math.min(s.inHeight,p+Ae),Ye=Ne+we*V;for(let je=0;je<s.outWidth;++je){const st=je*l-y;let Je=st;for(;Je<0;)Je+=d;const ct=Math.min(s.inWidth,f+st),_t=Ye+je*z;let Rt=v,Tt=0,Ht=0;for(let Sn=xe;Sn<De;Sn+=u){const Ln=se+Sn*r[1];for(let sr=ze;sr<He;sr+=c){const Vn=Ln+sr*r[2];for(let En=Je;En<ct;En+=d){const Kn=t[Vn+En*r[3]+fe];if("max"===o&&Kn>Rt?Rt=Kn:"avg"===o&&(Tt+=Kn,Ht++),isNaN(Rt))break}if(isNaN(Rt))break}if(isNaN(Rt))break}x[_t+fe]="avg"===o?Tt/Math.max(Ht,1):Rt}}}}return b}const Fue={kernelName:Ug,backendName:"cpu",kernelFunc:function Rue(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n;mt(s,"avgPool");const{filterSize:o,strides:i,pad:a,dimRoundingMode:l}=r;R(Gr(i,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`);const c=Ro(s.shape,o,i,1,a,l);let d;if(1===c.filterWidth&&1===c.filterHeight&&gn(c.inShape,c.outShape))d=Bi({inputs:{x:s},backend:e});else{const h=e.data.get(s.dataId).values,p=xt(s.shape),f=SI(h,0,s.dtype,p,c,"avg");d=e.makeTensorInfo(c.outShape,s.dtype,f.values)}return d}},Pue={kernelName:Wg,backendName:"cpu",kernelFunc:function Oue(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{filterSize:o,strides:i,pad:a,dimRoundingMode:l,dataFormat:u}=r;mt(s,"avgPool3d");const c=ca(s.shape,o,i,1,a,l,u),h=NV(e.data.get(s.dataId).values,0,s.dtype,xt(s.shape),c,"avg");return e.makeTensorInfo(h.shape,"float32",h.values)}},$ue={kernelName:K_,backendName:"cpu",kernelFunc:function Mue(t){const{inputs:n,backend:e,attrs:r}=t,{dy:s,input:o}=n,{filterSize:i,strides:a,pad:l,dimRoundingMode:u}=r;mt([s,o],"avgPool3DGrad");const c=ca(o.shape,i,a,1,l,u),d=c.strideDepth,h=c.strideHeight,p=c.strideWidth,f=c.filterDepth,g=c.filterHeight,m=c.filterWidth,y=c.dilationDepth,v=c.dilationHeight,b=c.dilationWidth,x=c.effectiveFilterDepth,w=c.effectiveFilterHeight,k=c.effectiveFilterWidth,V=x-1-c.padInfo.front,z=k-1-c.padInfo.left,K=w-1-c.padInfo.top,Y=en(o.shape,"float32"),se=1/(f*g*m),fe=e.bufferSync(s);for(let ve=0;ve<c.batchSize;++ve)for(let be=0;be<c.inChannels;++be)for(let xe=0;xe<c.inDepth;++xe)for(let De=0;De<c.inHeight;++De)for(let Ne=0;Ne<c.inWidth;++Ne){const we=xe-V,Ae=De-K,ze=Ne-z;let He=0;for(let Ye=0;Ye<x;Ye+=y){const je=(we+Ye)/d;if(!(je<0||je>=c.outDepth||Math.floor(je)!==je))for(let st=0;st<w;st+=v){const Je=(Ae+st)/h;if(!(Je<0||Je>=c.outHeight||Math.floor(Je)!==Je))for(let ct=0;ct<k;ct+=b){const _t=(ze+ct)/p;_t<0||_t>=c.outWidth||Math.floor(_t)!==_t||(He+=fe.get(ve,je,Je,_t,be))}}}Y.set(He*se,ve,xe,De,Ne,be)}return e.makeTensorInfo(Y.shape,Y.dtype,Y.values)}},Vue={kernelName:q_,backendName:"cpu",kernelFunc:function Lue(t){const{inputs:n,backend:e,attrs:r}=t,{dy:s,input:o}=n,i=o;mt([s,o],"avgPoolGrad");const{filterSize:a,strides:l,pad:u}=r,c=Ro(i.shape,a,l,1,u),d=c.strideHeight,h=c.strideWidth,p=c.filterHeight,f=c.filterWidth,g=c.dilationHeight,m=c.dilationWidth,y=c.effectiveFilterHeight,v=c.effectiveFilterWidth,b=v-1-c.padInfo.left,x=y-1-c.padInfo.top,w=en(i.shape,"float32"),k=1/(p*f),V=e.data.get(s.dataId).values,z=en(s.shape,"float32",V);for(let K=0;K<c.batchSize;++K)for(let Y=0;Y<c.inChannels;++Y)for(let se=0;se<c.inHeight;++se)for(let fe=0;fe<c.inWidth;++fe){const ve=se-x,be=fe-b;let xe=0;for(let De=0;De<y;De+=g){const Ne=(ve+De)/d;if(!(Ne<0||Ne>=c.outHeight||Math.floor(Ne)!==Ne))for(let we=0;we<v;we+=m){const Ae=(be+we)/h;Ae<0||Ae>=c.outWidth||Math.floor(Ae)!==Ae||(xe+=z.get(K,Ne,Ae,Y))}}w.set(xe*k,K,se,fe,Y)}return e.makeTensorInfo(w.shape,w.dtype,w.values)}},zue={kernelName:ny,backendName:"cpu",kernelFunc:function Bue(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,scale:o,offset:i,mean:a,variance:l}=n;R(a.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),R(null==i||a.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),R(null==o||a.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),mt([s,a,l,o,i],"batchNorm");let{varianceEpsilon:u}=r;null==u&&(u=.001);const c=e.data.get(s.dataId).values,d=e.data.get(a.dataId).values,h=e.data.get(l.dataId).values,p=o?e.data.get(o.dataId).values:new Float32Array([1]),f=i?e.data.get(i.dataId).values:new Float32Array([0]),g=new Float32Array(c.length),m=f.length,y=p.length,v=h.length,b=d.length;let x=0,w=0,k=0,V=0;for(let z=0;z<c.length;++z)g[z]=f[x++]+(c[z]-d[w++])*p[k++]/Math.sqrt(h[V++]+u),x>=m&&(x=0),w>=b&&(w=0),k>=y&&(k=0),V>=v&&(V=0);return e.makeTensorInfo(s.shape,s.dtype,g)}};function AV(t,n,e,r,s){const o=v1(r,n,e),i=_e(e),a=xt(r);if(o){const d=b1(n,a);return"string"===s?t.slice(d,d+i):t.subarray(d,d+i)}const u=en(r,s,"string"===s?ga(t):t),c=en(e,s);for(let d=0;d<c.size;++d){const h=c.indexToLoc(d),p=h.map((f,g)=>f+n[g]);c.set(u.get(...p),...h)}return"string"===s?JM(c.values):c.values}function hu(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{begin:o,size:i}=r;mt(s,"slice");const[a,l]=nv(s,o,i);g1(s,a,l);const c=AV(e.data.get(s.dataId).values,a,l,s.shape,s.dtype);return e.makeTensorInfo(l,s.dtype,c)}const Uue={kernelName:Ay,backendName:"cpu",kernelFunc:hu},Gue={kernelName:Hg,backendName:"cpu",kernelFunc:function Wue(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{blockShape:o,crops:i}=r;mt([s],"batchToSpaceND");const a=o.reduce((y,v)=>y*v),l=Kp(s.shape,o,a),u=Xp(l.length,o.length),c=Yp(s.shape,o,a),d=tS(i,o.length),h=nS(c,i,o.length),p=$n({inputs:{x:s},backend:e,attrs:{shape:l}}),f=Ms({inputs:{x:p},backend:e,attrs:{perm:u}}),g=$n({inputs:{x:f},backend:e,attrs:{shape:c}}),m=hu({inputs:{x:g},backend:e,attrs:{begin:d,size:h}});return e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(g),m}};function II(t,n,e,r,s){const o=_e(r),i=ns(s,e);for(let a=0;a<t.length;a++){const l=t[a];if(l<0)throw new Error("Input x must be non-negative!");l>=s||(i[l]+=o>0?n[a]:1)}return i}function RV(t,n,e,r=!1){const s=t.shape[0],o=t.shape[1],i=en([s,e],n.dtype);for(let a=0;a<s;a++)for(let l=0;l<o;l++){const u=t.get(a,l);if(u<0)throw new Error("Input x must be non-negative!");u>=e||i.set(r?1:n.size>0?i.get(a,u)+n.get(a,l):i.get(a,u)+1,a,u)}return i}const jue={kernelName:X_,backendName:"cpu",kernelFunc:function Hue(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,weights:o}=n,{size:i}=r,u=II(e.data.get(s.dataId).values,e.data.get(o.dataId).values,o.dtype,o.shape,i);return e.makeTensorInfo([i],o.dtype,u)}},Kue={kernelName:FO,backendName:"cpu",kernelFunc:function que(t){const{inputs:n,backend:e}=t,{s0:r,s1:s}=n,o=e.data.get(r.dataId).values,i=e.data.get(s.dataId).values,a=Vt(Array.from(o),Array.from(i));return e.makeTensorInfo([a.length],"int32",Int32Array.from(a))}},FV=Vi(t=>Math.ceil(t)),Xue=il(Wh,FV),Yue={kernelName:Wh,backendName:"cpu",kernelFunc:Xue},Zue=Cn(Gh,(t,n)=>t>n.clipValueMax?n.clipValueMax:t<n.clipValueMin?n.clipValueMin:t),Que={kernelName:Gh,backendName:"cpu",kernelFunc:Zue},Jue={kernelName:jg,backendName:"cpu",kernelFunc:t=>{const{x:n}=t.inputs,e=t.backend,r=new Float32Array(_e(n.shape)),s=e.data.get(n.dataId),i=s.complexTensorInfos.imag,a=e.data.get(s.complexTensorInfos.real.dataId).values,l=e.data.get(i.dataId).values;for(let u=0;u<a.length;u++)r[u]=Math.hypot(a[u],l[u]);return e.makeOutput(r,n.shape,"float32")}};function OV(t,n,e,r){const s=cr(e,_e(n));if(r&&"string"!==e){let o=0;t.forEach(i=>{const a=_e(i.shape);s.set(i.vals,o),o+=a})}else{let o=0;t.forEach(i=>{const a="string"===e?ga(i.vals):i.vals;let l=0;for(let u=0;u<i.shape[0];++u){const c=u*n[1]+o;for(let d=0;d<i.shape[1];++d)s[c+d]=a[l++]}o+=i.shape[1]})}return s}function Yc(t){const{inputs:n,backend:e}=t,{input:r}=n,s=e.data.get(r.dataId).complexTensorInfos.imag,o=e.data.get(s.dataId).values;return e.makeTensorInfo(s.shape,s.dtype,o)}const ece={kernelName:pC,backendName:"cpu",kernelFunc:Yc};function Zc(t){const{inputs:n,backend:e,attrs:r}=t,{axis:s}=r,o=Jt(s,n[0].shape)[0];Q1(n.map(g=>g.shape),o);let a=Ai(n.map(g=>g.shape),o);if(0===_e(a))return e.makeTensorInfo(a,n[0].dtype,[]);const l=n.filter(g=>_e(g.shape)>0);if(1===l.length)return Bi({inputs:{x:l[0]},backend:e});if("complex64"===l[0].dtype){const g=l.map(x=>du({inputs:{input:x},backend:e})),m=l.map(x=>Yc({inputs:{input:x},backend:e})),y=Zc({inputs:g,backend:e,attrs:{axis:o}}),v=Zc({inputs:m,backend:e,attrs:{axis:o}}),b=js({inputs:{real:y,imag:v},backend:e});return g.forEach(x=>e.disposeIntermediateTensorInfo(x)),m.forEach(x=>e.disposeIntermediateTensorInfo(x)),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(v),b}const u=l.map(g=>{const y=[-1,_e(g.shape.slice(o))];return $n({inputs:{x:g},backend:e,attrs:{shape:y}})}),c=u.map(g=>({vals:e.data.get(g.dataId).values,shape:g.shape}));a=Ai(u.map(g=>g.shape),1);const h=OV(c,a,n[0].dtype,1===u[0].shape[0]),p=Ai(l.map(g=>g.shape),o),f=e.makeTensorInfo(p,n[0].dtype,h);return u.forEach(g=>e.disposeIntermediateTensorInfo(g)),f}const tce={kernelName:qg,backendName:"cpu",kernelFunc:Zc};function PV(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,filter:o}=n,{strides:i,pad:a,dataFormat:l,dilations:u,dimRoundingMode:c}=r;mt([s,o],"conv2d");const d=da(l),h=Mr(s.shape,o.shape,i,u,a,c,!1,d),p=h.filterHeight,f=h.filterWidth,g=h.dilationHeight,m=h.dilationWidth,y=h.padInfo.left,v=h.padInfo.top,b="channelsLast"===h.dataFormat,x=new Wr(h.outShape,s.dtype),w=xt(s.shape),k=xt(o.shape),V=w[0],z=b?w[1]:w[2],K=b?w[2]:1,Y=b?1:w[1],se=x.strides[0],fe=b?x.strides[1]:x.strides[2],ve=b?x.strides[2]:1,be=b?1:x.strides[1],xe=e.data.get(s.dataId).values,De=e.data.get(o.dataId).values,Ne=x.values;for(let we=0;we<h.batchSize;++we){const Ae=we*V,ze=we*se;for(let He=0;He<h.outHeight;++He){const Ye=ze+He*fe,je=He*h.strideHeight-v;for(let st=0;st<p;++st){const Je=je+st*g;if(Je<0||Je>=h.inHeight)continue;const ct=st*k[0],_t=Ae+Je*z;for(let Rt=0;Rt<h.outWidth;++Rt){const Tt=Ye+Rt*ve,Ht=Rt*h.strideWidth-y;for(let Yt=0;Yt<f;++Yt){const Sn=Ht+Yt*m;if(Sn<0||Sn>=h.inWidth)continue;const sr=_t+Sn*K;let Vn=ct+Yt*k[1];for(let En=0;En<h.inChannels;++En){const er=xe[sr+En*Y];for(let Kn=0;Kn<h.outChannels;++Kn)Ne[Tt+Kn*be]+=er*De[Vn+Kn];Vn+=h.outChannels}}}}}}return e.makeTensorInfo(x.shape,x.dtype,Ne)}const nce={kernelName:Kg,backendName:"cpu",kernelFunc:PV},sce={kernelName:Z_,backendName:"cpu",kernelFunc:function rce(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,dy:o}=n,{strides:i,pad:a,dataFormat:l,dimRoundingMode:u,filterShape:c}=r;mt([s,o],"conv2dBackpropFilter");const d=da(l),h=Mr(s.shape,c,i,1,a,u,!1,d),{strideHeight:p,strideWidth:f,filterHeight:g,filterWidth:m}=h,y="channelsLast"===h.dataFormat,v=new Wr(h.filterShape,"float32"),b=h.padInfo.left,x=h.padInfo.top,w=e.data.get(s.dataId).values,k=e.data.get(o.dataId).values,V=new Wr(s.shape,s.dtype,w),z=new Wr(o.shape,o.dtype,k);for(let K=0;K<g;++K){const Y=Math.max(0,Math.ceil((x-K)/p)),se=Math.min(h.outHeight,(h.inHeight+x-K)/p);for(let fe=0;fe<m;++fe){const ve=Math.max(0,Math.ceil((b-fe)/f)),be=Math.min(h.outWidth,(h.inWidth+b-fe)/f);for(let xe=0;xe<h.inChannels;++xe)for(let De=0;De<h.outChannels;++De){let Ne=0;for(let we=0;we<h.batchSize;++we)for(let Ae=Y;Ae<se;++Ae){const ze=K+Ae*p-x;for(let He=ve;He<be;++He){const Ye=fe+He*f-b;Ne+=y?V.get(we,ze,Ye,xe)*z.get(we,Ae,He,De):V.get(we,xe,ze,Ye)*z.get(we,De,Ae,He)}}v.set(Ne,K,fe,xe,De)}}}return e.makeTensorInfo(v.shape,v.dtype,v.values)}},ice={kernelName:Xg,backendName:"cpu",kernelFunc:function oce(t){const{inputs:n,backend:e,attrs:r}=t,{dy:s,filter:o}=n,{inputShape:i,strides:a,pad:l,dataFormat:u,dimRoundingMode:c}=r;mt([s,o],"conv2dBackpropInput");const d=xt(o.shape),h=xt(s.shape);let p=da(u);const f=Mr(i,o.shape,a,1,l,c,!1,p),g=new Wr(f.inShape,"float32"),m=g.values,y=e.data.get(s.dataId).values,v=e.data.get(o.dataId).values,[b,x,w]=d,{batchSize:k,filterHeight:V,filterWidth:z,inChannels:K,inHeight:Y,inWidth:se,outChannels:fe,outHeight:ve,outWidth:be,strideHeight:xe,strideWidth:De}=f;p=f.dataFormat;const Ne=V-1-f.padInfo.top,we=z-1-f.padInfo.left,Ae="channelsLast"===p,ze=g.strides[0],He=Ae?g.strides[1]:g.strides[2],Ye=Ae?g.strides[2]:1,je=Ae?1:g.strides[1],st=h[0],Je=Ae?h[1]:h[2],ct=Ae?h[2]:1,_t=Ae?1:h[1];for(let Rt=0;Rt<k;++Rt)for(let Tt=0;Tt<K;++Tt)for(let Ht=0;Ht<Y;++Ht){const Yt=Ht-Ne,Sn=Math.max(0,Math.ceil(Yt/xe)),Ln=Math.min(ve,(V+Yt)/xe);for(let sr=0;sr<se;++sr){const Vn=sr-we,En=Math.max(0,Math.ceil(Vn/De)),er=Math.min(be,(z+Vn)/De);let Kn=0;for(let qr=Sn;qr<Ln;++qr){const hl=qr*xe-Yt;for(let yo=En;yo<er;++yo){const ci=st*Rt+Je*qr+ct*yo,xa=b*(V-1-hl)+x*(z-1-(yo*De-Vn))+w*Tt;for(let pl=0;pl<fe;++pl)Kn+=y[ci+_t*pl]*v[xa+pl]}}m[ze*Rt+He*Ht+Ye*sr+je*Tt]=Kn}}return e.makeTensorInfo(g.shape,g.dtype,g.values)}},lce={kernelName:Yg,backendName:"cpu",kernelFunc:function ace(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,filter:o}=n,{strides:i,pad:a,dilations:l}=r;mt([s,o],"conv3d");const u=ja(s.shape,o.shape,i,l,a),{filterDepth:c,filterHeight:d,filterWidth:h,dilationDepth:p,dilationHeight:f,dilationWidth:g,padInfo:m}=u,y=m.front,v=m.left,b=m.top,x=new Wr(u.outShape,s.dtype),w=e.data.get(s.dataId).values,k=e.data.get(o.dataId).values,V=x.values,z=xt(s.shape),K=xt(o.shape);for(let Y=0;Y<u.batchSize;++Y){const se=Y*z[0],fe=Y*x.strides[0];for(let ve=0;ve<u.outDepth;++ve){const be=fe+ve*x.strides[1],xe=ve*u.strideDepth-y;for(let De=0;De<c;++De){const Ne=xe+De*p;if(Ne<0||Ne>=u.inDepth)continue;const we=De*K[0],Ae=se+Ne*z[1];for(let ze=0;ze<u.outHeight;++ze){const He=be+ze*x.strides[2],Ye=ze*u.strideHeight-b;for(let je=0;je<d;++je){const st=Ye+je*f;if(st<0||st>=u.inHeight)continue;const Je=we+je*K[1],ct=Ae+st*z[2];for(let _t=0;_t<u.outWidth;++_t){const Rt=He+_t*u.outChannels,Tt=_t*u.strideWidth-v;for(let Ht=0;Ht<h;++Ht){const Yt=Tt+Ht*g;if(Yt<0||Yt>=u.inWidth)continue;const Ln=ct+Yt*u.inChannels;let sr=Je+Ht*K[2];for(let Vn=0;Vn<u.inChannels;++Vn){const En=w[Ln+Vn];for(let er=0;er<u.outChannels;++er)V[Rt+er]+=En*k[sr+er];sr+=u.outChannels}}}}}}}}return e.makeTensorInfo(x.shape,x.dtype,x.values)}},cce={kernelName:Q_,backendName:"cpu",kernelFunc:function uce(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,dy:o}=n,{strides:i,pad:a,filterShape:l}=r;mt([s,o],"conv3dBackpropFilterV2");const u=xt(s.shape),c=xt(o.shape),d=ja(s.shape,l,i,1,a),h=d.strideDepth,p=d.strideHeight,f=d.strideWidth,g=d.filterDepth,m=d.filterHeight,y=d.filterWidth,v=new Wr(d.filterShape,"float32"),b=v.values,[x,w,k,V]=v.strides,z=e.data.get(o.dataId).values,[K,Y,se,fe]=c,ve=e.data.get(s.dataId).values,[be,xe,De,Ne]=u,we=d.padInfo.front,Ae=d.padInfo.left,ze=d.padInfo.top;for(let He=0;He<g;++He){const Ye=Math.max(0,Math.ceil((we-He)/h)),je=Math.min(d.outDepth,(d.inDepth+we-He)/h),st=He*x;for(let Je=0;Je<m;++Je){const ct=Math.max(0,Math.ceil((ze-Je)/p)),_t=Math.min(d.outHeight,(d.inHeight+ze-Je)/p),Rt=Je*w+st;for(let Tt=0;Tt<y;++Tt){const Ht=Math.max(0,Math.ceil((Ae-Tt)/f)),Yt=Math.min(d.outWidth,(d.inWidth+Ae-Tt)/f),Sn=Tt*k+Rt;for(let Ln=0;Ln<d.inChannels;++Ln){const sr=Ln*V+Sn;for(let Vn=0;Vn<d.outChannels;++Vn){let En=0;for(let er=0;er<d.batchSize;++er){const Kn=er*be,ba=er*K;for(let qr=Ye;qr<je;++qr){const yo=(He+qr*h-we)*xe+Kn,bu=qr*Y+ba;for(let ci=ct;ci<_t;++ci){const pl=(Je+ci*p-ze)*De+yo,fl=ci*se+bu;for(let ml=Ht;ml<Yt;++ml)En+=ve[(Tt+ml*f-Ae)*Ne+pl+Ln]*z[ml*fe+fl+Vn]}}}b[sr+Vn]=En}}}}}return e.makeTensorInfo(v.shape,v.dtype,v.values)}},hce={kernelName:J_,backendName:"cpu",kernelFunc:function dce(t){const{inputs:n,backend:e,attrs:r}=t,{dy:s,filter:o}=n,{pad:i,strides:a,inputShape:l}=r;mt([s],"conv3dBackpropInputV2");const u=xt(s.shape),c=xt(o.shape),d=ja(l,o.shape,a,1,i),h=new Wr(d.inShape,"float32"),p=h.values,[f,g,m,y]=h.strides,v=e.data.get(s.dataId).values,[b,x,w,k]=u,V=e.data.get(o.dataId).values,[z,K,Y,se]=c,{batchSize:fe,filterDepth:ve,filterHeight:be,filterWidth:xe,inChannels:De,inDepth:Ne,inHeight:we,inWidth:Ae,outChannels:ze,outDepth:He,outHeight:Ye,outWidth:je,strideDepth:st,strideHeight:Je,strideWidth:ct}=d,_t=ve-1-d.padInfo.front,Rt=be-1-d.padInfo.top,Tt=xe-1-d.padInfo.left;for(let Ht=0;Ht<fe;++Ht)for(let Yt=0;Yt<De;++Yt)for(let Sn=0;Sn<Ne;++Sn){const Ln=Sn-_t,sr=Math.max(0,Math.ceil(Ln/st)),Vn=Math.min(He,(ve+Ln)/st);for(let En=0;En<we;++En){const er=En-Rt,Kn=Math.max(0,Math.ceil(er/Je)),ba=Math.min(Ye,(be+er)/Je);for(let qr=0;qr<Ae;++qr){const hl=qr-Tt,yo=Math.max(0,Math.ceil(hl/ct)),bu=Math.min(je,(xe+hl)/ct);let ci=0;for(let xa=sr;xa<Vn;++xa){const pl=xa*st-Ln;for(let fl=Kn;fl<ba;++fl){const ml=fl*Je-er;for(let Df=yo;Df<bu;++Df){const ZI=b*Ht+x*xa+w*fl+k*Df,pSe=z*(ve-1-pl)+K*(be-1-ml)+Y*(xe-1-(Df*ct-hl))+se*Yt;for(let Sb=0;Sb<ze;++Sb)ci+=v[ZI+Sb]*V[pSe+Sb]}}}p[f*Ht+g*Sn+m*En+y*qr+Yt]=ci}}}return e.makeTensorInfo(h.shape,h.dtype,h.values)}},pce=Cn(Hh,t=>Math.cos(t)),fce={kernelName:Hh,backendName:"cpu",kernelFunc:pce},mce=Cn(jh,t=>Math.cosh(t)),gce={kernelName:jh,backendName:"cpu",kernelFunc:mce},vce={kernelName:tC,backendName:"cpu",kernelFunc:function yce(t){const{inputs:n,backend:e,attrs:r}=t,{image:s,boxes:o,boxInd:i}=n,{cropSize:a,method:l,extrapolationValue:u}=r,[c,d,h,p]=s.shape,f=o.shape[0],[g,m]=a,y=en([f,g,m,p],"float32"),v=e.data.get(o.dataId).values,b=e.data.get(i.dataId).values,x=e.data.get(s.dataId).values,w=xt(s.shape),k=xt(y.shape);for(let V=0;V<f;V++){const z=4*V,K=v[z],Y=v[z+1],se=v[z+2],fe=v[z+3],ve=b[V];if(ve>=c)continue;const be=g>1?(se-K)*(d-1)/(g-1):0,xe=m>1?(fe-Y)*(h-1)/(m-1):0;for(let De=0;De<g;De++){const Ne=g>1?K*(d-1)+De*be:.5*(K+se)*(d-1);if(Ne<0||Ne>d-1)for(let we=0;we<m;we++)for(let Ae=0;Ae<p;Ae++)y.values[Ae+we*k[2]+De*k[1]+V*k[0]]=u;else if("bilinear"===l){const we=Math.floor(Ne),Ae=Math.ceil(Ne),ze=Ne-we;for(let He=0;He<m;He++){const Ye=m>1?Y*(h-1)+He*xe:.5*(Y+fe)*(h-1);if(Ye<0||Ye>h-1){for(let ct=0;ct<p;ct++)y.values[ct+He*k[2]+De*k[1]+V*k[0]]=u;continue}const je=Math.floor(Ye),st=Math.ceil(Ye),Je=Ye-je;for(let ct=0;ct<p;ct++){let _t=ct+je*w[2]+we*w[1]+ve*w[0];const Rt=x[_t];_t=ct+st*w[2]+we*w[1]+ve*w[0];const Tt=x[_t];_t=ct+je*w[2]+Ae*w[1]+ve*w[0];const Ht=x[_t];_t=ct+st*w[2]+Ae*w[1]+ve*w[0];const Yt=x[_t],Sn=Rt+(Tt-Rt)*Je;_t=ct+He*k[2]+De*k[1]+V*k[0],y.values[_t]=Sn+(Ht+(Yt-Ht)*Je-Sn)*ze}}}else for(let we=0;we<m;++we){const Ae=m>1?Y*(h-1)+we*xe:.5*(Y+fe)*(h-1);if(Ae<0||Ae>h-1){for(let Ye=0;Ye<p;Ye++)y.values[Ye+we*k[2]+De*k[1]+V*k[0]]=u;continue}const ze=Math.round(Ae),He=Math.round(Ne);for(let Ye=0;Ye<p;Ye++)y.values[Ye+we*k[2]+De*k[1]+V*k[0]]=x[Ye+ze*w[2]+He*w[1]+ve*w[0]]}}}return e.makeTensorInfo(y.shape,y.dtype,y.values)}},xce={kernelName:eC,backendName:"cpu",kernelFunc:function bce(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o,exclusive:i,reverse:a}=r;mt(s,"cumprod");const l=Qn([o],s.shape.length);let u=s;null!=l&&(u=Ms({inputs:{x:s},backend:e,attrs:{perm:l}}));const c=fr(1,s.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const d=Ws(u.dtype,"int32"),h=B_(_e(u.shape),d),p=e.data.get(u.dataId).values,f=u.shape[u.shape.length-1],g=a?(y,v)=>y+f-v-1:(y,v)=>y+v;for(let y=0;y<p.length;y+=f)for(let v=0;v<f;v++){const b=g(y,v);if(0===v)h[b]=i?1:p[b];else{const x=g(y,v-1);h[b]=i?p[x]*h[x]:p[b]*h[x]}}const m=e.makeTensorInfo(u.shape,d,h);if(null!=l){const v=Ms({inputs:{x:m},backend:e,attrs:{perm:Ka(l)}});return e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(u),v}return m}},_ce={kernelName:Zg,backendName:"cpu",kernelFunc:function wce(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o,exclusive:i,reverse:a}=r;mt(s,"cumsum");const l=Qn([o],s.shape.length);let u=s;null!=l&&(u=Ms({inputs:{x:s},backend:e,attrs:{perm:l}}));const c=fr(1,s.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const d=Ws(u.dtype,"int32"),h=ns(_e(u.shape),d),p=e.data.get(u.dataId).values,f=u.shape[u.shape.length-1],g=a?(y,v)=>y+f-v-1:(y,v)=>y+v;for(let y=0;y<p.length;y+=f)for(let v=0;v<f;v++){const b=g(y,v);if(0===v)h[b]=i?0:p[b];else{const x=g(y,v-1);h[b]=i?p[x]+h[x]:p[b]+h[x]}}const m=e.makeTensorInfo(u.shape,d,h);if(null!=l){const v=Ms({inputs:{x:m},backend:e,attrs:{perm:Ka(l)}});return e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(u),v}return m}},Sce={kernelName:nC,backendName:"cpu",kernelFunc:function Cce(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,weights:o}=n,{size:i,binaryOutput:a}=r;if(1===s.shape.length){const c=II(e.data.get(s.dataId).values,e.data.get(o.dataId).values,o.dtype,o.shape,i);return e.makeTensorInfo([i],o.dtype,c)}if(2===s.shape.length){const c=RV(e.bufferSync(s),e.bufferSync(o),i,a);return e.makeTensorInfo(c.shape,o.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}},Dce={kernelName:rC,backendName:"cpu",kernelFunc:function Ice(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{blockSize:o,dataFormat:i}=r;R("NHWC"===i,()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`);const a=s.shape[0],l=s.shape[1],u=s.shape[2],c=s.shape[3],d=l*o,h=u*o,p=c/(o*o),f=e.data.get(s.dataId).values,g=new Float32Array(a*d*h*p);let m=0;for(let y=0;y<a;++y)for(let v=0;v<d;++v){const b=Math.floor(v/o),x=v%o;for(let w=0;w<h;++w){const k=Math.floor(w/o),z=(x*o+w%o)*p;for(let K=0;K<p;++K)g[m++]=f[K+z+c*(k+u*(b+l*y))]}}return e.makeTensorInfo([a,d,h,p],s.dtype,g)}};function MV(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,filter:o}=n,{strides:i,pad:a,dilations:l,dimRoundingMode:u}=r;mt([s,o],"depthwiseConv2DNative");const c=xt(s.shape),d=xt(o.shape);let h=l;null==h&&(h=[1,1]),R(Gr(i,h),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${h}'`);const p=Mr(s.shape,o.shape,i,h,a,u,!0),{filterHeight:f,filterWidth:g,dilationHeight:m,dilationWidth:y,padInfo:v}=p,b=v.left,x=v.top,w=p.outChannels/p.inChannels,k=new Wr(p.outShape,s.dtype),V=e.data.get(s.dataId).values,z=e.data.get(o.dataId).values,K=k.values;for(let Y=0;Y<p.batchSize;++Y){const se=Y*c[0],fe=Y*k.strides[0];for(let ve=0;ve<p.outHeight;++ve){const be=fe+ve*k.strides[1],xe=ve*p.strideHeight-x;for(let De=0;De<f;++De){const Ne=xe+De*m;if(Ne<0||Ne>=p.inHeight)continue;const we=De*d[0],Ae=se+Ne*c[1];for(let ze=0;ze<p.outWidth;++ze){const He=be+ze*k.strides[2],Ye=ze*p.strideWidth-b;for(let je=0;je<g;++je){const st=Ye+je*y;if(st<0||st>=p.inWidth)continue;const ct=Ae+st*p.inChannels;let _t=He,Rt=we+je*d[1];for(let Tt=0;Tt<p.inChannels;++Tt){const Ht=V[ct+Tt];for(let Yt=0;Yt<w;++Yt)K[_t+Yt]+=Ht*z[Rt+Yt];_t+=w,Rt+=w}}}}}}return e.makeTensorInfo(k.shape,k.dtype,k.values)}const Tce={kernelName:Qg,backendName:"cpu",kernelFunc:MV},Ece={kernelName:sC,backendName:"cpu",kernelFunc:function kce(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,dy:o}=n,{strides:i,dilations:a,pad:l,dimRoundingMode:u,filterShape:c}=r;mt([s,o],"depthwiseConv2dNativeBackpropFilter");const d=Mr(s.shape,c,i,a,l,u,!0),{strideHeight:h,strideWidth:p,filterHeight:f,filterWidth:g}=d,m=new Wr(d.filterShape,"float32"),y=d.padInfo.left,v=d.padInfo.top,b=d.outChannels/d.inChannels,x=e.data.get(s.dataId).values,w=new Wr(s.shape,s.dtype,x),k=e.data.get(o.dataId).values,V=new Wr(o.shape,o.dtype,k);for(let z=0;z<f;++z){const K=Math.max(0,Math.ceil((v-z)/h)),Y=Math.min(d.outHeight,(d.inHeight+v-z)/h);for(let se=0;se<g;++se){const fe=Math.max(0,Math.ceil((y-se)/p)),ve=Math.min(d.outWidth,(d.inWidth+y-se)/p);for(let be=0;be<d.outChannels;++be){const xe=Math.trunc(be/b),De=be%b;let Ne=0;for(let we=0;we<d.batchSize;++we)for(let Ae=K;Ae<Y;++Ae){const ze=z+Ae*h-v;for(let He=fe;He<ve;++He)Ne+=w.get(we,ze,se+He*p-y,xe)*V.get(we,Ae,He,be)}m.set(Ne,z,se,xe,De)}}}return e.makeTensorInfo(m.shape,m.dtype,m.values)}},Ace={kernelName:oC,backendName:"cpu",kernelFunc:function Nce(t){const{inputs:n,backend:e,attrs:r}=t,{dy:s,filter:o}=n,{strides:i,dilations:a,pad:l,dimRoundingMode:u,inputShape:c}=r;mt([s,o],"depthwiseConv2DNativeBackpropInput");const d=xt(s.shape),h=xt(o.shape),p=Mr(c,o.shape,i,a,l,u,!0),f=new Wr(p.inShape,"float32"),g=f.values,[m,y,v]=f.strides,b=e.data.get(s.dataId).values,[x,w,k]=d,V=e.data.get(o.dataId).values,[z,K,Y]=h,{batchSize:se,filterHeight:fe,filterWidth:ve,inChannels:be,inHeight:xe,inWidth:De,outChannels:Ne,outHeight:we,outWidth:Ae,strideHeight:ze,strideWidth:He}=p,Ye=fe-1-p.padInfo.top,je=ve-1-p.padInfo.left,st=Ne/be;for(let Je=0;Je<se;++Je)for(let ct=0;ct<be;++ct)for(let _t=0;_t<xe;++_t){const Rt=_t-Ye,Tt=Math.max(0,Math.ceil(Rt/ze)),Ht=Math.min(we,(fe+Rt)/ze);for(let Yt=0;Yt<De;++Yt){const Sn=Yt-je,Ln=Math.max(0,Math.ceil(Sn/He)),sr=Math.min(Ae,(ve+Sn)/He);let Vn=0;for(let En=Tt;En<Ht;++En){const er=En*ze-Rt;for(let Kn=Ln;Kn<sr;++Kn){const qr=x*Je+w*En+k*Kn,hl=z*(fe-1-er)+K*(ve-1-(Kn*He-Sn))+Y*ct;for(let yo=0;yo<st;++yo)Vn+=b[qr+(ct*st+yo)]*V[hl+yo]}}g[m*Je+y*_t+v*Yt+ct]=Vn}}return e.makeTensorInfo(f.shape,f.dtype,f.values)}},Fce={kernelName:"Diag",backendName:"cpu",kernelFunc:function Rce(t){const{inputs:n,backend:e}=t,{x:r}=n,s=_e(r.shape),o=e.data.get(r.dataId).values,i=en([s,s],r.dtype),a=i.values;for(let u=0;u<o.length;u++)a[u*s+u]=o[u];const l=[...r.shape,...r.shape];return e.makeTensorInfo(l,i.dtype,i.values)}},Oce={kernelName:Jg,backendName:"cpu",kernelFunc:({inputs:t,backend:n,attrs:e})=>{const{x:r,filter:s}=t,{strides:o,pad:i,dilations:a}=e,l=n,u=l.data.get(r.dataId).values,c=r.shape.length,d=l.data.get(s.dataId).values,h=s.shape.length,{batchSize:p,inHeight:f,inWidth:g,inChannels:m,outHeight:y,outWidth:v,padInfo:b,strideHeight:x,strideWidth:w,filterHeight:k,filterWidth:V,dilationHeight:z,dilationWidth:K,outShape:Y}=Vp(r.shape,s.shape,o,i,"NHWC",a),se=_e(Y),fe=Y.length,ve=cr(r.dtype,se);for(let xe=0;xe<p;++xe)for(let De=0;De<y;++De){const Ne=De*x-b.top;for(let we=0;we<v;++we){const Ae=we*w-b.left;for(let ze=0;ze<m;++ze){let He=Number.MIN_SAFE_INTEGER;for(let je=0;je<k;++je){const st=Ne+je*z;if(st>=0&&st<f)for(let Je=0;Je<V;++Je){const ct=Ae+Je*K;if(ct>=0&&ct<g){const _t=Di([xe,st,ct,ze],c,xt(r.shape)),Rt=Di([je,Je,ze],h,xt(s.shape)),Tt=u[_t]+d[Rt];Tt>He&&(He=Tt)}}}ve[Di([xe,De,we,ze],fe,xt(Y))]=He}}}return{dataId:l.write(Hl(ve,r.dtype),Y,r.dtype),shape:Y,dtype:r.dtype}}},Pce={kernelName:aC,backendName:"cpu",kernelFunc:({inputs:t,backend:n,attrs:e})=>{const{x:r,filter:s,dy:o}=t,{strides:i,pad:a,dilations:l}=e,u=n,c=Qo(r.shape,u.data.get(r.dataId).values),d=Qo(s.shape,u.data.get(s.dataId).values),{batchSize:h,inHeight:p,inWidth:f,inChannels:g,outHeight:m,outWidth:y,padInfo:v,strideHeight:b,strideWidth:x,filterHeight:w,filterWidth:k,dilationHeight:V,dilationWidth:z,outShape:K}=Vp(r.shape,s.shape,i,a,"NHWC",l);R(o.rank===K.length,()=>`Error in ${aC}, dy must have the same rank as output ${K.length}, but got ${o.rank}`);const Y=Qo(K,u.data.get(o.dataId).values),se=EO(s.shape,s.dtype);for(let ve=0;ve<h;++ve)for(let be=0;be<m;++be){const xe=be*b-v.top;for(let De=0;De<y;++De){const Ne=De*x-v.left;for(let we=0;we<g;++we){let Ae=Number.MIN_SAFE_INTEGER,ze=0,He=0;for(let Ye=0;Ye<w;++Ye){const je=xe+Ye*V;if(je>=0&&je<p)for(let st=0;st<k;++st){const Je=Ne+st*z;if(Je>=0&&Je<f){const ct=c[ve][je][Je][we]+d[Ye][st][we];ct>Ae&&(Ae=ct,ze=Ye,He=st)}}}se[ze][He][we]+=Y[ve][be][De][we]}}}return{dataId:u.write(Hl(se,r.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},Mce={kernelName:iC,backendName:"cpu",kernelFunc:({inputs:t,backend:n,attrs:e})=>{const{x:r,filter:s,dy:o}=t,{strides:i,pad:a,dilations:l}=e,u=n,c=Qo(r.shape,u.data.get(r.dataId).values),d=Qo(s.shape,u.data.get(s.dataId).values),{batchSize:h,inHeight:p,inWidth:f,inChannels:g,outHeight:m,outWidth:y,padInfo:v,strideHeight:b,strideWidth:x,filterHeight:w,filterWidth:k,dilationHeight:V,dilationWidth:z,outShape:K}=Vp(r.shape,s.shape,i,a,"NHWC",l);R(o.rank===K.length,()=>`Error in ${iC}, dy must have the same rank as output ${K.length}, but got ${o.rank}`);const Y=Qo(K,u.data.get(o.dataId).values),se=EO(r.shape,r.dtype);for(let ve=0;ve<h;++ve)for(let be=0;be<m;++be){const xe=be*b-v.top;for(let De=0;De<y;++De){const Ne=De*x-v.left;for(let we=0;we<g;++we){let Ae=Number.MIN_SAFE_INTEGER,ze=xe<0?0:xe,He=Ne<0?0:Ne;for(let Ye=0;Ye<w;++Ye){const je=xe+Ye*V;if(je>=0&&je<p)for(let st=0;st<k;++st){const Je=Ne+st*z;if(Je>=0&&Je<f){const ct=c[ve][je][Je][we]+d[Ye][st][we];ct>Ae&&(Ae=ct,ze=je,He=Je)}}}se[ve][ze][He][we]+=Y[ve][be][De][we]}}}return{dataId:u.write(Hl(se,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},DI=wr((t,n)=>t*n),$ce=_I((t,n,e,r)=>({real:t*e-n*r,imag:t*r+n*e})),eb=Br(cp,DI,$ce),Lce={kernelName:cp,backendName:"cpu",kernelFunc:eb};function ff(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o,keepDims:i}=r;let a;mt(s,"sum"),a="bool"===s.dtype?al({inputs:{x:s},backend:e,attrs:{dtype:"int32"}}):Bi({inputs:{x:s},backend:e});const l=a.shape.length,u=Jt(o,a.shape),c=Qn(u,l);let d=u,h=a;null!=c&&(h=Ms({inputs:{x:a},backend:e,attrs:{perm:c}}),d=fr(d.length,l)),Hr("sum",d,h.shape.length);const[p,f]=$r(h.shape,d);let m=Jv(e,p,Ws(h.dtype,"int32"));const y=_e(f),v=e.data.get(m.dataId).values,b=e.data.get(h.dataId).values;for(let x=0;x<v.length;++x){const w=x*y;let k=0;for(let V=0;V<y;++V)k+=b[w+V];v[x]=k}if(i){const w=m;m=$n({inputs:{x:m},backend:e,attrs:{shape:pr(m.shape,u)}}),e.disposeIntermediateTensorInfo(w)}return e.disposeIntermediateTensorInfo(a),null!=c&&e.disposeIntermediateTensorInfo(h),m}const Vce={kernelName:Ry,backendName:"cpu",kernelFunc:ff},zce={kernelName:"Einsum",backendName:"cpu",kernelFunc:function Bce(t){const{inputs:n,backend:e,attrs:r}=t,{equation:s}=r,o=n,{allDims:i,summedDims:a,idDims:l}=hS(s,o.length);fS(i.length,l,o);const{path:u,steps:c}=mS(a,l),d=c.length;let h=null,p=i.length;const f=[];for(let g=0;g<d;++g){for(const m of c[g]){const{permutationIndices:y,expandDims:v}=pS(p,l[m]);let b;gS(y)?b=o[m]:(b=Ms({inputs:{x:o[m]},backend:e,attrs:{perm:y}}),f.push(b));const x=b.shape.slice();for(let w=0;w<v.length;++w)x.splice(v[w],0,1);gn(b.shape,x)||(b=$n({inputs:{x:b},backend:e,attrs:{shape:x}}),f.push(b)),null===h?h=b:(h=eb({inputs:{a:b,b:h},backend:e}),f.push(h))}g<d-1&&(u[g]>=0&&(h=ff({inputs:{x:h},backend:e,attrs:{axis:u[g]-(i.length-p),keepDims:!1}}),f.push(h)),p--)}for(const g of f)g!==h&&e.disposeIntermediateTensorInfo(g);return h}},Wce={kernelName:lC,backendName:"cpu",kernelFunc:function Uce(t){const{inputs:n,backend:e}=t,{dy:r,y:s}=n;mt([r,s],"eluGrad");const o=new Float32Array(_e(s.shape)),i=e.data.get(s.dataId).values,a=e.data.get(r.dataId).values;for(let l=0;l<i.length;++l){const u=i[l];o[l]=u>=0?a[l]:a[l]*(u+1)}return e.makeTensorInfo(s.shape,"float32",o)}},$V=wr((t,n)=>t===n?1:0),LV=Br(ey,$V,null,"bool"),Gce={kernelName:ey,backendName:"cpu",kernelFunc:LV},Hce=sS,jce=oS,qce=iS,Kce=aS,Xce=lS,Yce=uS,Zce=Cn(Xh,t=>{const n=Math.sign(t),e=Math.abs(t),r=1/(1+Hce*e);return n*(1-((((Yce*r+Xce)*r+Kce)*r+qce)*r+jce)*r*Math.exp(-e*e))}),Qce={kernelName:Xh,backendName:"cpu",kernelFunc:Zce},VV=Vi(t=>Math.exp(t)),BV=il(Yh,VV,"float32"),Jce={kernelName:Yh,backendName:"cpu",kernelFunc:BV};function tb(t){const{inputs:n,backend:e,attrs:r}=t,{input:s}=n,{dim:o}=r,i=s.shape.length,a=s.shape.slice();let l=o;return o<0&&(R(-(i+1)<=o,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+o+1),a.splice(l,0,1),$n({inputs:{x:s},backend:e,attrs:{shape:a}})}const ede={kernelName:ty,backendName:"cpu",kernelFunc:tb},zV=Vi(t=>Math.expm1(t)),tde=il(Zh,zV),nde={kernelName:Zh,backendName:"cpu",kernelFunc:tde},rde=wr((t,n)=>t/n),TI=Br(qh,rde),kI={kernelName:qh,backendName:"cpu",kernelFunc:TI},UV=wr((t,n)=>t-n),sde=_I((t,n,e,r)=>({real:t-e,imag:n-r})),EI=Br(Ip,UV,sde),ode={kernelName:Ip,backendName:"cpu",kernelFunc:EI};function WV(t,n,e){const r=t.shape,s=r[0],o=r[1],i=e.data.get(t.dataId),a=i.complexTensorInfos.real,l=i.complexTensorInfos.imag,u=[s,o],c=_e(u),d=ts("float32",c),h=ts("float32",c);for(let m=0;m<s;m++){const y=hu({inputs:{x:a},backend:e,attrs:{begin:[m,0],size:[1,o]}}),v=hu({inputs:{x:l},backend:e,attrs:{begin:[m,0],size:[1,o]}}),b=js({inputs:{real:y,imag:v},backend:e}),{real:x,imag:w}=ide(b,n,e),k=ma(x,w);for(let V=0;V<o;V++){const z=cS(k,V);d[m*o+V]=z.real,h[m*o+V]=z.imag}e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(v),e.disposeIntermediateTensorInfo(b)}const p=e.makeTensorInfo(u,"float32",d),f=e.makeTensorInfo(u,"float32",h),g=js({inputs:{real:p,imag:f},backend:e});return e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(f),g}function ide(t,n,e){const r=_e(t.shape),s=e.data.get(t.dataId),o=e.data.get(s.complexTensorInfos.real.dataId).values,i=e.data.get(s.complexTensorInfos.imag.dataId).values;if(function ade(t){return 0==(t&t-1)}(r)){const a=NI(o,i,r,n,e),l=[t.shape[0],t.shape[1]];if(n){const u=e.makeTensorInfo(l,"float32",a.real),c=e.makeTensorInfo(l,"float32",a.imag),d=e.makeTensorInfo([],"float32",Ba(r,"float32")),h=Bi({inputs:{x:d},backend:e}),p=kI.kernelFunc({inputs:{a:u,b:d},backend:e}),f=kI.kernelFunc({inputs:{a:c,b:h},backend:e}),g=e.data.get(p.dataId).values,m=e.data.get(f.dataId).values;return e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(f),{real:g,imag:m}}return a}{const l=function lde(t,n,e){const r=new Float32Array(2*n);for(let s=0;s<n;s++){let o=0,i=0;for(let a=0;a<n;a++){const l=$M(s*a,n,e),u=cS(t,a);o+=u.real*l.real-u.imag*l.imag,i+=u.real*l.imag+u.imag*l.real}e&&(o/=n,i/=n),PM(r,o,i,s)}return r}(ma(o,i),r,n);return RM(l)}}function NI(t,n,e,r,s){if(1===e)return{real:t,imag:n};const o=ma(t,n),i=e/2,a=FM(o),l=a.real,u=a.imag,c=[l.length],d=s.makeTensorInfo(c,"float32",l),h=s.makeTensorInfo(c,"float32",u),p=js({inputs:{real:d,imag:h},backend:s}),f=OM(o),g=f.real,m=f.imag,y=[g.length],v=s.makeTensorInfo(y,"float32",g),b=s.makeTensorInfo(y,"float32",m),x=js({inputs:{real:v,imag:b},backend:s}),w=NI(l,u,i,r,s),k=w.real,V=w.imag,z=[k.length],K=s.makeTensorInfo(z,"float32",k),Y=s.makeTensorInfo(z,"float32",V),se=js({inputs:{real:K,imag:Y},backend:s}),fe=NI(g,m,i,r,s),ve=fe.real,be=fe.imag,xe=[ve.length],De=s.makeTensorInfo(xe,"float32",ve),Ne=s.makeTensorInfo(xe,"float32",be),we=js({inputs:{real:De,imag:Ne},backend:s}),Ae=MM(e,r),ze=[Ae.real.length],He=s.makeTensorInfo(ze,"float32",Ae.real),Ye=s.makeTensorInfo(ze,"float32",Ae.imag),je=js({inputs:{real:He,imag:Ye},backend:s}),st=eb({inputs:{a:je,b:we},backend:s}),Je=Xc({inputs:{a:se,b:st},backend:s}),ct=EI({inputs:{a:se,b:st},backend:s}),_t=du({inputs:{input:Je},backend:s}),Rt=du({inputs:{input:ct},backend:s}),Tt=Yc({inputs:{input:Je},backend:s}),Ht=Yc({inputs:{input:ct},backend:s}),Yt=Zc({inputs:[_t,Rt],backend:s,attrs:{axis:0}}),Sn=Zc({inputs:[Tt,Ht],backend:s,attrs:{axis:0}}),Ln=s.data.get(Yt.dataId).values,sr=s.data.get(Sn.dataId).values;return s.disposeIntermediateTensorInfo(d),s.disposeIntermediateTensorInfo(h),s.disposeIntermediateTensorInfo(p),s.disposeIntermediateTensorInfo(v),s.disposeIntermediateTensorInfo(b),s.disposeIntermediateTensorInfo(x),s.disposeIntermediateTensorInfo(K),s.disposeIntermediateTensorInfo(Y),s.disposeIntermediateTensorInfo(se),s.disposeIntermediateTensorInfo(De),s.disposeIntermediateTensorInfo(Ne),s.disposeIntermediateTensorInfo(we),s.disposeIntermediateTensorInfo(He),s.disposeIntermediateTensorInfo(Ye),s.disposeIntermediateTensorInfo(je),s.disposeIntermediateTensorInfo(st),s.disposeIntermediateTensorInfo(Je),s.disposeIntermediateTensorInfo(ct),s.disposeIntermediateTensorInfo(_t),s.disposeIntermediateTensorInfo(Tt),s.disposeIntermediateTensorInfo(Rt),s.disposeIntermediateTensorInfo(Ht),s.disposeIntermediateTensorInfo(Yt),s.disposeIntermediateTensorInfo(Sn),{real:Ln,imag:sr}}const cde={kernelName:"FFT",backendName:"cpu",kernelFunc:function ude(t){const{inputs:n,backend:e}=t,{input:r}=n,s=_e(r.shape),o=r.shape[r.shape.length-1],a=$n({inputs:{x:r},backend:e,attrs:{shape:[s/o,o]}}),l=WV(a,!1,e),u=$n({inputs:{x:l},backend:e,attrs:{shape:r.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(l),u}};function AI(t){const{backend:n,attrs:e}=t,{shape:r,value:s,dtype:o}=e,i=o||Sc(s),a=cr(i,_e(r));return function hde(t,n,e){t.fill(n)}(a,s),n.makeTensorInfo(r,i,a)}const dde={kernelName:cC,backendName:"cpu",kernelFunc:AI},pde={kernelName:dC,backendName:"cpu",kernelFunc:({inputs:t,backend:e})=>{const{image:r}=t,s=e,o=ts(r.dtype,_e(r.shape)),[i,a,l,u]=r.shape,c=s.data.get(r.dataId).values;for(let h=0;h<i;h++){const p=h*l*a*u;for(let f=0;f<a;f++){const g=f*(l*u);for(let m=0;m<l;m++){const y=m*u;for(let v=0;v<u;v++){const b=Math.round(l-m-1),x=p+g+y+v;let w=c[x];b>=0&&b<l&&(w=c[p+g+b*u+v]),o[x]=w}}}}return{dataId:s.write(o,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},GV=Vi(t=>Math.floor(t)),fde=il(Qh,GV),mde={kernelName:Qh,backendName:"cpu",kernelFunc:fde},HV=wr((t,n)=>Math.floor(t/n)),gde=Br(Jh,HV,null,"int32"),yde={kernelName:Jh,backendName:"cpu",kernelFunc:gde},bde={kernelName:zy,backendName:"cpu",kernelFunc:function vde(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,filter:o,bias:i,preluActivationWeights:a}=n,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=r;let g=PV({inputs:{x:s,filter:o},backend:e,attrs:{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h}});if(i){const m=g;if("NCHW"===c&&1===i.shape.length&&1!==i.shape[0]){const y=$n({inputs:{x:i},backend:e,attrs:{shape:[i.shape[0],1,1]}});g=Xc({inputs:{a:g,b:y},backend:e}),e.disposeIntermediateTensorInfo(y)}else g=Xc({inputs:{a:g,b:i},backend:e});e.disposeIntermediateTensorInfo(m)}if(p){const m=g;if("NCHW"===c&&"prelu"===p&&1===a.shape.length&&1!==a.shape[0]){const y=$n({inputs:{x:a},backend:e,attrs:{shape:[a.shape[0],1,1]}});g=Qv(e,g,p,y,f),e.disposeIntermediateTensorInfo(y)}else g=Qv(e,g,p,a,f);e.disposeIntermediateTensorInfo(m)}return g}},wde={kernelName:Uy,backendName:"cpu",kernelFunc:function xde(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,filter:o,bias:i,preluActivationWeights:a}=n,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=r;let g=MV({inputs:{x:s,filter:o},backend:e,attrs:{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h}});if(i){const m=g;g=Xc({inputs:{a:g,b:i},backend:e}),e.disposeIntermediateTensorInfo(m)}if(p){const m=g;g=Qv(e,g,p,a,f),e.disposeIntermediateTensorInfo(m)}return g}};function jV(t,n,e,r,s,o,i,a,l){const u=en([r,o],e);for(let c=0;c<r;c++){const d=[];let h=0;for(let p=0;p<s;p++){const f=t[c*s+p];h+=f*i[p],d.push(f)}if(h<0||h>=l/o)throw new Error(`Invalid indices: ${d} does not index into ${a}`);for(let p=0;p<o;p++)u.values[c*o+p]=n.get(...n.indexToLoc(h*o+p))}return u}const Cde={kernelName:MO,backendName:"cpu",kernelFunc:function _de(t){const{inputs:n,backend:e}=t,{params:r,indices:s}=n,o=_e(r.shape),i=s.shape,a=i[i.length-1],[l,u,c,d]=rS(r,s);if(0===u)return e.makeTensorInfo(l,r.dtype,[]);const f=jV(e.data.get(s.dataId).values,e.bufferSync(r),r.dtype,u,a,c,d,r.shape,o);return e.makeTensorInfo(l,r.dtype,f.values)}};function qV(t,n,e){const r=en(e,t.dtype);for(let s=0;s<r.size;++s){const i=r.indexToLoc(s).slice(),u=n.locToIndex([i[0],i[2]]);i[2]=n.values[u];const c=t.locToIndex(i);0<=c&&c<t.values.length&&(r.values[s]=t.values[c])}return r}const Ide={kernelName:ry,backendName:"cpu",kernelFunc:function Sde(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,indices:o}=n,{axis:i,batchDims:a}=r;mt([s,o],"gatherV2");const l=Jt(i,s.shape)[0],u=e.data.get(o.dataId).values,c=s.shape[l];for(let x=0;x<u.length;++x){const w=u[x];R(w<=c-1&&w>=0,()=>`GatherV2: the index value ${w} is not in [0, ${c-1}]`)}let d=a;null==a&&(d=0);const h=_e(o.shape),p=bS(s,o,l,d),f=$n({inputs:{x:s},backend:e,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),g=$n({inputs:{x:o},backend:e,attrs:{shape:[p.batchSize,h/p.batchSize]}}),m=[p.batchSize,p.outerSize,h/p.batchSize,p.sliceSize],y=e.bufferSync(g),b=qV(e.bufferSync(f),y,m);return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(g),e.makeTensorInfo(p.outputShape,b.dtype,b.values)}},KV=wr((t,n)=>t>n?1:0),Dde=Br(sy,KV,null,"bool"),Tde={kernelName:sy,backendName:"cpu",kernelFunc:Dde},XV=wr((t,n)=>t>=n?1:0),kde=Br(ep,XV,null,"bool"),Ede={kernelName:ep,backendName:"cpu",kernelFunc:kde},Ade={kernelName:hC,backendName:"cpu",kernelFunc:function Nde(t){const{inputs:n,backend:e}=t,{input:r}=n,s=_e(r.shape),o=r.shape[r.shape.length-1],a=$n({inputs:{x:r},backend:e,attrs:{shape:[s/o,o]}}),l=WV(a,!0,e),u=$n({inputs:{x:l},backend:e,attrs:{shape:r.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(l),u}},Rde=Cn(np,t=>Number.isFinite(t)?1:0,"bool"),Fde={kernelName:np,backendName:"cpu",kernelFunc:Rde},Ode=Cn(rp,t=>Math.abs(t)===1/0?1:0,"bool"),Pde={kernelName:rp,backendName:"cpu",kernelFunc:Ode},Mde=Cn(sp,t=>Number.isNaN(t)?1:0,"bool"),$de={kernelName:sp,backendName:"cpu",kernelFunc:Mde},YV=wr((t,n)=>t<n?1:0),Lde=Br(iy,YV,null,"bool"),Vde={kernelName:iy,backendName:"cpu",kernelFunc:Lde},ZV=wr((t,n)=>t<=n?1:0),Bde=Br(ay,ZV,null,"bool"),zde={kernelName:ay,backendName:"cpu",kernelFunc:Bde};function QV(t,n,e){const r=(n-t)/(e-1),s=ns(e,"float32");s[0]=t;for(let o=1;o<s.length;o++)s[o]=s[o-1]+r;return s}const Wde={kernelName:$O,backendName:"cpu",kernelFunc:function Ude(t){const{backend:n,attrs:e}=t,{start:r,stop:s,num:o}=e,i=QV(r,s,o);return n.makeTensorInfo([i.length],"float32",i)}},JV=Vi(t=>Math.log(t)),Gde=il(op,JV),Hde={kernelName:op,backendName:"cpu",kernelFunc:Gde},jde=Cn(ip,t=>Math.log1p(t)),qde={kernelName:ip,backendName:"cpu",kernelFunc:jde},Kde=wr((t,n)=>t&&n),Xde=Br(ly,Kde,null,"bool"),Yde={kernelName:ly,backendName:"cpu",kernelFunc:Xde},Zde=Cn(uy,t=>t?0:1,"bool"),Qde={kernelName:uy,backendName:"cpu",kernelFunc:Zde},Jde=wr((t,n)=>t||n),ehe=Br(cy,Jde,null,"bool"),the={kernelName:cy,backendName:"cpu",kernelFunc:ehe},rhe={kernelName:dy,backendName:"cpu",kernelFunc:function nhe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{depthRadius:o,bias:i,alpha:a,beta:l}=r;mt(s,"LRN");const u=s.shape[3],c=u-1,d=e.data.get(s.dataId).values,h=_e(s.shape),p=new Float32Array(h);function f(g){const m=g%u;let y=g-m+Math.max(0,m-o);const v=g-m+Math.min(m+o,c);let b=0;for(;y<=v;y++){const x=d[y];b+=x*x}return b}for(let g=0;g<h;g++){const m=f(g),y=d[g]*Math.pow(i+a*m,-l);p[g]=y}return e.makeTensorInfo(s.shape,s.dtype,p)}},ohe={kernelName:fC,backendName:"cpu",kernelFunc:function she(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,y:o,dy:i}=n,{depthRadius:a,bias:l,alpha:u,beta:c}=r;mt(i,"LRNGrad");const d=_e(i.shape),h=i.shape[3],p=e.data.get(i.dataId).values,f=e.data.get(s.dataId).values,g=e.data.get(o.dataId).values,m=new Float32Array(d),y=d;for(let v=0;v<y;v++){const b=v%h,x=v-b+Math.max(0,b-a),w=v-b+Math.min(h,b+a+1);let k=0;for(let V=x;V<w;V++)k+=Math.pow(f[V],2);k=u*k+l;for(let V=x;V<w;V++){let z=-2*u*c*f[V]*g[v]/k;v===V&&(z+=Math.pow(k,-c)),z*=p[v],m[V]+=z}}return e.makeTensorInfo(i.shape,s.dtype,m)}};function e3(t,n,e,r){const s=ts(r,_e(e));for(let o=0;o<s.length;++o){const i=o*n;let a=t[i];for(let l=0;l<n;++l){const u=t[i+l];(Number.isNaN(u)||u>a)&&(a=u)}s[o]=a}return s}function t3(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{reductionIndices:o,keepDims:i}=r,a=e;let l=s.shape;const u=l.length,c=Jt(o,l);let d=c;const h=Qn(d,u);let p=a.data.get(s.dataId).values;if(null!=h){const x=new Array(u);for(let w=0;w<x.length;w++)x[w]=l[h[w]];p=CI(p,l,s.dtype,h,x),d=fr(d.length,u),l=x}mt(s,"max"),Hr("max",d,u);const[f,g]=$r(l,d),y=e3(p,_e(g),f,s.dtype),v=a.write(y,f,s.dtype);let b=f;return i&&(b=pr(f,c)),{dataId:v,shape:b,dtype:s.dtype}}const ihe={kernelName:hy,backendName:"cpu",kernelFunc:t3},n3=wr((t,n)=>Math.max(t,n)),ahe=Br(ap,n3),lhe={kernelName:ap,backendName:"cpu",kernelFunc:ahe},che={kernelName:py,backendName:"cpu",kernelFunc:function uhe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n;mt(s,"maxPool");const{filterSize:o,strides:i,pad:a,dimRoundingMode:l}=r;R(Gr(i,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`);const c=Ro(s.shape,o,i,1,a,l);let d;if(1===c.filterWidth&&1===c.filterHeight&&gn(c.inShape,c.outShape))d=Bi({inputs:{x:s},backend:e});else{const h=e.data.get(s.dataId).values,p=xt(s.shape),f=SI(h,0,s.dtype,p,c,"max");d=e.makeTensorInfo(c.outShape,s.dtype,f.values)}return d}},hhe={kernelName:fy,backendName:"cpu",kernelFunc:function dhe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{filterSize:o,strides:i,pad:a,dimRoundingMode:l,dataFormat:u}=r;mt(s,"maxPool3d");const c=ca(s.shape,o,i,1,a,l,u),h=NV(e.data.get(s.dataId).values,0,s.dtype,xt(s.shape),c,"max");return e.makeTensorInfo(h.shape,"float32",h.values)}},fhe={kernelName:gC,backendName:"cpu",kernelFunc:function phe(t){const{inputs:n,backend:e,attrs:r}=t,{dy:s,input:o}=n,{filterSize:i,strides:a,pad:l,dimRoundingMode:u}=r;mt([s,o],"maxPool3DGrad");const c=ca(o.shape,i,a,1,l,u),h=function Aue(t,n){const e=en(n.outShape,"int32"),r=n.strideDepth,s=n.strideHeight,o=n.strideWidth,i=n.dilationDepth,a=n.dilationHeight,l=n.dilationWidth,u=n.effectiveFilterDepth,c=n.effectiveFilterHeight,d=n.effectiveFilterWidth,h=n.padInfo.front,p=n.padInfo.top,f=n.padInfo.left;for(let g=0;g<n.batchSize;++g)for(let m=0;m<n.inChannels;++m)for(let y=0;y<n.outDepth;++y){const v=y*r-h;let b=v;for(;b<0;)b+=i;const x=Math.min(n.inDepth,u+v);for(let w=0;w<n.outHeight;++w){const k=w*s-p;let V=k;for(;V<0;)V+=a;const z=Math.min(n.inHeight,c+k);for(let K=0;K<n.outWidth;++K){const Y=K*o-f;let se=Y;for(;se<0;)se+=l;const fe=Math.min(n.inWidth,d+Y);let ve=Number.NEGATIVE_INFINITY,be=-1;for(let xe=b;xe<x;xe+=i){const De=xe-v;for(let Ne=V;Ne<z;Ne+=a){const we=Ne-k;for(let Ae=se;Ae<fe;Ae+=l){const ze=Ae-Y,He=t.get(g,xe,Ne,Ae,m);He>=ve&&(ve=He,be=De*c*d+we*c+ze)}}}e.set(be,g,y,w,K,m)}}}return e}(e.bufferSync(o),c),p=c.strideDepth,f=c.strideHeight,g=c.strideWidth,m=c.dilationDepth,y=c.dilationHeight,v=c.dilationWidth,b=c.effectiveFilterDepth,x=c.effectiveFilterHeight,w=c.effectiveFilterWidth,k=b-1-c.padInfo.front,V=w-1-c.padInfo.left,z=x-1-c.padInfo.top,K=en(o.shape,"float32"),Y=e.bufferSync(s);for(let se=0;se<c.batchSize;++se)for(let fe=0;fe<c.inChannels;++fe)for(let ve=0;ve<c.inDepth;++ve)for(let be=0;be<c.inHeight;++be)for(let xe=0;xe<c.inWidth;++xe){const De=ve-k,Ne=be-z,we=xe-V;let Ae=0;for(let ze=0;ze<b;ze+=m){const He=(De+ze)/p;if(!(He<0||He>=c.outDepth||Math.floor(He)!==He))for(let Ye=0;Ye<x;Ye+=y){const je=(Ne+Ye)/f;if(!(je<0||je>=c.outHeight||Math.floor(je)!==je))for(let st=0;st<w;st+=v){const Je=(we+st)/g;if(Je<0||Je>=c.outWidth||Math.floor(Je)!==Je)continue;const Rt=b*x*w-1-h.get(se,He,je,Je,fe)===ze*x*w+Ye*w+st?1:0;0!==Rt&&(Ae+=Y.get(se,He,je,Je,fe)*Rt)}}}K.set(Ae,se,ve,be,xe,fe)}return e.makeTensorInfo(K.shape,K.dtype,K.values)}},ghe={kernelName:mC,backendName:"cpu",kernelFunc:function mhe(t){const{inputs:n,backend:e,attrs:r}=t,{dy:s,input:o,output:i}=n,a=o;mt([o,i],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:d}=r,h=Ro(a.shape,l,u,1,c,d),p=e.data.get(a.dataId).values,f=en(h.outShape,a.dtype,EV(p,a.shape,a.dtype,h).values),g=h.strideHeight,m=h.strideWidth,y=h.dilationHeight,v=h.dilationWidth,b=h.effectiveFilterHeight,x=h.effectiveFilterWidth,w=x-1-h.padInfo.left,k=b-1-h.padInfo.top,V=en(a.shape,"float32"),z=e.data.get(s.dataId).values,K=en(s.shape,"float32",z);for(let Y=0;Y<h.batchSize;++Y)for(let se=0;se<h.inChannels;++se)for(let fe=0;fe<h.inHeight;++fe)for(let ve=0;ve<h.inWidth;++ve){const be=fe-k,xe=ve-w;let De=0;for(let Ne=0;Ne<b;Ne+=y){const we=(be+Ne)/g;if(!(we<0||we>=h.outHeight||Math.floor(we)!==we))for(let Ae=0;Ae<x;Ae+=v){const ze=(xe+Ae)/m;if(ze<0||ze>=h.outWidth||Math.floor(ze)!==ze)continue;const je=b*x-1-f.get(Y,we,ze,se)===Ne*x+Ae?1:0;0!==je&&(De+=K.get(Y,we,ze,se)*je)}}V.set(De,Y,fe,ve,se)}return e.makeTensorInfo(V.shape,V.dtype,V.values)}},vhe={kernelName:LO,backendName:"cpu",kernelFunc:({inputs:t,attrs:n,backend:e})=>{const{x:r}=t,{filterSize:s,strides:o,pad:i,includeBatchInIndex:a}=n,l=e;mt(r,"MaxPoolWithArgmax");const u=l.data.get(r.dataId).values,c=Ro(r.shape,s,o,[1,1],i),[d,h]=function yhe(t,n,e,r,s){const i=SI(t,0,e,xt(n),s,"max"),a=EV(t,n,e,s,!0,r);return[i.values,a.values]}(u,r.shape,r.dtype,a,c),p=l.write(d,c.outShape,r.dtype),f=l.write(h,c.outShape,r.dtype);return[{dataId:p,shape:c.outShape,dtype:r.dtype},{dataId:f,shape:c.outShape,dtype:"int32"}]}},xhe={kernelName:my,backendName:"cpu",kernelFunc:function bhe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o,keepDims:i}=r,a=Jt(o,s.shape),c=_e($r(s.shape,a)[1]),d=[],h=e.makeTensorInfo([],"float32",new Float32Array([c]));d.push(h);const p=al({inputs:{x:s},backend:e,attrs:{dtype:"float32"}});d.push(p);const f=TI({inputs:{a:p,b:h},backend:e});d.push(f);const g=ff({inputs:{x:f},backend:e,attrs:{axis:o,keepDims:i}});return d.forEach(m=>e.disposeIntermediateTensorInfo(m)),g}},_he={kernelName:gy,backendName:"cpu",kernelFunc:function whe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o,keepDims:i}=r;mt(s,"min");const a=Jt(o,s.shape);let l=a;const u=Qn(l,s.shape.length);let c=s;null!=u&&(c=Ms({inputs:{x:s},backend:e,attrs:{perm:u}}),l=fr(l.length,s.shape.length)),Hr("min",l,c.shape.length);const[d,h]=$r(c.shape,l),p=_e(h),f=ns(_e(d),c.dtype),g=e.data.get(c.dataId).values;for(let y=0;y<f.length;++y){const v=y*p;let b=g[v];for(let x=0;x<p;++x){const w=g[v+x];(Number.isNaN(w)||w<b)&&(b=w)}f[y]=b}null!=u&&e.disposeIntermediateTensorInfo(c);const m=e.makeTensorInfo(d,c.dtype,f);if(i){const v=$n({inputs:{x:m},backend:e,attrs:{shape:pr(d,a)}});return e.disposeIntermediateTensorInfo(m),v}return m}},r3=wr((t,n)=>Math.min(t,n)),Che=Br(lp,r3),She={kernelName:lp,backendName:"cpu",kernelFunc:Che},Dhe={kernelName:yy,backendName:"cpu",kernelFunc:function Ihe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{paddings:o,mode:i}=r;mt(s,"mirrorPad");const a=o.map((b,x)=>b[0]+s.shape[x]+b[1]),l=o.map(b=>b[0]),u=o.map((b,x)=>b[0]+s.shape[x]),c="reflect"===i?0:1,d=e.data.get(s.dataId).values,h=s.shape.length,p=xt(s.shape),f=_e(a),g=a.length,m=xt(a),y=ts(s.dtype,f);for(let b=0;b<f;b++){let x=Ic(b,g,m);for(let k=0;k<g;k++)x[k]<l[k]?x[k]=2*l[k]-x[k]-c:x[k]>=u[k]&&(x[k]=2*(u[k]-1)-x[k]+c);x=x.map((k,V)=>k-l[V]);const w=Di(x,h,p);y[b]=d[w]}return{dataId:e.write(y,a,s.dtype),shape:a,dtype:s.dtype}}},The=wr((t,n)=>{const e=t%n;return t<0&&n<0||t>=0&&n>=0?e:(e+n)%n}),khe=Br(up,The),Ehe={kernelName:up,backendName:"cpu",kernelFunc:khe};function s3(t){const{inputs:n,backend:e,attrs:r}=t,{logits:s}=n,{dim:o}=r,i=s.shape.length;let a=o;if(-1===a&&(a=i-1),a!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${a}`);const l=Jt([a],s.shape),u=t3({inputs:{x:s},backend:e,attrs:{reductionIndices:l,keepDims:!1}}),c=pr(u.shape,l),d=$n({inputs:{x:u},backend:e,attrs:{shape:c}}),h=EI({inputs:{a:s,b:d},backend:e}),p=BV({inputs:{x:h},backend:e}),f=ff({inputs:{x:p},backend:e,attrs:{axis:l,keepDims:!1}}),g=$n({inputs:{x:f},backend:e,attrs:{shape:c}}),m=TI({inputs:{a:p,b:g},backend:e});return e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(g),m}const Nhe={kernelName:Py,backendName:"cpu",kernelFunc:s3},Rhe={kernelName:VO,backendName:"cpu",kernelFunc:function Ahe(t){const{inputs:n,backend:e,attrs:r}=t,{logits:s}=n,{numSamples:o,seed:i,normalized:a}=r;mt(s,"multinomial");const l=a?s:s3({inputs:{logits:s},backend:e,attrs:{dim:-1}}),u=l.shape[0],c=l.shape[1],d=e.data.get(l.dataId).values,h=[u,o],p=ns(_e(h),"int32");for(let f=0;f<u;++f){const g=f*c,m=new Float32Array(c-1);m[0]=d[g];for(let b=1;b<m.length;++b)m[b]=m[b-1]+d[g+b];const y=O1.alea(i.toString()),v=f*o;for(let b=0;b<o;++b){const x=y();p[v+b]=m.length;for(let w=0;w<m.length;w++)if(x<m[w]){p[v+b]=w;break}}}return a||e.disposeIntermediateTensorInfo(l),e.makeTensorInfo(h,"int32",p)}};function o3(t,n,e){const r=Ba(-1,e);return DI([],n,r,t,e)}const Ohe={kernelName:vy,backendName:"cpu",kernelFunc:function Fhe(t){const{inputs:n,backend:e}=t,{x:r}=n;mt(r,"neg");const s=e.data.get(r.dataId).values,[o,i]=o3(s,r.shape,r.dtype);return e.makeTensorInfo(i,r.dtype,o)}},Phe=H1,$he={kernelName:yC,backendName:"cpu",kernelFunc:function Mhe(t){const{inputs:n,backend:e,attrs:r}=t,{boxes:s,scores:o}=n,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l}=r;mt(s,"NonMaxSuppression");const u=e.data.get(s.dataId).values,c=e.data.get(o.dataId).values,{selectedIndices:d}=Phe(u,c,i,a,l);return e.makeTensorInfo([d.length],"int32",new Int32Array(d))}},Lhe=j1,Bhe={kernelName:vC,backendName:"cpu",kernelFunc:function Vhe(t){const{inputs:n,backend:e,attrs:r}=t,{boxes:s,scores:o}=n,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:u}=r;mt(s,"NonMaxSuppressionPadded");const c=e.data.get(s.dataId).values,d=e.data.get(o.dataId).values,{selectedIndices:h,validOutputs:p}=Lhe(c,d,i,a,l,u);return[e.makeTensorInfo([h.length],"int32",new Int32Array(h)),e.makeTensorInfo([],"int32",new Int32Array([p]))]}},zhe=q1,Whe={kernelName:bC,backendName:"cpu",kernelFunc:function Uhe(t){const{inputs:n,backend:e,attrs:r}=t,{boxes:s,scores:o}=n,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l,softNmsSigma:u}=r;mt(s,"NonMaxSuppressionWithScore");const c=e.data.get(s.dataId).values,d=e.data.get(o.dataId).values,h=i,p=a,f=l,g=u,{selectedIndices:m,selectedScores:y}=zhe(c,d,h,p,f,g);return[e.makeTensorInfo([m.length],"int32",new Int32Array(m)),e.makeTensorInfo([y.length],"float32",new Float32Array(y))]}},i3=wr((t,n)=>t!==n?1:0),Ghe=Br(by,i3,null,"bool"),Hhe={kernelName:by,backendName:"cpu",kernelFunc:Ghe},qhe={kernelName:wy,backendName:"cpu",kernelFunc:function jhe(t){const{inputs:n,backend:e,attrs:r}=t,{indices:s}=n,{dtype:o,depth:i,onValue:a,offValue:l}=r;mt(s,"oneHot");const u=_e(s.shape),c=new Float32Array(u*i);c.fill(l);const d=e.data.get(s.dataId).values;for(let h=0;h<u;++h)d[h]>=0&&d[h]<i&&(c[h*i+d[h]]=a);return e.makeTensorInfo([...s.shape,i],o,c)}};function nb(t){const{inputs:n,backend:e}=t,{x:r}=n;if("string"===r.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===r.dtype){const s=du({inputs:{input:r},backend:e}),o=nb({inputs:{x:s},backend:e}),i=Yc({inputs:{input:r},backend:e}),a=nb({inputs:{x:i},backend:e}),l=js({inputs:{real:o,imag:a},backend:e});return e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),l}return AI({backend:e,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}const Khe={kernelName:Vy,backendName:"cpu",kernelFunc:nb},Xhe={kernelName:xy,backendName:"cpu",kernelFunc:function a3(t){const{inputs:n,backend:e}=t,{x:r}=n;if("string"===r.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===r.dtype){const s=du({inputs:{input:r},backend:e}),o=a3({inputs:{x:s},backend:e}),i=Yc({inputs:{input:r},backend:e}),a=nb({inputs:{x:i},backend:e}),l=js({inputs:{real:o,imag:a},backend:e});return e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),l}return AI({backend:e,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}};function l3(t){const{inputs:n,backend:e,attrs:r}=t,{axis:s}=r;if(1===n.length)return tb({inputs:{input:n[0]},backend:e,attrs:{dim:s}});const o=n[0].shape,i=n[0].dtype;n.forEach(c=>{No(o,c.shape,"All tensors passed to stack must have matching shapes"),R(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],u=Zc({inputs:n.map(c=>{const d=tb({inputs:{input:c},backend:e,attrs:{dim:s}});return a.push(d),d}),backend:e,attrs:{axis:s}});return a.forEach(c=>e.disposeIntermediateTensorInfo(c)),u}const Yhe={kernelName:_y,backendName:"cpu",kernelFunc:l3},u3={kernelName:Cy,backendName:"cpu",kernelFunc:function Zhe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{paddings:o,constantValue:i}=r;mt(s,"pad");const a=o.map((v,b)=>v[0]+s.shape[b]+v[1]),l=o.map(v=>v[0]),u=e.data.get(s.dataId).values,c=_e(s.shape),d=s.shape.length,h=xt(s.shape),p=_e(a),f=a.length,g=xt(a),m=ts(s.dtype,p);0!==i&&m.fill(i);for(let v=0;v<c;v++)m[Di(Ic(v,d,h).map((k,V)=>k+l[V]),f,g)]=u[v];return{dataId:e.write(m,a,s.dtype),shape:a,dtype:s.dtype}}},Qhe=wr((t,n)=>Math.pow(t,n)),Jhe=Br(dp,Qhe),epe={kernelName:dp,backendName:"cpu",kernelFunc:Jhe};function c3(t,n,e,r){const[s,o]=$r(t,r),i=Ws(n,"int32"),a=ns(_e(s),i),l=_e(o);for(let u=0;u<a.length;++u){const c=u*l;let d=1;for(let h=0;h<l;++h)d*=e[c+h];a[u]=d}return{outVals:a,outShape:s,outDtype:i}}const npe={kernelName:Iy,backendName:"cpu",kernelFunc:function tpe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o,keepDims:i}=r;mt(s,"prod");const a=s.shape.length,l=Jt(o,s.shape),u=Qn(l,a);let c=l,d=s;const h=[];null!=u&&(d=Ms({inputs:{x:s},backend:e,attrs:{perm:u}}),h.push(d),c=fr(c.length,a));const p=e.data.get(d.dataId).values,{outVals:f,outShape:g,outDtype:m}=c3(d.shape,d.dtype,p,c);let y=g;return i&&(y=pr(g,l)),h.forEach(v=>e.disposeIntermediateTensorInfo(v)),e.makeTensorInfo(y,m,f)}};function d3(t,n){const e=t.slice(0,n);for(;e.length<n;)e.push(1);for(let r=n;r<t.length;r++)e[n-1]*=t[r];return e}function h3(t,n,e,r,s,o,i,a){if(0===t.length)throw new Error("paramsNestedSplits must be non empty");if(0===n[0].length)throw new Error("Split tensors must not be scalars");if(function rpe(t,n,e){t.forEach((r,s)=>{if(r<0||r>=e){const o=Ic(s,n.length,xt(n)).join(",");throw new Error(`indices[${o}] = ${r} is not in [0, ${e})`)}})}(o,i,n[0][0]-1),0===r.length)throw new Error("params.rank must be nonzero");const u=r[0],{outSplits:c,valueSlices:d,numValues:h}=function ope(t,n,e,r){const s=[];let o=0;const a=new Array(n.length-1+e.length).fill(null).map(()=>[0]);!function spe(t,n){for(let e=0;e<t.length;++e){const r=t[e],s=e===t.length-1?n:t[e+1].length;if(0===r.length)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>s)throw new Error("Ragged splits must not point past values");for(let o=1;o<r.length;++o)if(r[o-1]>r[o])throw new Error("Ragged splits must be sorted in ascending order")}}(e,r);let l=1;for(let u=0;u<n.length-1;++u){l*=n[u];const c=n[u+1];for(let d=1;d<l+1;++d)a[u].push(d*c)}for(let u=0;u<t.length;++u){let c=t[u],d=t[u]+1;for(let h=0;h<e.length;++h){const p=e[h],f=h+n.length-1;if(f>=0){const g=a[f],m=g[g.length-1]-p[c];for(let y=c;y<d;++y)a[f].push(p[y+1]+m)}c=p[c],d=p[d]}d!==c&&(s.push([c,d]),o+=d-c)}return{outSplits:a,valueSlices:s,numValues:o}}(o,i,t,u),p=function ipe(t){const n=[];for(let e=0;e<t.length;++e){const s=cr("int32",t[e].length);n.push(s),t[e].forEach((o,i)=>s[i]=o)}return n}(c),f=function lpe(t,n,e,r,s){const o=n.slice();o[0]=s;const i=cr(e,_e(o)),a=t.length;return function ape(t,n,e,r,s,o){const i=d3(n,2)[1],a=d3(o,2)[1];let l=0;for(const u of e)for(let c=u[0];c<u[1];++c){for(let d=0;d<r;++d)s[l*a+d]=t[c*i+d];++l}}(t,n,r,0===a?0:a/n[0],i,o),[i,o]}(e,r,s,d,h);return[p,f[0],f[1]]}const cpe={kernelName:BO,backendName:"cpu",kernelFunc:function upe(t){const{inputs:n,backend:e,attrs:r}=t,{paramsNestedSplits:s,paramsDenseValues:o,indices:i}=n,l=s.map(y=>e.data.get(y.dataId).values),u=s.map(y=>y.shape),c=e.data.get(o.dataId).values,d=e.data.get(i.dataId).values,[h,p,f]=h3(l,u,c,o.shape,o.dtype,d,i.shape),g=h.map(y=>e.makeTensorInfo([y.length],"int32",y)),m=e.makeTensorInfo(f,o.dtype,p);return g.concat([m])}},p3=2147483647;function f3(t,n,e,r,s,o,i){if(n.length>1)throw new Error("starts must be a scalar or vector");if(s.length>1)throw new Error("limits must be a scalar or vector");if(i.length>1)throw new Error("deltas must be a scalar or vector");const a=0===n.length,l=0===s.length,u=0===i.length,c=[];a||c.push(n[0]),l||c.push(s[0]),u||c.push(i[0]);for(let m=1;m<c.length;++m)if(c[m]!==c[m-1])throw new Error("starts, limits, and deltas must have the same shape");const d=0===c.length?1:c[0],h=cr("int32",d+1);h[0]=0;for(let m=0;m<d;++m){const y=a?t[0]:t[m],v=l?r[0]:r[m],b=u?o[0]:o[m];if(0===b)throw new Error("Requires delta != 0");let x;if(b>0&&v<y||b<0&&v>y)x=0;else if(x=Math.ceil(Math.abs((v-y)/b)),x>p3)throw new Error(`Requires ((limit - start) / delta) <= ${p3}`);h[m+1]=h[m]+x}const f=cr(e,h[d]);let g=0;for(let m=0;m<d;++m){const y=h[m+1]-h[m];let v=a?t[0]:t[m];const b=u?o[0]:o[m];for(let x=0;x<y;++x)f[g++]=v,v+=b}return[h,f]}const hpe={kernelName:zO,backendName:"cpu",kernelFunc:function dpe(t){const{inputs:n,backend:e}=t,{starts:r,limits:s,deltas:o}=n,i=e.data.get(r.dataId).values,a=e.data.get(s.dataId).values,l=e.data.get(o.dataId).values,[u,c]=f3(i,r.shape,r.dtype,a,s.shape,l,o.shape);return[e.makeTensorInfo([u.length],"int32",u),e.makeTensorInfo([c.length],r.dtype,c)]}};var Bo=Mo;class rb{constructor(n,e,r,s,o,i,a,l,u,c){this.shape=n,this.shapeShape=e,this.values=r,this.valuesShape=s,this.valuesDType=o,this.defaultValue=i,this.defaultValueShape=a,this.rowPartitionValues=l,this.rowPartitionValuesShapes=u,this.rowPartitionTypes=kM(c),this.raggedRank=EM(this.rowPartitionTypes)}getRowPartitionTypeByDimension(n){return this.rowPartitionTypes[0]===Bo.FIRST_DIM_SIZE?this.rowPartitionTypes[n+1]:this.rowPartitionTypes[n]}getRowPartitionTensor(n){return this.rowPartitionTypes[0]===Bo.FIRST_DIM_SIZE?this.rowPartitionValues[n+1]:this.rowPartitionValues[n]}getMaxWidth(n){const e=this.getRowPartitionTensor(n-1);switch(this.getRowPartitionTypeByDimension(n-1)){case Bo.VALUE_ROWIDS:return rb.getMaxWidthValueRowID(e);case Bo.ROW_SPLITS:return rb.getMaxWidthRowSplit(e);default:throw new Error(`Cannot handle partition type ${Bo[this.getRowPartitionTypeByDimension(n-1)]}`)}}static getMaxWidthRowSplit(n){const e=n.length;if(0===e||1===e)return 0;let r=0;for(let s=0;s<e-1;++s){const o=n[s+1]-n[s];o>r&&(r=o)}return r}static getMaxWidthValueRowID(n){const e=n.length;if(0===e)return 0;let r=0,s=n[0],o=0;for(let i=1;i<e;++i){const a=n[i];a!==s&&(s=a,o=Math.max(i-r,o),r=i)}return Math.max(e-r,o)}tensorShapeFromTensor(n,e,r=!0){if(0===e.length){if(-1===n[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return g3(n,r)}calculateOutputSize(n){const e=this.valuesShape;NM(this.defaultValueShape,e);const s=this.tensorShapeFromTensor(this.shape,this.shapeShape),i=TM(this.raggedRank,s,e);i[0]<0&&(i[0]=n);for(let a=1;a<=this.raggedRank;++a)i[a]<0&&(i[a]=this.getMaxWidth(a));return i}calculateFirstParentOutputIndex(n,e,r){const s=Math.min(n,r),o=[];let i=0;for(let a=0;a<s;++a,i+=e)o.push(i);for(let a=s;a<n;++a)o.push(-1);return R(o.length===n,()=>"Final length of result must be equal to firstDimension."),o}calculateOutputIndexRowSplit(n,e,r,s){const o=n.length,i=[];for(let a=0;a<o-1;++a){const l=n[a+1]-n[a];let u=Math.min(s,l),c=e[a];-1===c&&(u=0);for(let d=0;d<u;++d)i.push(c),c+=r;for(let d=0;d<l-u;++d)i.push(-1)}if(o>0&&i.length!==n[o-1])throw new Error("Invalid row split size.");return i}calculateOutputIndexValueRowID(n,e,r,s){const o=n.length,i=[];if(0===o)return[];let a=0,l=n[0];if(l>=e.length)throw new Error(`Got currentValueRowId=${l}, which is not less than ${e.length}`);let u=e[l];i.push(u);for(let c=1;c<o;++c){const d=n[c];if(d===l)u>=0&&(++a,a<s?u+=r:u=-1);else{if(a=0,l=d,d>=e.length)throw new Error(`Got nextValueRowId=${d} which is not less than ${e.length}`);u=e[d]}i.push(u)}if(i.length!==n.length)throw new Error("Invalid row ids.");return i}calculateOutputIndex(n,e,r,s){const o=this.getRowPartitionTensor(n),i=this.getRowPartitionTypeByDimension(n);switch(i){case Bo.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(o,e,r,s);case Bo.ROW_SPLITS:if(o.length-1>e.length)throw new Error(`Row partition size is greater than output size: ${o.length-1} > ${e.length}`);return this.calculateOutputIndexRowSplit(o,e,r,s);default:throw new Error(`Unsupported partition type: ${Bo[i]}`)}}getFirstDimensionSize(){const n=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");const e=this.rowPartitionTypes[0];switch(e){case Bo.FIRST_DIM_SIZE:return n[0];case Bo.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case Bo.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${Bo[e]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const e=this.getFirstDimensionSize(),r=this.calculateOutputSize(e),s=new Array(this.raggedRank+1);s[s.length-1]=1;for(let l=s.length-2;l>=0;--l)s[l]=s[l+1]*r[l+1];const o=g3(r,!1),i=cr(this.valuesDType,_e(o));if(s[0]*r[0]>0){let l=this.calculateFirstParentOutputIndex(e,s[0],r[0]);for(let u=1;u<=this.raggedRank;++u)l=this.calculateOutputIndex(u-1,l,s[u],r[u]);this.setOutput(this.raggedRank,l,i,o)}return[o,i]}setOutput(n,e,r,s){if(0===r.length)return;const o=this.values,i=r;let a=s.slice();a=a.slice(n+1);const l=_e(a),u=e.length;let c=this.defaultValue;if(c.length!==l&&1!==c.length){const f=this.defaultValueShape;he(()=>{const g=re(c,f);c=Up(g,a).dataSync()})}let d=0,h=0,p=0;for(let f=0;f<=u;++f){let g=f<u?e[f]:-1;if(g!==p){if(h<p){const m=o.subarray(d*l);m3(i.subarray(h*l),m,(p-h)*l)}if(f>=u&&(g=Math.floor(r.length/l)),g>p)if(1===this.defaultValue.length)i.subarray(p*l,g*l).fill(this.defaultValue[0]),p=g;else for(;g>p;)m3(i.slice(p*l),c,l),++p;g<0?(d=f+1,h=p):(d=f,h=p,p=h+1)}else++p}}}function m3(t,n,e){for(let r=0;r<e;r++)t[r]=n[r]}function g3(t,n){const e=[];for(let r of t){if(r<0){if(!n)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}e.push(r)}return e}function y3(t,n,e,r,s,o,i,a,l,u){return new rb(t,n,e,r,s,o,i,a,l,u).compute()}const fpe={kernelName:UO,backendName:"cpu",kernelFunc:function ppe(t){const{inputs:n,backend:e,attrs:r}=t,{shape:s,values:o,defaultValue:i,rowPartitionTensors:a}=n,{rowPartitionTypes:l}=r,u=e.data.get(s.dataId).values,c=e.data.get(o.dataId).values,d=e.data.get(i.dataId).values,h=a.map(m=>e.data.get(m.dataId).values),p=a.map(m=>m.shape),[f,g]=y3(u,s.shape,c,o.shape,o.dtype,d,i.shape,h,p,l);return e.makeTensorInfo(f,o.dtype,g)}};function v3(t,n,e,r){if(t===n||t<n&&e<0||n<t&&e>1)return ns(0,r);const l=ns(Math.abs(Math.ceil((n-t)/e)),r);n<t&&1===e&&(e=-1),l[0]=t;for(let u=1;u<l.length;u++)l[u]=l[u-1]+e;return l}const gpe={kernelName:xC,backendName:"cpu",kernelFunc:function mpe(t){const{backend:n,attrs:e}=t,{start:r,stop:s,dtype:o,step:i}=e,a=v3(r,s,i,o);return n.makeTensorInfo([a.length],o,a)}},ype=Cn(hp,t=>1/t),vpe={kernelName:hp,backendName:"cpu",kernelFunc:ype},xpe={kernelName:ky,backendName:"cpu",kernelFunc:function bpe(t){const{inputs:n,backend:e,attrs:r}=t,{images:s}=n,{alignCorners:o,halfPixelCenters:i,size:a}=r;mt(s,"resizeBilinear");const l=xt(s.shape),[u,c]=a,[d,h,p,f]=s.shape,g=e.data.get(s.dataId).values,m=new Float32Array(_e([d,u,c,f])),y=[o&&u>1?h-1:h,o&&c>1?p-1:p],v=[o&&u>1?u-1:u,o&&c>1?c-1:c];let b=0;const x=y[0]/v[0],w=y[1]/v[1];for(let k=0;k<d;k++)for(let V=0;V<u;V++){let z;z=i?x*(V+.5)-.5:x*V;const K=Math.max(0,Math.floor(z)),Y=z-K,se=Math.min(h-1,Math.ceil(z)),fe=k*l[0]+K*l[1],ve=k*l[0]+se*l[1];for(let be=0;be<c;be++){let xe;xe=i?w*(be+.5)-.5:w*be;const De=Math.max(0,Math.floor(xe)),Ne=xe-De,we=Math.min(p-1,Math.ceil(xe)),Ae=fe+De*l[2],ze=ve+De*l[2],He=fe+we*l[2],Ye=ve+we*l[2];for(let je=0;je<f;je++){const st=g[Ae+je],Je=g[ze+je],Rt=st+(g[He+je]-st)*Ne;m[b++]=Rt+(Je+(g[Ye+je]-Je)*Ne-Rt)*Y}}}return e.makeTensorInfo([d,u,c,f],"float32",m)}},_pe={kernelName:CC,backendName:"cpu",kernelFunc:function wpe(t){const{inputs:n,backend:e,attrs:r}=t,{images:s,dy:o}=n,{alignCorners:i}=r;mt([o,s],"resizeBilinearGrad");const a=xt(s.shape),[l,u,c,d]=s.shape,[,h,p]=o.shape,f=new Float32Array(l*u*c*d),g=[i&&h>1?u-1:u,i&&p>1?c-1:c],m=[i&&h>1?h-1:h,i&&p>1?p-1:p],y=g[0]/m[0],v=g[1]/m[1],b=e.data.get(o.dataId).values;let x=0;for(let w=0;w<l;w++){const k=w*a[0];for(let V=0;V<h;V++){const z=V*y,K=Math.floor(z),Y=Math.min(Math.ceil(z),u-1),se=k+K*a[1],fe=k+Y*a[1],ve=z-K,be=1-ve;for(let xe=0;xe<p;xe++){const De=xe*v,Ne=Math.floor(De),we=Math.min(Math.ceil(De),c-1),Ae=De-Ne,ze=1-Ae,He=se+Ne*a[2],Ye=se+we*a[2],je=fe+Ne*a[2],st=fe+we*a[2],Je=be*ze,ct=be*Ae,_t=ve*ze,Rt=ve*Ae;for(let Tt=0;Tt<d;Tt++){const Ht=b[x++];f[He+Tt]+=Ht*Je,f[Ye+Tt]+=Ht*ct,f[je+Tt]+=Ht*_t,f[st+Tt]+=Ht*Rt}}}}return e.makeTensorInfo([l,c,u,d],"float32",f)}},Spe={kernelName:Ty,backendName:"cpu",kernelFunc:function Cpe(t){const{inputs:n,backend:e,attrs:r}=t,{images:s}=n,{alignCorners:o,halfPixelCenters:i,size:a}=r;mt(s,"resizeNearestNeighbor");const l=xt(s.shape),[u,c]=a,[d,h,p,f]=s.shape,g=e.data.get(s.dataId).values,m=new Float32Array(d*u*c*f),y=[o&&u>1?h-1:h,o&&c>1?p-1:p],v=[o&&u>1?u-1:u,o&&c>1?c-1:c],b=y[0]/v[0],x=y[1]/v[1];let w=0;for(let k=0;k<d;k++){const V=k*l[0];for(let z=0;z<u;z++){const K=i?b*(z+.5):b*z;let Y=Math.min(h-1,o?Math.round(K):Math.floor(K));i&&(Y=Math.max(0,Y));const se=V+Y*l[1];for(let fe=0;fe<c;fe++){const ve=i?x*(fe+.5):x*fe;let be=Math.min(p-1,o?Math.round(ve):Math.floor(ve));i&&(be=Math.max(0,be));const xe=se+be*l[2];for(let De=0;De<f;De++)m[w++]=g[xe+De]}}}return e.makeTensorInfo([d,u,c,f],s.dtype,m)}},Dpe={kernelName:_C,backendName:"cpu",kernelFunc:function Ipe(t){const{inputs:n,backend:e,attrs:r}=t,{images:s,dy:o}=n,{alignCorners:i}=r;mt([o,s],"resizeNearestNeighborGrad");const a=xt(s.shape),l=xt(o.shape),[u,c,d,h]=s.shape,[,p,f]=o.shape,g=new Float32Array(u*c*d*h),m=e.data.get(o.dataId).values,y=[i&&p>1?c-1:c,i&&f>1?d-1:d],v=[i&&p>1?p-1:p,i&&f>1?f-1:f],b=y[0]/v[0],x=y[1]/v[1],w=1/b,k=1/x,V=2*Math.ceil(w)+2,z=2*Math.ceil(k)+2;for(let K=0;K<u;K++){const Y=K*a[0];for(let se=0;se<c;se++){const fe=Y+se*a[1],ve=Math.floor(se*w),be=Math.floor(ve-V/2);for(let xe=0;xe<d;xe++){const De=fe+xe*a[2],Ne=Math.floor(xe*k),we=Math.floor(Ne-z/2);for(let Ae=0;Ae<h;Ae++){let ze=0;for(let He=0;He<V;He++){const Ye=He+be;if(Ye<0||Ye>=p)continue;const je=Y+Ye*l[1],st=Ye*b;if(se===Math.min(c-1,i?Math.round(st):Math.floor(st)))for(let ct=0;ct<z;ct++){const _t=ct+we;if(_t<0||_t>=f)continue;const Rt=je+_t*l[2],Tt=_t*x;xe===Math.min(d-1,i?Math.round(Tt):Math.floor(Tt))&&(ze+=m[Rt+Ae])}}g[De+Ae]=ze}}}}return e.makeTensorInfo(s.shape,s.dtype,g)}},kpe={kernelName:Ey,backendName:"cpu",kernelFunc:function Tpe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{dims:o}=r;mt(s,"reverse");const i=s.shape.length,a=Jt(o,s.shape);if(0===i)return Bi({inputs:{x:s},backend:e});const l=new Wr(s.shape,s.dtype),u=e.bufferSync(s);for(let c=0;c<l.size;c++){const d=l.indexToLoc(c),h=d.slice();a.forEach(p=>h[p]=s.shape[p]-1-h[p]),l.set(u.get(...h),...d)}return e.makeTensorInfo(l.shape,l.dtype,l.values)}},Epe={kernelName:$C,backendName:"cpu",kernelFunc:({inputs:t,attrs:n,backend:e})=>{const{image:r}=t,{radians:s,fillValue:o,center:i}=n,a=e,l=ts(r.dtype,_e(r.shape)),[u,c,d,h]=r.shape,[p,f]=eS(i,c,d),m=Math.sin(s),y=Math.cos(s),v=a.data.get(r.dataId).values;for(let x=0;x<u;x++){const w=x*d*c*h;for(let k=0;k<c;k++){const V=k*(d*h);for(let z=0;z<d;z++){const K=z*h;for(let Y=0;Y<h;Y++){const se=[u,k,z,Y],fe=se[2],ve=se[1];let be=(fe-p)*y-(ve-f)*m,xe=(fe-p)*m+(ve-f)*y;be=Math.round(be+p),xe=Math.round(xe+f);let De=o;"number"!=typeof o&&(De=3===Y?255:o[Y]),be>=0&&be<d&&xe>=0&&xe<c&&(De=v[w+xe*(d*h)+be*h+Y]),l[w+V+K+Y]=De}}}}return{dataId:a.write(l,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},Npe=Cn(mp,t=>{const n=Math.floor(t);return t-n<.5?Math.floor(t):t-n>.5?Math.ceil(t):n%2==0?n:n+1}),Ape={kernelName:mp,backendName:"cpu",kernelFunc:Npe},b3=Vi(t=>1/Math.sqrt(t)),Rpe=il(gp,b3),Fpe={kernelName:gp,backendName:"cpu",kernelFunc:Rpe};function pu(t,n,e,r,s,o,i,a,l,u){const c=[r/s,s],d=t.values,h=n.values;if(0===r)return en(e,n.dtype);const p=l instanceof Wr?l:en(c,n.dtype);"string"==typeof l||"number"==typeof l?p.values.fill(l):"boolean"==typeof l&&p.values.fill(+l);for(let f=0;f<o;f++){const g=[];let m=0;for(let y=0;y<i;y++){const v=d[f*i+y];g.push(v),m+=v*a[y]}if(m<0||m>=r/s)throw new Error(`Invalid indices: ${g} does not index into ${e}`);for(let y=0;y<s;y++)u?p.values[m*s+y]+=h[f*s+y]:p.values[m*s+y]=0===n.rank?h[0]:h[f*s+y]}return p}const Ppe={kernelName:WO,backendName:"cpu",kernelFunc:function Ope(t){const{inputs:n,backend:e,attrs:r}=t,{indices:s,updates:o}=n,{shape:i}=r,{sliceRank:a,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=ru(0,s,i),g=pu(e.bufferSync(s),e.bufferSync(o),i,d,u,l,a,c,0,!0);return e.makeTensorInfo(i,g.dtype,g.values)}};function Mpe(t,n){let e=0,r=t.length,s=0;for(;e<r;)s=Math.floor((e+r)/2),t[s]<n?e=s+1:r=s;return r}function $pe(t,n){let e=0,r=t.length,s=0;for(;e<r;)s=Math.floor((e+r)/2),t[s]<=n?e=s+1:r=s;return r}const Bpe={kernelName:HO,backendName:"cpu",kernelFunc:function Vpe(t){const{inputs:n,backend:e,attrs:r}=t,{sortedSequence:s,values:o}=n,{side:i}=r,u=function Lpe(t,n,e,r,s,o){const i=cr("int32",e*s);for(let a=0;a<e;++a){const l=t.slice(a*r,(a+1)*r),u=a*s;for(let c=0;c<s;++c)i[u+c]="left"===o?Mpe(l,n[c+u]):$pe(l,n[c+u])}return i}(e.data.get(s.dataId).values,e.data.get(o.dataId).values,s.shape[0],s.shape[1],o.shape[1],i);return e.makeTensorInfo(o.shape,"int32",u)}},Upe={kernelName:Ny,backendName:"cpu",kernelFunc:function zpe(t){const{inputs:n,backend:e}=t,{condition:r,t:s,e:o}=n;mt([r,s,o],"select");const i=r.shape.length,a=e.data.get(r.dataId).values,l=e.data.get(s.dataId).values,u=e.data.get(o.dataId).values,c=Ws(s.dtype,o.dtype),d=ns(_e(s.shape),c);let h=0;const p=0===i||i>1||1===s.shape.length?1:_e(s.shape.slice(1));for(let f=0;f<a.length;f++)for(let g=0;g<p;g++)d[h++]=1===a[f]?l[f]:u[f];return e.makeTensorInfo(s.shape,c,d)}},Wpe=xv,Gpe=wv,Hpe=Cn(yp,t=>t>=0?Gpe*t:Wpe*(Math.exp(t)-1)),jpe={kernelName:yp,backendName:"cpu",kernelFunc:Hpe},qpe=Cn(xp,t=>t<0?-1:t>0?1:0),Kpe={kernelName:xp,backendName:"cpu",kernelFunc:qpe},Xpe=Cn(vp,t=>Math.sin(t)),Ype={kernelName:vp,backendName:"cpu",kernelFunc:Xpe},Zpe=Cn(bp,t=>Math.sinh(t)),Qpe={kernelName:bp,backendName:"cpu",kernelFunc:Zpe},x3=Math.log(1.1920928955078125e-7)+2,Jpe=Cn(_p,t=>{const n=t>-x3,e=t<x3,r=Math.exp(t);let s;return s=e?r:n?t:Math.log(1+r),s}),efe={kernelName:_p,backendName:"cpu",kernelFunc:Jpe},nfe={kernelName:Fy,backendName:"cpu",kernelFunc:function tfe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{blockShape:o,paddings:i}=r;mt([s],"spaceToBatchND");const a=_e(o),l=[[0,0]];l.push(...i);for(let k=1+o.length;k<s.shape.length;++k)l.push([0,0]);const u=u3.kernelFunc({inputs:{x:s},backend:e,attrs:{paddings:l,constantValue:0}}),c=Kp(u.shape,o,a,!1),d=Xp(c.length,o.length,!1),h=Yp(u.shape,o,a,!1),g=$n({inputs:{x:u},backend:e,attrs:{shape:c}}),v=Ms({inputs:{x:g},backend:e,attrs:{perm:d}}),w=$n({inputs:{x:v},backend:e,attrs:{shape:h}});return e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(v),w}};function w3(t,n,e,r,s,o,i){const a=n[0],l=o[0],u=new Array(l),c=new Array(a),d=n[1];if(0===l){if(0!==a)throw new Error(BM(a));return[cr(e,0),[0,d],cr(s,0),u,c]}let h=!0,p=0;const f=new Array(l).fill(0);for(let m=0;m<a;++m){const y=t[m*d];if(y<0)throw new Error(zM(m,y));if(y>=l)throw new Error(UM(m,y,l));++f[y],h=h&&y>=p,p=y}let g=!0;for(let m=0;m<l;++m){const y=0===f[m];u[m]=y,g=g&&!y,f[m]=Math.max(f[m],1),m>0&&(f[m]+=f[m-1])}if(g&&h){const m=t,y=r;for(let v=0;v<a;++v)c[v]=v;return[m,[a,d],y,u,c]}{const m=f[l-1],y=cr(e,m*d),v=cr(s,m),b=new Array(l).fill(0);for(let x=0;x<a;++x){const w=t[x*d],V=(0===w?0:f[w-1])+b[w];b[w]++;for(let z=0;z<d;++z)y[V*d+z]=t[x*d+z];v[V]=r[x],c[x]=V}for(let x=0;x<l;++x)if(0===b[x]){const k=0===x?0:f[x-1];y[k*d+0]=x;for(let V=1;V<d;++V)y[k*d+V]=0;v[k]=i}return[y,[m,d],v,u,c]}}const sfe={kernelName:SC,backendName:"cpu",kernelFunc:function rfe(t){const{inputs:n,backend:e}=t,{indices:r,values:s,denseShape:o,defaultValue:i}=n;if(1!==o.shape.length)throw new Error(`Dense shape must be a vector, saw:\n        ${o.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n        ${r.shape}`);if(1!==s.shape.length)throw new Error(`Values must be a vector, saw:\n        ${s.shape}`);if(0!==i.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`);const a=e.data.get(r.dataId).values,l=e.data.get(s.dataId).values,u=e.data.get(o.dataId).values,c=e.data.get(i.dataId).values[0],[d,h,p,f,g]=w3(a,r.shape,r.dtype,l,s.dtype,u,c);return[e.makeTensorInfo(h,r.dtype,d),e.makeTensorInfo([h[0]],s.dtype,p),e.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(m=>Number(m)))),e.makeTensorInfo([g.length],r.dtype,new Int32Array(g))]}};function _3(t,n,e,r,s){const o=_e(r),i=n[0],a=s.length,l=[];let u=1,c=-1;for(let m=0;m<a;++m){const y=s[m];if(-1===y){if(-1!==c)throw new Error(WM(c,m));c=m,l.push(1)}else{if(y<0)throw new Error(GM(m,y));u*=y,l.push(y)}}if(-1!==c){if(u<=0)throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");const m=Math.trunc(o/u);if(u*m!==o)throw new Error(jM(r,l));l[c]=m}if(_e(l)!==o)throw new Error(qM(r,l));const h=r.length,p=[];if(h>0){p[h-1]=1;for(let m=h-2;m>=0;--m)p[m]=p[m+1]*r[m+1]}const f=[];if(a>0){f[a-1]=1;for(let m=a-2;m>=0;--m)f[m]=f[m+1]*l[m+1]}const g=cr(e,i*a);for(let m=0;m<i;++m){let y=0;for(let v=0;v<h;++v)y+=t[m*h+v]*p[v];for(let v=0;v<a;++v)g[m*a+v]=Math.trunc(y/f[v]),y%=f[v]}return[g,[i,a],l]}const ife={kernelName:IC,backendName:"cpu",kernelFunc:function ofe(t){const{inputs:n,backend:e}=t,{inputIndices:r,inputShape:s,newShape:o}=n;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${r.shape}`);if(1!==s.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${s.shape}`);if(1!==o.shape.length)throw new Error(`Target shape should be a vector but received shape ${o.shape}`);const i=Array.from(e.data.get(s.dataId).values),a=e.data.get(r.dataId).values,l=Array.from(e.data.get(o.dataId).values),[u,c,d]=_3(a,r.shape,r.dtype,i,l);return[e.makeTensorInfo(c,r.dtype,u),e.makeTensorInfo([d.length],o.dtype,new Int32Array(d))]}};function RI(t,n,e,r,s,o=!1,i=0){const a=r.length,l=[n[0],t.length/n[0]],u=l[1],d=a>0?s[a-1]+1:0;if(d<0)throw new Error("segment ids must be >= 0");const h=n.slice();h[0]=d;const f=cr(e,h.reduce((b,x)=>b*x,1));if(0===a)return d>0&&f.fill(i),[f,h];if(d<=0)throw new Error("segment ids must be >= 0");let g=0,m=1,y=0,v=s[g];for(;;){let b=0;if(m<a){if(b=s[m],v===b){++m;continue}if(v>=b)throw new Error("segment ids are not increasing")}if(v<0||v>=d)throw new Error(XM(v,d));v>y&&f.fill(i,y*u,v*u);for(let x=g;x<m;++x){const w=r[x];if(w<0||w>=l[0])throw new Error(YM(x,r[x],l[0]));for(let k=0;k<u;k++)f[v*u+k]+=t[w*u+k]}if(o)for(let x=0;x<u;x++)f[v*u+x]/=m-g;if(g=m,++m,y=v+1,v=b,m>a)break}return y<d&&f.fill(i,y*u,d*u),[f,h]}const lfe={kernelName:DC,backendName:"cpu",kernelFunc:function afe(t){const{inputs:n,backend:e}=t,{data:r,indices:s,segmentIds:o}=n;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n          ${s.shape}`);if(1!==o.shape.length)throw new Error(`Segment ids should be a vector but received shape\n          ${o.shape}`);if(s.shape[0]!==o.shape[0])throw new Error("segmentIds and indices should have same size.");const i=e.data.get(r.dataId).values,a=e.data.get(s.dataId).values,l=e.data.get(o.dataId).values,[u,c]=RI(i,r.shape,r.dtype,a,l,!0);return e.makeTensorInfo(c,r.dtype,u)}},cfe={kernelName:TC,backendName:"cpu",kernelFunc:function ufe(t){const{inputs:n,backend:e}=t,{data:r,indices:s,segmentIds:o}=n;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n         ${s.shape}`);if(1!==o.shape.length)throw new Error(`Segment ids should be a vector but received shape\n         ${o.shape}`);if(s.shape[0]!==o.shape[0])throw new Error("segmentIds and indices should have same size.");const i=e.data.get(r.dataId).values,a=e.data.get(s.dataId).values,l=e.data.get(o.dataId).values,[u,c]=RI(i,r.shape,r.dtype,a,l);return e.makeTensorInfo(c,r.dtype,u)}},hfe={kernelName:jO,backendName:"cpu",kernelFunc:function dfe(t){const{inputs:n,backend:e,attrs:r}=t,{sparseIndices:s,sparseValues:o,defaultValue:i}=n,{outputShape:a}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:d,outputSize:h}=ru(0,s,a),p=!1,f=e.bufferSync(s);let g;switch(o.dtype){case"bool":g=pu(f,e.bufferSync(o),a,h,c,u,l,d,Boolean(e.data.get(i.dataId).values[0]),p);break;case"float32":case"int32":g=pu(f,e.bufferSync(o),a,h,c,u,l,d,e.data.get(i.dataId).values[0],p);break;case"string":g=pu(f,e.bufferSync(o),a,h,c,u,l,d,Ua(e.data.get(i.dataId).values[0]),p);break;default:throw new Error(`Unsupported type ${o.dtype}`)}return e.makeTensorInfo(a,g.dtype,g.values)}},ffe={kernelName:Oy,backendName:"cpu",kernelFunc:function pfe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{numOrSizeSplits:o,axis:i}=r,a=Jt(i,s.shape)[0],l=yS(s,o,a),u=new Array(s.shape.length).fill(0),c=s.shape.slice();return l.map(d=>{const h=[...c];h[a]=d;const p=hu({inputs:{x:s},backend:e,attrs:{begin:u,size:h}});return u[a]+=d,p})}},mfe=Vi(t=>Math.sqrt(t)),gfe=Cn(Cp,t=>Math.sqrt(t)),yfe={kernelName:Cp,backendName:"cpu",kernelFunc:gfe},vfe={kernelName:kC,backendName:"cpu",kernelFunc:({inputs:t,backend:n})=>{const{x:e}=t,r=n;mt(e,"square");const s=r.data.get(e.dataId).values,o=new Float32Array(s.length);for(let a=0;a<s.length;++a){const l=s[a];o[a]=l*l}return{dataId:r.write(o,e.shape,e.dtype),shape:e.shape,dtype:e.dtype}}},C3=wr((t,n)=>{const e=t-n;return e*e}),bfe=Br(Sp,C3),xfe={kernelName:Sp,backendName:"cpu",kernelFunc:bfe},S3=Vi((t,n)=>{const{pattern:e,replaceGlobal:r,rewrite:s}=n;return t.replace(new RegExp(e,r?"g":""),s)}),_fe={kernelName:My,backendName:"cpu",kernelFunc:il(My,S3)},Cfe=Cn(Ep,(t,n)=>{const e=n;return isNaN(t)?NaN:t>0?1:e.alpha}),Sfe={kernelName:Ep,backendName:"cpu",kernelFunc:Cfe};function I3(t,n,e,r){const s=en(t,n.dtype);for(let o=0;o<s.size;o++){const i=s.indexToLoc(o),a=new Array(i.length);for(let l=0;l<a.length;l++)a[l]=i[l]*e[l]+r[l];s.set(n.get(...a),...i)}return s}const Dfe={kernelName:EC,backendName:"cpu",kernelFunc:function Ife(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{begin:o,end:i,strides:a,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:h}=r;mt(s,"stridedSlice");const{finalShapeSparse:p,finalShape:f,isIdentity:g,sliceDim0:m,isSimpleSlice:y,begin:v,end:b,strides:x}=x1(s.shape,o,i,a,l,u,c,d,h);let w;if(g)w=$n({inputs:{x:s},backend:e,attrs:{shape:f}});else if(m||y){R(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);const k=y1(v,b,x),V=hu({inputs:{x:s},backend:e,attrs:{begin:v,size:k}});w=$n({inputs:{x:V},backend:e,attrs:{shape:f}}),e.disposeIntermediateTensorInfo(V)}else{const V=I3(p,e.bufferSync(s),x,v);w=e.makeTensorInfo(f,V.dtype,V.values)}return w}};class Tfe{constructor(n,e,r,s,o,i){this.separator=za(n),this.nGramWidths=e,this.leftPad=za(r),this.rightPad=za(s),this.padWidth=o,this.preserveShort=i}getPadWidth(n){return Math.min(this.padWidth<0?n-1:this.padWidth,n-1)}getNumNGrams(n,e){const r=this.getPadWidth(e);return Math.max(0,n+2*r-e+1)}createNGrams(n,e,r,s,o,i){for(let a=0;a<o;++a){const l=this.getPadWidth(i),u=Math.max(0,l-a),c=Math.max(0,l-(o-(a+1))),d=i-(u+c),h=e+(u>0?0:a-l);let p=0;p+=u*this.leftPad.length;for(let v=0;v<d;++v)p+=n[h+v].length;p+=c*this.rightPad.length,p+=(u+c+d-1)*this.separator.length,r[s+a]=new Uint8Array(p);const g=r[s+a];let m=0;const y=v=>v.forEach(b=>g[m++]=b);for(let v=0;v<u;++v)y(this.leftPad),y(this.separator);for(let v=0;v<d-1;++v)y(n[h+v]),y(this.separator);if(d>0){y(n[h+d-1]);for(let v=0;v<c;++v)y(this.separator),y(this.rightPad)}else{for(let v=0;v<c-1;++v)y(this.rightPad),y(this.separator);y(this.rightPad)}}}compute(n,e){const r=n.length,s=e.length;if(s>0){let l=e[0];if(0!==l)throw new Error(`First split value must be 0, got ${l}`);for(let u=1;u<s;++u){let c=e[u]>=l;if(c=c&&e[u]<=r,!c)throw new Error(`Invalid split value ${e[u]}, must be in [${l}, ${r}]`);l=e[u]}if(l!==r)throw new Error(`Last split value must be data size. Expected ${r}, got ${l}`)}const o=s-1,i=cr("int32",s);if(0===r||0===s){const l=new Array(r);for(let u=0;u<=o;++u)i[u]=0;return[l,i]}i[0]=0;for(let l=1;l<=o;++l){const u=e[l]-e[l-1];let c=0;this.nGramWidths.forEach(d=>{c+=this.getNumNGrams(u,d)}),this.preserveShort&&u>0&&0===c&&(c=1),i[l]=i[l-1]+c}const a=new Array(i[o]);for(let l=0;l<o;++l){const u=e[l];let c=i[l];if(this.nGramWidths.forEach(d=>{const p=this.getNumNGrams(e[l+1]-e[l],d);this.createNGrams(n,u,a,c,p,d),c+=p}),this.preserveShort&&c===i[l]){const d=e[l+1]-e[l];if(0===d)continue;this.createNGrams(n,u,a,c,1,d+2*this.padWidth)}}return[a,i]}}function D3(t,n,e,r,s,o,i,a){return new Tfe(e,r,s,o,i,a).compute(t,n)}const Efe={kernelName:NC,backendName:"cpu",kernelFunc:function kfe(t){const{inputs:n,backend:e,attrs:r}=t,{separator:s,nGramWidths:o,leftPad:i,rightPad:a,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:d}=n,h=e.data.get(c.dataId).values,p=e.data.get(d.dataId).values,[f,g]=D3(h,p,s,o,i,a,l,u);return[e.makeTensorInfo([f.length],"string",f),e.makeTensorInfo(d.shape,"int32",g)]}};function Nfe(t,n,e,r){if(!t.length)return;if(0===n.length){for(let o=0;o<t.length;++o)r.push(t.subarray(o,o+1));return}if(1===n.length){const o=n[0];let i=t.indexOf(o);for(;-1!==i;){const a=t.subarray(0,i);(!e||0!==a.length)&&r.push(a),i=(t=t.subarray(i+1)).indexOf(o)}return void((!e||0!==t.length)&&r.push(t))}let s=0;for(let o=0;o<t.length+1;o++)if(o===t.length||-1!==n.indexOf(t[o])){const i=t.subarray(s,o);(!e||0!==i.length)&&r.push(i),s=o+1}}function T3(t,n,e){const r=t.length,s=[];let o=0,i=0;const a=new Array(r);for(let h=0;h<r;++h){const p=s.length;Nfe(t[h],n,e,s);const f=s.length-p;a[h]=f,o+=f,i=Math.max(i,f)}const l=cr("int32",2*o),u=new Array(o),c=[r,i];let d=0;for(let h=0;h<r;++h)for(let p=0;p<a[h];++p)l[2*d]=h,l[2*d+1]=p,u[d]=s[d],++d;return[l,u,c]}const Rfe={kernelName:AC,backendName:"cpu",kernelFunc:function Afe(t){const{inputs:n,backend:e,attrs:r}=t,{skipEmpty:s}=r,{input:o,delimiter:i}=n;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(1!==o.shape.length)throw new Error(`Input must be a vector, got shape: ${o.shape}`);if(0!==i.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const a=e.data.get(o.dataId).values,l=e.data.get(i.dataId).values[0],[u,c,d]=T3(a,l,s),h=c.length;return[e.makeTensorInfo([h,2],"int32",u),e.makeTensorInfo([h],"string",c),e.makeTensorInfo([2],"int32",new Int32Array(d))]}};function k3(t,n){const e=cr("int32",t.length);for(let r=0;r<t.length;++r)e[r]=eZ(t[r]).modulo(n).getLowBitsUnsigned();return e}const Ofe={kernelName:RC,backendName:"cpu",kernelFunc:function Ffe(t){const{inputs:n,backend:e,attrs:r}=t,{numBuckets:s}=r,{input:o}=n;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const a=k3(e.data.get(o.dataId).values,s);return e.makeTensorInfo(o.shape,"int32",a)}},Pfe=Cn(Dp,t=>Math.tan(t)),Mfe={kernelName:Dp,backendName:"cpu",kernelFunc:Pfe},$fe=Cn(Tp,t=>Math.tanh(t));function E3(t,n){const e=new Array(t.rank);for(let s=0;s<e.length;s++)e[s]=t.shape[s]*n[s];const r=en(e,t.dtype);for(let s=0;s<r.values.length;++s){const o=r.indexToLoc(s),i=new Array(t.rank);for(let l=0;l<i.length;l++)i[l]=o[l]%t.shape[l];const a=t.locToIndex(i);r.values[s]=t.values[a]}return r}const mf=(t,n)=>{const e=n.value-t.value;return 0===e?t.index-n.index:e};function N3(t,n,e=0,r=t.length-1){for(;r>e;){if(r-e>600){const a=r-e+1,l=n-e+1,u=Math.log(a),c=.5*Math.exp(2*u/3),d=.5*Math.sqrt(u*c*(a-c)/a)*Math.sign(l-a/2);N3(t,n,Math.max(e,Math.floor(n-l*c/a+d)),Math.min(r,Math.floor(n+(a-l)*c/a+d)))}const s=t[n];let o=e,i=r;for($a(t,e,n),mf(t[r],s)>0&&$a(t,e,r);o<i;){for($a(t,o,i),o++,i--;mf(t[o],s)<0;)o+=1;for(;mf(t[i],s)>0;)i-=1}0===mf(t[e],s)?$a(t,e,i):(i+=1,$a(t,i,r)),i<=n&&(e=i+1),n<=i&&(r=i-1)}}function A3(t,n,e,r,s){const o=n[n.length-1],[i,a]=[t.length/o,o],l=ts(e,i*r),u=ts("int32",i*r);for(let d=0;d<i;d++){const h=d*a,p=t.subarray(h,h+a);let f=new Array(p.length);p.forEach((v,b)=>f[b]={value:v,index:b}),r<f.length&&(N3(f,r),f=f.slice(0,r)),s&&f.sort(mf);const g=d*r,m=l.subarray(g,g+r),y=u.subarray(g,g+r);for(let v=0;v<r;v++)m[v]=f[v].value,y[v]=f[v].index}const c=n.slice();return c[c.length-1]=r,[en(c,e,l),en(c,"int32",u)]}function R3(t,n,e){switch(e){case"reflect":return function qfe(t,n){let e=t;if(e<0)if(n<=1)e=0;else{const r=2*n;e<r&&(e=r*Math.trunc(-e/r)+e),e=e<-n?e+r:-e-1}else if(e>n-1)if(n<=1)e=0;else{const r=2*n;e-=r*Math.trunc(e/r),e>=n&&(e=r-e-1)}return Ul(0,e,n-1)}(t,n);case"wrap":return function Kfe(t,n){let e=t;return e<0?n<=1?e=0:e+=n*(Math.trunc(-e/(n-1))+1):e>n-1&&(n<=1?e=0:e-=n*Math.trunc(e/(n-1))),Ul(0,e,n-1)}(t,n);case"nearest":return function Yfe(t,n){return Ul(0,t,n-1)}(t,n);default:return function Xfe(t,n){return t}(t)}}function gf(t,n,e,r,s,o,i,a,l,u,c){return 0<=a&&a<n&&0<=l&&l<e?t[i*r+a*s+l*o+u]:c}function Zfe(t,n,e,r,s,o,i,a,l,u,c){return gf(t,n,e,r,s,o,i,Math.round(a),Math.round(l),u,c)}function Qfe(t,n,e,r,s,o,i,a,l,u,c){const d=Math.floor(a),h=Math.floor(l),p=d+1,f=h+1;return(p-a)*((f-l)*gf(t,n,e,r,s,o,i,d,h,u,c)+(l-h)*gf(t,n,e,r,s,o,i,d,f,u,c))+(a-d)*((f-l)*gf(t,n,e,r,s,o,i,p,h,u,c)+(l-h)*gf(t,n,e,r,s,o,i,p,f,u,c))}function F3(t,n,e,r){const s=Jt(n,e)[0],o=[1,e[0],1];for(let f=0;f<s;f++)o[0]*=e[f];o[1]=e[s];for(let f=s+1;f<e.length;f++)o[2]*=e[f];const i=new Map,a=new Int32Array(e[s]),l=new Wr(o,r,t),u=[],c=1===o[0]&&1===o[2];for(let f=0;f<e[s];f++){let g;if(c)g=t[f].toString();else{const y=[];for(let v=0;v<o[0];v++)for(let b=0;b<o[2];b++)y.push(l.get(v,f,b));g=y.join(",")}const m=i.get(g);if(null!=m)a[f]=m;else{const y=i.size;i.set(g,y),a[f]=y,u.push(f)}}const d=o.slice();d[1]=i.size;const h=new Wr(d,r);u.forEach((f,g)=>{for(let m=0;m<o[0];m++)for(let y=0;y<o[2];y++)h.set(l.get(m,f,y),m,g,y)});const p=e.slice();return p[s]=d[1],{outputValues:h.values,outputShape:p,indices:a}}const ome=[rue,sue,iue,lue,Jle,cue,pue,mue,yue,bue,wue,Cue,Iue,kue,Nue,Fue,Pue,$ue,Vue,tue,zue,Gue,jue,Kue,Zle,Yue,Que,Xle,Jue,tce,nce,sce,ice,lce,cce,hce,fce,gce,vce,xce,_ce,Sce,Dce,Tce,Ece,Ace,Fce,Oce,Pce,Mce,zce,Ble,Wce,Gce,Qce,Jce,ede,nde,cde,dde,pde,mde,yde,bde,wde,Cde,Ide,Tde,Ede,zle,Ade,ece,Fde,Pde,$de,Ule,Vde,zde,Wde,Hde,qde,Yde,Qde,the,rhe,ohe,ihe,lhe,che,hhe,fhe,ghe,vhe,xhe,_he,She,Dhe,Ehe,Rhe,Lce,Ohe,$he,Bhe,Whe,Hhe,qhe,Xhe,Yhe,u3,epe,Gle,npe,cpe,hpe,fpe,gpe,Yle,kI,vpe,Hle,jle,eue,xpe,_pe,Spe,Dpe,kpe,Epe,Ape,Fpe,Ppe,Bpe,Upe,jpe,Kle,Kpe,Ype,Qpe,Uue,Nhe,efe,nfe,sfe,ife,lfe,cfe,hfe,ffe,yfe,vfe,xfe,_fe,Sfe,Dfe,Efe,Rfe,Ofe,ode,Vce,Mfe,{kernelName:Tp,backendName:"cpu",kernelFunc:$fe},{kernelName:GO,backendName:"cpu",kernelFunc:function Vfe(t){const{inputs:n,backend:e}=t,{tensor:r,indices:s,updates:o}=n,{sliceRank:i,numUpdates:a,sliceSize:l,strides:u,outputSize:c}=ru(0,s,r.shape),h=e.bufferSync(s),p=e.bufferSync(o),f=e.bufferSync(r),g=pu(h,p,r.shape,c,l,a,i,u,f,!1);return e.makeTensorInfo(r.shape,g.dtype,g.values)}},{kernelName:kp,backendName:"cpu",kernelFunc:function zfe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{reps:o}=r;mt(s,"tile");const i=E3(e.bufferSync(s),o);return e.makeTensorInfo(i.shape,i.dtype,i.values)}},{kernelName:FC,backendName:"cpu",kernelFunc:function Wfe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{k:o,sorted:i}=r;mt(s,"topk");const a=e.data.get(s.dataId).values,[l,u]=A3(a,s.shape,s.dtype,o,i);return[e.makeTensorInfo(l.shape,l.dtype,l.values),e.makeTensorInfo(u.shape,u.dtype,u.values)]}},{kernelName:OC,backendName:"cpu",kernelFunc:function Hfe(t){const{inputs:n,attrs:e,backend:r}=t,{image:s,transforms:o}=n,{interpolation:i,fillMode:a,fillValue:l,outputShape:u}=e,[c,d,h,p]=s.shape,[f,g]=u??[d,h],m=[c,f,g,p],y=xt(s.shape),v=y[0],b=y[1],x=y[2],w=xt(m),k=w[0],V=w[1],z=w[2],K=ts(s.dtype,_e(m));K.fill(l);const Y=r.data.get(s.dataId).values,se=r.data.get(o.dataId).values;for(let ve=0;ve<c;++ve){const be=1===o.shape[0]?se:se.subarray(8*ve,8*ve+8);for(let xe=0;xe<f;++xe)for(let De=0;De<g;++De)for(let Ne=0;Ne<p;++Ne){let we;const Ae=be[6]*De+be[7]*xe+1;if(0===Ae)continue;const He=(be[3]*De+be[4]*xe+be[5])/Ae,Ye=R3((be[0]*De+be[1]*xe+be[2])/Ae,h,a),je=R3(He,d,a);switch(i){case"nearest":we=Zfe(Y,d,h,v,b,x,ve,je,Ye,Ne,l);break;case"bilinear":we=Qfe(Y,d,h,v,b,x,ve,je,Ye,Ne,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}K[ve*k+xe*V+De*z+Ne]=we}return r.makeTensorInfo(m,s.dtype,K)}return{dataId:r.write(K,m,s.dtype),shape:s.shape,dtype:s.dtype}}},due,{kernelName:PC,backendName:"cpu",kernelFunc:function Jfe(t){const{inputs:n,attrs:e,backend:r}=t,{axis:s}=e,{x:o}=n;mt(o,"unique");const i=r.data.get(o.dataId).values,{outputValues:a,outputShape:l,indices:u}=F3(i,s,o.shape,o.dtype);return[r.makeTensorInfo(l,o.dtype,a),r.makeTensorInfo([u.length],"int32",u)]}},{kernelName:$y,backendName:"cpu",kernelFunc:function tme(t){const{inputs:n,backend:e,attrs:r}=t,{value:s}=n;let{axis:o}=r;o<0&&(o+=s.shape.length);const i=s.shape.length,a=s.shape[o],l=new Array(i-1);let u=0;for(let p=0;p<i;p++)p!==o&&(l[u++]=s.shape[p]);const c=new Array(i).fill(0),d=s.shape.slice();d[o]=1;const h=new Array(a);for(let p=0;p<h.length;p++){c[o]=p;const f=hu({inputs:{x:s},backend:e,attrs:{begin:c,size:d}});h[p]=$n({inputs:{x:f},backend:e,attrs:{shape:l}}),e.disposeIntermediateTensorInfo(f)}return h}},{kernelName:Ly,backendName:"cpu",kernelFunc:function rme(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,segmentIds:o}=n,{numSegments:i}=r;mt(s,"unsortedSegmentSum");const u=[],c=[],d=s.shape.length-o.shape.length;let h=o;for(let f=0;f<d;++f){const g=tb({inputs:{input:h},backend:e,attrs:{dim:f+1}});h=g,c.push(g)}for(let f=0;f<i;++f){const g=Ba(f,"int32"),m=e.makeTensorInfo([],"int32",g),y=LV({inputs:{a:m,b:h},backend:e}),v=al({inputs:{x:y},backend:e,attrs:{dtype:"float32"}}),b=eb({inputs:{a:v,b:s},backend:e}),x=ff({inputs:{x:b},backend:e,attrs:{axis:0,keepDims:!1}});u.push(x),c.push(m),c.push(y),c.push(v),c.push(b),c.push(x)}const p=l3({inputs:u,backend:e,attrs:{axis:0}});return c.forEach(f=>e.disposeIntermediateTensorInfo(f)),p}},Khe];for(const t of ome)BC(t);const ll={},sb={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function ui(t,n){if(!(t in ll)||null!=n){const r=function lme(t,n){if(1!==t&&2!==t)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const e=n??function ame(t){if(!pe().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&2===t)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(t);return e.addEventListener("webglcontextlost",r=>{r.preventDefault(),delete ll[t]},!1),pe().getBool("SOFTWARE_WEBGL_ENABLED")&&(sb.failIfMajorPerformanceCaveat=!1),1===t?e.getContext("webgl",sb)||e.getContext("experimental-webgl",sb):e.getContext("webgl2",sb)}(t,n);if(null===r)return console.log("Could not get context for WebGL version",t),null;ll[t]=r}const e=ll[t];return null==e||e.isContextLost()?(delete ll[t],ui(t)):(e.disable(e.DEPTH_TEST),e.disable(e.STENCIL_TEST),e.disable(e.BLEND),e.disable(e.DITHER),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SAMPLE_COVERAGE),e.enable(e.SCISSOR_TEST),e.enable(e.CULL_FACE),e.cullFace(e.BACK),ll[t])}var Qc=(()=>{return(t=Qc||(Qc={}))[t.DENSE=0]="DENSE",t[t.SHARED_BATCH=1]="SHARED_BATCH",Qc;var t})(),qs=(()=>{return(t=qs||(qs={}))[t.RENDER=0]="RENDER",t[t.UPLOAD=1]="UPLOAD",t[t.PIXELS=2]="PIXELS",t[t.DOWNLOAD=3]="DOWNLOAD",qs;var t})(),zr=(()=>{return(t=zr||(zr={}))[t.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",t[t.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",t[t.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",t[t.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",t[t.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16",zr;var t})();function yf(t,n){return[n,t]}function ob(t){const n=_e(t);return M_(Math.ceil(n/4))}function Jc(t,n){return[Math.max(1,Math.ceil(n/2)),Math.max(1,Math.ceil(t/2))]}function FI(t,n){const e=t;let r,s,o,i,a,l,u,c,d,h;return 2===pe().getNumber("WEBGL_VERSION")?(r=e.R32F,s=e.R16F,o=e.RGBA16F,i=e.RGBA32F,a=e.RED,u=4,c=1,d=e.HALF_FLOAT,h=e.FLOAT,l=e.RGBA8):(r=t.RGBA,s=t.RGBA,o=t.RGBA,i=e.RGBA,a=t.RGBA,u=4,c=4,d=null!=n?n.HALF_FLOAT_OES:null,h=t.FLOAT,l=t.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:s,internalFormatPackedHalfFloat:o,internalFormatPackedFloat:i,textureFormatFloat:a,downloadTextureFormat:l,downloadUnpackNumChannels:u,defaultNumChannels:c,textureTypeHalfFloat:d,textureTypeFloat:h}}function rt(t,n){const e=n();return pe().getBool("DEBUG")&&function dme(t){const n=t.getError();if(n!==t.NO_ERROR)throw new Error("WebGL Error: "+function mme(t,n){switch(n){case t.NO_ERROR:return"NO_ERROR";case t.INVALID_ENUM:return"INVALID_ENUM";case t.INVALID_VALUE:return"INVALID_VALUE";case t.INVALID_OPERATION:return"INVALID_OPERATION";case t.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case t.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case t.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${n}`}}(t,n))}(t),e}const hme=5.96e-8,pme=65504;function fme(t){return!!(pe().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===t||hme<Math.abs(t)&&Math.abs(t)<pme)}function ib(t,n){return va(t,()=>t.getExtension(n),'Extension "'+n+'" not supported on this browser.')}const vme=/ERROR: [0-9]+:([0-9]+):/g;function O3(t,n){const e=vme.exec(n);if(null==e)return console.log(`Couldn't parse line number in error: ${n}`),void console.log(t);const r=+e[1],s=t.split("\n"),o=s.length.toString().length+2,i=s.map((d,h)=>Cc((h+1).toString(),o)+d);let a=0;for(let d=0;d<i.length;d++)a=Math.max(i[d].length,a);const l=i.slice(0,r-1),u=i.slice(r-1,r),c=i.slice(r);console.log(l.join("\n")),console.log(n.split("\n")[0]),console.log(`%c ${Cc(u[0],a)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join("\n"))}function OI(t,n){if(rt(t,()=>t.validateProgram(n)),!1===t.getProgramParameter(n,t.VALIDATE_STATUS))throw console.log(t.getProgramInfoLog(n)),new Error("Shader program validation failed.")}function P3(t,n,e,r,s,o,i){const a=t.getAttribLocation(n,e);return-1!==a&&(rt(t,()=>t.bindBuffer(t.ARRAY_BUFFER,r)),rt(t,()=>t.vertexAttribPointer(a,s,t.FLOAT,!1,o,i)),rt(t,()=>t.enableVertexAttribArray(a)),!0)}function Eme(t,n,e,r){rt(t,()=>function Dme(t,n,e){(function $3(t,n){const e=t.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=n+t.TEXTURE0;if(r<t.TEXTURE0||r>e)throw new Error(`textureUnit must be in [gl.TEXTURE0, gl.TEXTURE${e}].`)})(t,e),rt(t,()=>t.activeTexture(t.TEXTURE0+e)),rt(t,()=>t.bindTexture(t.TEXTURE_2D,n))}(t,n,r)),rt(t,()=>t.uniform1i(e,r))}function PI(t,n,e){rt(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,e)),rt(t,()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,n,0))}function M3(t,n){rt(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,n)),rt(t,()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,null,0))}function ab(t){const n=t.checkFramebufferStatus(t.FRAMEBUFFER);if(n!==t.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function Nme(t,n){switch(n){case t.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case t.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${n}`}}(t,n))}function va(t,n,e){const r=rt(t,()=>n());if(null==r)throw new Error(e);return r}function ed(t,n=2){return _e(t.slice(0,t.length-n))}function td(t){if(0===t.length)throw Error("Cannot get rows and columns of an empty shape array.");return[t.length>1?t[t.length-2]:1,t[t.length-1]]}function lb(t){let n=[1,1,1];return 0===t.length||1===t.length&&1===t[0]||(n=[ed(t),...td(t)]),n}function ub(t){return t%2==0}function cb(t,n){if(gn(t=t.slice(-2),n=n.slice(-2))||!t.length||!n.length||0===t[0]||0===t[1]||0===n[0]||0===n[1])return!0;if(t.length!==n.length){const e=t[t.length-1],r=n[n.length-1];if(e===r||ub(e)&&ub(r)&&(1===t[0]||1===n[0]))return!0}return t[1]===n[1]&&ub(t[0])&&ub(n[0])}let db,hb;function zo(t,n){return null!=t.getExtension(n)}function L3(t){try{if(null!=ui(t))return!0}catch(n){return console.log("Error when getting WebGL context: ",n),!1}return!1}function MI(t){const n=FI(t),e=t.createTexture();t.bindTexture(t.TEXTURE_2D,e),t.texImage2D(t.TEXTURE_2D,0,n.internalFormatFloat,1,1,0,n.textureFormatFloat,n.textureTypeFloat,null);const o=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,o),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,e,0);const i=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(e),t.deleteFramebuffer(o),i}function vf(t,n){Array.isArray(t)||(t=[t]),t.forEach(e=>{null!=e&&R("complex64"!==e.dtype,()=>`${n} does not support complex64 tensors in the WebGL backend.`)})}const vt=pe();function bs(){let t,n,e,r,s,o,i,a,l,u;return 2===pe().getNumber("WEBGL_VERSION")?(t="#version 300 es",n="in",e="out",r="in",s="texture",o="outputColor",i="out vec4 outputColor;",a=pe().getBool("WEBGL2_ISNAN_CUSTOM")?"\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ":"",l="",u="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(t="",n="attribute",e="varying",r="varying",s="texture2D",o="gl_FragColor",i="",a="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",l="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",u="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:t,attribute:n,varyingVs:e,varyingFs:r,texture2D:s,output:o,defineOutput:i,defineSpecialNaN:a,defineSpecialInf:l,defineRound:u}}function fu(t,n,e="index"){const r=xt(n);return r.map((s,o)=>`int ${t[o]} = ${e} / ${s}; ${o===r.length-1?`int ${t[o+1]} = ${e} - ${t[o]} * ${s}`:`index -= ${t[o]} * ${s}`};`).join("")}function pb(t,n,e="index"){const r=xt(n);return r.map((s,o)=>`int ${t[o]} = ${e} / outShapeStrides[${o}]; ${o===r.length-1?`int ${t[o+1]} = ${e} - ${t[o]} * outShapeStrides[${o}]`:`index -= ${t[o]} * outShapeStrides[${o}]`};`).join("")}function $I(t){const n=xt(t).map(e=>e.toString());return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${n[0]} + coords.y * ${n[1]} + coords.z;\n  }\n`}vt.registerFlag("HAS_WEBGL",()=>vt.getNumber("WEBGL_VERSION")>0),vt.registerFlag("WEBGL_VERSION",()=>L3(2)?2:L3(1)?1:0),vt.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1),vt.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>2===vt.get("WEBGL_VERSION")),vt.registerFlag("WEBGL_CPU_FORWARD",()=>!0),vt.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1),vt.registerFlag("WEBGL_PACK",()=>vt.getBool("HAS_WEBGL")),vt.registerFlag("WEBGL_PACK_NORMALIZATION",()=>vt.getBool("WEBGL_PACK")),vt.registerFlag("WEBGL_PACK_CLIP",()=>vt.getBool("WEBGL_PACK")),vt.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>vt.getBool("WEBGL_PACK")),vt.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>vt.getBool("WEBGL_PACK")),vt.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>vt.getBool("WEBGL_PACK")),vt.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>vt.getBool("WEBGL_PACK")),vt.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>vt.getBool("WEBGL_PACK")),vt.registerFlag("WEBGL_PACK_REDUCE",()=>vt.getBool("WEBGL_PACK")),vt.registerFlag("WEBGL_LAZILY_UNPACK",()=>vt.getBool("WEBGL_PACK")),vt.registerFlag("WEBGL_CONV_IM2COL",()=>vt.getBool("WEBGL_PACK")),vt.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>function Rme(t){if(null==db){const n=ui(t);db=n.getParameter(n.MAX_TEXTURE_SIZE)}return db}(vt.getNumber("WEBGL_VERSION"))),vt.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>function Fme(t){if(null==hb){const n=ui(t);hb=n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,hb)}(vt.getNumber("WEBGL_VERSION"))),vt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const t=vt.getNumber("WEBGL_VERSION");return 0===t?0:function Ome(t){if(0===t)return 0;let n;const e=ui(t);return n=zo(e,"EXT_disjoint_timer_query_webgl2")&&2===t?2:zo(e,"EXT_disjoint_timer_query")?1:0,n}(t)}),vt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>vt.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!aP()),vt.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>function Pme(t){if(0===t)return!1;const n=ui(t);if(1===t){if(!zo(n,"OES_texture_float"))return!1}else if(!zo(n,"EXT_color_buffer_float"))return!1;return MI(n)}(vt.getNumber("WEBGL_VERSION"))),vt.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>!vt.getBool("WEBGL_FORCE_F16_TEXTURES")&&vt.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")),vt.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>function Mme(t){if(0===t)return!1;const n=ui(t);if(1!==t){if(zo(n,"EXT_color_buffer_float"))return MI(n);const r="EXT_color_buffer_half_float";if(zo(n,r)){const s=n.getExtension(r);return function $me(t,n){const e=FI(t,n),r=t.createTexture();t.bindTexture(t.TEXTURE_2D,r),t.texImage2D(t.TEXTURE_2D,0,e.internalFormatHalfFloat,1,1,0,e.textureFormatFloat,e.textureTypeHalfFloat,null);const i=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,i),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,r,0);const a=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(r),t.deleteFramebuffer(i),a}(n,s)}return!1}return!(!zo(n,"OES_texture_float")||!zo(n,"WEBGL_color_buffer_float"))&&MI(n)}(vt.getNumber("WEBGL_VERSION"))),vt.registerFlag("WEBGL_FENCE_API_ENABLED",()=>function Lme(t){return 2===t&&null!=ui(t).fenceSync}(vt.getNumber("WEBGL_VERSION"))),vt.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>vt.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0),vt.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,t=>{if(t<0&&-1!==t)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${t}.`)}),vt.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>aP()?1:-1,t=>{if(t<0&&-1!==t)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${t}.`)}),vt.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128),vt.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1),vt.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5),vt.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128),vt.registerFlag("WEBGL_EXP_CONV",()=>!1),vt.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>vt.getBool("IS_TEST")),vt.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0),vt.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1),vt.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1),vt.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);const V3="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:B3}=M;function zme(t,n,e){const r=[];if(t.forEach(p=>{const f=_e(p.shapeInfo.logicalShape);if(p.shapeInfo.isUniform?r.push(`uniform float ${p.name}${f>1?`[${f}]`:""};`):(r.push(`uniform sampler2D ${p.name};`),r.push(`uniform int offset${p.name};`)),e.enableShapeUniforms){const{uniformShape:g}=VI(e.packedInputs,p.shapeInfo.logicalShape,p.shapeInfo.texShape);switch(g.length){case 1:r.push(`uniform int ${p.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${p.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${p.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${p.name}Shape;`)}r.push(`uniform ivec2 ${p.name}TexShape;`)}}),e.enableShapeUniforms){switch(n.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;")}r.push("uniform ivec2 outTexShape;")}e.customUniforms&&e.customUniforms.forEach(p=>{r.push(`uniform ${p.type} ${p.name}${p.arrayIndex?`[${p.arrayIndex}]`:""};`)});const s=r.join("\n"),o=t.map(p=>function Ume(t,n,e=!1,r){let s="";s+=e?z3(t,r):nd(t,r);return t.shapeInfo.logicalShape.length<=n.logicalShape.length&&(s+=e?function wge(t,n){const e=t.name,r=e.charAt(0).toUpperCase()+e.slice(1),s="get"+r+"AtOutCoords",o=t.shapeInfo.logicalShape.length,i=n.logicalShape.length,a=B3(t.shapeInfo.logicalShape,n.logicalShape),l=kn(i),u=i-o;let c;const d=["x","y","z","w","u","v"];c=0===o?"":i<2&&a.length>=1?"coords = 0;":a.map(v=>`coords.${d[v+u]} = 0;`).join("\n");let h="";h=i<2&&o>0?"coords":t.shapeInfo.logicalShape.map((v,b)=>`coords.${d[b+u]}`).join(", ");let p="return outputValue;";const g=1===_e(t.shapeInfo.logicalShape),y=1===_e(n.logicalShape);if(1!==o||g||y){if(g&&!y)p=1===i?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(a.length){const v=o-2,b=o-1;a.indexOf(v)>-1&&a.indexOf(b)>-1?p="return vec4(outputValue.x);":a.indexOf(v)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":a.indexOf(b)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}}else p="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${s}() {\n      ${l} coords = getOutputCoords();\n      ${c}\n      vec4 outputValue = get${r}(${h});\n      ${p}\n    }\n  `}(t,n):function _ge(t,n){const e=t.name,r=e.charAt(0).toUpperCase()+e.slice(1),s="get"+r+"AtOutCoords",a=t.shapeInfo.logicalShape.length,l=n.logicalShape.length;if(!t.shapeInfo.isUniform&&a===l&&null==t.shapeInfo.flatOffset&&gn(t.shapeInfo.texShape,n.texShape))return`\n      float ${s}() {\n        return sampleTexture(${e}, resultUV);\n      }\n    `;const u=kn(l),c=B3(t.shapeInfo.logicalShape,n.logicalShape),d=l-a;let h;const p=["x","y","z","w","u","v"];h=0===a?"":l<2&&c.length>=1?"coords = 0;":c.map(g=>`coords.${p[g+d]} = 0;`).join("\n");let f="";return f=l<2&&a>0?"coords":t.shapeInfo.logicalShape.map((g,m)=>`coords.${p[m+d]}`).join(", "),`\n    float ${s}() {\n      ${u} coords = getOutputCoords();\n      ${h}\n      return get${r}(${f});\n    }\n  `}(t,n)),s}(p,n,e.packedInputs,e.enableShapeUniforms)).join("\n"),i=n.texShape,a=bs(),l=function Hme(t){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${t.texture2D}(textureSampler, uv).r;\n    }\n  `}(a);let u,c,d=function Kme(t){return`${t.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${t.varyingFs} vec2 resultUV;\n    ${t.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${t.defineSpecialNaN}\n    ${t.defineSpecialInf}\n    ${t.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${Xme}\n    ${Yme}\n    ${Zme}\n  `}(a);return n.isPacked?(u=function Wme(t,n,e){switch(t.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function Jme(t,n,e){const r=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)];return 1===r[0]?e?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${r[1]}.0);\n      }\n    `:1===r[1]?e?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${r[0]}.0);\n      }\n    `:e?"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);\n    }\n  `}(0,n,e);case 2:return function age(t,n,e){const r=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)];if(gn(t,n))return e?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));\n      }\n    `;const s=Math.ceil(t[1]/2);return e?"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(t,n,e);case 3:return function tge(t,n,e){if(e)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const r=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)],s=Math.ceil(t[2]/2),o=s*Math.ceil(t[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      int b = index / ${o};\n      index -= b * ${o};\n\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(t,n,e);default:return function rge(t,n,e){if(e)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const r=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)],s=Math.ceil(t[t.length-1]/2),o=s*Math.ceil(t[t.length-2]/2);let i=o,a="",l="b, r, c";for(let u=2;u<t.length-1;u++)i*=t[t.length-u-1],a=`\n      int b${u} = index / ${i};\n      index -= b${u} * ${i};\n    `+a,l=`b${u}, `+l;return`\n    ivec${t.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      ${a}\n\n      int b = index / ${o};\n      index -= b * ${o};\n\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec${t.length}(${l});\n    }\n  `}(t,n,e)}}(n.logicalShape,i,e.enableShapeUniforms),c=function qme(t){return`\n    void setOutput(vec4 val) {\n      ${t.output} = val;\n    }\n  `}(a)):(u=function Gme(t,n,e){switch(t.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function ege(t,n,e){return 1===n[0]?e?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.x * ${n[1]}.0);\n      }\n    `:1===n[1]?e?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.y * ${n[0]}.0);\n      }\n    `:e?"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      return resTexRC.x * ${n[1]} + resTexRC.y;\n    }\n  `}(0,n,e);case 2:return function lge(t,n,e){return gn(t,n)?e?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${n[0]}, ${n[1]}));\n      }\n    `:1===t[1]?e?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${n[0]}, ${n[1]}));\n        int index = resTexRC.x * ${n[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:1===t[0]?e?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${n[0]}, ${n[1]}));\n        int index = resTexRC.x * ${n[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:e?"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n      int r = index / ${t[1]};\n      int c = index - r * ${t[1]};\n      return ivec2(r, c);\n    }\n  `}(t,n,e);case 3:return function nge(t,n,e){if(e)return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${pb(["r","c","d"],t)}\n    return ivec3(r, c, d);\n  }\n`;const r=fu(["r","c","d"],t);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n      ${r}\n      return ivec3(r, c, d);\n    }\n  `}(t,n,e);case 4:return function sge(t,n,e){if(e)return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${pb(["r","c","d","d2"],t)}\n      return ivec4(r, c, d, d2);\n    }\n  `;const r=fu(["r","c","d","d2"],t);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n      ${r}\n      return ivec4(r, c, d, d2);\n    }\n  `}(t,n,e);case 5:return function oge(t,n){const e=fu(["r","c","d","d2","d3"],t);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${n[0]},\n                             ${n[1]}));\n\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      ${e}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(t,n);case 6:return function ige(t,n){const e=fu(["r","c","d","d2","d3","d4"],t);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      ${e}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(t,n);default:throw new Error(`${t.length}-D output sampling is not yet supported`)}}(n.logicalShape,i,e.enableShapeUniforms),c=function jme(t){return`\n    void setOutput(float val) {\n      ${t.output} = vec4(val, 0, 0, 0);\n    }\n  `}(a)),e.packedInputs&&(d+=Qme),[d,l,c,s,u,o,e.userCode].join("\n")}function nd(t,n=!1){const e=t.shapeInfo.logicalShape;switch(e.length){case 0:return function cge(t,n){const e=t.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1);if(t.shapeInfo.isUniform)return`float ${r}() {return ${e};}`;const[s,o]=t.shapeInfo.texShape;if(1===s&&1===o)return`\n      float ${r}() {\n        return sampleTexture(${e}, halfCR);\n      }\n    `;const i=mu(e);if(n)return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], ${i});\n      return sampleTexture(${e}, uv);\n    }\n  `;const[a,l]=t.shapeInfo.texShape;return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${a}, ${l}, ${i});\n      return sampleTexture(${e}, uv);\n    }\n  `}(t,n);case 1:return function hge(t,n){const e=t.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1);if(t.shapeInfo.isUniform)return`\n      float ${r}(int index) {\n        ${rd(t)}\n      }\n    `;const s=t.shapeInfo.texShape,o=s[0],i=s[1];if(1===i&&1===o)return`\n      float ${r}(int index) {\n        return sampleTexture(${e}, halfCR);\n      }\n    `;const a=mu(e);return 1===i?n?`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / float(${e}TexShape[0]));\n        return sampleTexture(${e}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${o}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `:1===o?n?`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${a}) + 0.5) / float(${e}TexShape[1]), 0.5);\n        return sampleTexture(${e}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${i}.0, 0.5);\n        return sampleTexture(${e}, uv);\n      }\n    `:n?`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], index + ${a});\n      return sampleTexture(${e}, uv);\n    }\n  `:`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${o}, ${i}, index + ${a});\n      return sampleTexture(${e}, uv);\n    }\n  `}(t,n);case 2:return function fge(t,n){const e=t.shapeInfo.logicalShape,r=t.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=t.shapeInfo.texShape;if(null!=o&&gn(e,o))return n?`\n      float ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${o[1]}.0, ${o[0]}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;const{newShape:i,keptDims:a}=La(e);if(i.length<e.length){const p=["row","col"];return`\n      ${nd(sd(t,i),n)}\n      float ${s}(int row, int col) {\n        return ${s}(${od(p,a)});\n      }\n    `}if(t.shapeInfo.isUniform)return`\n      float ${s}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${e[1]}, 1)));\n        ${rd(t)}\n      }\n    `;const u=o[0],c=o[1],d=mu(r);return 1===c?n?`\n      float ${s}(int row, int col) {\n        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col) {\n      float index = dot(vec3(row, col, ${d}), vec3(${e[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `:1===u?n?`\n      float ${s}(int row, int col) {\n        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col) {\n      float index = dot(vec3(row, col, ${d}), vec3(${e[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);\n      return sampleTexture(${r}, uv);\n    }\n  `:n?`\n      float ${s}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${r}Shape[1] + col + ${d};\n        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n  float ${s}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${e[1]} + col + ${d};\n    vec2 uv = uvFromFlat(${u}, ${c}, index);\n    return sampleTexture(${r}, uv);\n  }\n`}(t,n);case 3:return function gge(t,n){const e=t.shapeInfo.logicalShape,r=t.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=e[1]*e[2],i=e[2],{newShape:a,keptDims:l}=La(e);if(a.length<e.length){const m=["row","col","depth"];return`\n        ${nd(sd(t,a),n)}\n        float ${s}(int row, int col, int depth) {\n          return ${s}(${od(m,l)});\n        }\n      `}if(t.shapeInfo.isUniform)return`\n      float ${s}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${o}, ${i}, 1)));\n        ${rd(t)}\n      }\n    `;const c=t.shapeInfo.texShape,d=c[0],h=c[1],p=t.shapeInfo.flatOffset;if(h===o&&null==p)return n?`\n      float ${s}(int row, int col, int depth) {\n        int stride1 = ${r}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n        float ${s}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${i}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${h}.0, ${d}.0);\n          return sampleTexture(${r}, uv);\n        }\n      `;if(h===i&&null==p)return n?`\n      float ${s}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${e[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${h}.0, ${d}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;const f=mu(r);return n?`\n    float ${s}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${r}Shape[1] * ${r}Shape[2];\n      int stride1 = ${r}Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ${f};\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n      return sampleTexture(${r}, uv);\n    }\n    `:`\n      float ${s}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${o} + col * ${i} + depth + ${f};\n        vec2 uv = uvFromFlat(${d}, ${h}, index);\n        return sampleTexture(${r}, uv);\n      }\n  `}(t,n);case 4:return function vge(t,n){const e=t.shapeInfo.logicalShape,r=t.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=e[3],i=e[2]*o,a=e[1]*i,{newShape:l,keptDims:u}=La(e);if(l.length<e.length){const b=["row","col","depth","depth2"];return`\n      ${nd(sd(t,l),n)}\n      float ${s}(int row, int col, int depth, int depth2) {\n        return ${s}(${od(b,u)});\n      }\n    `}if(t.shapeInfo.isUniform)return`\n      float ${s}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${a}, ${i}, ${o}, 1)));\n        ${rd(t)}\n      }\n    `;const c=t.shapeInfo.flatOffset,d=t.shapeInfo.texShape,h=d[0],p=d[1],f=`int stride2 = ${r}Shape[3];`,g=`int stride1 = ${r}Shape[2] * stride2;`,m=`int stride0 = ${r}Shape[1] * stride1;`;if(p===a&&null==c)return n?`\n      float ${s}(int row, int col, int depth, int depth2) {\n        ${f}\n        ${g}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${i}, ${o}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${h}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;if(p===o&&null==c)return n?`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${e[1]*e[2]}, ${e[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${h}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;const y=mu(r);return n?`\n    float ${s}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${f}\n      ${g}\n      ${m}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${y});\n      return sampleTexture(${r}, uv);\n    }\n  `:`\n    float ${s}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${a} + col * ${i} +\n          depth * ${o} + depth2;\n      vec2 uv = uvFromFlat(${h}, ${p}, index + ${y});\n      return sampleTexture(${r}, uv);\n    }\n  `}(t,n);case 5:return function bge(t){const n=t.shapeInfo.logicalShape,e=t.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),s=n[4],o=n[3]*s,i=n[2]*o,a=n[1]*i,{newShape:l,keptDims:u}=La(n);if(l.length<n.length){const m=["row","col","depth","depth2","depth3"];return`\n      ${nd(sd(t,l))}\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        return ${r}(${od(m,u)});\n      }\n    `}if(t.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${a}, ${i}, ${o}, ${s})) +\n          depth3;\n        ${rd(t)}\n      }\n    `;const c=t.shapeInfo.flatOffset,d=t.shapeInfo.texShape,h=d[0],p=d[1];if(p===a&&null==c)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${i}, ${o}, ${s}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${h}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;if(p===s&&null==c)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${n[1]*n[2]*n[3]},\n               ${n[2]*n[3]}, ${n[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${h}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;return`\n    float ${r}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${a} + col * ${i} + depth * ${o} +\n          depth2 * ${s} + depth3 + ${mu(e)};\n      vec2 uv = uvFromFlat(${h}, ${p}, index);\n      return sampleTexture(${e}, uv);\n    }\n  `}(t);case 6:return function xge(t){const n=t.shapeInfo.logicalShape,e=t.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),{newShape:s,keptDims:o}=La(n);if(s.length<n.length){const y=["row","col","depth","depth2","depth3","depth4"];return`\n      ${nd(sd(t,s))}\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${r}(${od(y,o)});\n      }\n    `}const i=n[5],a=n[4]*i,l=n[3]*a,u=n[2]*l,c=n[1]*u;if(t.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${c}, ${u}, ${l}, ${a})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${i}, 1)));\n        ${rd(t)}\n      }\n    `;const d=t.shapeInfo.flatOffset,h=t.shapeInfo.texShape,p=h[0],f=h[1];if(f===c&&null==d)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${u}, ${l}, ${a}, ${i})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${p}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;if(f===i&&null==d)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${n[1]*n[2]*n[3]*n[4]},\n               ${n[2]*n[3]*n[4]},\n               ${n[3]*n[4]},\n               ${n[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${p}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;return`\n    float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${c} + col * ${u} + depth * ${l} +\n          depth2 * ${a} + depth3 * ${i} + depth4 + ${mu(e)};\n      vec2 uv = uvFromFlat(${p}, ${f}, index);\n      return sampleTexture(${e}, uv);\n    }\n  `}(t);default:throw new Error(`${e.length}-D input sampling is not yet supported`)}}function z3(t,n){switch(t.shapeInfo.logicalShape.length){case 0:return function uge(t){const n=t.name;return`\n    vec4 ${"get"+n.charAt(0).toUpperCase()+n.slice(1)}() {\n      return ${bs().texture2D}(${n}, halfCR);\n    }\n  `}(t);case 1:return function dge(t,n){const e=t.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),s=t.shapeInfo.texShape,o=bs();if(n)return`\n    vec4 ${r}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${o.texture2D}(${e}, uv);\n    }\n  `;const i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];return`\n    vec4 ${r}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${i[0]}, ${i[1]}, index);\n      return ${o.texture2D}(${e}, uv);\n    }\n  `}(t,n);case 2:return function pge(t,n){const e=t.shapeInfo.logicalShape,r=t.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=t.shapeInfo.texShape,i=o[0],a=o[1],l=bs();if(null!=o&&gn(e,o))return n?`\n      vec4 ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `:`\n      vec4 ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${i}.0);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `;if(n)return`\n    vec4 ${s}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `;const u=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];return`\n    vec4 ${s}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${Math.ceil(e[1]/2)}, ${u[0]}, ${u[1]}, row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `}(t,n);case 3:return function mge(t,n){const e=t.shapeInfo.logicalShape,r=t.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=t.shapeInfo.texShape,i=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];if(1===e[0]){const p=[1,2],g=["b","row","col"];return`\n        ${z3(sd(t,e.slice(1)),n)}\n        vec4 ${s}(int b, int row, int col) {\n          return ${s}(${od(g,p)});\n        }\n      `}const a=bs();if(n)return`\n    vec4 ${s}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${a.texture2D}(${r}, uv);\n    }\n  `;const l=i[0],u=i[1],c=Math.ceil(e[2]/2);return`\n    vec4 ${s}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${l}, ${u}, ${c*Math.ceil(e[1]/2)}, ${c}, b, row, col);\n      return ${a.texture2D}(${r}, uv);\n    }\n  `}(t,n);default:return function yge(t,n){const e=t.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),s=bs();if(n)return`\n    vec4 ${r}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${e}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${e}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${e}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${s.texture2D}(${e}, uv);\n    }\n  `;const o=t.shapeInfo.logicalShape,i=o.length,a=t.shapeInfo.texShape,l=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],u=l[0],c=l[1],d=Math.ceil(o[i-1]/2);let h=d*Math.ceil(o[i-2]/2),p="int b, int row, int col",f=`b * ${h} + (row / 2) * ${d} + (col / 2)`;for(let g=2;g<i-1;g++)p=`int b${g}, `+p,h*=o[i-g-1],f=`b${g} * ${h} + `+f;return`\n    vec4 ${r}(${p}) {\n      int index = ${f};\n      int texR = index / ${c};\n      int texC = index - texR * ${c};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${u});\n      return ${s.texture2D}(${e}, uv);\n    }\n  `}(t,n)}}const Xme="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Yme="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Zme="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Qme="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function mu(t){return`offset${t}`}function rd(t){const n=t.name,e=_e(t.shapeInfo.logicalShape);return e<2?`return ${n};`:`\n    for (int i = 0; i < ${e}; i++) {\n      if (i == index) {\n        return ${n}[i];\n      }\n    }\n  `}function kn(t){if(t<=1)return"int";if(2===t)return"ivec2";if(3===t)return"ivec3";if(4===t)return"ivec4";if(5===t)return"ivec5";if(6===t)return"ivec6";throw Error(`GPU for rank ${t} is not yet supported`)}function VI(t,n,e){const{newShape:r,keptDims:s}=La(n),o=n.length,i=t&&3===o&&1===n[0],a=i?n.slice(1):r,l=!t&&o>1&&!gn(n,e)&&r.length<o||i;return{useSqueezeShape:l,uniformShape:l?a:n,keptDims:s}}function sd(t,n){const e=JSON.parse(JSON.stringify(t));return e.shapeInfo.logicalShape=n,e}function od(t,n){return n.map(e=>t[e]).join(", ")}function W3(t,n,e){const r=[],s=[];let o,i,a,l=null,u=null;u=t.getUniformLocation(e,"NAN",!1),1===pe().getNumber("WEBGL_VERSION")&&(l=t.getUniformLocation(e,"INFINITY",!1));const c=!1;for(const d of n.variableNames){const h={name:d,uniform:t.getUniformLocation(e,d,c),offset:t.getUniformLocation(e,`offset${d}`,c)};n.enableShapeUniforms&&(h.shape=t.getUniformLocation(e,`${d}Shape`,c),h.texShape=t.getUniformLocation(e,`${d}TexShape`,c)),r.push(h)}if(n.enableShapeUniforms&&(o=t.getUniformLocation(e,"outShape",c),a=t.getUniformLocation(e,"outShapeStrides",c),i=t.getUniformLocation(e,"outTexShape",c)),n.customUniforms)for(const d of n.customUniforms)s.push(t.getUniformLocation(e,d.name,c));return{variablesLocations:r,customUniformLocations:s,infLoc:l,nanLoc:u,outShapeLocation:o,outShapeStridesLocation:a,outTexShapeLocation:i}}function G3(t,n){if(t.length!==n.length)throw Error(`Binary was compiled with ${t.length} inputs, but was executed with ${n.length} inputs`);t.forEach((e,r)=>{const s=e.logicalShape,o=n[r],i=o.shape;if(!gn(s,i))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${s} and ${i} must match`);if(e.isUniform&&o.isUniform)return;const a=e.texShape,l=o.isUniform?null:o.texData.texShape;if(!gn(a,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${l} must match`)})}function ss(t){return pe().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&t<=4}class Dge{constructor(n){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=Qc.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const e=bs();this.outputShape=n,this.enableShapeUniforms=ss(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?pb(["r","c","d"],n):fu(["r","c","d"],n)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${e.output} = result;\n      }\n    `}}class Tge{constructor(n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=Qc.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const e=bs();this.outputShape=n,this.enableShapeUniforms=ss(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?pb(["r","c","d"],n):fu(["r","c","d"],n)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${e.output} = result;\n      }\n    `}}class kge{constructor(n){this.variableNames=["A"],this.outTexUsage=qs.DOWNLOAD;const e=bs();this.outputShape=n,this.userCode=`\n      ${V3}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${e.output} = encode_float(x);\n      }\n    `}}class Ege{constructor(n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=qs.DOWNLOAD;const e=bs();this.outputShape=n,this.userCode=`\n      ${V3}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${e.output} = encode_float(x);\n      }\n    `}}const Nge={R:0,G:1,B:2,A:3};class H3{constructor(n,e=!1,r="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const s=bs();this.outputShape=n,this.enableShapeUniforms=ss(this.outputShape.length);let o="result";e&&(o="floor(result * 255. + 0.5)");let i="";for(let a=0;a<r.length;a++)i+=`\n          if(offset == ${a}) {\n            result = values[${Nge[r[a]]}];\n          }`;this.userCode=`\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":$I(n)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int flatIndex = getFlatIndex(coords);\n        float result = 0.;\n        int offset = imod(flatIndex, ${r.length});\n\n        flatIndex = idiv(flatIndex, ${r.length}, 1.);\n\n        int r = flatIndex / texShape[1];\n        if (r < texShape[0]) {\n          int c = imod(flatIndex, texShape[1]);\n          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n          vec4 values = ${s.texture2D}(A, uv);\n          ${i}\n        }\n        ${s.output} = vec4(${o}, 0., 0., 0.);\n      }\n    `}}class Age{constructor(n,e=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=bs();this.outputShape=n,this.enableShapeUniforms=ss(this.outputShape.length);let s="",o="result";e&&(o="floor(result * 255. + 0.5)");for(let i=0;i<=1;i++)for(let a=0;a<=1;a++){const l=2*i+a;s+=`\n          localCoords = coords;\n          if(localCoords[2] + ${a} < ${this.enableShapeUniforms?"outShape[2]":`${n[2]}`}) {\n          localCoords[2] += ${a};\n          if (localCoords[1] + ${i} < ${this.enableShapeUniforms?"outShape[1]":`${n[1]}`}) {\n            localCoords[1] += ${i};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${r.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${l}] = values[0];\n            } else if (offset == 1) {\n              result[${l}] = values[1];\n            } else if (offset == 2) {\n              result[${l}] = values[2];\n            } else {\n              result[${l}] = values[3];\n            }\n          }\n        }\n        `}this.userCode=`\n        ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":$I(n)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${s}\n\n          ${r.output} = ${o};\n        }\n    `}}function bf(t,n,e,r,s,o){!function Sme(t,n){const e=pe().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(t<=0||n<=0)throw new Error(`Requested texture size [${t}x${n}] is invalid.`);if(t>e||n>e)throw new Error(`Requested texture size [${t}x${n}] greater than WebGL maximum on this browser / GPU [${e}x${e}].`)}(n,e);const i=function Cme(t){return va(t,()=>t.createTexture(),"Unable to create WebGLTexture.")}(t),a=t.TEXTURE_2D;return rt(t,()=>t.bindTexture(a,i)),rt(t,()=>t.texParameteri(a,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE)),rt(t,()=>t.texParameteri(a,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE)),rt(t,()=>t.texParameteri(a,t.TEXTURE_MIN_FILTER,t.NEAREST)),rt(t,()=>t.texParameteri(a,t.TEXTURE_MAG_FILTER,t.NEAREST)),1===pe().getNumber("WEBGL_VERSION")?rt(t,()=>t.texImage2D(a,0,r,n,e,0,s,o,null)):rt(t,()=>t.texStorage2D(a,1,r,n,e)),rt(t,()=>t.bindTexture(t.TEXTURE_2D,null)),{texture:i,texShape:[e,n]}}function j3(t){return t.internalFormatFloat}function q3(t){return t.internalFormatHalfFloat}function K3(t){return t.downloadTextureFormat}function X3(t){return t.internalFormatPackedFloat}function Y3(t){return t.internalFormatPackedHalfFloat}class BI{constructor(n){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const e=pe().getNumber("WEBGL_VERSION");if(null!=n?(this.gl=n,function ime(t,n){ll[t]=n}(e,n)):this.gl=ui(e),n=this.gl,2===pe().getNumber("WEBGL_VERSION")){const o=n;this.createVertexArray=()=>rt(o,()=>o.createVertexArray()),this.bindVertexArray=i=>rt(o,()=>o.bindVertexArray(i)),this.deleteVertexArray=i=>rt(o,()=>o.deleteVertexArray(i)),this.getVertexArray=()=>rt(o,()=>o.getParameter(o.VERTEX_ARRAY_BINDING))}else if(null!=n){const o=n.getExtension("OES_vertex_array_object");if(null==o)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>rt(n,()=>o.createVertexArrayOES()),this.bindVertexArray=i=>rt(n,()=>o.bindVertexArrayOES(i)),this.deleteVertexArray=i=>rt(n,()=>o.deleteVertexArrayOES(i)),this.getVertexArray=()=>rt(n,()=>n.getParameter(o.VERTEX_ARRAY_BINDING_OES))}let r="WEBGL_color_buffer_float";const s="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===pe().getNumber("WEBGL_VERSION")){const i="OES_texture_half_float";if(this.textureFloatExtension=ib(this.gl,"OES_texture_float"),zo(this.gl,i))this.textureHalfFloatExtension=ib(this.gl,i);else if(pe().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(r),zo(this.gl,s))this.colorBufferHalfFloatExtension=ib(this.gl,s);else if(pe().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(r="EXT_color_buffer_float",zo(this.gl,r))this.colorBufferFloatExtension=this.gl.getExtension(r);else{if(!zo(this.gl,s))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(s)}this.vertexBuffer=function Fge(t){return function wme(t,n){const e=va(t,()=>t.createBuffer(),"Unable to create WebGLBuffer");return rt(t,()=>t.bindBuffer(t.ARRAY_BUFFER,e)),rt(t,()=>t.bufferData(t.ARRAY_BUFFER,n,t.STATIC_DRAW)),e}(t,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}(this.gl),this.indexBuffer=function Oge(t){return function _me(t,n){const e=va(t,()=>t.createBuffer(),"Unable to create WebGLBuffer");return rt(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,e)),rt(t,()=>t.bufferData(t.ELEMENT_ARRAY_BUFFER,n,t.STATIC_DRAW)),e}(t,new Uint16Array([0,1,2,2,1,3]))}(this.gl),this.framebuffer=function Ime(t){return va(t,()=>t.createFramebuffer(),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=FI(this.gl,this.textureHalfFloatExtension)}get debug(){return pe().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const n=this.gl;rt(n,()=>n.finish()),rt(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,null)),rt(n,()=>n.deleteFramebuffer(this.framebuffer)),rt(n,()=>n.bindBuffer(n.ARRAY_BUFFER,null)),rt(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,null)),rt(n,()=>n.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(n,e){return this.throwIfDisposed(),function Pge(t,n,e,r){const[s,o]=yf(n,e);return bf(t,s,o,j3(r),r.textureFormatFloat,t.FLOAT)}(this.gl,n,e,this.textureConfig)}createFloat16MatrixTexture(n,e){return this.throwIfDisposed(),function Mge(t,n,e,r){const[s,o]=yf(n,e);return bf(t,s,o,q3(r),r.textureFormatFloat,r.textureTypeHalfFloat)}(this.gl,n,e,this.textureConfig)}createUnsignedBytesMatrixTexture(n,e){return this.throwIfDisposed(),function $ge(t,n,e,r){const[s,o]=yf(n,e);return bf(t,s,o,K3(r),t.RGBA,t.UNSIGNED_BYTE)}(this.gl,n,e,this.textureConfig)}uploadPixelDataToTexture(n,e){this.throwIfDisposed(),function Uge(t,n,e){rt(t,()=>t.bindTexture(t.TEXTURE_2D,n)),e.data instanceof Uint8Array?2===pe().getNumber("WEBGL_VERSION")?rt(t,()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,e.width,e.height,t.RGBA,t.UNSIGNED_BYTE,e.data)):rt(t,()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,e.width,e.height,0,t.RGBA,t.UNSIGNED_BYTE,e.data)):2===pe().getNumber("WEBGL_VERSION")?rt(t,()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,t.RGBA,t.UNSIGNED_BYTE,e)):rt(t,()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,e)),rt(t,()=>t.bindTexture(t.TEXTURE_2D,null))}(this.gl,n,e)}uploadDenseMatrixToTexture(n,e,r,s){this.throwIfDisposed(),function zge(t,n,e,r,s,o){let i,a,l;rt(t,()=>t.bindTexture(t.TEXTURE_2D,n)),s instanceof Uint8Array?(i=new Uint8Array(e*r*4),a=t.UNSIGNED_BYTE,l=t.RGBA):(i=new Float32Array(e*r*4),a=t.FLOAT,l=o.internalFormatPackedFloat),i.set(s),2===pe().getNumber("WEBGL_VERSION")?rt(t,()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,e,r,t.RGBA,a,i)):rt(t,()=>t.texImage2D(t.TEXTURE_2D,0,l,e,r,0,t.RGBA,a,i)),rt(t,()=>t.bindTexture(t.TEXTURE_2D,null))}(this.gl,n,e,r,s,this.textureConfig)}createFloat16PackedMatrixTexture(n,e){return this.throwIfDisposed(),function Vge(t,n,e,r){const[s,o]=Jc(n,e);return bf(t,s,o,Y3(r),t.RGBA,r.textureTypeHalfFloat)}(this.gl,n,e,this.textureConfig)}createPackedMatrixTexture(n,e){return this.throwIfDisposed(),function Lge(t,n,e,r){const[s,o]=Jc(n,e);return bf(t,s,o,X3(r),t.RGBA,t.FLOAT)}(this.gl,n,e,this.textureConfig)}deleteMatrixTexture(n){this.throwIfDisposed(),this.outputTexture===n&&(M3(this.gl,this.framebuffer),this.outputTexture=null),rt(this.gl,()=>this.gl.deleteTexture(n))}downloadByteEncodedFloatMatrixFromOutputTexture(n,e,r){return this.downloadMatrixDriver(n,()=>function Hge(t,n,e,r){const[s,o]=yf(n,e),a=new Uint8Array(function ume(t,n){return t*n}(n*e,4));return rt(t,()=>t.readPixels(0,0,s,o,r.downloadTextureFormat,t.UNSIGNED_BYTE,a)),new Float32Array(a.buffer)}(this.gl,e,r,this.textureConfig))}downloadPackedMatrixFromBuffer(n,e,r,s,o,i){return function jge(t,n,e,r,s,o,i,a){const l=t,u=new Float32Array(function cme(t,n){const[e,r]=Jc(t,n);return e*r*4}(o,i));return l.bindBuffer(l.PIXEL_PACK_BUFFER,n),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,u),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),u}(this.gl,n,0,0,0,o,i)}downloadFloat32MatrixFromBuffer(n,e){return function Gge(t,n,e){const r=t,s=new Float32Array(e);return r.bindBuffer(r.PIXEL_PACK_BUFFER,n),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,s),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),s}(this.gl,n,e)}createBufferFromTexture(n,e,r){this.bindTextureToFrameBuffer(n);const s=function Wge(t,n,e,r){const s=t.createBuffer();rt(t,()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,s));const a=16*n*e;return rt(t,()=>t.bufferData(t.PIXEL_PACK_BUFFER,a,t.STREAM_READ)),rt(t,()=>t.readPixels(0,0,e,n,t.RGBA,t.FLOAT,0)),rt(t,()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,null)),s}(this.gl,e,r);return this.unbindTextureToFrameBuffer(),s}createAndWaitForFence(){const n=this.createFence(this.gl);return this.pollFence(n)}createFence(n){let e,r;if(pe().getBool("WEBGL_FENCE_API_ENABLED")){const s=n,o=s.fenceSync(s.SYNC_GPU_COMMANDS_COMPLETE,0);n.flush(),r=()=>{const i=s.clientWaitSync(o,0,0);return i===s.ALREADY_SIGNALED||i===s.CONDITION_SATISFIED},e=o}else pe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(e=this.beginQuery(),this.endQuery(),r=()=>this.isQueryAvailable(e,pe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):r=()=>!0;return{query:e,isFencePassed:r}}downloadMatrixFromPackedTexture(n,e,r){return this.downloadMatrixDriver(n,()=>function qge(t,n,e){const r=new Float32Array(n*e*4);return rt(t,()=>t.readPixels(0,0,e,n,t.RGBA,t.FLOAT,r)),r}(this.gl,e,r))}createProgram(n){this.throwIfDisposed();const e=this.gl;null==this.vertexShader&&(this.vertexShader=function Rge(t){const n=bs();return function gme(t,n){const e=va(t,()=>t.createShader(t.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(rt(t,()=>t.shaderSource(e,n)),rt(t,()=>t.compileShader(e)),!1===t.getShaderParameter(e,t.COMPILE_STATUS))throw console.log(t.getShaderInfoLog(e)),new Error("Failed to compile vertex shader.");return e}(t,`${n.version}\n    precision highp float;\n    ${n.attribute} vec3 clipSpacePos;\n    ${n.attribute} vec2 uv;\n    ${n.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}(e));const r=function bme(t){return va(t,()=>t.createProgram(),"Unable to create WebGLProgram.")}(e);let s;return rt(e,()=>e.attachShader(r,this.vertexShader)),rt(e,()=>e.attachShader(r,n)),function xme(t,n){if(rt(t,()=>t.linkProgram(n)),!pe().get("ENGINE_COMPILE_ONLY")&&!1===t.getProgramParameter(n,t.LINK_STATUS))throw console.log(t.getProgramInfoLog(n)),new Error("Failed to link vertex and fragment shaders.")}(e,r),s=Object.assign(r,{vao:this.createVertexArray()}),this.bindVertexArray(s.vao),rt(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),console.assert(function Bge(t,n,e){return rt(t,()=>t.bindBuffer(t.ARRAY_BUFFER,e)),P3(t,n,"clipSpacePos",e,3,20,0)&&P3(t,n,"uv",e,2,20,12)}(e,s,this.vertexBuffer),"gpgpu_util.bindVertexProgramAttributeStreams not fully successful."),this.debug&&OI(e,s),this.setProgram(s),s}deleteProgram(n){this.throwIfDisposed(),n===this.program&&(this.program=null),null!=n&&(rt(this.gl,()=>this.gl.deleteProgram(n)),this.deleteVertexArray(n.vao))}setProgram(n){this.throwIfDisposed(),this.program=n,null!=this.program&&(this.bindVertexArray(this.program.vao),this.debug&&OI(this.gl,this.program)),rt(this.gl,()=>this.gl.useProgram(n))}getUniformLocation(n,e,r=!0){return this.throwIfDisposed(),r?function Tme(t,n,e){return va(t,()=>t.getUniformLocation(n,e),'uniform "'+e+'" not present in program.')}(this.gl,n,e):function kme(t,n,e){return t.getUniformLocation(n,e)}(this.gl,n,e)}getAttributeLocation(n,e){return this.throwIfDisposed(),rt(this.gl,()=>this.gl.getAttribLocation(n,e))}getUniformLocationNoThrow(n,e){return this.throwIfDisposed(),this.gl.getUniformLocation(n,e)}setInputMatrixTexture(n,e,r){this.throwIfDisposed(),this.throwIfNoProgram(),Eme(this.gl,n,e,r)}setOutputMatrixTexture(n,e,r){this.setOutputMatrixTextureDriver(n,r,e)}setOutputPackedMatrixTexture(n,e,r){this.throwIfDisposed();const[s,o]=Jc(e,r);this.setOutputMatrixTextureDriver(n,s,o)}setOutputMatrixWriteRegion(n,e,r,s){this.setOutputMatrixWriteRegionDriver(r,n,s,e)}setOutputPackedMatrixWriteRegion(n,e,r,s){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&OI(this.gl,this.program),ab(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const n=this.gl;if(this.debug){const e=this.getVertexArray();console.assert(e===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}rt(n,()=>n.drawElements(n.TRIANGLES,6,n.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),rt(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=ib(this.gl,2===pe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===pe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const r=this.gl,s=this.getQueryTimerExtensionWebGL2(),o=r.createQuery();return r.beginQuery(s.TIME_ELAPSED_EXT,o),o}const n=this.getQueryTimerExtensionWebGL1(),e=n.createQueryEXT();return n.beginQueryEXT(n.TIME_ELAPSED_EXT,e),e}endQuery(){if(2===pe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,r=this.getQueryTimerExtensionWebGL2();return void e.endQuery(r.TIME_ELAPSED_EXT)}const n=this.getQueryTimerExtensionWebGL1();n.endQueryEXT(n.TIME_ELAPSED_EXT)}waitForQueryAndGetTime(n){var e=this;return $e(function*(){return yield IO(()=>e.disposed||e.isQueryAvailable(n,pe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),e.getQueryTime(n,pe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))})()}getQueryTime(n,e){if(0===e)return null;if(2===e){const r=this.gl;return r.getQueryParameter(n,r.QUERY_RESULT)/1e6}{const r=this.getQueryTimerExtensionWebGL1();return r.getQueryObjectEXT(n,r.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(n,e){if(0===e)return!0;if(2===e){const r=this.gl,s=this.getQueryTimerExtensionWebGL2(),o=r.getQueryParameter(n,r.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),o&&!this.disjoint}{const r=this.getQueryTimerExtensionWebGL1(),s=r.getQueryObjectEXT(n,r.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),s&&!this.disjoint}}pollFence(n){return new Promise(e=>{this.addItemToPoll(()=>n.isFencePassed(),()=>e())})}pollItems(){const n=function Kge(t){let n=0;for(;n<t.length&&t[n]();++n);return n-1}(this.itemsToPoll.map(e=>e.isDoneFn));for(let e=0;e<=n;++e){const{resolveFn:r}=this.itemsToPoll[e];r()}this.itemsToPoll=this.itemsToPoll.slice(n+1)}addItemToPoll(n,e){if(this.itemsToPoll.push({isDoneFn:n,resolveFn:e}),this.itemsToPoll.length>1)return;let r;"setTimeoutCustom"in pe().platform&&(r=pe().platform.setTimeoutCustom.bind(pe().platform)),IO(()=>(this.pollItems(),0===this.itemsToPoll.length),()=>0,null,r)}bindTextureToFrameBuffer(n){this.throwIfDisposed(),PI(this.gl,n,this.framebuffer),this.debug&&ab(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(PI(this.gl,this.outputTexture,this.framebuffer),this.debug&&ab(this.gl)):M3(this.gl,this.framebuffer)}downloadMatrixDriver(n,e){this.bindTextureToFrameBuffer(n);const r=e();return this.unbindTextureToFrameBuffer(),r}setOutputMatrixTextureDriver(n,e,r){this.throwIfDisposed();const s=this.gl;PI(s,n,this.framebuffer),this.debug&&ab(s),this.outputTexture=n,rt(s,()=>s.viewport(0,0,e,r)),rt(s,()=>s.scissor(0,0,e,r))}setOutputMatrixWriteRegionDriver(n,e,r,s){this.throwIfDisposed(),rt(this.gl,()=>this.gl.scissor(n,e,r,s))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}const{addImpl:Xge,bincountImpl:Z3,bincountReduceImpl:Yge,castImpl:Zge,ceilImpl:Qge,concatImpl:Jge,equalImpl:eye,expImpl:tye,expm1Impl:nye,floorImpl:rye,gatherNdImpl:sye,gatherV2Impl:oye,greaterImpl:iye,greaterEqualImpl:aye,lessImpl:lye,lessEqualImpl:uye,linSpaceImpl:cye,logImpl:dye,maxImpl:hye,maximumImpl:pye,minimumImpl:fye,multiplyImpl:mye,negImpl:gye,notEqualImpl:yye,prodImpl:vye,raggedGatherImpl:bye,raggedRangeImpl:xye,raggedTensorToTensorImpl:wye,rangeImpl:_ye,rsqrtImpl:Cye,scatterImpl:Sye,sigmoidImpl:Iye,simpleAbsImpl:Q3,sliceImpl:Dye,sparseFillEmptyRowsImpl:Tye,sparseReshapeImpl:kye,sparseSegmentReductionImpl:J3,sqrtImpl:Eye,staticRegexReplaceImpl:Nye,stridedSliceImpl:Aye,stringNGramsImpl:Rye,stringSplitImpl:Fye,stringToHashBucketFastImpl:Oye,subImpl:Pye,tileImpl:Mye,topKImpl:$ye,transposeImpl:zI,uniqueImpl:Lye}=F;function eB(t,n){return["x","y","z","w","u","v"].slice(0,n).map(e=>`${t}.${e}`)}function xs(t,n){return 1===n?[t]:eB(t,n)}class Bye{constructor(n){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=n,this.rank=n.length,this.enableShapeUniforms=ss(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const e=xs("rc",this.rank),r=kn(this.rank),s=this.getOutOfBoundsCondition(e),o=this.getSetup(e),i=this.getOutput(e);this.userCode=`\n        void main() {\n          ${r} rc = getOutputCoords();\n\n          if(${s}) {\n            setOutput(vec4(0));\n          } else {\n            ${o}\n\n            setOutput(vec4(${i}));\n          }\n        }\n      `}}getSourceCoordsArr(n){const e=[];for(let r=0;r<=1;r++)for(let s=0;s<=1;s++){let o=`${0===r?"r":"rp1"}, ${0===s?"c":"cp1"}`;for(let i=2;i<this.rank;i++)o=`${n[n.length-1-i]},`+o;e.push(o)}return e}getOutOfBoundsCondition(n){if(1===this.rank)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let e="";for(let r=this.rank-2;r<this.rank;r++)e+=`${n[r]} >= ${this.enableShapeUniforms?`outShape[${r}]`:this.outputShape[r]}`,r<this.rank-1&&(e+="||");return e}getSetup(n){if(1===this.rank)return"";const e=n.slice(-2);return`\n      int r = ${e[0]};\n      int c = ${e[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1]};\n      bool rEdge = rp1 >= ${this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2]};\n    `}getOutput(n){const e=this.getSourceCoordsArr(n);return 1===this.rank?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${e[0]}),\n            cEdge ? 0. : getA(${e[1]}),\n            rEdge ? 0. : getA(${e[2]}),\n            rEdge || cEdge ? 0. : getA(${e[3]})`}}class tB{constructor(n,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=n,this.enableShapeUniforms=ss(this.outputShape.length);let r="";for(let s=0;s<4;s++){let o="thisRC = rc;";s%2==1&&(o+="thisRC.z += 1;"),s>1&&(o+="thisRC.y += 1;"),r+=`\n        ${o}\n        ${s>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${s}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${s>0?"}":""}\n      `}this.userCode=`\n      ${function zye(t,n){return`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${n?function Bme(t,n,e="index"){const s=function Vme(t,n){const e=t.length,r=t.map(o=>`${n}[${o}]`),s=new Array(e-1);s[e-2]=r[e-1];for(let o=e-3;o>=0;--o)s[o]=`(${s[o+1]} * ${r[o+1]})`;return s}(t.map((o,i)=>i),n);return s.map((o,i)=>`int ${t[i]} = ${e} / ${s[i]}; ${i===s.length-1?`int ${t[i+1]} = ${e} - ${t[i]} * ${s[i]}`:`index -= ${t[i]} * ${s[i]}`};`).join("")}(["r","c","d"],"inputShape"):fu(["r","c","d"],t)}\n      return ivec3(r, c, d);\n    }\n  `}(e,this.enableShapeUniforms)}\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":$I(n)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms?"outShape[1]":n[1]};\n        int cols = ${this.enableShapeUniforms?"outShape[2]":n[2]};\n\n        ${r}\n\n        setOutput(result);\n      }\n    `}}class Uye{constructor(n){this.gpgpu=n,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(n,e,r){const s=rB(e,r),o=sB(n,s,r);o in this.freeTextures||(this.freeTextures[o]=[]),o in this.usedTextures||(this.usedTextures[o]=[]);const i=nB(n,s,this.gpgpu.gl,this.gpgpu.textureConfig,r);if(this.freeTextures[o].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=i,this.log();const l=this.freeTextures[o].pop();return this.usedTextures[o].push(l),l}let a;return s===zr.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(n[0],n[1]):s===zr.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(n[0],n[1]):s===zr.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(n[0],n[1]):s===zr.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(n[0],n[1]):s===zr.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(n[0],n[1])),this.usedTextures[o].push(a),this.numUsedTextures++,this._numBytesAllocated+=i,this.log(),a}releaseTexture(n,e,r,s){if(null==this.freeTextures)return;const o=rB(r,s),i=sB(e,o,s);i in this.freeTextures||(this.freeTextures[i]=[]);const a=nB(e,o,this.gpgpu.gl,this.gpgpu.textureConfig,s),l=pe().get("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==l&&this._numBytesAllocated>l?(this.gpgpu.deleteMatrixTexture(n.texture),this._numBytesAllocated-=a):(this.freeTextures[i].push(n),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;const u=this.usedTextures[i],c=u&&u.indexOf(n);if(null==c||c<0)throw new Error("Cannot release a texture that was never provided by this texture manager");u[c]=u[u.length-1],u.pop(),this.log()}log(){if(!this.logEnabled)return;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${this.numFreeTextures+this.numUsedTextures})`);const e=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*e)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const n in this.freeTextures)this.freeTextures[n].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});for(const n in this.usedTextures)this.usedTextures[n].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function nB(t,n,e,r,s){const o=function Gye(t,n){switch(t){case zr.PACKED_2X2_FLOAT32:return X3(n);case zr.PACKED_2X2_FLOAT16:return Y3(n);case zr.UNPACKED_FLOAT32:return j3(n);case zr.UNPACKED_FLOAT16:return q3(n);case zr.PACKED_4X1_UNSIGNED_BYTE:return K3(n);default:throw new Error(`Unknown physical texture type ${t}`)}}(n,r);let i;if(s){const[l,u]=Jc(t[0],t[1]);i=l*u}else{const[l,u]=yf(t[0],t[1]);i=l*u}const a=function Wye(t,n){if(n===t.R32F)return 4;if(n===t.R16F)return 2;if(n===t.RGBA32F)return 16;if(n===t.RGBA)return 16;if(n===t.RGBA16F)return 8;if(n===t.RGBA8)return 4;throw new Error(`Unknown internal format ${n}`)}(e,o);return i*a}function rB(t,n){if(t===qs.UPLOAD)return zr.PACKED_2X2_FLOAT32;if(t===qs.RENDER||null==t)return function Hye(t){return pe().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?t?zr.PACKED_2X2_FLOAT32:zr.UNPACKED_FLOAT32:t?zr.PACKED_2X2_FLOAT16:zr.UNPACKED_FLOAT16}(n);if(t===qs.DOWNLOAD||t===qs.PIXELS)return zr.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${t}`)}function sB(t,n,e){return`${t[0]}_${t[1]}_${n}_${e}`}class zi{constructor(n,e){this.variableNames=["A"],this.outputShape=n,this.enableShapeUniforms=ss(this.outputShape.length),this.userCode=`\n      float unaryOperation(float x) {\n        ${e}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const go="if (isnan(x)) return x;",jye="return x;",oB="return abs(x);",qye="return (x >= 0.0) ? x : (exp(x) - 1.0);",Kye=go+"\n  return (x < 0.0) ? 0.0 : x;\n",Xye=go+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",ul="return x;",Yye="return 1.0 / (1.0 + exp(-1.0 * x));",Zye="return x;",Qye="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",Jye="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",eve="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",tve="return 1.0 / (1.0 + exp(-1.0 * x));";class cl{constructor(n,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=ss(this.outputShape.length),this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${e}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}class nve{constructor(n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=n,this.enableShapeUniforms=ss(this.outputShape.length);const e=n.length,r=xs("rc",e),s=kn(e),o=function Vye(t,n){if(1===t)return"rc";let e="";for(let r=0;r<t;r++)e+=n[r],r<t-1&&(e+=",");return e}(e,r),i=r.slice(-2),a=e<=1?"rc":`vec2(${i.join(",")})`;this.userCode=`\n      void main() {\n        ${s} rc = getOutputCoords();\n        vec4 packedInput = getA(${o});\n\n        setOutput(getChannel(packedInput, ${a}));\n      }\n    `}}const rve=e$,mb={},ave=pe().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");let cve=(()=>{class t extends F_{nextDataId(){return t.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!pe().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let r;if(null!=e){if(e instanceof BI)r=e;else{const s=ui(pe().getNumber("WEBGL_VERSION"),e);r=new BI(s)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const s=ui(pe().getNumber("WEBGL_VERSION"));r=new BI(s),this.binaryCache=function ive(t){return t in mb||(mb[t]={}),mb[t]}(pe().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=r,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new Uye(this.gpgpu),this.numMBBeforeWarning=function uve(){return null==pe().global.screen?1024:pe().global.screen.height*pe().global.screen.width*window.devicePixelRatio*600/1024/1024}(),this.texData=new CO(this,ki())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,r,s,o,i,a){const l=this.makeTensorInfo(r,s),u=this.texData.get(l.dataId);u.isPacked=!1,u.texture={texture:e,texShape:[o,i]},u.texShape=[o,i];const c=lb(r),d=new H3(c,!1,a),h=this.runWebGLProgram(d,[l],s,[[o,i]]);return h.shape=r,u.texture=null,this.disposeIntermediateTensorInfo(l),h.dataId}write(e,r,s){if((pe().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||pe().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===s&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const o={id:this.nextDataId()};return this.texData.set(o,{shape:r,dtype:s,values:e,usage:qs.UPLOAD,refCount:1}),o}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){this.texData.get(e).refCount++}decRef(e){this.texData.has(e)&&this.texData.get(e).refCount--}move(e,r,s,o,i){if(pe().getBool("DEBUG")&&this.checkNumericalProblems(r),"complex64"===o)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:s,dtype:o,values:r,usage:qs.UPLOAD,refCount:i})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const r=this.texData.get(e),{values:s,dtype:o,complexTensorInfos:i,slice:a,shape:l,isPacked:u}=r;if(null!=a){let p;p=u?new cl(l,ul):new zi(l,ul);const f=this.runWebGLProgram(p,[{dataId:e,shape:l,dtype:o}],o),g=this.readSync(f.dataId);return this.disposeIntermediateTensorInfo(f),g}if(null!=s)return this.convertAndCacheOnCPU(e);if("string"===o)return s;const c=null!=this.activeTimers;let d,h;return c&&(d=Rs()),h="complex64"===o?ma(this.readSync(i.real.dataId),this.readSync(i.imag.dataId)):this.getValuesFromTexture(e),c&&(this.downloadWaitMs+=Rs()-d),this.convertAndCacheOnCPU(e,h)}read(e){var r=this;return $e(function*(){if(r.pendingRead.has(e)){const m=r.pendingRead.get(e);return new Promise(y=>m.push(y))}const s=r.texData.get(e),{values:o,shape:i,slice:a,dtype:l,complexTensorInfos:u,isPacked:c}=s;if(null!=a){let m;m=c?new cl(i,ul):new zi(i,ul);const y=r.runWebGLProgram(m,[{dataId:e,shape:i,dtype:l}],l),v=r.read(y.dataId);return r.disposeIntermediateTensorInfo(y),v}if(null!=o)return r.convertAndCacheOnCPU(e);if(pe().getBool("DEBUG")&&!pe().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===pe().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let h,p,d=null;if("complex64"!==l&&pe().get("WEBGL_BUFFER_SUPPORTED")){h=r.decode(e);const m=r.texData.get(h.dataId);d=r.gpgpu.createBufferFromTexture(m.texture.texture,...ob(i))}if(r.pendingRead.set(e,[]),"complex64"!==l&&(yield r.gpgpu.createAndWaitForFence()),"complex64"===l){const m=yield Promise.all([r.read(u.real.dataId),r.read(u.imag.dataId)]);p=ma(m[0],m[1])}else if(null==d)p=r.getValuesFromTexture(e);else{const m=_e(i);p=r.gpgpu.downloadFloat32MatrixFromBuffer(d,m)}if(null!=h&&r.disposeIntermediateTensorInfo(h),null!=d){const m=r.gpgpu.gl;rt(m,()=>m.deleteBuffer(d))}const f=r.convertAndCacheOnCPU(e,p),g=r.pendingRead.get(e);return r.pendingRead.delete(e),g.forEach(m=>m(f)),r.pendingDisposal.has(e)&&(r.pendingDisposal.delete(e),r.disposeData(e)&&ki().removeDataId(e,r),r.pendingDeletes--),f})()}readToGPU(e,r={}){const s=this.texData.get(e),{values:o,shape:i,slice:a,dtype:l,isPacked:u,texture:c}=s;if("complex64"===l)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=a){let f;f=u?new cl(i,ul):new zi(i,ul);const g=this.runWebGLProgram(f,[{dataId:e,shape:i,dtype:l}],l),m=this.readToGPU(g,r);return this.disposeIntermediateTensorInfo(g),m}if(null==c)throw null!=o?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const d=this.decode(e,r.customTexShape),h=ki().makeTensorFromTensorInfo(d),p=this.texData.get(d.dataId);return Object.assign({tensorRef:h},p.texture)}bufferSync(e){const r=this.readSync(e.dataId);if("string"===e.dtype)try{const s=r.map(o=>Ua(o));return en(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return en(e.shape,e.dtype,r)}checkNumericalProblems(e){if(null!=e)for(let r=0;r<e.length;r++){const s=e[r];if(!fme(s))throw pe().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${s} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${s} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:r,dtype:s,isPacked:o}=this.texData.get(e),i=_e(r);if(pe().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const p=this.decode(e),f=this.texData.get(p.dataId),g=this.gpgpu.downloadMatrixFromPackedTexture(f.texture.texture,...ob(r)).subarray(0,i);return this.disposeIntermediateTensorInfo(p),g}const a=pe().getBool("WEBGL_PACK")&&!0===o,l=a?lb(r):r,u=a?new Ege(l):new kge(l),c=this.runWebGLProgram(u,[{shape:l,dtype:s,dataId:e}],"float32"),d=this.texData.get(c.dataId),h=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(d.texture.texture,d.texShape[0],d.texShape[1]).subarray(0,i);return this.disposeIntermediateTensorInfo(c),h}timerAvailable(){return pe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){var r=this;const s=this.activeTimers,o=[];let i=!1;null==this.programTimersStack?(this.programTimersStack=o,i=!0):this.activeTimers.push(o),this.activeTimers=o,e();const a=jl(this.activeTimers.map(c=>c.query)).filter(c=>null!=c),l=jl(this.activeTimers.map(c=>c.name)).filter(c=>null!=c);this.activeTimers=s,i&&(this.programTimersStack=null);const u={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return $e(function*(){if(pe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const c=yield Promise.all(a);u.kernelMs=function FY(t){let n=0;for(let e=0;e<t.length;e++)n+=t[e];return n}(c),u.getExtraProfileInfo=()=>c.map((d,h)=>({name:l[h],ms:d})).map(d=>`${d.name}: ${d.ms}`).join(", ")}else u.kernelMs={error:"WebGL query timers are not supported in this environment."};return r.uploadWaitMs=0,r.downloadWaitMs=0,u})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return pe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:Rs(),endMs:null}}endTimer(e){return pe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=Rs(),e)}getQueryTime(e){var r=this;return $e(function*(){return pe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?r.gpgpu.waitForQueryAndGetTime(e):e.endMs-e.startMs})()}disposeData(e,r=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(r?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!r&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:s}=this.texData.get(e);return null!=s&&(this.disposeData(s.real.dataId,r),this.disposeData(s.imag.dataId,r)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:r,dtype:s,texShape:o,usage:i,isPacked:a,slice:l}=this.texData.get(e),u=l&&l.origDataId||e,c=this.dataRefCount.get(u);c>1?this.dataRefCount.set(u,c-1):(this.dataRefCount.delete(u),null!=r&&(this.numBytesInGPU-=this.computeBytes(o,s),this.textureManager.releaseTexture(r,o,i,a)));const d=this.texData.get(e);d.texture=null,d.texShape=null,d.isPacked=!1,d.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,r=ave){return pe().getBool("WEBGL_CPU_FORWARD")&&e.every(s=>null==this.texData.get(s.dataId).texture&&_e(s.shape)<r)}getGPGPUContext(){return this.gpgpu}where(e){lo("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const r=e.dataSync();return rve(e.shape,r)}packedUnaryOp(e,r,s){const o=new cl(e.shape,r),i=this.compileAndRun(o,[e],s);return ki().makeTensorFromTensorInfo(i)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){const o=Q3(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,o)}if(pe().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,oB,e.dtype);const r=new zi(e.shape,oB),s=this.compileAndRun(r,[e]);return ki().makeTensorFromTensorInfo(s)}makeTensorInfo(e,r,s){let o;if("string"===r&&null!=s&&s.length>0&&Oh(s[0])){const i=s.map(a=>za(a));o=this.write(i,e,r)}else o=this.write(s,e,r);return this.texData.get(o).usage=null,{dataId:o,shape:e,dtype:r}}makeOutput(e,r,s){return ki().makeTensorFromTensorInfo(this.makeTensorInfo(e,r,s),this)}unpackTensor(e){const r=new nve(e.shape);return this.runWebGLProgram(r,[e],e.dtype)}packTensor(e){const r=new Bye(e.shape);return this.runWebGLProgram(r,[e],e.dtype,null,!0)}packedReshape(e,r){const s=[ed(e.shape),...td(e.shape)],o={dtype:e.dtype,shape:s,dataId:e.dataId},i=[ed(r),...td(r)],a=new tB(i,s),c=this.runWebGLProgram(a,[o],e.dtype,[s],!0);return{dataId:c.dataId,shape:r,dtype:c.dtype}}decode(e,r){const s=this.texData.get(e),{isPacked:o,shape:i,dtype:a}=s;null!=r&&R(_e(i)<=r[0]*r[1]*4,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.");const l=lb(i);let u;u=o?new Tge(l):new Dge(l);const d=[r??ob(l)];return{dtype:a,shape:i,dataId:this.runWebGLProgram(u,[{shape:l,dtype:a,dataId:e}],a,d,!0,r).dataId}}runWebGLProgram(e,r,s,o,i=!1,a){const l=this.makeTensorInfo(e.outputShape,s),u=this.texData.get(l.dataId);if(e.packedOutput&&(u.isPacked=!0),e.outPackingScheme===Qc.DENSE){const v=a??ob(e.outputShape);u.texShape=v.map(b=>2*b)}if(null!=e.outTexUsage&&(u.usage=e.outTexUsage),0===_e(l.shape))return u.values=ts(l.dtype,0),l;const c=[],d=r.map(v=>{if("complex64"===v.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let b=this.texData.get(v.dataId);if(null==b.texture){if(!e.packedInputs&&_e(v.shape)<=pe().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:v.shape,texData:null,isUniform:!0,uniformValues:b.values};e.packedInputs&&(b.isPacked=!0,b.shape=v.shape)}if(this.uploadToGPU(v.dataId),!!b.isPacked!=!!e.packedInputs)v=b.isPacked?this.unpackTensor(v):this.packTensor(v),c.push(v),b=this.texData.get(v.dataId);else if(b.isPacked&&!cb(b.shape,v.shape)){const x=v,w=v.shape;v.shape=b.shape,v=this.packedReshape(v,w),c.push(v),b=this.texData.get(v.dataId),x.shape=w}return{shape:v.shape,texData:b,isUniform:!1}});this.uploadToGPU(l.dataId);const h={shape:l.shape,texData:u,isUniform:!1},p=function Ige(t,n,e){let r="";n.concat(e).forEach(i=>{const a=null!=i.texData&&null!=i.texData.slice&&i.texData.slice.flatOffset>0;if(t.enableShapeUniforms&&!i.isUniform){const l=i.texData.texShape,{useSqueezeShape:u,uniformShape:c,keptDims:d}=VI(t.packedInputs,i.shape,l);let h="",p="",f="";if(1===c.length&&t.packedInputs){const w=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];h=`${w[0]>1}_${w[1]>1}`}else if(2!==c.length||t.packedInputs){if(c.length>2&&!t.packedInputs){const w=xt(c);f=`${w[0]===l[1]}_${w[w.length-1]===l[1]}`}}else p=`${c[0]>1}_${c[1]>1}`;const g=i.shape.length,m=2===c.length&&gn(i.shape,l),y=1===_e(i.shape),v=Mc(i.shape,e.shape),b=!t.packedInputs&&g===e.shape.length&&gn(l,e.texData.texShape);r+=`${g}_${b}_${u?d:""}_${c.length}_${y}_${v}_${m}_${h}_${p}_${f}_${t.packedInputs||c.length>2?"":`${l[0]>1}_${l[1]>1}`}_${a}`}else r+=`${i.shape}_${i.isUniform?"uniform":i.texData.texShape}_${a}`});let o=t.constructor.name;return o+="_"+r+"_"+t.userCode+`${pe().getNumber("WEBGL_VERSION")}`,o}(e,d,h),f=this.getAndSaveBinary(p,()=>function Cge(t,n,e,r){const s=e.map((c,d)=>{const h={logicalShape:c.shape,texShape:c.isUniform?null:c.texData.texShape,isUniform:c.isUniform,isPacked:!c.isUniform&&c.texData.isPacked,flatOffset:null};return null!=c.texData&&null!=c.texData.slice&&c.texData.slice.flatOffset>0&&(h.flatOffset=c.texData.slice.flatOffset),{name:n.variableNames[d],shapeInfo:h}}),o=s.map(c=>c.shapeInfo),i={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},a=zme(s,i,n),l=function yme(t,n){const e=va(t,()=>t.createShader(t.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(rt(t,()=>t.shaderSource(e,n)),rt(t,()=>t.compileShader(e)),pe().get("ENGINE_COMPILE_ONLY"))return e;if(!1===t.getShaderParameter(e,t.COMPILE_STATUS))throw O3(n,t.getShaderInfoLog(e)),new Error("Failed to compile fragment shader.");return e}(t.gl,a),u=t.createProgram(l);return pe().get("ENGINE_COMPILE_ONLY")?{program:n,fragmentShader:l,source:a,webGLProgram:u,inShapeInfos:o,outShapeInfo:i,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:Object.assign({program:n,fragmentShader:l,source:a,webGLProgram:u,inShapeInfos:o,outShapeInfo:i},W3(t,n,u))}(this.gpgpu,e,d,h)),g=null!=this.activeTimers;let m;g&&(m=this.startTimer()),pe().get("ENGINE_COMPILE_ONLY")||function Sge(t,n,e,r,s){n.program.enableShapeUniforms||(G3(n.inShapeInfos,e),G3([n.outShapeInfo],[r]));const o=r.texData.texture,i=r.texData.texShape;r.texData.isPacked?t.setOutputPackedMatrixTexture(o.texture,i[0],i[1]):t.setOutputMatrixTexture(o.texture,i[0],i[1]),t.setProgram(n.webGLProgram),1===pe().getNumber("WEBGL_VERSION")&&null!==n.infLoc&&t.gl.uniform1f(n.infLoc,1/0),null!==n.nanLoc&&t.gl.uniform1f(n.nanLoc,NaN);for(let l=0;l<e.length;++l){const u=e[l],{uniform:c,offset:d,shape:h,texShape:p}=n.variablesLocations[l];if(h){const{uniformShape:f}=VI(n.program.packedInputs,u.shape,u.texData.texShape);switch(f.length){case 1:t.gl.uniform1iv(h,new Int32Array(f));break;case 2:t.gl.uniform2iv(h,new Int32Array(f));break;case 3:t.gl.uniform3iv(h,new Int32Array(f));break;case 4:t.gl.uniform4iv(h,new Int32Array(f))}}if(p&&t.gl.uniform2i(p,u.texData.texShape[0],u.texData.texShape[1]),null!=c){if(u.isUniform){if(_e(u.shape)<2)t.gl.uniform1f(c,u.uniformValues[0]);else{let f=u.uniformValues;f instanceof Float32Array||(f=new Float32Array(f)),t.gl.uniform1fv(c,f)}continue}null!=u.texData.slice&&null!=d&&t.gl.uniform1i(d,u.texData.slice.flatOffset),t.setInputMatrixTexture(u.texData.texture.texture,c,l)}}const a=n.outShapeLocation;if(a)switch(r.shape.length){case 1:t.gl.uniform1iv(a,new Int32Array(r.shape));break;case 2:t.gl.uniform2iv(a,new Int32Array(r.shape));break;case 3:t.gl.uniform3iv(a,new Int32Array(r.shape));break;case 4:t.gl.uniform4iv(a,new Int32Array(r.shape))}if(n.outShapeStridesLocation){const l=xt(r.shape);switch(r.shape.length){case 2:t.gl.uniform1iv(n.outShapeStridesLocation,new Int32Array(l));break;case 3:t.gl.uniform2iv(n.outShapeStridesLocation,new Int32Array(l));break;case 4:t.gl.uniform3iv(n.outShapeStridesLocation,new Int32Array(l))}}if(n.outTexShapeLocation&&t.gl.uniform2i(n.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),n.program.customUniforms&&s)for(let l=0;l<n.program.customUniforms.length;++l){const u=n.program.customUniforms[l],c=n.customUniformLocations[l],d=s[l];if("float"===u.type)t.gl.uniform1fv(c,d);else if("vec2"===u.type)t.gl.uniform2fv(c,d);else if("vec3"===u.type)t.gl.uniform3fv(c,d);else if("vec4"===u.type)t.gl.uniform4fv(c,d);else if("int"===u.type)t.gl.uniform1iv(c,d);else if("ivec2"===u.type)t.gl.uniform2iv(c,d);else if("ivec3"===u.type)t.gl.uniform3iv(c,d);else{if("ivec4"!==u.type)throw Error(`uniform type ${u.type} is not supported yet.`);t.gl.uniform4iv(c,d)}}t.executeProgram()}(this.gpgpu,f,d,h,o),c.forEach(v=>this.disposeIntermediateTensorInfo(v)),g&&(m=this.endTimer(m),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(m)}));const y=pe().get("WEBGL_FLUSH_THRESHOLD");if(y>0){const v=Rs();v-this.lastGlFlushTime>y&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=v)}if(!pe().getBool("WEBGL_LAZILY_UNPACK")&&u.isPacked&&!1===i){const v=this.unpackTensor(l);return this.disposeIntermediateTensorInfo(l),v}return l}compileAndRun(e,r,s,o,i=!1){return this.runWebGLProgram(e,r,s=s||r[0].dtype,o,i)}getAndSaveBinary(e,r){return e in this.binaryCache||(this.binaryCache[e]=r()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(pe().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(r=>{this.gpgpu.deleteProgram(this.binaryCache[r].webGLProgram),delete this.binaryCache[r]}),this.textureManager.dispose(),null!=this.canvas&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=he(()=>{if(!pe().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=pe().getBool("DEBUG");pe().set("DEBUG",!1);const r=this.abs(Lt(1e-8)).dataSync()[0];if(pe().set("DEBUG",e),r>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){const r=this.texData.get(e),{shape:s,dtype:o,values:i,texture:a,usage:l,isPacked:u}=r;if(null!=a)return;const c=null!=this.activeTimers;let d;c&&(d=Rs());let h=r.texShape;if(null==h&&(h=function Ame(t,n=!1){let e=pe().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=pe().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");r===1/0&&pe().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=e/2),n&&(e*=2,r*=2,1===(t=t.map((a,l)=>l>=t.length-2?O_(t[l]):t[l])).length&&(t=[2,t[0]])),2!==t.length&&(t=La(t).newShape);let s=_e(t),o=null;t.length<=1&&s<=e?o=[1,s]:2===t.length&&t[0]<=e&&t[1]<=e?o=t:3===t.length&&t[0]*t[1]<=e&&t[2]<=e?o=[t[0]*t[1],t[2]]:3===t.length&&t[0]<=e&&t[1]*t[2]<=e?o=[t[0],t[1]*t[2]]:4===t.length&&t[0]*t[1]*t[2]<=e&&t[3]<=e?o=[t[0]*t[1]*t[2],t[3]]:4===t.length&&t[0]<=e&&t[1]*t[2]*t[3]<=e&&(o=[t[0],t[1]*t[2]*t[3]]);const i=null!=o&&Math.max(...o)>r&&Math.min(...o)<=(n?2:1)&&Math.min(...o)>0;if(null==o||i)if(n){const a=ed(t);let l=2,u=2;t.length&&([l,u]=td(t)),s=a*(l/2)*(u/2),o=M_(s).map(c=>2*c)}else o=M_(s);return o}(s,u),r.texShape=h),null!=i){const p=lb(s);let f,g=h[1],m=h[0];const y=i instanceof Uint8Array||i instanceof Uint8ClampedArray;(u||!y)&&([g,m]=Jc(h[0],h[1])),f=u?new Age(p,y):new H3(p,y);const v=y?[m,g]:h,b=this.makeTensorInfo(v,o),x=this.texData.get(b.dataId);x.usage=y?qs.PIXELS:qs.UPLOAD,x.texShape=v,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(b.dataId),g,m,i);const V=this.runWebGLProgram(f,[b],o,[[m,g]],!0),z=this.texData.get(V.dataId);r.texShape=z.texShape,r.isPacked=z.isPacked,r.usage=z.usage,pe().get("ENGINE_COMPILE_ONLY")?this.disposeData(V.dataId):(r.texture=z.texture,r.values=null,this.texData.delete(V.dataId)),this.disposeIntermediateTensorInfo(b),c&&(this.uploadWaitMs+=Rs()-d)}else{const p=this.acquireTexture(h,l,o,u);r.texture=p}}convertAndCacheOnCPU(e,r){const s=this.texData.get(e),{dtype:o}=s;return null!=r&&(s.values=function dve(t,n){if("float32"===n||"complex64"===n)return t;if("int32"===n||"bool"===n){const e="int32"===n?new Int32Array(t.length):new Uint8Array(t.length);for(let r=0;r<e.length;++r)e[r]=Math.round(t[r]);return e}throw new Error(`Unknown dtype ${n}`)}(r,o)),s.values}acquireTexture(e,r,s,o){if(this.numBytesInGPU+=this.computeBytes(e,s),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const i=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${i} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,r,o)}computeBytes(e,r){return e[0]*e[1]*Lg(r)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}checkCompileCompletionAsync(){var e=this;return $e(function*(){const r=[];if(e.gpgpu.parallelCompilationExtension){for(const[,s]of Object.entries(e.binaryCache))r.push(e.checkCompletionAsync_(s));return Promise.all(r)}for(const[,s]of Object.entries(e.binaryCache)){const o=new Promise(i=>{try{e.checkCompletion_(s),i(!0)}catch(a){throw a}});r.push(o)}return Promise.all(r)})()}checkCompletionAsync_(e){var r=this;return $e(function*(){return r.gpgpu.gl.getProgramParameter(e.webGLProgram,r.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?r.checkCompletion_(e):(yield DM(),r.checkCompletionAsync_(e))})()}checkCompletion_(e){if(!1===this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS))throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)?(O3(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){const{variablesLocations:r,customUniformLocations:s,infLoc:o,nanLoc:i,outShapeLocation:a,outShapeStridesLocation:l,outTexShapeLocation:u}=W3(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=r,e.customUniformLocations=s,e.infLoc=o,e.nanLoc=i,e.outShapeLocation=a,e.outShapeStridesLocation=l,e.outTexShapeLocation=u}}createTensorFromGPUData(e,r,s){e.channels=e.channels||"RGBA";const{texture:o,height:i,width:a,channels:l}=e,u=ki().backend;if(!u.gpgpu.gl.isTexture(o))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const c=u.writeTexture(o,r,s,i,a,l);return ki().makeTensorFromDataId(c,r,s,u)}}return t.nextDataId=0,t})();lP()&&IP("webgl",()=>new cve,2);const UI="\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n";class id{constructor(n,e,r){this.variableNames=["A","B"],this.outputShape=Vt(e,r),this.enableShapeUniforms=ss(this.outputShape.length),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${n}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}const gu="\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n";class xf{constructor(n,e,r,s=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=Vt(e,r);const o=this.outputShape.length;this.enableShapeUniforms=ss(o);let i="";if(s)if(0===o||1===_e(this.outputShape))i="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(i=`\n          ${kn(o)} coords = getOutputCoords();\n        `,1===o)i+=this.enableShapeUniforms?"\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const l=xs("coords",o);i+=this.enableShapeUniforms?`\n            bool nextRowOutOfBounds =\n              (${l[o-2]} + 1) >= outShape[${o} - 2];\n            bool nextColOutOfBounds =\n              (${l[o-1]} + 1) >= outShape[${o} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `:`\n            bool nextRowOutOfBounds =\n              (${l[o-2]} + 1) >= ${this.outputShape[o-2]};\n            bool nextColOutOfBounds =\n              (${l[o-1]} + 1) >= ${this.outputShape[o-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${n}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${i}\n\n        setOutput(result);\n      }\n    `}}function Ks(t){const{inputs:n,backend:e}=t,{x:r}=n;return e.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const fve={kernelName:tp,backendName:"webgl",kernelFunc:Ks};function dl(t){const{inputs:n,backend:e}=t,{real:r,imag:s}=n,o=e.makeTensorInfo(r.shape,"complex64"),i=e.texData.get(o.dataId),a=Ks({inputs:{x:r},backend:e}),l=Ks({inputs:{x:s},backend:e});return i.complexTensorInfos={real:a,imag:l},o}const mve={kernelName:Y_,backendName:"webgl",kernelFunc:dl},iB="return (a < 0.) ? b * a : a;",aB="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",yve={kernelName:oy,backendName:"webgl",kernelFunc:function gve(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{alpha:o}=r,i=e.makeTensorInfo([],"float32",Ba(o,"float32")),a=pe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new xf(aB,s.shape,i.shape):new id(iB,s.shape,i.shape),l=e.runWebGLProgram(a,[s,i],"float32");return e.disposeIntermediateTensorInfo(i),l}},lB="return (a < 0.) ? b * a : a;",uB="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",bve={kernelName:Sy,backendName:"webgl",kernelFunc:function vve(t){const{inputs:n,backend:e}=t,{x:r,alpha:s}=n,o=pe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new xf(uB,r.shape,s.shape):new id(lB,r.shape,s.shape);return e.runWebGLProgram(o,[r,s],"float32")}},ad="if (isnan(x)) return x;";function pn({opSnippet:t,packedOpSnippet:n,cpuKernelImpl:e,dtype:r}){return({inputs:s,backend:o})=>{const{x:i}=s,a=o,l=r||i.dtype;if(a.shouldExecuteOnCPU([i])&&null!=e){const d=a.texData.get(i.dataId),h=e(d.values,l);return a.makeTensorInfo(i.shape,l,h)}let c;return c=pe().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=n?new cl(i.shape,n):new zi(i.shape,t),a.runWebGLProgram(c,[i],l)}}function jr({opSnippet:t,packedOpSnippet:n,checkOutOfBounds:e=!1,supportsComplex:r=!1,cpuKernelImpl:s,dtype:o}){return({inputs:i,backend:a})=>{const{a:l,b:u}=i,c=a;if(r&&"complex64"===l.dtype){const f=c.texData.get(l.dataId),g=c.texData.get(u.dataId),[m,y]=[[f.complexTensorInfos.real,g.complexTensorInfos.real],[f.complexTensorInfos.imag,g.complexTensorInfos.imag]].map(b=>{const[x,w]=b,k={dataId:x.dataId,dtype:x.dtype,shape:l.shape},V={dataId:w.dataId,dtype:w.dtype,shape:u.shape},z=new id(t,l.shape,u.shape);return c.runWebGLProgram(z,[k,V],Ws(x.dtype,w.dtype))}),v=dl({inputs:{real:m,imag:y},backend:c});return c.disposeIntermediateTensorInfo(m),c.disposeIntermediateTensorInfo(y),v}const d=o||Ws(l.dtype,u.dtype);if(("string"===l.dtype||"string"===u.dtype||c.shouldExecuteOnCPU([l,u]))&&null!=s){const f=c.texData.get(l.dataId).values,g=c.texData.get(u.dataId).values,m="string"===l.dtype?ga(f):f,y="string"===l.dtype?ga(g):g,[v,b]=s(l.shape,u.shape,m,y,d),x=c.makeTensorInfo(b,d);return c.texData.get(x.dataId).values=v,x}let p;return p=pe().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=n?new xf(n,l.shape,u.shape,e):new id(t,l.shape,u.shape),c.runWebGLProgram(p,[l,u],d)}}function wf(t,n=!1){if("linear"===t)return n?Zye:jye;if("relu"===t)return n?Jye:Kye;if("elu"===t)return n?Qye:qye;if("relu6"===t)return n?eve:Xye;if("prelu"===t)return n?uB:lB;if("leakyrelu"===t)return n?aB:iB;if("sigmoid"===t)return n?tve:Yye;throw new Error(`Activation ${t} has not been implemented for the WebGL backend.`)}class cB{constructor(n,e,r,s=!1,o=!1,i=!1,a=null,l=!1,u=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=r,this.enableShapeUniforms=ss(this.outputShape.length);const d=Math.ceil((s?n[1]:n[2])/2),h=s?"i * 2, rc.y":"rc.y, i * 2",p=o?"rc.z, i * 2":"i * 2, rc.z",f=s?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],g=o?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let m="",y="";a&&(m=l?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${a}\n        }`:u?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${a}\n        }`:`vec4 activation(vec4 x) {\n          ${a}\n        }`,y="result = activation(result);");const v=i?"result += getBiasAtOutCoords();":"";i&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),u&&this.variableNames.push("leakyreluAlpha");let b="rc.x",x="rc.x";n[0]<e[0]?b=`imod(rc.x, ${n[0]})`:e[0]<n[0]&&(x=`imod(rc.x, ${e[0]})`),this.userCode=`\n      ${m}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${d}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        int batchA = ${b};\n        int batchB = ${x};\n        for (int i = 0; i < ${d}; i++) {\n          vec4 a = getMatrixA(batchA, ${h});\n          vec4 b = getMatrixB(batchB, ${p});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${f[0]} * ${g[0]});\n          result += (${f[1]} * ${g[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${v}\n\n        ${y}\n\n        setOutput(result);\n      }\n    `}}const dB={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class hB{constructor(n,e,r){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=Vt(e,r),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${n}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}const pB="return a * b;";function WI(t){const{inputs:n,backend:e}=t,{a:r,b:s}=n,o=Ws(r.dtype,s.dtype);if("complex64"===r.dtype){const a=e.texData.get(r.dataId),l=e.texData.get(s.dataId),u=new hB(dB.REAL,r.shape,s.shape),c=new hB(dB.IMAG,r.shape,s.shape),d=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:r.shape},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:s.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:s.shape}],h=e.runWebGLProgram(u,d,"float32"),p=e.runWebGLProgram(c,d,"float32"),f=dl({inputs:{real:h,imag:p},backend:e});return e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(p),f}if(e.shouldExecuteOnCPU([r,s])){const a=e.texData.get(r.dataId),l=e.texData.get(s.dataId),[u,c]=mye(r.shape,s.shape,a.values,l.values,o),d=e.makeTensorInfo(c,o);return e.texData.get(d.dataId).values=u,d}let i;return i=pe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new xf(pB,r.shape,s.shape):new id(pB,r.shape,s.shape),e.runWebGLProgram(i,[r,s],o)}const xve={kernelName:cp,backendName:"webgl",kernelFunc:WI};function tt(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{shape:o}=r,i=e,a=_e(s.shape),l=DO(o,a),u=_e(l);R(a===u,()=>`The new shape (${l}) has ${u} elements and the old shape (${s.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`);const c=i.texData.get(s.dataId);return!c.isPacked||cb(s.shape,l)||null!==c.texture&&cb(c.shape,l)?(i.incRef(s.dataId),{dataId:s.dataId,shape:l,dtype:s.dtype}):function wve(t,n,e){const r=[ed(t.shape),...td(t.shape)],s={dtype:t.dtype,shape:r,dataId:t.dataId},o=[ed(n),...td(n)],i=new tB(o,r),u=e.runWebGLProgram(i,[s],t.dtype,[r],!0);return{dataId:u.dataId,shape:n,dtype:u.dtype}}(s,l,i)}const _ve={kernelName:Dy,backendName:"webgl",kernelFunc:tt};class fB{constructor(n,e){this.variableNames=["x"];const{windowSize:r,batchSize:s,inSize:o,outSize:i}=n;this.outputShape=[s,i];const a=4*Math.floor(r/4),l=r%4;let u="sumValue += dot(values, ones);";if(null!=e){const d=1/e;u=`sumValue += dot(values * ${_c(d)?d.toPrecision(2):d}, ones);`}let c="";o%r>0&&(c=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${c}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${a}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${u}\n        }\n\n        int inIdx = inOffset + ${a};\n        if (${1===l}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${u}\n        } else if (${2===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${u}\n        } else if (${3===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${u}\n        }\n        setOutput(sumValue);\n      }\n    `}}class Cve{constructor(n,e){this.variableNames=["x"];const{windowSize:r,batchSize:s,inSize:o,outSize:i}=n;this.outputShape=[s,i];let a="0.0",l="";"prod"===e?a="1.0":"min"===e?(a="1.0 / 1e-20",l="min"):"max"===e&&(a="-1.0 / 1e-20",l="max");let u=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===e?u="sumValue":"prod"===e?u="prodValue":"all"===e?u="allValue":"any"===e&&(u="anyValue");const c=4*Math.floor(r/4),d=r%4;let h=`\n      if (${"sum"===e}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===e}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${l}(values, minMaxValue);\n        if (${"min"===e} || ${"max"===e}) {\n          minMaxValue = ${l}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,p="vec4";"all"===e?(a="1.0",h="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",p="bvec4"):"any"===e&&(a="0.0",h="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",p="bvec4");let f="";o%r>0&&(f=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${a};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${f}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        vec4 minMaxValue = vec4(${a});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${c}; i += 4) {\n          int inIdx = inOffset + i;\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${h}\n        }\n\n        int inIdx = inOffset + ${c};\n        if (${1===d}) {\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${2===d}) {\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${3===d}) {\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${h}\n        }\n        setOutput(${u});\n      }\n    `}}function yu(t,n,e,r){const s=function Sve(t){const n=[];for(;0===n.length||1!==n[n.length-1].outSize;){const e=n.length?n[n.length-1].outSize:t[1],r=bv(e);n.push({inSize:e,windowSize:r,outSize:Math.ceil(e/r)})}return n}(t.shape);let o=t;for(let i=0;i<s.length;i++){const{inSize:a,windowSize:l,outSize:u}=s[i];let c,d;c="mean"===e?0===i?new fB({windowSize:l,inSize:a,batchSize:t.shape[0],outSize:u},a):new fB({windowSize:l,inSize:a,batchSize:t.shape[0],outSize:u}):new Cve({windowSize:l,inSize:a,batchSize:t.shape[0],outSize:u},e),d=o,o=r.runWebGLProgram(c,[o],n),d.dataId!==t.dataId&&r.disposeIntermediateTensorInfo(d)}return o}class Ive{constructor(n,e){this.variableNames=["A"];const r=new Array(n.length);for(let i=0;i<r.length;i++)r[i]=n[e[i]];this.outputShape=r,this.rank=r.length;const s=kn(this.rank),o=function Dve(t){const n=t.length;if(n>6)throw Error(`Transpose for rank ${n} is not yet supported`);const e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(n);for(let s=0;s<t.length;s++)r[t[s]]=e[s];return r.join()}(e);this.userCode=`\n    void main() {\n      ${s} resRC = getOutputCoords();\n      setOutput(getA(${o}));\n    }\n    `}}class Tve{constructor(n,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const r=new Array(n.length);for(let c=0;c<r.length;c++)r[c]=n[e[c]];if(this.outputShape=r,this.rank=r.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const s=kn(this.rank),o=eB("rc",this.rank),i=new Array(this.rank);for(let c=0;c<e.length;c++)i[e[c]]=o[c];const a=`vec2(${i.slice(-2).join()})`,l=`++${o[this.rank-1]} < ${r[this.rank-1]}`,u=`getChannel(getA(${i.join()}), ${a})`;this.userCode=`\n    void main() {\n      ${s} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${u};\n      if(${l}) {\n        result[1] = ${u};\n      }\n      --${o[this.rank-1]};\n      if(++${o[this.rank-2]} < ${r[this.rank-2]}) {\n        result[2] = ${u};\n        if(${l}) {\n          result[3] = ${u};\n        }\n      }\n      setOutput(result);\n    }\n    `}}function gb(t,n,e){const r=pe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Tve(t.shape,n):new Ive(t.shape,n);return e.runWebGLProgram(r,[t],t.dtype)}function yb(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o,keepDims:i}=r;return function kve(t,n,e,r){const o=t.shape.length,i=Jt(n,t.shape);let a=i;const l=Qn(a,o),u=null!=l;let c=t;u&&(c=gb(t,l,r),a=fr(a.length,o)),Hr("sum",a,o);const[d,h]=$r(c.shape,a);let p=d;e&&(p=pr(d,i));const f=_e(h),y=tt({inputs:{x:c},attrs:{shape:[_e(t.shape)/f,f]},backend:r}),b=yu(y,GC(t.dtype),"sum",r),x=tt({inputs:{x:b},attrs:{shape:p},backend:r});return r.disposeIntermediateTensorInfo(y),r.disposeIntermediateTensorInfo(b),u&&r.disposeIntermediateTensorInfo(c),x}(s,o,i,e)}const Eve={kernelName:Ry,backendName:"webgl",kernelFunc:yb};function ws(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{perm:o}=r,i=e,l=new Array(s.shape.length);for(let c=0;c<l.length;c++)l[c]=s.shape[o[c]];let u;if(i.shouldExecuteOnCPU([s])){const d=i.texData.get(s.dataId).values,h=zI(d,s.shape,s.dtype,o,l);u=i.makeTensorInfo(l,s.dtype),i.texData.get(u.dataId).values=h}else u=gb(s,o,i);return u}const Nve={kernelName:Tc,backendName:"webgl",kernelFunc:ws},mB=1e3;function vb({a:t,b:n,transposeA:e,transposeB:r,backend:s,bias:o=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:l=null}){const u=t.shape.length,c=n.shape.length,d=e?t.shape[u-2]:t.shape[u-1],h=r?n.shape[c-1]:n.shape[c-2],p=e?t.shape[u-1]:t.shape[u-2],f=r?n.shape[c-2]:n.shape[c-1],g=t.shape.slice(0,-2),m=n.shape.slice(0,-2),y=_e(g),v=_e(m),x=Vt(t.shape.slice(0,-2),n.shape.slice(0,-2)).concat([p,f]);R(d===h,()=>`Error in matMul: inner shapes (${d}) and (${h}) of Tensors with shapes ${t.shape} and ${n.shape} and transposeA=${e} and transposeB=${r} must match.`);const w=e?[y,d,p]:[y,p,d],k=r?[v,f,h]:[v,h,f],V=tt({inputs:{x:t},backend:s,attrs:{shape:w}}),z=tt({inputs:{x:n},backend:s,attrs:{shape:k}}),K=[V,z],Y=Math.max(y,v),se=e?V.shape[1]:V.shape[2],fe=null!=o,ve=null!=i,be="leakyrelu"===l,xe=null!=l?wf(l,!0):null;let Ne;if((1===p||1===f)&&se>mB&&!1===(fe||ve||be||null!=xe)){let Ae=V,ze=z;e&&(Ae=ws({inputs:{x:V},backend:s,attrs:{perm:[0,2,1]}}),K.push(Ae)),r&&(ze=ws({inputs:{x:z},backend:s,attrs:{perm:[0,2,1]}}),K.push(ze));const Ye=1===f;let je=Ae;1!==f&&(je=tt({inputs:{x:Ae},backend:s,attrs:{shape:[Y,se,1]}}),K.push(je));const st=1===f?2:1;let Je=ze;Ye&&(Je=tt({inputs:{x:ze},backend:s,attrs:{shape:[Y,1,se]}}),K.push(Je));const ct=WI({inputs:{a:je,b:Je},backend:s});Ne=yb({inputs:{x:ct},backend:s,attrs:{axis:st,keepDims:!0}}),K.push(ct)}else{const Ae=Ws(t.dtype,n.dtype),ze=new cB(w,k,[Y,p,f],e,r,fe,xe,ve,be),He=[V,z];if(null!=o&&He.push(o),ve&&He.push(i),be){const Ye=s.makeTensorInfo([],"float32",Ba(a,"float32"));He.push(Ye),K.push(Ye)}Ne=s.runWebGLProgram(ze,He,Ae)}const we=tt({inputs:{x:Ne},backend:s,attrs:{shape:x}});K.push(Ne);for(const Ae of K)s.disposeIntermediateTensorInfo(Ae);return we}const Rve={kernelName:By,backendName:"webgl",kernelFunc:function Ave(t){const{inputs:n,backend:e,attrs:r}=t,{a:s,b:o,bias:i,preluActivationWeights:a}=n,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:d}=r;return vb({a:s,b:o,transposeA:l,transposeB:u,backend:e,bias:i,preluActivationWeights:a,leakyreluAlpha:d,activation:c})}},gB="return abs(x);",Ove={kernelName:Vg,backendName:"webgl",kernelFunc:function Fve(t){const{inputs:n,backend:e}=t,{x:r}=n;if(e.shouldExecuteOnCPU([r])&&"complex64"!==r.dtype){const o=e.texData.get(r.dataId),i=Q3(o.values);return e.makeTensorInfo(r.shape,r.dtype,i)}let s;return s=pe().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new cl(r.shape,gB):new zi(r.shape,gB),e.runWebGLProgram(s,[r],r.dtype)}},Mve=pn({opSnippet:go+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),$ve={kernelName:Ph,backendName:"webgl",kernelFunc:Mve},Vve=pn({opSnippet:go+"\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),Bve={kernelName:Mh,backendName:"webgl",kernelFunc:Vve},yB="return a + b;",zve=jr({opSnippet:yB,packedOpSnippet:yB,supportsComplex:!0,cpuKernelImpl:Xge}),Uve={kernelName:Dc,backendName:"webgl",kernelFunc:zve};class Wve{constructor(n,e){this.outputShape=[],this.outputShape=n,this.variableNames=e.map((o,i)=>`T${i}`);const r=[];this.variableNames.forEach(o=>{r.push(`float v${o} = get${o}AtOutCoords();`)});const s=this.variableNames.map(o=>`v${o}`).join(" + ");this.userCode=`\n      void main() {\n        ${r.join("\n        ")}\n\n        float result = ${s};\n        setOutput(result);\n      }\n    `}}class Gve{constructor(n,e){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.variableNames=e.map((o,i)=>`T${i}`);const r=[];this.variableNames.forEach(o=>{r.push(`vec4 v${o} = get${o}AtOutCoords();`)});const s=this.variableNames.map(o=>`v${o}`).join(" + ");this.userCode=`\n      void main() {\n        ${r.join("\n        ")}\n\n        vec4 result = ${s};\n        setOutput(result);\n      }\n    `}}const Hve={kernelName:G_,backendName:"webgl",kernelFunc:function bb(t){const{inputs:n,backend:e}=t,r=n;if(1===r.length)return Ks({inputs:{x:r[0]},backend:e});if(r.length>pe().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const l=Math.floor(r.length/2),u=bb({inputs:r.slice(0,l),backend:e}),c=bb({inputs:r.slice(l),backend:e});return bb({inputs:[u,c],backend:e})}const s=r.map(l=>l.dtype).reduce((l,u)=>Ws(l,u)),o=r.map(l=>l.shape),a=pe().getBool("WEBGL_PACK")?new Gve(r[0].shape,o):new Wve(r[0].shape,o);return e.runWebGLProgram(a,r,s)}},qve={kernelName:"All",backendName:"webgl",kernelFunc:function jve(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o,keepDims:i}=r,a=s.shape.length,l=Jt(o,s.shape);let u=l;const c=Qn(u,a);let d=s;null!=c&&(d=ws({inputs:{x:s},backend:e,attrs:{perm:c}}),u=fr(u.length,a)),Hr("all",u,a);const[h,p]=$r(d.shape,u),g=tt({inputs:{x:d},backend:e,attrs:{shape:[-1,_e(p)]}}),m=yu(g,g.dtype,"all",e);let y;return y=tt(i?{inputs:{x:m},backend:e,attrs:{shape:pr(h,l)}}:{inputs:{x:m},backend:e,attrs:{shape:h}}),e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(m),null!=c&&e.disposeIntermediateTensorInfo(d),y}},Xve={kernelName:"Any",backendName:"webgl",kernelFunc:function Kve(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o,keepDims:i}=r,a=s.shape.length,l=Jt(o,s.shape);let u=l;const c=Qn(u,a);let d=s;null!=c&&(d=ws({inputs:{x:s},backend:e,attrs:{perm:c}}),u=fr(u.length,a)),Hr("any",u,a);const[h,p]=$r(d.shape,u),g=tt({inputs:{x:d},backend:e,attrs:{shape:[-1,_e(p)]}}),m=yu(g,g.dtype,"any",e);let y;return y=tt(i?{inputs:{x:m},backend:e,attrs:{shape:pr(h,l)}}:{inputs:{x:m},backend:e,attrs:{shape:h}}),e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(m),null!=c&&e.disposeIntermediateTensorInfo(d),y}};class Yve{constructor(n,e,r){this.variableNames=["A"];const{windowSize:s,batchSize:o,outSize:i}=n;r||this.variableNames.push("bestIndicesA"),this.outputShape=[o,i],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${s};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${s}; i++) {\n          int inIdx = ${r?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));"};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${"max"===e?">":"<"} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}class Zve{constructor(n,e,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,R(n.length>2,()=>`Packed arg${r.charAt(0).toUpperCase()+r.slice(1)} supports only inputs with rank above 2.`);const i=Math.ceil(n[n.length-1]/e);this.outputShape=n.slice(0,-1),i>1&&this.outputShape.push(i),s||this.variableNames.push("bestIndicesA");const a=this.outputShape,l=a.length,u=kn(l),c=xs("coords",l);let d,h;if(1===i){h=l+1;const z=kn(h);d=`\n        ${z} sourceLocR = ${z}(${c.join()}, 0);\n        ++${c[l-1]};\n        ${z} sourceLocG = ${z}(${c.join()}, 0);\n        ++${c[l-2]};\n        ${z} sourceLocA = ${z}(${c.join()}, 0);\n        --${c[l-1]};\n        ${z} sourceLocB = ${z}(${c.join()}, 0);\n        --${c[l-2]};`}else h=l,d=`\n        ${u} sourceLocR = coords;\n        ++${c[l-1]};\n        ${u} sourceLocG = coords;\n        ++${c[l-2]};\n        ${u} sourceLocA = coords;\n        --${c[l-1]};\n        ${u} sourceLocB = coords;\n        --${c[l-2]};`;const p=["x","y","z","w","u","v"].slice(0,h),f="."+p[h-1],g=p.map(z=>"int "+z),m=xs("sourceLocR",h-1).concat("inIdx.r"),y=xs("sourceLocG",h-1).concat("inIdx.g"),v=xs("sourceLocB",h-1).concat("inIdx.b"),b=xs("sourceLocA",h-1).concat("inIdx.a"),x="max"===r?"greaterThan":"lessThan",w=s?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${m.join()}),\n                             getBestIndicesAChannel(${y.join()}),\n                             getBestIndicesAChannel(${v.join()}),\n                             getBestIndicesAChannel(${b.join()})));`,k=`vec4(\n            getAChannel(${m.join()}),\n            hasNextCol ? getAChannel(${y.join()}) : 0.,\n            hasNextRow ? getAChannel(${v.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${b.join()}) : 0.)`,V=s?"":`\n      float getBestIndicesAChannel(${g.join()}) {\n        return getChannel(getBestIndicesA(${p.join()}),\n                                          vec2(${p.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${g.join()}) {\n        return getChannel(getA(${p.join()}),\n                               vec2(${p.slice(-2).join()}));\n      }\n      ${V}\n      void main() {\n        ${u} coords = getOutputCoords();\n        bool hasNextCol = ${c[l-1]} < ${a[l-1]-1};\n        bool hasNextRow = ${c[l-2]} < ${a[l-2]-1};\n        ${d}\n        ivec4 srcIdx = ivec4(sourceLocR${f}, sourceLocG${f},\n          sourceLocB${f}, sourceLocA${f}) * ${e};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${k};\n\n        for (int i = 0; i < ${e}; i++) {\n          inIdx = srcIdx;\n          ${w}\n          vec4 candidate = ${k};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${x}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}function vB(t,n,e,r=null){let s=n.shape[0],o=n.shape[1];null!=r&&(s=r.shape[0],o=r.shape[1]);const i=bv(o),a={windowSize:i,inSize:o,batchSize:s,outSize:Math.ceil(o/i)},l=new Yve(a,e,null==r),u=[n];null!=r&&u.push(r);const c=t.runWebGLProgram(l,u,"int32");if(1===c.shape[1])return c;const d=vB(t,n,e,c);return t.disposeIntermediateTensorInfo(c),d}function bB(t,n,e,r=null){const s=null!=r?r.shape:n.shape,i=bv(s[s.length-1]),a=new Zve(s,i,e,null==r),u=t.runWebGLProgram(a,null==r?[n]:[n,r],"int32");if(u.shape.length===n.shape.length){const c=bB(t,n,e,u);return t.disposeIntermediateTensorInfo(u),c}return u}function xB(t,n,e,r){const s=[e];if(Hr("arg"+r.charAt(0).toUpperCase()+r.slice(1),s,n.shape.length),!pe().getBool("WEBGL_PACK_REDUCE")||n.shape.length<=2){const o=[],i=t.texData.get(n.dataId);let l=n;null!==i&&i.isPacked&&(l=t.unpackTensor(n),o.push(l));const[u,c]=$r(l.shape,s),d=_e(c),h=tt({inputs:{x:l},backend:t,attrs:{shape:[-1,d]}});o.push(h);const p=vB(t,h,r);o.push(p);const f=tt({inputs:{x:p},backend:t,attrs:{shape:u}});return o.forEach(g=>t.disposeIntermediateTensorInfo(g)),f}return bB(t,n,r)}const Jve={kernelName:Bg,backendName:"webgl",kernelFunc:function Qve(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o}=r;let i=Jt(o,s.shape);const a=Qn(i,s.shape.length);let l=s;const u=[];null!=a&&(l=ws({inputs:{x:s},backend:e,attrs:{perm:a}}),u.push(l),i=fr(i.length,l.shape.length)),Hr("argMax",[i[0]],l.shape.length);const c=xB(e,l,i[0],"max");return u.forEach(d=>e.disposeIntermediateTensorInfo(d)),c}},tbe={kernelName:zg,backendName:"webgl",kernelFunc:function ebe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o}=r;let i=Jt(o,s.shape);const a=Qn(i,s.shape.length);let l=s;const u=[];null!=a&&(l=ws({inputs:{x:s},backend:e,attrs:{perm:a}}),u.push(l),i=fr(i.length,l.shape.length)),Hr("argMin",[i[0]],l.shape.length);const c=xB(e,l,i[0],"min");return u.forEach(d=>e.disposeIntermediateTensorInfo(d)),c}},rbe=pn({opSnippet:go+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),sbe={kernelName:$h,backendName:"webgl",kernelFunc:rbe},ibe=pn({opSnippet:go+"return log(x + sqrt(x * x + 1.0));"}),abe={kernelName:Lh,backendName:"webgl",kernelFunc:ibe},ube=pn({opSnippet:go+"\n  return atan(x);\n"}),cbe={kernelName:Vh,backendName:"webgl",kernelFunc:ube},pbe=jr({opSnippet:UI+"\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+gu+"\n  return result;\n"}),fbe={kernelName:zh,backendName:"webgl",kernelFunc:pbe},gbe=pn({opSnippet:go+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),ybe={kernelName:Bh,backendName:"webgl",kernelFunc:gbe};class _f{constructor(n,e,r,s=!1,o=!1){if(this.variableNames=["x"],"avg"===e&&r)throw new Error("Cannot compute positions for average pool.");const i=n.filterWidth,a=n.strideHeight,l=n.strideWidth,u=n.dilationHeight,c=n.dilationWidth,d=n.effectiveFilterHeight,h=n.effectiveFilterWidth,p=n.padInfo.top,f=n.padInfo.left;this.outputShape=n.outShape;const g="avg"===e;let v="0.0";if(g||(v="-1.0 / 1e-20"),r)return void(this.userCode=`\n        const ivec2 strides = ivec2(${a}, ${l});\n        const ivec2 pads = ivec2(${p}, ${f});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${d};\n              wR += ${u}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${n.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${h};\n                wC += ${c}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${n.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value >= currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${s?o?`((batch  * ${n.inHeight} + xR) * ${n.inWidth} + xC) * ${n.inChannels} + d`:`(xR * ${n.inWidth} + xC) * ${n.inChannels} + d`:`wR * ${h} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let x=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===e&&(x="avgValue / max(count, 1.0)");const w=4*Math.floor(i/4),k=i%4,V=`\n      if (${g}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${a}, ${l});\n      const ivec2 pads = ivec2(${p}, ${f});\n      const float initializationValue = ${v};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${n.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${v});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${d};\n            wR += ${u}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${n.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${w}; wC += 4) {\n            int xC = xCCorner + wC * ${c};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${c}, d),\n              getValue(batch, xR, xC + 2 * ${c}, d),\n              getValue(batch, xR, xC + 3 * ${c}, d)\n            );\n\n            ${V}\n          }\n\n          int xC = xCCorner + ${w};\n          if (${1===k}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${V}\n          } else if (${2===k}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${c}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${V}\n          } else if (${3===k}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${c}, d),\n              getValue(batch, xR, xC + 2 * ${c}, d),\n              initializationValue\n            );\n\n            ${V}\n          }\n        }\n        setOutput(${x});\n      }\n    `}}class GI{constructor(n,e,r,s=!1,o=!1){if(this.variableNames=["x"],"avg"===e&&r)throw new Error("Cannot compute positions for average pool.");const i=n.filterWidth,a=n.strideDepth,l=n.strideHeight,u=n.strideWidth,c=n.dilationDepth,d=n.dilationHeight,h=n.dilationWidth,p=n.effectiveFilterDepth,f=n.effectiveFilterHeight,g=n.effectiveFilterWidth,m=n.padInfo.front,y=n.padInfo.top,v=n.padInfo.left;this.outputShape=n.outShape;const b="avg"===e;let x="0.0";if(b||(x="-1.0 / 1e-20"),r)return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${a}, ${l}, ${u});\n        const ivec3 pads = ivec3(${m}, ${y}, ${v});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${p};\n              wD += ${c}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${n.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${f};\n                wR += ${d}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${n.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${g};\n                  wC += ${h}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${n.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value >= currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${s?o?`(((batch * ${n.inDepth} + xD) * ${n.inHeight} + xR) * ${n.inWidth} + xC) * ${n.inChannels} + ch`:`((xD * ${n.inHeight} + xR) * ${n.inWidth} + xC) * ${n.inChannels} + ch`:`wD * ${f} * ${g} +\n                      wR * ${g} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let k=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===e&&(k="avgValue / max(count, 1.0)");const V=4*Math.floor(i/4),z=i%4,K=`\n      if (${b}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${a}, ${l}, ${u});\n      const ivec3 pads = ivec3(${m}, ${y}, ${v});\n      const float initializationValue = ${x};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${n.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${x});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${p};\n            wD += ${c}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${n.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${f};\n            wR += ${d}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${n.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${V}; wC += 4) {\n              int xC = xCCorner + wC * ${h};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${h}, ch)\n              );\n\n              ${K}\n            }\n\n            int xC = xCCorner + ${V};\n            if (${1===z}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${K}\n            } else if (${2===z}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${K}\n            } else if (${3===z}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                initializationValue\n              );\n\n              ${K}\n            }\n          }\n        }\n        setOutput(${k});\n      }\n    `}}const bbe={kernelName:Ug,backendName:"webgl",kernelFunc:function vbe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n;vf(s,"avgPool");const{filterSize:o,strides:i,pad:a,dimRoundingMode:l}=r;R(Gr(i,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`);const c=Ro(s.shape,o,i,1,a,l);if(1===c.filterWidth&&1===c.filterHeight&&gn(c.inShape,c.outShape))return Ks({inputs:{x:s},backend:e});const d=new _f(c,"avg",!1);return e.runWebGLProgram(d,[s],"float32")}},wbe={kernelName:Wg,backendName:"webgl",kernelFunc:function xbe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{filterSize:o,strides:i,pad:a,dimRoundingMode:l,dataFormat:u}=r,d=ca(s.shape,o,i,[1,1,1],a,l,u),h=new GI(d,"avg",!1);return e.runWebGLProgram(h,[s],"float32")}};class _be{constructor(n){this.variableNames=["dy"],this.outputShape=n.inShape;const l=n.effectiveFilterHeight,u=n.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${l-1-n.padInfo.top}, ${u-1-n.padInfo.left});\n      const float avgMultiplier = float(${1/(n.filterHeight*n.filterWidth)});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${l};\n            wR += ${n.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${n.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${n.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${u};\n            wC+= ${n.dilationWidth}) {\n            float dyC = float(dyCCorner + wC) / ${n.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Cbe{constructor(n){this.variableNames=["dy"],this.outputShape=n.inShape;const d=n.effectiveFilterDepth,h=n.effectiveFilterHeight,p=n.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${d-1-n.padInfo.front}, ${h-1-n.padInfo.top}, ${p-1-n.padInfo.left});\n      const float avgMultiplier = float(${1/(n.filterDepth*n.filterHeight*n.filterWidth)});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${d};\n            wD += ${n.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${n.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${n.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${h};\n              wR += ${n.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${n.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${n.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${p};\n                wC += ${n.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${n.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const Ibe={kernelName:K_,backendName:"webgl",kernelFunc:function Sbe(t){const{inputs:n,backend:e,attrs:r}=t,{dy:s,input:o}=n,i=o,{filterSize:a,strides:l,pad:u,dimRoundingMode:c}=r,h=ca(i.shape,a,l,[1,1,1],u,c),p=new Cbe(h);return e.runWebGLProgram(p,[s],i.dtype)}},Tbe={kernelName:q_,backendName:"webgl",kernelFunc:function Dbe(t){const{inputs:n,backend:e,attrs:r}=t,{dy:s,input:o}=n,i=o;vf([s,o],"avgPoolGrad");const{filterSize:a,strides:l,pad:u}=r,c=Ro(i.shape,a,l,1,u),d=new _be(c);return e.runWebGLProgram(d,[s],i.dtype)}},Ebe={kernelName:Gg,backendName:"webgl",kernelFunc:function kbe(t){const{inputs:n,backend:e,attrs:r}=t,{a:s,b:o}=n,{transposeA:i,transposeB:a}=r;return vb({a:s,b:o,transposeA:i,transposeB:a,backend:e})}};class Nbe{constructor(n,e,r,s,o,i){this.outputShape=[],this.variableNames=["x","mean","variance"],Vt(n,e),Vt(n,r);let a="0.0";null!=s&&(Vt(n,s),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="1.0";null!=o&&(Vt(n,o),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=n,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${a};\n        float scale = ${l};\n        float inv = scale * inversesqrt(variance + float(${i}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}class Abe{constructor(n,e,r,s,o,i){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],Vt(n,e),Vt(n,r);let a="vec4(0.0)";null!=s&&(Vt(n,s),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="vec4(1.0)";null!=o&&(Vt(n,o),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=n,this.userCode=`\n      void main() {\n        vec4 offset = ${a};\n        vec4 scale = ${l};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${i}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}const Rbe={kernelName:ny,backendName:"webgl",kernelFunc:({inputs:t,backend:n,attrs:e})=>{const{x:r,mean:s,variance:o,offset:i,scale:a}=t;R(s.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),R(null==i||s.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),R(null==a||s.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=e;null==l&&(l=.001);const u=[r,s,o];let c=null;null!=i&&(c=i.shape,u.push(i));let d=null;null!=a&&(d=a.shape,u.push(a));const h=pe().getBool("WEBGL_PACK_NORMALIZATION")?new Abe(r.shape,s.shape,o.shape,c,d,l):new Nbe(r.shape,s.shape,o.shape,c,d,l);return n.runWebGLProgram(h,u,u[0].dtype)}};class Fbe{constructor(n){this.variableNames=["source"],this.outputShape=n,this.rank=n.length;const e=kn(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const r=function Obe(t){if(1===t)return"sourceLoc";if(t<=6)return HI.slice(0,t).map(n=>"sourceLoc."+n).join(",");throw Error(`Slicing for rank ${t} is not yet supported`)}(this.rank);let s;s=`\n        ${e} sourceLoc;\n        ${e} coords = getOutputCoords();\n        ${n.map((i,a)=>`sourceLoc.${HI[a]} = start[${a}] + coords.${HI[a]};`).join("\n")}\n      `,this.userCode=`\n      void main() {\n        ${s}\n        setOutput(getSource(${r}));\n      }\n    `}}const HI=["x","y","z","w","u","v"];class Pbe{constructor(n){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.rank=n.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const e=kn(this.rank),r=xs("coords",this.rank),s=xs("sourceLoc",this.rank),o=1===this.rank?"sourceLoc":`vec2(${s.slice(-2).join()})`,i=`getChannel(getSource(${s.join()}), ${o})`,a=`\n      result.x = ${i};\n      if (++${r[this.rank-1]} < ${n[this.rank-1]}) {\n        ++${s[this.rank-1]};\n        result.y = ${i};\n        --${s[this.rank-1]};\n      }\n    `,l=1===this.rank?"":`\n      --${r[this.rank-1]};\n      if (++${r[this.rank-2]} < ${n[this.rank-2]}) {\n        ++${s[this.rank-2]};\n        result.z = ${i};\n        if (++${r[this.rank-1]} < ${n[this.rank-1]}) {\n          ++${s[this.rank-1]};\n          result.w = ${i};\n        }\n      }\n    `,u=this.rank<=4?`sourceLoc = coords +\n            ${e}(${n.map((c,d)=>`start[${d}]`).join()});`:n.map((c,d)=>`${s[d]} = ${r[d]} + start[${d}];`).join("\n");this.userCode=`\n      void main() {\n        ${e} coords = getOutputCoords();\n        ${e} sourceLoc;\n        ${u}\n        vec4 result = vec4(0.);\n        ${a}\n        ${l}\n        setOutput(result);\n      }\n    `}}function ld(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{begin:o,size:i}=r,[a,l]=nv(s,o,i);if(g1(s,a,l),0===_e(l))return e.makeTensorInfo(l,s.dtype,[]);if(e.shouldExecuteOnCPU([s])||"string"===s.dtype){const d=e.texData.get(s.dataId),h=Dye(d.values,a,l,s.shape,s.dtype);return e.makeTensorInfo(l,s.dtype,h)}const{isPacked:u}=e.texData.get(s.dataId),c=v1(s.shape,a,l);if(u||!c){const d=pe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Pbe(l):new Fbe(l);return e.runWebGLProgram(d,[s],s.dtype,[a])}return e.uploadToGPU(s.dataId),function Mbe(t,n,e,r){const s=r.texData.get(t.dataId),o=r.makeTensorInfo(e,t.dtype),i=r.texData.get(o.dataId);Object.assign(i,s),i.refCount=1,i.shape=e,i.dtype=t.dtype;let a=b1(n,xt(t.shape));s.slice&&(a+=s.slice.flatOffset),i.slice={flatOffset:a,origDataId:s.slice&&s.slice.origDataId||t.dataId};const l=r.dataRefCount.get(i.slice.origDataId)||1;return r.dataRefCount.set(i.slice.origDataId,l+1),o}(s,a,l,e)}const $be={kernelName:Ay,backendName:"webgl",kernelFunc:ld},Lbe={kernelName:Hg,backendName:"webgl",kernelFunc:t=>{const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{blockShape:o,crops:i}=r;R(s.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const a=o.reduce((v,b)=>v*b),l=Kp(s.shape,o,a),u=Xp(l.length,o.length),c=Yp(s.shape,o,a),d=tS(i,o.length),h=nS(c,i,o.length),p=[],f=tt({inputs:{x:s},backend:e,attrs:{shape:l}}),g=ws({inputs:{x:f},backend:e,attrs:{perm:u}}),m=tt({inputs:{x:g},backend:e,attrs:{shape:c}}),y=ld({inputs:{x:m},backend:e,attrs:{begin:d,size:h}});return p.push(f),p.push(g),p.push(m),p.forEach(v=>e.disposeIntermediateTensorInfo(v)),y}},Bbe={kernelName:X_,backendName:"webgl",kernelFunc:function Vbe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,weights:o}=n,{size:i}=r,a=e.readSync(s.dataId),l=e.readSync(o.dataId),u=Z3(a,l,o.dtype,o.shape,i);return e.makeTensorInfo([i],o.dtype,u)}},Ube={kernelName:FO,backendName:"webgl",kernelFunc:function zbe(t){const{inputs:n,backend:e}=t,{s0:r,s1:s}=n,o=e.readSync(r.dataId),i=e.readSync(s.dataId),a=Vt(Array.from(o),Array.from(i));return e.makeTensorInfo([a.length],"int32",Int32Array.from(a))}},wB=jr({opSnippet:"return float(a != b);",cpuKernelImpl:yye,dtype:"bool"}),Wbe={kernelName:by,backendName:"webgl",kernelFunc:wB};function Cf(t){const{inputs:n,backend:e}=t,{input:r}=n;return Ks({inputs:{x:e.texData.get(r.dataId).complexTensorInfos.real},backend:e})}const Gbe={kernelName:wC,backendName:"webgl",kernelFunc:Cf},qbe={kernelName:Uh,backendName:"webgl",kernelFunc:function jI(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{dtype:o}=r;if("complex64"===o){if("complex64"===s.dtype)return Ks({inputs:{x:s},backend:e});const i=Lr(s.shape),a=jI({inputs:{x:s},backend:e,attrs:{dtype:"float32"}}),l=dl({inputs:{real:a,imag:i},backend:e});return i.dispose(),e.disposeIntermediateTensorInfo(a),l}if("complex64"===s.dtype){const i=Cf({inputs:{input:s},backend:e}),a=jI({inputs:{x:i},backend:e,attrs:{dtype:o}});return e.disposeIntermediateTensorInfo(i),a}if(!TO(s.dtype,o)){const i=Ks({inputs:{x:s},backend:e});return{dataId:i.dataId,shape:i.shape,dtype:o}}if(e.shouldExecuteOnCPU([s])){const i=e.texData.get(s.dataId).values,[a,l,u]=Zge(i,s.shape,s.dtype,o);return e.makeTensorInfo(a,l,u)}if("int32"===o)return function jbe(t,n){const e=new zi(t.shape,"return float(int(x));"),r=n.runWebGLProgram(e,[t],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}(s,e);if("bool"===o){const i=e.makeTensorInfo([],"bool",ts("bool",1)),l=wB({inputs:{a:s,b:i},backend:e});return e.disposeIntermediateTensorInfo(i),l}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${o}`)}},_B="return ceil(x);",Kbe=pn({opSnippet:_B,packedOpSnippet:_B,cpuKernelImpl:Qge}),Xbe={kernelName:Wh,backendName:"webgl",kernelFunc:Kbe};class Ybe{constructor(n){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=n,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}}class Zbe{constructor(n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=n,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}}const Jbe={kernelName:Gh,backendName:"webgl",kernelFunc:function Qbe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{clipValueMin:o,clipValueMax:i}=r;let a;return a=pe().getBool("WEBGL_PACK_CLIP")?new Zbe(s.shape):new Ybe(s.shape),e.runWebGLProgram(a,[s],s.dtype,[[o],[i]])}};class e0e{constructor(n){this.variableNames=["real","imag"],this.outputShape=n,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function CB(t,n){return{dataId:n.dataId,dtype:n.dtype,shape:t.shape}}const n0e={kernelName:jg,backendName:"webgl",kernelFunc:function t0e(t){const{inputs:n,backend:e}=t,{x:r}=n,s=e.texData.get(r.dataId),o=new e0e(r.shape),i=[CB(r,s.complexTensorInfos.real),CB(r,s.complexTensorInfos.imag)];return e.runWebGLProgram(o,i,i[0].dtype)}};class r0e{constructor(n){this.outputShape=[],this.outputShape=Ai(n,1),this.variableNames=n.map((i,a)=>`T${a}`);const e=new Array(n.length-1);e[0]=n[0][1];for(let i=1;i<e.length;i++)e[i]=e[i-1]+n[i][1];const r=[`if (yC < ${e[0]}) setOutput(getT0(yR, yC));`];for(let i=1;i<e.length;i++)r.push(`else if (yC < ${e[i]}) setOutput(getT${i}(yR, yC-${e[i-1]}));`);r.push(`else setOutput(getT${e.length}(yR, yC-${e[e.length-1]}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${r.join("\n        ")}\n      }\n    `}}class s0e{constructor(n,e){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=Ai(n,e);const r=this.outputShape,s=r.length,o=kn(s),i=xs("coords",s),a=["x","y","z","w","u","v"].slice(0,s);this.variableNames=n.map((g,m)=>`T${m}`);const l=new Array(n.length-1);l[0]=n[0][e];for(let g=1;g<l.length;g++)l[g]=l[g-1]+n[g][e];const u=a[e],c=a.slice(-2),d=a.join();let h=`if (${u} < ${l[0]}) {\n        return getChannel(\n            getT0(${d}), vec2(${c.join()}));\n        }`;for(let g=1;g<l.length;g++){const m=l[g-1];h+=`\n        if (${u} < ${l[g]}  && ${u} >= ${l[g-1]}) {\n          return getChannel(\n            getT${g}(${xb(a,u,m)}),\n            vec2(${xb(c,u,m)}));\n        }`}const f=l[l.length-1];h+=`\n        return getChannel(\n          getT${l.length}(${xb(a,u,f)}),\n          vec2(${xb(c,u,f)}));`,this.userCode=`\n      float getValue(${a.map(g=>"int "+g)}) {\n        ${h}\n      }\n\n      void main() {\n        ${o} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${i}), 0., 0., 0.);\n\n        ${i[s-1]} = ${i[s-1]} + 1;\n        if (${i[s-1]} < ${r[s-1]}) {\n          result.g = getValue(${i});\n        }\n\n        ${i[s-2]} = ${i[s-2]} + 1;\n        if (${i[s-2]} < ${r[s-2]}) {\n          result.a = getValue(${i});\n        }\n\n        ${i[s-1]} = ${i[s-1]} - 1;\n        if (${i[s-2]} < ${r[s-2]} &&\n            ${i[s-1]} < ${r[s-1]}) {\n          result.b = getValue(${i});\n        }\n        setOutput(result);\n      }\n    `}}function xb(t,n,e){const r=t.indexOf(n);return t.map((o,i)=>i===r?`${o} - ${e}`:o).join()}function wb(t){const{inputs:n,backend:e}=t,{input:r}=n;return Ks({inputs:{x:e.texData.get(r.dataId).complexTensorInfos.imag},backend:e})}const o0e={kernelName:pC,backendName:"webgl",kernelFunc:wb};function Sf(t,n,e){const r=t[0].dtype;if("complex64"===r){const p=t.map(v=>Cf({inputs:{input:v},backend:e})),f=t.map(v=>wb({inputs:{input:v},backend:e})),g=Sf(p,n,e),m=Sf(f,n,e),y=dl({inputs:{real:g,imag:m},backend:e});return p.forEach(v=>e.disposeIntermediateTensorInfo(v)),f.forEach(v=>e.disposeIntermediateTensorInfo(v)),e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(m),y}let s=e.shouldExecuteOnCPU(t);if("string"===r&&(s=!0),s){const p=t.map(x=>{const k=[-1,_e(x.shape.slice(n))];return tt({inputs:{x},backend:e,attrs:{shape:k}})}),f=p.map(x=>({vals:e.readSync(x.dataId),shape:x.shape})),g=Ai(p.map(x=>x.shape),1),y=Jge(f,g,r,1===p[0].shape[0]),v=Ai(t.map(x=>x.shape),n),b=e.makeTensorInfo(v,r,y);return p.forEach(x=>e.disposeIntermediateTensorInfo(x)),b}const o=t.filter(p=>_e(p.shape)>0),i=pe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&o[0].shape.length>1;if(1===o.length){const p=i?new zi(t[0].shape,ul):new cl(t[0].shape,ul);return e.runWebGLProgram(p,t,r)}const a=pe().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(o.length>a){const p=[];for(let g=0;g<o.length;g+=a){const m=o.slice(g,g+a);p.push(Sf(m,n,e))}const f=Sf(p,n,e);for(const g of p)e.disposeIntermediateTensorInfo(g);return f}if(i){const p=new s0e(o.map(f=>f.shape),n);return e.runWebGLProgram(p,o,r)}const{tensors2D:l,outShape:u}=function i0e(t,n,e){const r=Ai(t.map(o=>o.shape),n);return{tensors2D:t.map(o=>tt({inputs:{x:o},attrs:{shape:[-1,_e(o.shape.slice(n))]},backend:e})),outShape:r}}(o,n,e),c=new r0e(l.map(p=>p.shape)),d=e.runWebGLProgram(c,l,r);l.forEach(p=>e.disposeIntermediateTensorInfo(p));const h=tt({inputs:{x:d},attrs:{shape:u},backend:e});return e.disposeIntermediateTensorInfo(d),h}function SB(t){const{inputs:n,backend:e,attrs:r}=t,{axis:s}=r,o=Jt(s,n[0].shape)[0];Q1(n.map(u=>u.shape),o);const a=Ai(n.map(u=>u.shape),o);if(0===_e(a))return e.makeTensorInfo(a,n[0].dtype,[]);const l=n.filter(u=>_e(u.shape)>0);return 1===l.length?Ks({inputs:{x:l[0]},backend:e}):Sf(l,o,e)}const a0e={kernelName:qg,backendName:"webgl",kernelFunc:SB};class IB{constructor(n,e=!1,r=null,s=!1,o=!1){this.variableNames=["x","W"],this.outputShape=n.outShape;const i=n.padInfo.top,a=n.padInfo.left,l=n.strideHeight,u=n.strideWidth,c=n.dilationHeight,d=n.dilationWidth,h=n.filterHeight,p=n.filterWidth,f=4*Math.floor(n.inChannels/4),g=n.inChannels%4,m="channelsLast"===n.dataFormat,y=m?1:2,v=m?2:3,b=m?3:1;let x="",w="";r&&(x=s?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${r}\n        }`:o?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${r}\n        }`:`\n          float activation(float x) {\n            ${r}\n          }\n        `,w="result = activation(result);");const k=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${x}\n\n      const ivec2 strides = ivec2(${l}, ${u});\n      const ivec2 pads = ivec2(${i}, ${a});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${b}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${y}], coords[${v}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${h}; wR++) {\n          int xR = xRCorner + wR * ${c};\n\n          if (xR < 0 || xR >= ${n.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${p}; wC++) {\n            int xC = xCCorner + wC * ${d};\n\n            if (xC < 0 || xC >= ${n.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${f}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${m}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===g}) {\n\n              if (${m}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${f}) *\n                    getW(wR, wC, ${f}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${f}, xR, xC) *\n                    getW(wR, wC, ${f}, d2);\n              }\n\n            } else if (${2===g}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${f}, d2),\n                getW(wR, wC, ${f} + 1, d2)\n              );\n\n              if (${m}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${f}),\n                  getX(batch, xR, xC, ${f} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${f}, xR, xC),\n                  getX(batch, ${f} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===g}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${f}, d2),\n                getW(wR, wC, ${f} + 1, d2),\n                getW(wR, wC, ${f} + 2, d2)\n              );\n\n              if (${m}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${f}),\n                  getX(batch, xR, xC, ${f} + 1),\n                  getX(batch, xR, xC, ${f} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${f}, xR, xC),\n                  getX(batch, ${f} + 1, xR, xC),\n                  getX(batch, ${f} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${k}\n        ${w}\n        setOutput(result);\n      }\n    `}}class l0e{constructor(n){this.variableNames=["x","W"],this.outputShape=n.outShape;const e=n.padInfo.front,r=n.padInfo.top,s=n.padInfo.left,o=n.strideDepth,i=n.strideHeight,a=n.strideWidth,l=n.dilationDepth,u=n.dilationHeight,c=n.dilationWidth,d=n.filterDepth,h=n.filterHeight,p=n.filterWidth,f=4*Math.floor(n.inChannels/4),g=n.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${o}, ${i}, ${a});\n      const ivec3 pads = ivec3(${e}, ${r}, ${s});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${d}; wF++) {\n          int xF = xFCorner + wF * ${l};\n\n          if (xF < 0 || xF >= ${n.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${h}; wR++) {\n            int xR = xRCorner + wR * ${u};\n\n            if (xR < 0 || xR >= ${n.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${p}; wC++) {\n              int xC = xCCorner + wC * ${c};\n\n              if (xC < 0 || xC >= ${n.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${f}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===g}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${f}) *\n                  getW(wF, wR, wC, ${f}, d2);\n              } else if (${2===g}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${f}),\n                  getX(batch, xF, xR, xC, ${f} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${f}, d2),\n                  getW(wF, wR, wC, ${f} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===g}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${f}),\n                  getX(batch, xF, xR, xC, ${f} + 1),\n                  getX(batch, xF, xR, xC, ${f} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${f}, d2),\n                  getW(wF, wR, wC, ${f} + 1, d2),\n                  getW(wF, wR, wC, ${f} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class DB{constructor(n,e=!1,r=null,s=!1,o=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=n.outShape,this.enableShapeUniforms=ss(this.outputShape.length);const i=n.padInfo.left,a=n.strideWidth,l=n.dilationWidth,u=n.filterHeight,c=n.filterWidth,d=c;let h="\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;";for(let m=0;m<c;m++)h+=`\n           vec4 xTexelC${2*m};\n           int xTexelC${2*m}Ready;\n           vec4 xTexelC${2*m+1};\n           int xTexelC${2*m+1}Ready;\n           vec4 xC${m};`;h+=`\n     for (int r = 0; r < ${u}; r++) {\n      for (int d1 = 0; d1 < ${n.inChannels}; d1 += 2) {\n       `;for(let m=0;m<c;m++)h+=`\n           xTexelC${2*m} = vec4(0.0);\n           xTexelC${2*m}Ready = 0;\n           xTexelC${2*m+1} = vec4(0.0);\n           xTexelC${2*m+1}Ready = 0;\n           xC${m} = vec4(0.0);`;h+="\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";for(let m=0;m<(d+1)/2;m++){const y=2*m;if(h+=`\n           xC = xCCorner + ${y*l};\n           `,1===a){if(y<c&&(i%2==1?(h+=`\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {\n                   xTexelC${y} = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${y}.zw = vec2(0.0);\n                   }\n                   xTexelC${y}Ready = 1;\n                 }\n               `,h+=1===l&&y>0?`\n                 xC${y} = vec4(xTexelC${y-2}.zw, xTexelC${y}.xy);\n                 `:`\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC${y} = vec4(previous.zw, xTexelC${y}.xy);\n                   } else {\n                     xC${y} = vec4(0.0, 0.0, xTexelC${y}.xy);\n                   }\n                   `):h+=`\n                 if (xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {\n                   xTexelC${y} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${y}.zw = vec2(0.0);\n                   }\n                   xTexelC${y}Ready = 1;\n                 }\n\n                 xC${y} = xTexelC${y};\n                 `,y+1<c)){const v=i%2==0?O_(l):l;l%2==0&&i%2==1||l%2!=0&&i%2!=1?(h+=`\n                   xCOffset = xC + imod(pads[1], 2) + ${v};\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {\n                     xTexelC${y+1} = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC${y+1}.zw = vec2(0.0);\n                     }\n                     xTexelC${y+1}Ready = 1;\n                   }\n                   `,h+=l>1?`\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC${y+1} = vec4(previous.zw, xTexelC${y+1}.xy);\n                     } else {\n                      xC${y+1} = vec4(0.0, 0.0, xTexelC${y+1}.xy);\n                     }\n                     `:`\n                     xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.xy);\n                     `):h+=1===v?`\n                     xC${y+1} = xTexelC${y};\n                     `:`\n                     xCOffset = xC + ${v};\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {\n                       xTexelC${y+1} = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC${y+1}.zw = vec2(0.0);\n                       }\n                       xTexelC${y+1}Ready = 1;\n                     }\n\n                     xC${y+1} = xTexelC${y+1};\n                     `}}else y<c&&(i%2==1?(h+=`\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {\n                   xTexelC${y} = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${y}.zw = vec2(0.0);\n                   }\n                   xTexelC${y}Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${y+1}Ready == 0) {\n                   xTexelC${y+1} = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC${y+1}.zw = vec2(0.0);\n                   }\n                   xTexelC${y+1}Ready = 1;\n                 }\n\n                 xC${y} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);\n               `,y+1<c&&(h+=`\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC${y+1} = vec4(xTexelC${y+1}.xy, final.xy);\n                 `)):(h+=`\n                 if(xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {\n                   xTexelC${y} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${y}.zw = vec2(0.0);\n                   }\n                   xTexelC${y}Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {\n                   xTexelC${y+1} = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${y+1}.zw = vec2(0.);\n                   }\n                   xTexelC${y+1}Ready = 1;\n                 }\n\n                 xC${y} = vec4(\n                   xTexelC${y}.xy, xTexelC${y+1}.xy);\n               `,y+1<c&&(h+=`\n                   xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);\n                 `)));y<c&&(h+=`\n             wTexel = getW(r, ${y}, d1, d2);\n             dotProd += xC${y}.xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ${n.inChannels}) {\n               dotProd += xC${y}.yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           `,y+1<c&&(h+=`\n               wTexel = getW(r, ${y+1}, d1, d2);\n               dotProd += xC${y+1}.xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ${n.inChannels}) {\n                 dotProd += xC${y+1}.yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             `))}h+="\n     }\n   ",h+="\n     }\n   ",h+="\n     }\n   ";let p="",f="";r&&(p=s?`vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ${r}\n         }`:o?`vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ${r}\n         }`:`vec4 activation(vec4 x) {\n           ${r}\n         }`,f="result = activation(result);");const g=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n       ${p}\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ${h}\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ${g}\n         ${f}\n         setOutput(result);\n       }\n     `}}class u0e{constructor(n,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=n,this.enableShapeUniforms=ss(this.outputShape.length);const{dataFormat:r}=e,s=bs(),o="channelsLast"===r,i=o?1:2,a=o?2:3,l=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${n[2]} && pos < ${n[1]}) {`;let u="";for(let c=0;c<=1;c++)for(let d=0;d<=1;d++)u+=`\n          blockIndex = rc.z + ${d};\n          pos = rc.y + ${c};\n\n          ${l}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${i}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${a}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${o}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*c+d}] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*c+d}] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${u}\n\n        ${s.output} = result;\n      }\n    `}}function _b(t,n){const e=t.length;return e>=3?n?[...t.slice(0,-3),t[e-3]*t[e-2],t[e-1]]:[...t.slice(0,-3),t[e-3],t[e-2]*t[e-1]]:!n&&1===e&&t[0]>1?[t[0],1]:null}function TB({x:t,filter:n,convInfo:e,backend:r,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:a=null}){const l=t.shape,u=r.texData.get(t.dataId),c=e.inChannels,d=l[0]*l[1]*l[2],h=e.outChannels,p="channelsLast"===e.dataFormat;let m;const y=[];if(null!=o){const x=_b(o.shape,p);null!=x&&(o=tt({inputs:{x:o},backend:r,attrs:{shape:x}}),y.push(o))}if(null!=s){const x=_b(s.shape,p);null!=x&&(s=tt({inputs:{x:s},backend:r,attrs:{shape:x}}),y.push(s))}if((1!==d&&1!==h||!(c>mB))&&u.isPacked&&p&&null!=u.texture&&l[2]%2!=0&&gn(u.shape.slice(-3),l.slice(-3))){const w={dataId:t.dataId,shape:[1,l[0]*l[1]*(l[2]+1),e.inChannels],dtype:t.dtype},k=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,R(cb(u.shape,w.shape),()=>`packed reshape ${u.shape} to ${w.shape} isn't free`);const V=tt({inputs:{x:n},backend:r,attrs:{shape:[1,e.inChannels,e.outChannels]}});y.push(V);const z=vb({a:w,b:V,backend:r,transposeA:!1,transposeB:!1,bias:s,activation:a,preluActivationWeights:o,leakyreluAlpha:i}),K=r.texData.get(z.dataId);R(K.isPacked,()=>"batchMatMul result is expected to be packed"),u.shape=k,K.shape=e.outShape,m=Ks({inputs:{x:z},backend:r}),m.shape=e.outShape,y.push(z)}else{const x=e.outHeight*e.outWidth,w=tt({inputs:{x:t},backend:r,attrs:{shape:p?[e.batchSize,x,e.inChannels]:[e.batchSize,e.inChannels,x]}}),k=tt({inputs:{x:n},backend:r,attrs:{shape:[1,e.inChannels,e.outChannels]}}),V=vb({a:p?w:k,b:p?k:w,transposeA:!p,transposeB:!1,backend:r,bias:s,activation:a,preluActivationWeights:o,leakyreluAlpha:i});m=tt({inputs:{x:V},backend:r,attrs:{shape:e.outShape}}),y.push(w),y.push(k),y.push(V)}for(const x of y)r.disposeIntermediateTensorInfo(x);return m}function kB({x:t,filter:n,convInfo:e,backend:r,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:a=null}){const{filterWidth:l,filterHeight:u,inChannels:c,outWidth:d,outHeight:h,dataFormat:p}=e,f="channelsLast"===p,g=l*u*c,m=h*d,y=[e.batchSize,g,m],x=[];if(null!=o){const we=_b(o.shape,f);null!=we&&(o=tt({inputs:{x:o},backend:r,attrs:{shape:we}}),x.push(o))}if(null!=s){const we=_b(s.shape,f);null!=we&&(s=tt({inputs:{x:s},backend:r,attrs:{shape:we}}),x.push(s))}const w=tt({inputs:{x:n},backend:r,attrs:{shape:[1,g,_e(n.shape)/g]}});x.push(w);const k=new u0e(y,e),z=r.runWebGLProgram(k,[t],"float32",[t.shape,[e.padInfo.top,e.padInfo.left],[e.strideHeight,e.strideWidth],[e.dilationHeight,e.dilationWidth],[e.inChannels],[e.filterWidth*e.inChannels],[e.outWidth]]),K=tt({inputs:{x:z},backend:r,attrs:{shape:y}});x.push(z),x.push(K);const Y=null!=s,se=null!=o,fe="leakyrelu"===a,ve=a?wf(a,!0):null,be=new cB(f?K.shape:w.shape,f?w.shape:K.shape,f?[e.batchSize,m,e.outChannels]:[e.batchSize,e.outChannels,m],!0,!1,Y,ve,se,fe),xe=f?[K,w]:[w,K];if(s&&xe.push(s),se&&xe.push(o),fe){const we=r.makeTensorInfo([],"float32",Ba(i,"float32"));xe.push(we),x.push(we)}const De=r.runWebGLProgram(be,xe,"float32"),Ne=tt({inputs:{x:De},backend:r,attrs:{shape:e.outShape}});x.push(De);for(const we of x)r.disposeIntermediateTensorInfo(we);return Ne}const d0e={kernelName:Kg,backendName:"webgl",kernelFunc:function c0e(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,filter:o}=n,{strides:i,pad:a,dataFormat:l,dilations:u,dimRoundingMode:c}=r,d=da(l),h=Mr(s.shape,o.shape,i,u,a,c,!1,d);let p;if(1!==h.filterHeight||1!==h.filterWidth||1!==h.dilationHeight||1!==h.dilationWidth||1!==h.strideHeight||1!==h.strideWidth||"SAME"!==h.padInfo.type&&"VALID"!==h.padInfo.type)if(h.strideWidth<=2&&"channelsLast"===d&&pe().getBool("WEBGL_EXP_CONV")){const g=new DB(h);p=e.runWebGLProgram(g,[s,o],"float32",[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]])}else if(pe().getBool("WEBGL_CONV_IM2COL"))p=kB({x:s,filter:o,convInfo:h,backend:e});else{const g=new IB(h);p=e.runWebGLProgram(g,[s,o],"float32")}else p=TB({x:s,filter:o,convInfo:h,backend:e});const f=tt({inputs:{x:p},backend:e,attrs:{shape:h.outShape}});return e.disposeIntermediateTensorInfo(p),f}};class h0e{constructor(n){this.variableNames=["x","dy"],this.outputShape=n.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${n.batchSize}; b++) {\n          for (int yR = 0; yR < ${n.outHeight}; yR++) {\n            int xR = wR + yR * ${n.strideHeight} - ${n.padInfo.top};\n\n            if (xR < 0 || xR >= ${n.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${n.outWidth}; yC++) {\n              int xC = wC + yC * ${n.strideWidth} - ${n.padInfo.left};\n\n              if (xC < 0 || xC >= ${n.inWidth}) {\n                continue;\n              }\n\n              ${"channelsLast"===n.dataFormat?"float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);":"float dyValue = getDy(b, d2, yR, yC);\n              float xValue = getX(b, d1, xR, xC);\n              dotProd += (xValue * dyValue);"}\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class p0e{constructor(n){this.variableNames=["dy","W"],this.outputShape=n.inShape;const e=n.filterHeight,r=n.filterWidth,i="channelsLast"===n.dataFormat;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-n.padInfo.top}, ${r-1-n.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${i?3:1}];\n\n        ivec2 dyCorner = ivec2(coords[${i?1:2}], coords[${i?2:3}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${n.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${n.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${r}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${n.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${r} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${n.outChannels}; d2++) {\n\n              if (${i}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class f0e{constructor(n){this.variableNames=["x","dy"],this.outputShape=n.filterShape,this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${n.batchSize}; b++) {\n          for (int yF = 0; yF < ${n.outDepth}; yF++) {\n            int xF = wF + yF * ${n.strideDepth} - ${n.padInfo.front};\n\n            if (xF < 0 || xF >= ${n.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${n.outHeight}; yR++) {\n              int xR = wR + yR * ${n.strideHeight} - ${n.padInfo.top};\n\n              if (xR < 0 || xR >= ${n.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${n.outWidth}; yC++) {\n                int xC = wC + yC * ${n.strideWidth} - ${n.padInfo.left};\n\n                if (xC < 0 || xC >= ${n.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class m0e{constructor(n){this.variableNames=["dy","W"],this.outputShape=n.inShape;const e=n.filterDepth,r=n.filterHeight,s=n.filterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${e-1-n.padInfo.front}, ${r-1-n.padInfo.top}, ${s-1-n.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${e}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${n.strideDepth}.0;\n\n          if (dyF < 0.0 || dyF >= ${n.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${e} - 1 - wF;\n\n          for (int wR = 0; wR < ${r}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${n.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${n.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${r} - 1 - wR;\n\n            for (int wC = 0; wC < ${s}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${n.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${s} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${n.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const y0e={kernelName:Z_,backendName:"webgl",kernelFunc:function g0e(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,dy:o}=n,{strides:i,pad:a,dataFormat:l,dimRoundingMode:u,filterShape:c}=r,d=da(l),h=Mr(s.shape,c,i,1,a,u,!1,d),p=new h0e(h);return e.runWebGLProgram(p,[s,o],"float32")}};class v0e{constructor(n){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=n.inShape,this.enableShapeUniforms=ss(this.outputShape.length);const e=n.filterHeight,r=n.filterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-n.padInfo.top}, ${r-1-n.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        vec4 result = vec4(0.);\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / strides[0];\n          if (dyR < 0.0 || dyR >= ${n.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${r}; wC++) {\n            int wCPerm = ${r} - 1 - wC;\n\n            float dyC = float(dyCCorner + wC) / strides[1];\n            bool idyCVal = (dyC >= 0.0) && (dyC < ${n.outWidth}.0)\n              && (fract(dyC) == 0.0);\n            int idyC = int(dyC);\n\n            float dyC2 = float(dyCCorner + wC + 1) / strides[1];\n            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${n.outWidth}.0)\n              && (fract(dyC2) == 0.0);\n            int idyC2 = int(dyC2);\n\n            if (idyCVal && idyCVal2) {\n              for (int d2 = 0; d2 < ${n.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?\n                  dySample : getDy(batch, idyR, idyC2, d2);\n\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n\n                dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample2.xy : dySample2.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal) {\n              for (int d2 = 0; d2 < ${n.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal2) {\n              for (int d2 = 0; d2 < ${n.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC2, d2);\n                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            }\n          }\n        }\n        setOutput(result);\n      }\n    `}}const x0e={kernelName:Xg,backendName:"webgl",kernelFunc:function b0e(t){const{inputs:n,backend:e,attrs:r}=t,{dy:s,filter:o}=n,{inputShape:i,strides:a,pad:l,dataFormat:u,dimRoundingMode:c}=r,d=da(u),h=Mr(i,o.shape,a,1,l,c,!1,d);if(pe().getBool("WEBGL_PACK")&&"channelsLast"===d){const p=[[h.strideHeight,h.strideWidth]],f=new v0e(h);return e.runWebGLProgram(f,[s,o],"float32",p)}{const p=new p0e(h);return e.runWebGLProgram(p,[s,o],"float32")}}},_0e={kernelName:Yg,backendName:"webgl",kernelFunc:function w0e(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,filter:o}=n,{strides:i,pad:a,dilations:l}=r,u=ja(s.shape,o.shape,i,l,a),c=new l0e(u);return e.runWebGLProgram(c,[s,o],"float32")}},S0e={kernelName:Q_,backendName:"webgl",kernelFunc:function C0e(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,dy:o}=n,{strides:i,pad:a,filterShape:l}=r,u=ja(s.shape,l,i,1,a),c=new f0e(u);return e.runWebGLProgram(c,[s,o],"float32")}},D0e={kernelName:J_,backendName:"webgl",kernelFunc:function I0e(t){const{inputs:n,backend:e,attrs:r}=t,{dy:s,filter:o}=n,{pad:i,strides:a,inputShape:l}=r,u=ja(l,o.shape,a,1,i),c=new m0e(u);return e.runWebGLProgram(c,[s,o],"float32")}},E0e=pn({opSnippet:ad+"\n  return cos(x);\n",packedOpSnippet:`\n  vec4 result = cos(x);\n  bvec4 isNaN = isnan(x);\n  ${gu}\n  return result;\n`}),N0e={kernelName:Hh,backendName:"webgl",kernelFunc:E0e},A0e=pn({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),R0e={kernelName:jh,backendName:"webgl",kernelFunc:A0e};class F0e{constructor(n,e,r,s,o){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[i,a,l,u]=n,[c]=e,[d,h]=r;this.outputShape=[c,d,h,u];const p="bilinear"===s?1:0,[f,g]=[a-1+".0",l-1+".0"],[m,y,v]=d>1?[""+(a-1)/(d-1),"(y2-y1) * height_ratio",`y1*${f} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${f}`],[b,x,w]=h>1?[""+(l-1)/(h-1),"(x2-x1) * width_ratio",`x1*${g} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${g}`];this.userCode=`\n      const float height_ratio = float(${m});\n      const float width_ratio = float(${b});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${i}) {\n          return;\n        }\n\n        float height_scale = ${y};\n        float width_scale = ${x};\n\n        float in_y = ${v};\n        if( in_y < 0.0 || in_y > ${f} ) {\n          setOutput(float(${o}));\n          return;\n        }\n        float in_x = ${w};\n        if( in_x < 0.0 || in_x > ${g} ) {\n          setOutput(float(${o}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${p} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}const O0e={kernelName:tC,backendName:"webgl",kernelFunc:t=>{const{inputs:n,backend:e,attrs:r}=t,{image:s,boxes:o,boxInd:i}=n,{cropSize:a,method:l,extrapolationValue:u}=r,c=new F0e(s.shape,o.shape,a,l,u);return e.runWebGLProgram(c,[s,o,i],"float32")}};var ud=(()=>{return(t=ud||(ud={})).Prod="*",t.Sum="+",ud;var t})();class EB{constructor(n,e,r,s){this.op=n,this.outputShape=e,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const o=this.outputShape.length,a=r?this.op===ud.Prod?"1.0":"0.0":`getX(${NB(o,"coords",this.op)})`,l=this.outputShape[this.outputShape.length-1];let u="",c="";r?(u=s?"end != "+(l-1):"end != 0",c=s?"end + 1":"end - 1"):(u=s?`end + pow2 < ${l}`:"end >= pow2",c=s?"end + pow2":"end - pow2"),this.userCode=`\n      void main() {\n        ${kn(o)} coords = getOutputCoords();\n        int end = ${AB(o,"coords",this.op)};\n        float val = ${a};\n        int pow2 = int(pow(2.0, index));\n        if (${u}) {\n          int idx = ${c};\n          ${AB(o,"coords",this.op)} = idx;\n          val ${this.op}= getX(${NB(o,"coords",this.op)});\n        }\n        setOutput(val);\n      }\n    `}}function NB(t,n,e){if(1===t)return`${n}`;if(2===t)return`${n}.x, ${n}.y`;if(3===t)return`${n}.x, ${n}.y, ${n}.z`;if(4===t)return`${n}.x, ${n}.y, ${n}.z, ${n}.w`;throw new Error(`Cumulative ${e} for rank ${t} is not yet supported`)}function AB(t,n,e){if(1===t)return`${n}`;if(2===t)return`${n}.y`;if(3===t)return`${n}.z`;if(4===t)return`${n}.w`;throw new Error(`Cumulative ${e} for rank ${t} is not yet supported`)}function RB(t,n,e,r,s,o){const i=n.shape.length,a=Qn([r],i);let l=n;null!=a&&(l=ws({inputs:{x:n},backend:e,attrs:{perm:a}}));const u=fr(1,i)[0];if(u!==i-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${n.shape.length-1} but got axis=${r}`);const c=l.shape[u];let d=Ks({inputs:{x:l},backend:e});for(let h=0;h<=Math.ceil(Math.log2(c))-1;h++){const p=new EB(t,l.shape,!1,o),g=d;d=e.runWebGLProgram(p,[d],d.dtype,[[h]]),e.disposeIntermediateTensorInfo(g)}if(s){const h=new EB(t,l.shape,s,o),p=d;d=e.runWebGLProgram(h,[d],d.dtype),e.disposeIntermediateTensorInfo(p)}if(null!=a){const p=ws({inputs:{x:d},backend:e,attrs:{perm:Ka(a)}});return e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(l),p}return d}const M0e={kernelName:eC,backendName:"webgl",kernelFunc:function P0e(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o,exclusive:i,reverse:a}=r;return RB(ud.Prod,s,e,o,i,a)}},L0e={kernelName:Zg,backendName:"webgl",kernelFunc:function $0e(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o,exclusive:i,reverse:a}=r;return RB(ud.Sum,s,e,o,i,a)}},B0e={kernelName:nC,backendName:"webgl",kernelFunc:function V0e(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,weights:o}=n,{size:i,binaryOutput:a}=r;if(1===s.shape.length){const l=e.readSync(s.dataId),u=e.readSync(o.dataId),c=Z3(l,u,o.dtype,o.shape,i);return e.makeTensorInfo([i],o.dtype,c)}if(2===s.shape.length){const l=e.bufferSync(s),u=e.bufferSync(o),c=Yge(l,u,i,a);return e.makeTensorInfo(c.shape,o.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}};class z0e{constructor(n,e,r){this.variableNames=["x"],this.outputShape=[],this.outputShape=n,this.blockSize=e,this.dataFormat=r,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${e};\n      int offset_h = imod(h, ${e});\n      int in_w = w / ${e};\n      int offset_w = imod(w, ${e});\n      int offset_d = (offset_h * ${e} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const W0e={kernelName:rC,backendName:"webgl",kernelFunc:function U0e(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{blockSize:o,dataFormat:i}=r,a=s.shape[0],d=("NHWC"===i?s.shape[1]:s.shape[2])*o,h=("NHWC"===i?s.shape[2]:s.shape[3])*o,p=("NHWC"===i?s.shape[3]:s.shape[1])/(o*o),g=new z0e("NHWC"===i?[a,d,h,p]:[a,p,d,h],o,i);return e.runWebGLProgram(g,[s],s.dtype)}};class FB{constructor(n,e=!1,r=null,s=!1,o=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=n.outShape,this.enableShapeUniforms=ss(this.outputShape.length);const i=n.filterHeight,a=n.filterWidth,l=n.outChannels/n.inChannels;let u="",c="";r&&(u=s?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${r}\n        }`:o?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${r}\n        }`:`\n          float activation(float x) {\n            ${r}\n          }\n        `,c="result = activation(result);");const d=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${u}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${l};\n        int q = d2 - d1 * ${l};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${i}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${a}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${d}\n        ${c}\n        setOutput(result);\n      }\n    `}}class OB{constructor(n,e=!1,r=null,s=!1,o=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=n.outShape,this.enableShapeUniforms=ss(this.outputShape.length);const i=n.outChannels/n.inChannels,a=n.padInfo.left,l=n.strideWidth,u=n.dilationWidth,c=n.filterHeight,d=n.filterWidth,h=d;let p="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let y=0;y<d;y++)p+=`\n          vec4 xTexelC${2*y};\n          int xTexelC${2*y}Ready;\n          vec4 xTexelC${2*y+1};\n          int xTexelC${2*y+1}Ready;\n          vec4 xC${y};`;p+=`\n    for (int r = 0; r < ${c}; r++) {\n      `;for(let y=0;y<d;y++)p+=`\n          xTexelC${2*y} = vec4(0.0);\n          xTexelC${2*y}Ready = 0;\n          xTexelC${2*y+1} = vec4(0.0);\n          xTexelC${2*y+1}Ready = 0;\n          xC${y} = vec4(0.0);`;p+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let y=0;y<(h+1)/2;y++){const v=2*y;if(p+=`\n          xC = xCCorner + ${v*u};\n          `,1===l){if(v<d&&(a%2==1?(p+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v}Ready == 0) {\n                  xTexelC${v} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${v}.zw = vec2(0.0);\n                  }\n                  xTexelC${v}Ready = 1;\n                }\n              `,p+=1===u&&v>0?`\n                xC${v} = vec4(xTexelC${v-2}.zw, xTexelC${v}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${v} = vec4(previous.zw, xTexelC${v}.xy);\n                  } else {\n                    xC${v} = vec4(0.0, 0.0, xTexelC${v}.xy);\n                  }\n                  `):p+=`\n                if (xC >= 0 && xC < inDims[1] && xTexelC${v}Ready == 0) {\n                  xTexelC${v} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${v}.zw = vec2(0.0);\n                  }\n                  xTexelC${v}Ready = 1;\n                }\n\n                xC${v} = xTexelC${v};\n                `,v+1<d)){const b=a%2==0?O_(u):u;u%2==0&&a%2==1||u%2!=0&&a%2!=1?(p+=`\n                  xCOffset = xC + imod(pads[1], 2) + ${b};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v+1}Ready == 0) {\n                    xTexelC${v+1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${v+1}.zw = vec2(0.0);\n                    }\n                    xTexelC${v+1}Ready = 1;\n                  }\n                  `,p+=u>1?`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC${v+1} = vec4(previous.zw, xTexelC${v+1}.xy);\n                    } else {\n                     xC${v+1} = vec4(0.0, 0.0, xTexelC${v+1}.xy);\n                    }\n                    `:`\n                    xC${v+1} = vec4(xTexelC${v}.zw, xTexelC${v+1}.xy);\n                    `):p+=1===b?`\n                    xC${v+1} = xTexelC${v};\n                    `:`\n                    xCOffset = xC + ${b};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v+1}Ready == 0) {\n                      xTexelC${v+1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${v+1}.zw = vec2(0.0);\n                      }\n                      xTexelC${v+1}Ready = 1;\n                    }\n\n                    xC${v+1} = xTexelC${v+1};\n                    `}}else v<d&&(a%2==1?(p+=`\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v}Ready == 0) {\n                  xTexelC${v} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${v}.zw = vec2(0.0);\n                  }\n                  xTexelC${v}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${v+1}Ready == 0) {\n                  xTexelC${v+1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${v+1}.zw = vec2(0.0);\n                  }\n                  xTexelC${v+1}Ready = 1;\n                }\n\n                xC${v} = vec4(xTexelC${v}.zw, xTexelC${v+1}.zw);\n              `,v+1<d&&(p+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${v+1} = vec4(xTexelC${v+1}.xy, final.xy);\n                `)):(p+=`\n                if(xC >= 0 && xC < inDims[1] && xTexelC${v}Ready == 0) {\n                  xTexelC${v} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${v}.zw = vec2(0.0);\n                  }\n                  xTexelC${v}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v+1}Ready == 0) {\n                  xTexelC${v+1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${v+1}.zw = vec2(0.);\n                  }\n                  xTexelC${v+1}Ready = 1;\n                }\n\n                xC${v} = vec4(\n                  xTexelC${v}.xy, xTexelC${v+1}.xy);\n              `,v+1<d&&(p+=`\n                  xC${v+1} = vec4(xTexelC${v}.zw, xTexelC${v+1}.zw);\n                `)));v<d&&(p+=`\n            wTexel = getW(r, ${v}, d1, q);\n            dotProd += xC${v} * vec4(wTexel.xz, wTexel.xz);\n          `,v+1<d&&(p+=`\n              wTexel = getW(r, ${v+1}, d1, q);\n              dotProd += xC${v+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}p+="\n    }\n  ",p+="\n      }\n    ";let f="",g="";r&&(f=s?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${r}\n        }`:o?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${r}\n        }`:`vec4 activation(vec4 x) {\n          ${r}\n        }`,g="result = activation(result);");const m=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${f}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${i};\n        int q = d2 - d1 * ${i};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${p}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${m}\n        ${g}\n        setOutput(result);\n      }\n    `}}const H0e={kernelName:Qg,backendName:"webgl",kernelFunc:function G0e(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,filter:o}=n,{strides:i,pad:a,dilations:l,dimRoundingMode:u}=r;let c=l;null==c&&(c=[1,1]),R(Gr(i,c),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);const d=Mr(s.shape,o.shape,i,c,a,u,!0);let h;return h=pe().getBool("WEBGL_PACK_DEPTHWISECONV")&&d.strideWidth<=2&&d.outChannels/d.inChannels==1?new OB(d):new FB(d),e.runWebGLProgram(h,[s,o],"float32",[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]])}};class j0e{constructor(n){this.variableNames=["x","dy"],this.outputShape=n.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${n.outChannels/n.inChannels} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${n.batchSize}; b++) {\n          for (int yR = 0; yR < ${n.outHeight}; yR++) {\n            int xR = wR + yR * ${n.strideHeight} - ${n.padInfo.top};\n\n            if (xR < 0 || xR >= ${n.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${n.outWidth}; yC++) {\n              int xC = wC + yC * ${n.strideWidth} - ${n.padInfo.left};\n\n              if (xC < 0 || xC >= ${n.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class q0e{constructor(n){this.variableNames=["dy","W"],this.outputShape=n.inShape;const e=n.filterHeight,r=n.filterWidth,l=n.outChannels/n.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-n.padInfo.top}, ${r-1-n.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${n.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${n.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${r}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${n.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${r} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${l}; dm++) {\n              int d2 = d1 * ${l} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const X0e={kernelName:sC,backendName:"webgl",kernelFunc:function K0e(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,dy:o}=n,{strides:i,dilations:a,pad:l,dimRoundingMode:u,filterShape:c}=r,d=Mr(s.shape,c,i,a,l,u,!0),h=new j0e(d);return e.runWebGLProgram(h,[s,o],"float32")}},Z0e={kernelName:oC,backendName:"webgl",kernelFunc:function Y0e(t){const{inputs:n,backend:e,attrs:r}=t,{dy:s,filter:o}=n,{strides:i,dilations:a,pad:l,dimRoundingMode:u,inputShape:c}=r,d=Mr(c,o.shape,i,a,l,u,!0),h=new q0e(d);return e.runWebGLProgram(h,[s,o],"float32")}};class Q0e{constructor(n){this.variableNames=["X"],this.outputShape=[n,n],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const exe={kernelName:"Diag",backendName:"webgl",kernelFunc:function J0e(t){const{inputs:n,backend:e}=t,{x:r}=n,s=[...r.shape,...r.shape],o=_e(r.shape),i=tt({inputs:{x:r},backend:e,attrs:{shape:[o]}}),a=new Q0e(o),l=e.runWebGLProgram(a,[i],i.dtype),u=tt({inputs:{x:l},backend:e,attrs:{shape:s}});return e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(l),u}};class txe{constructor(n){this.variableNames=["x","W"],this.outputShape=n.outShape;const{inHeight:e,inWidth:r,padInfo:s,strideHeight:o,strideWidth:i,filterHeight:a,filterWidth:l,dilationHeight:u,dilationWidth:c}=n,{top:d,left:h}=s;this.userCode=`\n      const ivec2 strides = ivec2(${o}, ${i});\n      const ivec2 pads = ivec2(${d}, ${h});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${a}; h++) {\n          int hIn = hBeg + h * ${u};\n\n          if (hIn >= 0 && hIn < ${e}) {\n            for (int w = 0; w < ${l}; w++) {\n              int wIn = wBeg + w * ${c};\n\n              if (wIn >= 0 && wIn < ${r}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}const rxe={kernelName:Jg,backendName:"webgl",kernelFunc:function nxe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,filter:o}=n,{strides:i,pad:a,dilations:l}=r,u=Vp(s.shape,o.shape,i,a,"NHWC",l);let c;const d=new txe(u);c=e.runWebGLProgram(d,[s,o],"float32");const h=tt({inputs:{x:c},backend:e,attrs:{shape:u.outShape}});return e.disposeIntermediateTensorInfo(c),h}},oxe={kernelName:"Einsum",backendName:"webgl",kernelFunc:function sxe(t){const{inputs:n,backend:e,attrs:r}=t,{equation:s}=r,o=n,{allDims:i,summedDims:a,idDims:l}=hS(s,o.length);fS(i.length,l,o);const{path:u,steps:c}=mS(a,l),d=c.length;let h=null,p=i.length;const f=[];for(let g=0;g<d;++g){for(const m of c[g]){const{permutationIndices:y,expandDims:v}=pS(p,l[m]);let b;gS(y)?b=o[m]:(b=ws({inputs:{x:o[m]},backend:e,attrs:{perm:y}}),f.push(b));const x=b.shape.slice();for(let w=0;w<v.length;++w)x.splice(v[w],0,1);gn(b.shape,x)||(b=tt({inputs:{x:b},backend:e,attrs:{shape:x}}),f.push(b)),null===h?h=b:(h=WI({inputs:{a:b,b:h},backend:e}),f.push(h))}g<d-1&&(u[g]>=0&&(h=yb({inputs:{x:h},backend:e,attrs:{axis:u[g]-(i.length-p),keepDims:!1}}),f.push(h)),p--)}for(const g of f)g!==h&&e.disposeIntermediateTensorInfo(g);return h}},ixe=pn({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),axe={kernelName:Kh,backendName:"webgl",kernelFunc:ixe},cxe={kernelName:lC,backendName:"webgl",kernelFunc:t=>{const{inputs:n,backend:e}=t,{dy:r,y:s}=n,o=pe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new xf("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",r.shape,s.shape):new id("return (b >= 0.0) ? a : a * (b + 1.0);",r.shape,s.shape);return e.runWebGLProgram(o,[r,s],r.dtype)}},dxe=jr({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:eye}),hxe={kernelName:ey,backendName:"webgl",kernelFunc:dxe},fxe=pn({opSnippet:`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${sS};\n  float a1 = ${oS};\n  float a2 = ${iS};\n  float a3 = ${aS};\n  float a4 = ${lS};\n  float a5 = ${uS};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`}),mxe={kernelName:Xh,backendName:"webgl",kernelFunc:fxe},PB=pn({opSnippet:ad+"\n  return exp(x);\n",packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:tye,dtype:"float32"}),yxe={kernelName:Yh,backendName:"webgl",kernelFunc:PB};function qI(t){const{inputs:n,attrs:e,backend:r}=t,{dim:s}=e,{input:o}=n,i=o.shape.length,a=o.shape.slice();let l=s;return s<0&&(R(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+s+1),a.splice(l,0,1),tt({inputs:{x:o},backend:r,attrs:{shape:a}})}const vxe={kernelName:ty,backendName:"webgl",kernelFunc:qI},MB="return exp(x) - 1.0;",bxe=pn({opSnippet:MB,packedOpSnippet:MB,cpuKernelImpl:nye}),xxe={kernelName:Zh,backendName:"webgl",kernelFunc:bxe};class $B{constructor(n,e,r){this.variableNames=["real","imag"];const s=e[1];this.outputShape=e;const o=r?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,i=r?`${s}.0`:"1.0";let a;if("real"===n)a="return real * expR - imag * expI;";else{if("imag"!==n)throw new Error(`FFT component must be either "real" or "imag", got ${n}.`);a="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${o};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${a}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${s});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${s}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${i};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}function LB(t,n,e){const r=e.texData.get(t.dataId),s=_e(t.shape),o=t.shape[t.shape.length-1],a=tt({inputs:{x:t},backend:e,attrs:{shape:[s/o,o]}}),l=a.shape,u=new $B("real",l,n),c=new $B("imag",l,n),d=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:l},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:l}],h=e.runWebGLProgram(u,d,"float32"),p=e.runWebGLProgram(c,d,"float32"),f=dl({inputs:{real:h,imag:p},backend:e});e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(p);const g=tt({inputs:{x:f},backend:e,attrs:{shape:t.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(f),g}const _xe={kernelName:"FFT",backendName:"webgl",kernelFunc:function wxe(t){const{inputs:n,backend:e}=t,{input:r}=n;return LB(r,!1,e)}};class Cxe{constructor(n,e){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=n,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}}function If(t){const{backend:n,attrs:e}=t,{shape:r,value:s}=e;let{dtype:o}=e;if(o=o||Sc(s),"string"===o){const i=cr(o,_e(r));return i.fill(s),n.makeTensorInfo(r,o,i)}{const i=new Cxe(r,s);return n.runWebGLProgram(i,[],o,[[s]])}}const Sxe={kernelName:cC,backendName:"webgl",kernelFunc:If};class Ixe{constructor(n){this.variableNames=["Image"],this.outputShape=[];const e=n[2];this.outputShape=n,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${e} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${e}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const Dxe={kernelName:dC,backendName:"webgl",kernelFunc:({inputs:t,backend:n})=>{const{image:e}=t,r=n,s=new Ixe(e.shape);return r.runWebGLProgram(s,[e],e.dtype)}},VB="return floor(x);",Txe=pn({opSnippet:VB,packedOpSnippet:VB,cpuKernelImpl:rye}),kxe={kernelName:Qh,backendName:"webgl",kernelFunc:Txe},Exe=jr({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),Nxe={kernelName:Jh,backendName:"webgl",kernelFunc:Exe};class Axe{constructor(n){this.variableNames=["A"];const e=bs(),[r,s]=n;this.outputShape=n,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}.0, ${r}.0);\n\n        vec4 values = ${e.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}class Rxe{constructor(n){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const e=bs(),[r,s]=n;this.outputShape=n,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${s}.0, ${r}.0);\n            vec4 values = ${e.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${e.output} = result;\n      }\n    `}}const Fxe={kernelName:MC,backendName:"webgl",kernelFunc:function Oxe(t){const{inputs:n,backend:e,attrs:r}=t;let{pixels:s}=n;const{numChannels:o}=r,i=typeof HTMLVideoElement<"u"&&s instanceof HTMLVideoElement,a=typeof HTMLImageElement<"u"&&s instanceof HTMLImageElement,[l,u]=i?[s.videoWidth,s.videoHeight]:[s.width,s.height],c=[u,l],d=[u,l,o];if(a||i){const g=pe().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(null==cd||g!==KI)&&(KI=g,cd=document.createElement("canvas").getContext("2d",{willReadFrequently:KI})),cd.canvas.width=l,cd.canvas.height=u,cd.drawImage(s,0,0,l,u),s=cd.canvas}const h=e.makeTensorInfo(c,"int32");e.texData.get(h.dataId).usage=qs.PIXELS,e.gpgpu.uploadPixelDataToTexture(e.getTexture(h.dataId),s);const p=pe().getBool("WEBGL_PACK")?new Rxe(d):new Axe(d),f=e.runWebGLProgram(p,[h],"int32");return e.disposeData(h.dataId),f}};let cd,KI=pe().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");const Mxe={kernelName:zy,backendName:"webgl",kernelFunc:function Pxe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,filter:o,bias:i,preluActivationWeights:a}=n,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=r,g=da(c),m=Mr(s.shape,o.shape,l,d,u,h,!1,g);let y;const v=[],b=null!=i,x=null!=a,w="leakyrelu"===p,k=()=>{const z=[s,o],K=(Y,se)=>{if("NCHW"===se&&1===Y.shape.length&&1!==Y.shape[0]){const fe=tt({inputs:{x:Y},backend:e,attrs:{shape:[Y.shape[0],1,1]}});return v.push(fe),fe}return Y};if(b&&z.push(K(i,c)),x&&z.push(K(a,c)),w){const Y=e.makeTensorInfo([],"float32",Ba(f,"float32"));z.push(Y),v.push(Y)}return z};if(1!==m.filterHeight||1!==m.filterWidth||1!==m.dilationHeight||1!==m.dilationWidth||1!==m.strideHeight||1!==m.strideWidth||"SAME"!==m.padInfo.type&&"VALID"!==m.padInfo.type)if(m.strideWidth<=2&&"channelsLast"===g&&pe().getBool("WEBGL_EXP_CONV")){const z=p?wf(p,!0):null,K=new DB(m,b,z,x,w),Y=[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]],se=k();y=e.runWebGLProgram(K,se,"float32",Y)}else if(pe().getBool("WEBGL_CONV_IM2COL"))y=kB({x:s,filter:o,convInfo:m,backend:e,bias:i,activation:p,preluActivationWeights:a,leakyreluAlpha:f});else{const z=p?wf(p,!1):null,K=new IB(m,b,z,x,w),Y=k();y=e.runWebGLProgram(K,Y,"float32")}else y=TB({x:s,filter:o,convInfo:m,backend:e,bias:i,activation:p,preluActivationWeights:a,leakyreluAlpha:f});const V=tt({inputs:{x:y},backend:e,attrs:{shape:m.outShape}});return v.push(y),v.forEach(z=>e.disposeIntermediateTensorInfo(z)),V}},Lxe={kernelName:Uy,backendName:"webgl",kernelFunc:function $xe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,filter:o,bias:i,preluActivationWeights:a}=n,{strides:l,pad:u,dilations:c,dimRoundingMode:d,activation:h,leakyreluAlpha:p}=r,f=[];let g=c;null==g&&(g=[1,1]),R(Gr(l,g),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${g}'`);const m=Mr(s.shape,o.shape,l,g,u,d,!0),y=pe().getBool("WEBGL_PACK_DEPTHWISECONV")&&m.strideWidth<=2&&m.outChannels/m.inChannels==1,v=h?wf(h,y):null,b=[s,o],x=null!=i,w=null!=a,k="leakyrelu"===h;if(x&&b.push(i),w&&b.push(a),k){const Y=e.makeTensorInfo([],"float32",Ba(p,"float32"));b.push(Y),f.push(Y)}let V;V=y?new OB(m,x,v,w,k):new FB(m,x,v,w,k);const K=e.runWebGLProgram(V,b,"float32",[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]]);return f.forEach(Y=>e.disposeIntermediateTensorInfo(Y)),K}};class Vxe{constructor(n,e,r,s){this.sliceDim=n,this.strides=e,this.paramsShape=s,this.variableNames=["x","indices"],this.outputShape=r;const o=kn(r.length);let i="\n    int index;";for(let a=0;a<this.sliceDim;a++)i+=`\n          index = round(getIndices(coords[0], ${a}));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[a]};\n          flattenIndex += index * ${this.strides[a]};`;this.userCode=`\n         void main() {\n          ${o} coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ${i}\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      `}}const zxe={kernelName:MO,backendName:"webgl",kernelFunc:function Bxe(t){const{inputs:n,backend:e}=t,{params:r,indices:s}=n,o=s.shape,i=o[o.length-1],a=_e(r.shape),[l,u,c,d]=rS(r,s),h=tt({inputs:{x:s},backend:e,attrs:{shape:[u,i]}}),p=tt({inputs:{x:r},backend:e,attrs:{shape:[_e(r.shape)/c,c]}});if(e.shouldExecuteOnCPU([r,s])||"string"===r.dtype){const y=e.readSync(s.dataId),v=e.bufferSync(r),b=sye(y,v,r.dtype,u,i,c,d,r.shape,a);return e.makeTensorInfo(l,r.dtype,b.values)}const f=new Vxe(i,d,[u,c],r.shape),g=e.runWebGLProgram(f,[p,h],p.dtype),m=tt({inputs:{x:g},backend:e,attrs:{shape:l}});return e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(g),m}};class Uxe{constructor(n,e){this.variableNames=["A","indices"],this.outputShape=e,this.rank=e.length;const r=kn(this.rank),s=function Wxe(t,n){const e=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let s=0;s<t.length;s++)r.push(2===s?"index":`${e[s]}`);return r.join()}(n);this.userCode=`\n      void main() {\n        ${r} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${n[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${s}));\n      }\n    `}}function BB(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,indices:o}=n,{axis:i,batchDims:a}=r,l=Jt(i,s.shape)[0];if(pe().get("DEBUG")){const v=e.readSync(o.dataId),b=s.shape[l];for(let x=0;x<v.length;++x){const w=v[x];R(w<=b-1&&w>=0,()=>`GatherV2: the index value ${w} is not in [0, ${b-1}]`)}}const u=bS(s,o,l,a),c=_e(o.shape),d=[],h=tt({inputs:{x:s},backend:e,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),p=tt({inputs:{x:o},backend:e,attrs:{shape:[u.batchSize,c/u.batchSize]}});d.push(h),d.push(p);const f=[u.batchSize,u.outerSize,c/u.batchSize,u.sliceSize];if(e.shouldExecuteOnCPU([s,o])||"string"===s.dtype){const v=e.bufferSync(p),b=e.bufferSync(h),x=oye(b,v,f);return d.forEach(w=>e.disposeIntermediateTensorInfo(w)),e.makeTensorInfo(u.outputShape,x.dtype,x.values)}const g=new Uxe(h.shape,f),m=e.runWebGLProgram(g,[h,p],h.dtype);d.push(m);const y=tt({inputs:{x:m},backend:e,attrs:{shape:u.outputShape}});return d.forEach(v=>e.disposeIntermediateTensorInfo(v)),y}const Gxe={kernelName:ry,backendName:"webgl",kernelFunc:BB},Hxe=jr({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:iye,dtype:"bool"}),jxe={kernelName:sy,backendName:"webgl",kernelFunc:Hxe},qxe=jr({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:aye}),Kxe={kernelName:ep,backendName:"webgl",kernelFunc:qxe},Yxe={kernelName:hC,backendName:"webgl",kernelFunc:function Xxe(t){const{inputs:n,backend:e}=t,{input:r}=n;return LB(r,!0,e)}},Zxe=pn({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),Qxe={kernelName:np,backendName:"webgl",kernelFunc:Zxe},Jxe=pn({opSnippet:"return float(isinf(x));",dtype:"bool"}),ewe={kernelName:rp,backendName:"webgl",kernelFunc:Jxe},twe=pn({opSnippet:"return float(isnan(x));",dtype:"bool"}),nwe={kernelName:sp,backendName:"webgl",kernelFunc:twe},rwe=jr({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:lye,dtype:"bool"}),swe={kernelName:iy,backendName:"webgl",kernelFunc:rwe},owe=jr({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:uye,dtype:"bool"}),iwe={kernelName:ay,backendName:"webgl",kernelFunc:owe},lwe={kernelName:$O,backendName:"webgl",kernelFunc:function awe(t){const{backend:n,attrs:e}=t,{start:r,stop:s,num:o}=e,i=cye(r,s,o);return n.makeTensorInfo([i.length],"float32",i)}},cwe=pn({opSnippet:ad+"\n  return x < 0.0 ? 0./0. : log(x);\n",packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:dye}),dwe={kernelName:op,backendName:"webgl",kernelFunc:cwe},pwe=pn({opSnippet:ad+"\n  return log(1.0 + x);\n"}),fwe={kernelName:ip,backendName:"webgl",kernelFunc:pwe},mwe=jr({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),gwe={kernelName:ly,backendName:"webgl",kernelFunc:mwe},ywe=pn({opSnippet:"return float(!(x >= 1.0));"}),vwe={kernelName:uy,backendName:"webgl",kernelFunc:ywe},bwe=jr({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),xwe={kernelName:cy,backendName:"webgl",kernelFunc:bwe};class wwe{constructor(n,e,r,s,o){this.variableNames=["x"],this.outputShape=[];const i=e,a=n[3]-1;let l;this.outputShape=n;const u=`float(${r}) + float(${s}) * sum`;l=.5===o?`inversesqrt(${u})`:1===o?`1.0/(${u})`:`exp(log(${u}) * float(-${o}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${i}; j <= ${i}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${a}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${l};\n        setOutput(val);\n      }\n    `}}class _we{constructor(n,e,r,s,o){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const i=e,a=n[3]-1;let l;this.outputShape=n;const u=`float(${r}) + float(${s}) * sum`;l=.5===o?`inversesqrt(${u})`:1===o?`1.0/(${u})`:`exp(log(${u}) * float(-${o}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${i};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${i}; j <= ${i}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${l};\n        setOutput(result);\n      }\n    `}}const Cwe={kernelName:dy,backendName:"webgl",kernelFunc:t=>{const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{depthRadius:o,bias:i,alpha:a,beta:l}=r,u=pe().getBool("WEBGL_PACK_NORMALIZATION")?new _we(s.shape,o,i,a,l):new wwe(s.shape,o,i,a,l);return e.runWebGLProgram(u,[s],s.dtype)}};class Swe{constructor(n,e,r,s,o){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=n,this.depth=n[3],this.depthRadius=e,this.bias=r,this.alpha=s,this.beta=o,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${e})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${e} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${s}) * norm + float(${r});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${s})\n                * float(${o})\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${o});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}const Iwe={kernelName:fC,backendName:"webgl",kernelFunc:t=>{const{inputs:n,backend:e,attrs:r}=t,{x:s,y:o,dy:i}=n,{depthRadius:a,bias:l,alpha:u,beta:c}=r,d=new Swe(s.shape,a,l,u,c);return e.runWebGLProgram(d,[s,o,i],s.dtype)}};function zB(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{reductionIndices:o,keepDims:i}=r,a=s.shape.length,l=Jt(o,s.shape);let u=l;const c=Qn(u,a),d=null!=c,h=e.shouldExecuteOnCPU([s]);let p=s;if(d){if(h){const b=e.texData.get(p.dataId).values,x=new Array(a);for(let V=0;V<x.length;V++)x[V]=s.shape[c[V]];const w=zI(b,s.shape,s.dtype,c,x);p=e.makeTensorInfo(x,s.dtype),e.texData.get(p.dataId).values=w}else p=gb(s,c,e);u=fr(u.length,a)}Hr("max",u,a);const[f,g]=$r(p.shape,u);let y,m=f;if(i&&(m=pr(f,l)),h){const b=e.texData.get(p.dataId).values,x=hye(b,_e(g),m,s.dtype);y=e.makeTensorInfo(m,s.dtype),e.texData.get(y.dataId).values=x}else y=function Dwe(t,n,e,r){const s=_e(n),a=tt({inputs:{x:t},attrs:{shape:[_e(t.shape)/s,s]},backend:r}),l=yu(a,t.dtype,"max",r),u=tt({inputs:{x:l},attrs:{shape:e},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(l),u}(p,g,m,e);return d&&e.disposeIntermediateTensorInfo(p),y}const Twe={kernelName:hy,backendName:"webgl",kernelFunc:zB},Nwe=jr({opSnippet:UI+"\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+gu+"\n  return result;\n",cpuKernelImpl:pye}),Awe={kernelName:ap,backendName:"webgl",kernelFunc:Nwe},Fwe={kernelName:py,backendName:"webgl",kernelFunc:function Rwe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n;vf(s,"maxPool");const{filterSize:o,strides:i,pad:a,dimRoundingMode:l}=r;R(Gr(i,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`);const c=Ro(s.shape,o,i,1,a,l);if(1===c.filterWidth&&1===c.filterHeight&&gn(c.inShape,c.outShape))return Ks({inputs:{x:s},backend:e});const d=new _f(c,"max",!1);return e.runWebGLProgram(d,[s],s.dtype)}},Pwe={kernelName:fy,backendName:"webgl",kernelFunc:function Owe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{filterSize:o,strides:i,pad:a,dataFormat:l,dimRoundingMode:u}=r,d=ca(s.shape,o,i,[1,1,1],a,u,l),h=new GI(d,"max",!1);return e.runWebGLProgram(h,[s],s.dtype)}};class Mwe{constructor(n){this.variableNames=["dy","maxPos"],this.outputShape=n.inShape;const o=n.effectiveFilterHeight,i=n.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${o-1-n.padInfo.top}, ${i-1-n.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${o};\n          wR += ${n.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${n.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${n.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${i}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${n.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${o*i-1} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${i} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class $we{constructor(n){this.variableNames=["dy","maxPos"],this.outputShape=n.inShape;const l=n.effectiveFilterDepth,u=n.effectiveFilterHeight,c=n.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${l-1-n.padInfo.front}, ${u-1-n.padInfo.top}, ${c-1-n.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${l};\n           wD += ${n.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${n.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${n.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${u};\n              wR += ${n.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${n.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${n.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${c};\n                wC += ${n.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${n.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${l*u*c-1} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${u} * ${c} +\n                  wR * ${c} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const Vwe={kernelName:gC,backendName:"webgl",kernelFunc:function Lwe(t){const{inputs:n,backend:e,attrs:r}=t,{dy:s,input:o}=n,i=o,{filterSize:a,strides:l,pad:u,dimRoundingMode:c}=r,h=ca(i.shape,a,l,[1,1,1],u,c),p=new GI(h,"max",!0),f=e.runWebGLProgram(p,[i],i.dtype),g=new $we(h),m=e.runWebGLProgram(g,[s,f],i.dtype);return e.disposeIntermediateTensorInfo(f),m}},zwe={kernelName:mC,backendName:"webgl",kernelFunc:function Bwe(t){const{inputs:n,backend:e,attrs:r}=t,{dy:s,input:o,output:i}=n,a=o;vf([o,i],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:d}=r,h=Ro(a.shape,l,u,1,c,d),f=new _f(h,"max",!0),g=e.runWebGLProgram(f,[a],a.dtype),m=new Mwe(h),y=e.runWebGLProgram(m,[s,g],a.dtype);return e.disposeIntermediateTensorInfo(g),y}},Wwe={kernelName:LO,backendName:"webgl",kernelFunc:({inputs:t,attrs:n,backend:e})=>{const{x:r}=t,{filterSize:s,strides:o,pad:i,includeBatchInIndex:a}=n,l=e;R(4===r.shape.length,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);const u=[1,1];R(Gr(o,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${u}'`);const c=Ro(r.shape,s,o,u,i),[d,h]=function Uwe(t,n,e,r){let s=new _f(e,"max",!1);const o=r.runWebGLProgram(s,[t],"float32");return s=new _f(e,"max",!0,!0,n),[o,r.runWebGLProgram(s,[t],"float32")]}(r,a,c,l);return[d,h]}},Hwe={kernelName:my,backendName:"webgl",kernelFunc:({inputs:t,attrs:n,backend:e})=>{const{x:r}=t,{keepDims:s,axis:o}=n,i=e,a=r.shape.length,l=Jt(o,r.shape);let u=l;const c=Qn(u,a),d=null!=c,h=i.shouldExecuteOnCPU([r]),p=[];let f=r;if(d){if(h){const x=i.texData.get(f.dataId).values,w=new Array(a);for(let z=0;z<w.length;z++)w[z]=r.shape[c[z]];const k=zI(x,r.shape,r.dtype,c,w);f=i.makeTensorInfo(w,r.dtype),i.texData.get(f.dataId).values=k}else f=gb(r,c,i);p.push(f),u=fr(u.length,a)}Hr("sum",u,a);const[g,m]=$r(f.shape,u);let y=g;s&&(y=pr(g,l));const v=function Gwe(t,n,e,r){const s=_e(n),a=tt({inputs:{x:t},attrs:{shape:[_e(t.shape)/s,s]},backend:r}),l=yu(a,"float32","mean",r),u=tt({inputs:{x:l},attrs:{shape:e},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(l),u}(f,m,y,i);for(const b of p)i.disposeIntermediateTensorInfo(b);return v}},qwe={kernelName:gy,backendName:"webgl",kernelFunc:function jwe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o,keepDims:i}=r,a=s.shape.length,l=Jt(o,s.shape);let u=l;const c=Qn(u,a);let d=s;null!=c&&(d=ws({inputs:{x:s},backend:e,attrs:{perm:c}}),u=fr(u.length,s.shape.length)),Hr("min",u,a);const[h,p]=$r(d.shape,u),g=tt({inputs:{x:d},backend:e,attrs:{shape:[-1,_e(p)]}}),m=yu(g,g.dtype,"min",e);let y;return y=tt(i?{inputs:{x:m},backend:e,attrs:{shape:pr(h,l)}}:{inputs:{x:m},backend:e,attrs:{shape:h}}),e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(m),null!=c&&e.disposeIntermediateTensorInfo(d),y}},Ywe=jr({opSnippet:UI+"\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+gu+"\n  return result;\n",cpuKernelImpl:fye}),Zwe={kernelName:lp,backendName:"webgl",kernelFunc:Ywe};class Qwe{constructor(n,e,r){this.variableNames=["x"],this.outputShape=e.map((c,d)=>c[0]+n[d]+c[1]);const s=n.length,o=kn(s),i=e.map(c=>c[0]).join(","),a=e.map((c,d)=>c[0]+n[d]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s),u="reflect"===r?0:1;this.userCode=1!==s?`\n      ${o} start = ${o}(${i});\n      ${o} end = ${o}(${a});\n\n      void main() {\n        ${o} outC = getOutputCoords();\n        for (int i = 0; i < ${s}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${u};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${u};\n          }\n        }\n        ${o} coords = outC - start;\n        setOutput(getX(${l}));\n      }\n    `:`\n        int start = ${i};\n        int end = ${a};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${u};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${u};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}}class Jwe{constructor(n,e,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map((f,g)=>f[0]+n[g]+f[1]);const s=n.length,o=kn(s),i=e.map(f=>f[0]).join(","),a=e.map((f,g)=>f[0]+n[g]).join(","),l=xs("rc",s),u=xs("source",s),c=`${l[s-1]} < ${this.outputShape[s-1]}`,d=1===s?"source":`vec2(${u.slice(-2).join()})`,h="reflect"===r?0:1;let p="";if(1===s){const f=`\n        ${o} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${h};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${h};\n        }\n        source -= start;\n      `;p=`\n        ${o} rc = outputLoc;\n        ${f}\n        result[0] = getChannel(getX(${u.join()}), ${d});\n        ${l[s-1]} += 1;\n        if(${c}) {\n          ${f}\n          result[1] = getChannel(getX(${u.join()}), ${d});\n        }\n      `}else{const f=`\n        ${o} source = rc;\n        ${o} lt = ${o}(lessThan(source, start));\n        ${o} gte = ${o}(greaterThanEqual(source, end));\n        ${o} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${h}) +\n                gte * ((end - 1) * 2 - source + ${h});\n        source -= start;\n      `;p=`\n        ${o} rc = outputLoc;\n        ${f}\n        result[0] = getChannel(getX(${u.join()}), ${d});\n        ${l[s-1]} += 1;\n        if(${c}) {\n          ${f}\n          result[1] = getChannel(getX(${u.join()}), ${d});\n        }\n        rc = outputLoc;\n        ${l[s-2]} += 1;\n        if(${l[s-2]} < ${this.outputShape[s-2]}) {\n          ${f}\n          result[2] = getChannel(getX(${u.join()}), ${d});\n          ${l[s-1]} += 1;\n          if(${c}) {\n            ${f}\n            result[3] = getChannel(getX(${u.join()}), ${d});\n          }\n        }\n      `}this.userCode=`\n      const ${o} start = ${o}(${i});\n      const ${o} end = ${o}(${a});\n\n      void main() {\n        ${o} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${p}\n        setOutput(result);\n      }\n    `}}const e_e={kernelName:yy,backendName:"webgl",kernelFunc:({inputs:t,backend:n,attrs:e})=>{const{x:r}=t,{paddings:s,mode:o}=e,i=pe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Jwe(r.shape,s,o):new Qwe(r.shape,s,o);return n.runWebGLProgram(i,[r],r.dtype)}},r_e=jr({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  "+gu+"\n  return result;\n"}),s_e={kernelName:up,backendName:"webgl",kernelFunc:r_e};class o_e{constructor(n,e,r){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[n,r],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${e-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${e-1}));\n      }\n    `}}const UB=jr({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),i_e={kernelName:qh,backendName:"webgl",kernelFunc:UB},WB="return a - b;",GB=jr({opSnippet:WB,packedOpSnippet:WB,supportsComplex:!0,cpuKernelImpl:Pye}),a_e={kernelName:Ip,backendName:"webgl",kernelFunc:GB};function HB(t){const{inputs:n,backend:e,attrs:r}=t,{logits:s}=n,{dim:o}=r,i=Jt([o],s.shape),a=zB({inputs:{x:s},backend:e,attrs:{reductionIndices:i,keepDims:!1}}),l=pr(a.shape,i),u=tt({inputs:{x:a},backend:e,attrs:{shape:l}}),c=GB({inputs:{a:s,b:u},backend:e}),d=PB({inputs:{x:c},backend:e}),h=yb({inputs:{x:d},backend:e,attrs:{axis:i,keepDims:!1}}),p=tt({inputs:{x:h},backend:e,attrs:{shape:l}}),f=UB({inputs:{a:d,b:p},backend:e});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(p),f}const l_e={kernelName:Py,backendName:"webgl",kernelFunc:HB},c_e={kernelName:VO,backendName:"webgl",kernelFunc:function u_e(t){const{inputs:n,backend:e,attrs:r}=t,{logits:s}=n,{numSamples:o,seed:i,normalized:a}=r,l=a?s:HB({inputs:{logits:s},backend:e,attrs:{dim:s.shape.length-1}}),d=new o_e(l.shape[0],l.shape[1],o),p=e.runWebGLProgram(d,[l],"int32",[[i]]);return a||e.disposeIntermediateTensorInfo(l),p}},d_e=go+"\n  return -x;\n",f_e={kernelName:vy,backendName:"webgl",kernelFunc:function p_e(t){const{inputs:n,backend:e}=t,{x:r}=n;if(e.shouldExecuteOnCPU([r])){const o=e.texData.get(r.dataId),[i,a]=gye(o.values,r.shape,r.dtype);return e.makeTensorInfo(a,r.dtype,i)}let s;return s=pe().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new cl(r.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new zi(r.shape,d_e),e.runWebGLProgram(s,[r],r.dtype)}},m_e=H1,y_e={kernelName:yC,backendName:"webgl",kernelFunc:function g_e(t){lo("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:n,backend:e,attrs:r}=t,{boxes:s,scores:o}=n,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l}=r,u=e.readSync(s.dataId),c=e.readSync(o.dataId),{selectedIndices:d}=m_e(u,c,i,a,l);return e.makeTensorInfo([d.length],"int32",new Int32Array(d))}},v_e=j1,x_e={kernelName:vC,backendName:"webgl",kernelFunc:function b_e(t){lo("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:n,backend:e,attrs:r}=t,{boxes:s,scores:o}=n,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:u}=r,c=e.readSync(s.dataId),d=e.readSync(o.dataId),{selectedIndices:h,validOutputs:p}=v_e(c,d,i,a,l,u);return[e.makeTensorInfo([h.length],"int32",new Int32Array(h)),e.makeTensorInfo([],"int32",new Int32Array([p]))]}},w_e=q1,C_e={kernelName:bC,backendName:"webgl",kernelFunc:function __e(t){lo("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:n,backend:e,attrs:r}=t,{boxes:s,scores:o}=n,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l,softNmsSigma:u}=r,c=e.readSync(s.dataId),d=e.readSync(o.dataId),h=i,p=a,f=l,g=u,{selectedIndices:m,selectedScores:y}=w_e(c,d,h,p,f,g);return[e.makeTensorInfo([m.length],"int32",new Int32Array(m)),e.makeTensorInfo([y.length],"float32",new Float32Array(y))]}};class S_e{constructor(n,e,r,s){this.variableNames=["indices"],this.outputShape=[n,e],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${s}), float(${r}),\n                      float(index == coords.y)));\n      }\n    `}}const I_e={kernelName:wy,backendName:"webgl",kernelFunc:t=>{const{inputs:n,backend:e,attrs:r}=t,{indices:s}=n,{dtype:o,depth:i,onValue:a,offValue:l}=r,u=_e(s.shape),c=new S_e(u,i,a,l),d=tt({inputs:{x:s},backend:e,attrs:{shape:[u]}}),h=e.runWebGLProgram(c,[d],o);e.disposeIntermediateTensorInfo(d);const f=tt({inputs:{x:h},backend:e,attrs:{shape:[...s.shape,i]}});return e.disposeIntermediateTensorInfo(h),f}};function Cb(t){const{inputs:n,backend:e}=t,{x:r}=n;if("complex64"===r.dtype){const s=Cf({inputs:{input:r},backend:e}),o=Cb({inputs:{x:s},backend:e}),i=wb({inputs:{input:r},backend:e}),a=Cb({inputs:{x:i},backend:e}),l=dl({inputs:{real:o,imag:a},backend:e});return e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),l}return If({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:e})}const D_e={kernelName:Vy,backendName:"webgl",kernelFunc:Cb},T_e={kernelName:xy,backendName:"webgl",kernelFunc:function jB(t){const{inputs:n,backend:e}=t,{x:r}=n;if("string"===r.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===r.dtype){const s=Cf({inputs:{input:r},backend:e}),o=jB({inputs:{x:s},backend:e}),i=wb({inputs:{input:r},backend:e}),a=Cb({inputs:{x:i},backend:e}),l=dl({inputs:{real:o,imag:a},backend:e});return e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),l}return If({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:e})}},E_e={kernelName:_y,backendName:"webgl",kernelFunc:function k_e(t){const{inputs:n,backend:e,attrs:r}=t,{axis:s}=r;if(1===n.length)return qI({inputs:{input:n[0]},backend:e,attrs:{dim:s}});const o=n[0].shape,i=n[0].dtype;n.forEach(c=>{No(o,c.shape,"All tensors passed to stack must have matching shapes"),R(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],u=SB({inputs:n.map(c=>{const d=qI({inputs:{input:c},backend:e,attrs:{dim:s}});return a.push(d),d}),backend:e,attrs:{axis:s}});return a.forEach(c=>e.disposeIntermediateTensorInfo(c)),u}};class N_e{constructor(n,e,r){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((u,c)=>u[0]+n[c]+u[1]);const s=n.length,o=kn(s),i=e.map(u=>u[0]).join(","),a=e.map((u,c)=>u[0]+n[c]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s);this.userCode=1!==s?`\n      ${o} start = ${o}(${i});\n      ${o} end = ${o}(${a});\n\n      void main() {\n        ${o} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${o} coords = outC - start;\n          setOutput(getX(${l}));\n        }\n      }\n    `:`\n        int start = ${i};\n        int end = ${a};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}}class A_e{constructor(n,e,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((g,m)=>g[0]+n[m]+g[1]);const s=n.length,o=kn(s),i=e.map(g=>g[0]).join(","),a=e.map((g,m)=>g[0]+n[m]).join(","),l=xs("rc",s),u=xs("source",s),c=`${l[s-1]} < ${this.outputShape[s-1]}`,d=1===s?"source":`vec2(${u.slice(-2).join()})`,h=[`${o} rc = outputLoc;`,`${l[s-1]} += 1;\n       if(${c}) {\n      `,1===s?"":`}\n       rc = outputLoc;\n       ${l[s-2]} += 1;\n       if(${l[s-2]} < ${this.outputShape[s-2]}) {`,1===s?"":`  ${l[s-1]} += 1;\n         if(${c}) {`],p=1===s?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let f="";for(let g=0,m=1===s?2:4;g<m;g++)f+=`\n        ${h[g]}\n        if (${p}) {\n          result[${g}] = float(value);\n        } else {\n          ${o} source = rc - start;\n          result[${g}] = getChannel(getX(${u.join()}), ${d});\n        }\n      `;f+=1===s?"} ":"}}",this.userCode=`\n      const ${o} start = ${o}(${i});\n      const ${o} end = ${o}(${a});\n\n      void main() {\n        ${o} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${f}\n        setOutput(result);\n      }\n    `}}const qB=t=>{const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{paddings:o,constantValue:i}=r;if(0===_e(s.shape))return If({backend:e,attrs:{shape:o.map((c,d)=>c[0]+s.shape[d]+c[1]),value:i,dtype:s.dtype}});const a=pe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new A_e(s.shape,o,i):new N_e(s.shape,o,i);return e.runWebGLProgram(a,[s],s.dtype,[[i]])},R_e={kernelName:Cy,backendName:"webgl",kernelFunc:qB},P_e=jr({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  "+gu+"\n  return result;\n"}),M_e={kernelName:dp,backendName:"webgl",kernelFunc:P_e},L_e={kernelName:Iy,backendName:"webgl",kernelFunc:function $_e(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o,keepDims:i}=r,a=s.shape.length,l=[],u=Jt(o,s.shape);let c=u;const d=Qn(c,a);let p,h=s;if(null!=d&&(h=ws({inputs:{x:s},backend:e,attrs:{perm:d}}),c=fr(c.length,a),l.push(h)),Hr("prod",c,a),e.shouldExecuteOnCPU([h])){const f=e.texData.get(h.dataId).values,{outVals:g,outShape:m,outDtype:y}=vye(h.shape,h.dtype,f,c);p=e.makeTensorInfo(m,y,g)}else{const[f,g]=$r(h.shape,c),m=_e(g),y=tt({inputs:{x:h},backend:e,attrs:{shape:[-1,m]}}),b=yu(y,GC(s.dtype),"prod",e);p=tt({inputs:{x:b},backend:e,attrs:{shape:f}}),l.push(y),l.push(b)}if(i){l.push(p);const f=pr(p.shape,u);p=tt({inputs:{x:p},backend:e,attrs:{shape:f}})}return l.forEach(f=>e.disposeIntermediateTensorInfo(f)),p}},B_e={kernelName:BO,backendName:"webgl",kernelFunc:function V_e(t){const{inputs:n,backend:e,attrs:r}=t,{paramsNestedSplits:s,paramsDenseValues:o,indices:i}=n,{outputRaggedRank:a}=r,l=s.map(y=>e.readSync(y.dataId)),u=s.map(y=>y.shape),c=e.readSync(o.dataId),d=e.readSync(i.dataId),[h,p,f]=bye(l,u,c,o.shape,o.dtype,d,i.shape,a),g=h.map(y=>e.makeTensorInfo([y.length],"int32",y)),m=e.makeTensorInfo(f,o.dtype,p);return g.concat([m])}},U_e={kernelName:zO,backendName:"webgl",kernelFunc:function z_e(t){const{inputs:n,backend:e}=t,{starts:r,limits:s,deltas:o}=n,i=e.readSync(r.dataId),a=e.readSync(s.dataId),l=e.readSync(o.dataId),[u,c]=xye(i,r.shape,r.dtype,a,s.shape,l,o.shape);return[e.makeTensorInfo([u.length],"int32",u),e.makeTensorInfo([c.length],r.dtype,c)]}},G_e={kernelName:UO,backendName:"webgl",kernelFunc:function W_e(t){const{inputs:n,backend:e,attrs:r}=t,{shape:s,values:o,defaultValue:i,rowPartitionTensors:a}=n,{rowPartitionTypes:l}=r,u=e.readSync(s.dataId),c=e.readSync(o.dataId),d=e.readSync(i.dataId),h=a.map(m=>e.readSync(m.dataId)),p=a.map(m=>m.shape),[f,g]=wye(u,s.shape,c,o.shape,o.dtype,d,i.shape,h,p,l);return e.makeTensorInfo(f,o.dtype,g)}},KB=t=>{const{backend:n,attrs:e}=t,{start:r,stop:s,step:o,dtype:i}=e,a=_ye(r,s,o,i);return n.makeTensorInfo([a.length],i,a)},H_e={kernelName:xC,backendName:"webgl",kernelFunc:KB},j_e=pn({opSnippet:"return 1.0 / x;"}),q_e={kernelName:hp,backendName:"webgl",kernelFunc:j_e},X_e=pn({opSnippet:go+"\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),Y_e={kernelName:pp,backendName:"webgl",kernelFunc:X_e},Q_e=pn({opSnippet:go+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),J_e={kernelName:fp,backendName:"webgl",kernelFunc:Q_e};class eCe{constructor(n,e,r,s,o){this.variableNames=["A"],this.outputShape=[];const[i,a,l,u]=n;this.outputShape=[i,e,r,u];const c=[s&&e>1?a-1:a,s&&r>1?l-1:l],d=[s&&e>1?e-1:e,s&&r>1?r-1:r];let h;h=o?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${c[0]/d[0]},\n          ${c[1]/d[1]});\n      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}class tCe{constructor(n,e,r,s,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[i,a,l,u]=n;this.outputShape=[i,e,r,u];const c=[s&&e>1?a-1:a,s&&r>1?l-1:l],d=[s&&e>1?e-1:e,s&&r>1?r-1:r];let h;h=o?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${c[0]/d[0]},\n          ${c[1]/d[1]},\n          ${c[1]/d[1]});\n      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,\n                                     ${l}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${u-1};\n        bool hasNextRow = coords.z < ${r-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}const rCe={kernelName:ky,backendName:"webgl",kernelFunc:function nCe(t){const{inputs:n,backend:e,attrs:r}=t,{images:s}=n,{alignCorners:o,halfPixelCenters:i,size:a}=r,[l,u]=a,c=pe().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new tCe(s.shape,l,u,o,i):new eCe(s.shape,l,u,o,i);return e.runWebGLProgram(c,[s],"float32")}};class sCe{constructor(n,e,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,s,o]=e,[,i,a]=n,l=[r&&i>1?s-1:s,r&&a>1?o-1:o],u=[r&&i>1?i-1:i,r&&a>1?a-1:a],c=l[0]/u[0],d=l[1]/u[1],h=1/c,p=1/d,f=2*Math.ceil(h)+2,g=2*Math.ceil(p)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${c});\n        const float widthScale = float(${d});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${p});\n\n        const int winHeight = int(${f});\n        const int winWidth = int(${g});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${i}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${a}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${s-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${o-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const iCe={kernelName:CC,backendName:"webgl",kernelFunc:function oCe(t){const{inputs:n,backend:e,attrs:r}=t,{images:s,dy:o}=n,{alignCorners:i}=r,a=new sCe(o.shape,s.shape,i);return e.runWebGLProgram(a,[o],o.dtype)}};class aCe{constructor(n,e,r,s,o){this.variableNames=["A"],this.outputShape=[];const[i,a,l,u]=n;this.outputShape=[i,e,r,u];const c=[s&&e>1?a-1:a,s&&r>1?l-1:l],d=[s&&e>1?e-1:e,s&&r>1?r-1:r];let p;p=o?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${c[0]/d[0]},\n          ${c[1]/d[1]});\n      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${p};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${s?"0.5":"0.0"})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}class lCe{constructor(n,e,r,s,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[i,a,l,u]=n;this.outputShape=[i,e,r,u];const c=[s&&e>1?a-1:a,s&&r>1?l-1:l],d=[s&&e>1?e-1:e,s&&r>1?r-1:r];let p;p=o?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${c[0]/d[0]},\n          ${c[1]/d[1]},\n          ${c[1]/d[1]});\n      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,\n                                     ${l}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${p};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${s?"0.5":"0.0"})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${u-1};\n        bool hasNextRow = coords.z < ${r-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}}const cCe={kernelName:Ty,backendName:"webgl",kernelFunc:function uCe(t){const{inputs:n,backend:e,attrs:r}=t,{images:s}=n,{alignCorners:o,halfPixelCenters:i,size:a}=r,[l,u]=a,c=pe().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new lCe(s.shape,l,u,o,i):new aCe(s.shape,l,u,o,i);return e.runWebGLProgram(c,[s],s.dtype)}};class dCe{constructor(n,e,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,s,o]=e,[,i,a]=n,l=[r&&i>1?s-1:s,r&&a>1?o-1:o],u=[r&&i>1?i-1:i,r&&a>1?a-1:a],c=l[0]/u[0],d=l[1]/u[1],h=1/c,p=1/d,f=2*Math.ceil(h)+2,g=2*Math.ceil(p)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${c});\n        const float widthScale = float(${d});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${p});\n\n        const int winHeight = int(${f});\n        const int winWidth = int(${g});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${i}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${a}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${l[0]}) *\n                (float(dyR) / float(${u[0]}));\n\n            float sourceFracCol =\n                float(${l[1]}) *\n                  (float(dyC) / float(${u[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${s}) - 1),\n                ${r} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${o}) - 1),\n                ${r} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const pCe={kernelName:_C,backendName:"webgl",kernelFunc:function hCe(t){const{inputs:n,backend:e,attrs:r}=t,{images:s,dy:o}=n,{alignCorners:i}=r,a=new dCe(o.shape,s.shape,i);return e.runWebGLProgram(a,[o],o.dtype)}};class fCe{constructor(n,e){this.variableNames=["x"];const r=n.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);if(this.outputShape=n,1===r)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${n[0]} - coord - 1));\n        }\n      `);const o=n.map((a,l)=>(a=>-1!==e.indexOf(a)&&1!==n[a]?`${n[a]} - coords[${a}] - 1`:`coords[${a}]`)(l)).join(","),i=kn(r);this.userCode=`\n      void main() {\n        ${i} coords = getOutputCoords();\n        setOutput(getX(${o}));\n      }\n    `}}class mCe{constructor(n,e){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const r=n.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);this.outputShape=n;const s=xs("rc",r),o=`${s[r-1]} + 1 < ${this.outputShape[r-1]}`,i=`${s[r-2]} + 1 < ${this.outputShape[r-2]}`,a=kn(r);function h(f){const g=n.map((v,b)=>function p(f,g){return-1!==e.indexOf(f)&&1!==n[f]?`${n[f]} - ${g[f]} - 1`:`${g[f]}`}(b,f));return`getChannel(getX(${g.join(",")}), vec2(${g.slice(-2).join(",")}))`}this.userCode=1===r?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${n[0]} - rc - 1),\n            ${n[0]} - rc - 1);\n          if(${o}){\n              result.g = getChannel(getX(${n[0]} - (rc  + 1) - 1),\n                ${n[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${a} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function l(f){return h(f)}(s.slice())};\n          if(${o}){\n            result.g = ${function u(f){return f[r-1]="("+f[r-1]+" + 1)",h(f)}(s.slice())};\n          }\n          if(${i}) {\n            result.b = ${function c(f){return f[r-2]="("+f[r-2]+" + 1)",h(f)}(s.slice())};\n            if(${o}) {\n              result.a = ${function d(f){return f[r-1]="("+f[r-1]+" + 1)",f[r-2]="("+f[r-2]+" + 1)",h(f)}(s.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}const yCe={kernelName:Ey,backendName:"webgl",kernelFunc:function gCe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{dims:o}=r,i=s.shape.length,a=Jt(o,s.shape);if(0===i)return Ks({inputs:{x:s},backend:e});const l=pe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new mCe(s.shape,a):new fCe(s.shape,a);return e.runWebGLProgram(l,[s],s.dtype)}};class vCe{constructor(n,e){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const r=n[1],s=n[2];this.outputShape=n;let o="";o="number"==typeof e?`float outputValue = ${e.toFixed(2)};`:`\n        vec3 fill = vec3(${e.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${o}\n          if(coordX >= 0 && coordX < ${s} && coordY >= 0 && coordY < ${r}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const bCe={kernelName:$C,backendName:"webgl",kernelFunc:({inputs:t,attrs:n,backend:e})=>{const{image:r}=t,{radians:s,fillValue:o,center:i}=n,a=e,l=new vCe(r.shape,o),[u,c]=eS(i,r.shape[1],r.shape[2]),d=[[u,c,Math.sin(s),Math.cos(s)]];return a.runWebGLProgram(l,[r],r.dtype,d)}},xCe=pn({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),wCe={kernelName:mp,backendName:"webgl",kernelFunc:xCe},_Ce=pn({opSnippet:"return inversesqrt(x);",cpuKernelImpl:Cye}),CCe={kernelName:gp,backendName:"webgl",kernelFunc:_Ce};class XI{constructor(n,e,r,s,o,i,a=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=i;const u=kn(o.length),c=kn(i.length);let d="";1===r?d="i":2===r&&(d="i, j");let p="";1===s?p="i":2===s&&(p="i, coords[1]");let g="";l&&(g="coords[0], coords[1]"),this.userCode=`\n        ${u} strides = ${u}(${o});\n\n        void main() {\n          ${c} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${n}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${e}; j++) {\n              int index = round(getIndices(${d}));\n              flattenedIndex += index * ${e>1?"strides[j]":"strides"};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += getUpdates(${p});\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(${g}), sum, float(found)));\n        }\n      `}}class SCe{constructor(n,e,r,s,o,i,a=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=i;const u=kn(o.length),c=kn(i.length);let d="";1===r?d="i":2===r&&(d="i, j");let p="";1===s?p="i":2===s&&(p="i, coords[1]");let g="";l&&(g="coords[0], coords[1]"),this.userCode=`\n        ${u} strides = ${u}(${o});\n\n        void main() {\n          ${c} coords = getOutputCoords();\n          vec4 sum = vec4(0.);\n          vec4 found = vec4(0.);\n          for (int i = 0; i < ${n}; i+=2) {\n            ivec2 flattenedIndex = ivec2(0);\n            for (int j = 0; j < ${e}; j+=2) {\n              ivec4 index = round(getIndices(${d}));\n              flattenedIndex += index.xz * ${e>1?"strides[j]":"strides"};\n              if (j + 1 < ${e}) {\n                flattenedIndex += index.yw * ${e>1?"strides[j + 1]":"strides"};\n              }\n            }\n            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||\n                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {\n              vec4 updVals = getUpdates(${p});\n              if (flattenedIndex[0] == coords[0]) {\n                sum.xy += updVals.xy;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[0] == coords[0] + 1) {\n                sum.zw += updVals.xy;\n                found.zw = vec2(1.);\n              }\n              if (flattenedIndex[1] == coords[0]) {\n                sum.xy += updVals.zw;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[1] == coords[0] + 1) {\n                sum.zw += updVals.zw;\n                found.zw = vec2(1.);\n              }\n            }\n          }\n          setOutput(mix(getDefaultValue(${g}), sum, found));\n        }\n      `}}const DCe={kernelName:WO,backendName:"webgl",kernelFunc:function ICe(t){const{inputs:n,backend:e,attrs:r}=t,{indices:s,updates:o}=n,{shape:i}=r,{sliceRank:a,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=ru(0,s,i),h=[d/u,u];if(0===d)return e.makeTensorInfo(i,s.dtype);const p=tt({inputs:{x:s},backend:e,attrs:{shape:[l,a]}}),f=tt({inputs:{x:o},backend:e,attrs:{shape:[l,u]}}),g=e.makeTensorInfo([],"float32",new Float32Array([0]));let m;m=pe().getBool("WEBGL_PACK")?new SCe(l,a,p.shape.length,f.shape.length,c,h):new XI(l,a,p.shape.length,f.shape.length,c,h);const y=e.runWebGLProgram(m,[f,p,g],f.dtype),v=tt({inputs:{x:y},backend:e,attrs:{shape:i}});return e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(g),v}};class TCe{constructor(n,e,r,s){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[n,r];const i=`for (int i = 0; i < ${Math.ceil(Math.log2(e+1))}; ++i) { if (left >= right) break;`,a=2===pe().getNumber("WEBGL_VERSION")?"while (left < right) {":i;this.userCode=`\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ${a}\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ${"left"===s?"<":"<="} value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     `}}const ECe={kernelName:HO,backendName:"webgl",kernelFunc:function kCe(t){const{inputs:n,backend:e,attrs:r}=t,{sortedSequence:s,values:o}=n,{side:i}=r,a=new TCe(s.shape[0],s.shape[1],o.shape[1],i);return e.runWebGLProgram(a,[s,o],"int32",[[s.shape[1]]])}};class NCe{constructor(n,e,r){let s,o;if(this.variableNames=["c","a","b"],this.outputShape=e,r>4)throw Error(`Where for rank ${r} is not yet supported`);if(1===r)o="resRC",s="resRC";else{const a=["resRC.x","resRC.y","resRC.z","resRC.w"],l=[],u=[];for(let c=0;c<e.length;c++)u.push(`${a[c]}`),c<n&&l.push(`${a[c]}`);s=l.join(),o=u.join()}const i=kn(r);this.userCode=`\n      void main() {\n        ${i} resRC = getOutputCoords();\n        float cVal = getC(${s});\n        if (cVal >= 1.0) {\n          setOutput(getA(${o}));\n        } else {\n          setOutput(getB(${o}));\n        }\n      }\n    `}}const RCe={kernelName:Ny,backendName:"webgl",kernelFunc:function ACe(t){const{inputs:n,backend:e}=t,{condition:r,t:s,e:o}=n,i=new NCe(r.shape.length,s.shape,s.shape.length);return e.runWebGLProgram(i,[r,s,o],Ws(s.dtype,o.dtype))}},OCe=pn({opSnippet:`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${xv};\n  float scale = ${wv};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`}),PCe={kernelName:yp,backendName:"webgl",kernelFunc:OCe},$Ce=pn({opSnippet:ad+"\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:Iye}),LCe={kernelName:wp,backendName:"webgl",kernelFunc:$Ce},VCe=pn({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),BCe={kernelName:xp,backendName:"webgl",kernelFunc:VCe},WCe=pn({opSnippet:ad+"\n  return sin(x);\n",packedOpSnippet:`\n  vec4 result = sin(x);\n  bvec4 isNaN = isnan(x);\n  ${gu}\n  return result;\n`}),GCe={kernelName:vp,backendName:"webgl",kernelFunc:WCe},HCe=pn({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),jCe={kernelName:bp,backendName:"webgl",kernelFunc:HCe},qCe=pn({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),KCe={kernelName:_p,backendName:"webgl",kernelFunc:qCe},XCe={kernelName:Fy,backendName:"webgl",kernelFunc:t=>{const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{blockShape:o,paddings:i}=r;R(s.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const a=o.reduce((y,v)=>y*v),l=[[0,0]];l.push(...i);for(let y=1+o.length;y<s.shape.length;++y)l.push([0,0]);const u=[],c=qB({inputs:{x:s},backend:e,attrs:{paddings:l,constantValue:0}}),d=Kp(c.shape,o,a,!1),h=Xp(d.length,o.length,!1),p=Yp(c.shape,o,a,!1),f=tt({inputs:{x:c},backend:e,attrs:{shape:d}}),g=ws({inputs:{x:f},backend:e,attrs:{perm:h}}),m=tt({inputs:{x:g},backend:e,attrs:{shape:p}});return u.push(c),u.push(f),u.push(g),u.forEach(y=>e.disposeIntermediateTensorInfo(y)),m}},ZCe={kernelName:SC,backendName:"webgl",kernelFunc:function YCe(t){const{inputs:n,backend:e}=t,{indices:r,values:s,denseShape:o,defaultValue:i}=n;if(1!==o.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${o.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${r.shape}`);if(1!==s.shape.length)throw new Error(`Values must be a vector, saw:\n         ${s.shape}`);if(0!==i.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`);const a=e.readSync(r.dataId),l=e.readSync(s.dataId),u=e.readSync(o.dataId),c=e.readSync(i.dataId)[0],[d,h,p,f,g]=Tye(a,r.shape,r.dtype,l,s.dtype,u,c);return[e.makeTensorInfo(h,r.dtype,d),e.makeTensorInfo([h[0]],s.dtype,p),e.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(m=>Number(m)))),e.makeTensorInfo([g.length],r.dtype,new Int32Array(g))]}},JCe={kernelName:IC,backendName:"webgl",kernelFunc:function QCe(t){const{inputs:n,backend:e}=t,{inputIndices:r,inputShape:s,newShape:o}=n;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(1!==s.shape.length)throw new Error(`Input shape should be a vector but received shape ${s.shape}`);if(1!==o.shape.length)throw new Error(`Target shape should be a vector but received shape ${o.shape}`);const i=Array.from(e.readSync(s.dataId)),a=e.readSync(r.dataId),l=Array.from(e.readSync(o.dataId)),[u,c,d]=kye(a,r.shape,r.dtype,i,l);return[e.makeTensorInfo(c,r.dtype,u),e.makeTensorInfo([d.length],o.dtype,new Int32Array(d))]}},t1e={kernelName:DC,backendName:"webgl",kernelFunc:function e1e(t){const{inputs:n,backend:e}=t,{data:r,indices:s,segmentIds:o}=n;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n              ${s.shape}`);if(1!==o.shape.length)throw new Error(`Segment ids should be a vector but received shape\n              ${o.shape}`);const i=e.readSync(r.dataId),a=e.readSync(s.dataId),l=e.readSync(o.dataId),[u,c]=J3(i,r.shape,r.dtype,a,l,!0);return e.makeTensorInfo(c,r.dtype,u)}},r1e={kernelName:TC,backendName:"webgl",kernelFunc:function n1e(t){const{inputs:n,backend:e}=t,{data:r,indices:s,segmentIds:o}=n;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n             ${s.shape}`);if(1!==o.shape.length)throw new Error(`Segment ids should be a vector but received shape\n             ${o.shape}`);const i=e.readSync(r.dataId),a=e.readSync(s.dataId),l=e.readSync(o.dataId),[u,c]=J3(i,r.shape,r.dtype,a,l);return e.makeTensorInfo(c,r.dtype,u)}},o1e={kernelName:jO,backendName:"webgl",kernelFunc:function s1e(t){const{inputs:n,backend:e,attrs:r}=t,{sparseIndices:s,sparseValues:o,defaultValue:i}=n,{outputShape:a}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:d,outputSize:h}=ru(0,s,a);if("string"===o.dtype){const y=e.bufferSync(s),v=e.bufferSync(o),b=Ua(e.readSync(i.dataId)[0]),x=Sye(y,v,a,h,c,u,l,d,b,!1);return e.makeTensorInfo(a,x.dtype,x.values)}const f=new XI(u,l,s.shape.length,o.shape.length,d,[h,1],!1),g=e.runWebGLProgram(f,[o,s,i],o.dtype),m=tt({inputs:{x:g},backend:e,attrs:{shape:a}});return e.disposeIntermediateTensorInfo(g),m}},a1e={kernelName:Oy,backendName:"webgl",kernelFunc:function i1e(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{numOrSizeSplits:o,axis:i}=r,a=Jt(i,s.shape)[0],l=yS(s,o,a),c=new Array(s.shape.length).fill(0),d=s.shape.slice();return l.map(h=>{const p=[...d];p[a]=h;const f=ld({inputs:{x:s},backend:e,attrs:{begin:c,size:p}});return c[a]+=h,f})}},XB="return sqrt(x);",l1e=pn({opSnippet:XB,packedOpSnippet:XB,cpuKernelImpl:Eye}),u1e={kernelName:Cp,backendName:"webgl",kernelFunc:l1e},d1e={kernelName:kC,backendName:"webgl",kernelFunc:pn({opSnippet:"return x * x;"})},YB="return (a - b) * (a - b);",h1e=jr({opSnippet:YB,packedOpSnippet:YB}),p1e={kernelName:Sp,backendName:"webgl",kernelFunc:h1e},m1e={kernelName:My,backendName:"webgl",kernelFunc:function f1e(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n;if("string"!==s.dtype)throw new Error("Input must be of datatype string");const i=ga(e.readSync(s.dataId)),a=Nye(i,"string",r);return e.makeTensorInfo(s.shape,"string",a)}},y1e={kernelName:Ep,backendName:"webgl",kernelFunc:function g1e({inputs:t,attrs:n,backend:e}){const{x:r}=t,o=new zi(r.shape,go+`\n    return x > 0.0 ? 1.0 : float(${n.alpha});\n  `);return e.runWebGLProgram(o,[r],r.dtype)}};class v1e{constructor(n,e,r){this.variableNames=["x"],this.outputShape=r;const s=r.length,o=kn(r.length),i=kn(r.length);let a="";if(1===s)a="coords * strides + begin";else{let l=0;a=r.map((u,c)=>(l++,1===r.length?`coords * strides[${c}] + begin[${c}]`:`coords[${l-1}] * strides[${c}] + begin[${c}]`)).join(",")}this.userCode=`\n      ${o} begin = ${o}(${n});\n      ${o} strides = ${o}(${e});\n\n      void main() {\n        ${i} coords = getOutputCoords();\n        setOutput(getX(${a}));\n      }\n    `}}const x1e={kernelName:EC,backendName:"webgl",kernelFunc:function b1e(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{begin:o,end:i,strides:a,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:h}=r,{finalShapeSparse:p,finalShape:f,isIdentity:g,sliceDim0:m,isSimpleSlice:y,begin:v,end:b,strides:x}=x1(s.shape,o,i,a,l,u,c,d,h);let w;if(g)w=tt({inputs:{x:s},backend:e,attrs:{shape:f}});else if(m||y){R(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);const V=y1(v,b,x),z=ld({inputs:{x:s},backend:e,attrs:{begin:v,size:V}});w=tt({inputs:{x:z},backend:e,attrs:{shape:f}}),e.disposeIntermediateTensorInfo(z)}else if(e.shouldExecuteOnCPU([s])){const z=e.readSync(s.dataId),K=en(s.shape,s.dtype,z),Y=Aye(p,K,x,v);w=e.makeTensorInfo(f,s.dtype,Y.values)}else{const z=new v1e(v,x,p);w=e.runWebGLProgram(z,[s],s.dtype)}const k=tt({inputs:{x:w},backend:e,attrs:{shape:f}});return e.disposeIntermediateTensorInfo(w),k}},_1e={kernelName:NC,backendName:"webgl",kernelFunc:function w1e(t){const{inputs:n,backend:e,attrs:r}=t,{separator:s,nGramWidths:o,leftPad:i,rightPad:a,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:d}=n,h=e.readSync(c.dataId),p=e.readSync(d.dataId),[f,g]=Rye(h,p,s,o,i,a,l,u);return[e.makeTensorInfo([f.length],"string",f),e.makeTensorInfo(d.shape,"int32",g)]}},S1e={kernelName:AC,backendName:"webgl",kernelFunc:function C1e(t){const{inputs:n,backend:e,attrs:r}=t,{skipEmpty:s}=r,{input:o,delimiter:i}=n;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(1!==o.shape.length)throw new Error(`Input must be a vector, got shape: ${o.shape}`);if(0!==i.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const a=e.readSync(o.dataId),l=e.readSync(i.dataId)[0],[u,c,d]=Fye(a,l,s),h=c.length;return[e.makeTensorInfo([h,2],"int32",u),e.makeTensorInfo([h],"string",c),e.makeTensorInfo([2],"int32",new Int32Array(d))]}},D1e={kernelName:RC,backendName:"webgl",kernelFunc:function I1e(t){const{inputs:n,backend:e,attrs:r}=t,{numBuckets:s}=r,{input:o}=n;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const i=e.readSync(o.dataId),a=Oye(i,s);return e.makeTensorInfo(o.shape,"int32",a)}},T1e=pn({opSnippet:"return tan(x);"}),k1e={kernelName:Dp,backendName:"webgl",kernelFunc:T1e},E1e=pn({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),N1e={kernelName:Tp,backendName:"webgl",kernelFunc:E1e},R1e={kernelName:GO,backendName:"webgl",kernelFunc:function A1e(t){const{inputs:n,backend:e}=t,{tensor:s,indices:o,updates:i}=n,{sliceRank:a,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=ru(0,o,s.shape),h=[d/u,u];if(0===d)return e.makeTensorInfo(s.shape,o.dtype);const p=tt({inputs:{x:o},backend:e,attrs:{shape:[l,a]}}),f=tt({inputs:{x:i},backend:e,attrs:{shape:[l,u]}}),g=tt({inputs:{x:s},backend:e,attrs:{shape:h}}),m=new XI(l,a,p.shape.length,f.shape.length,c,h,!1,!0),y=e.runWebGLProgram(m,[f,p,g],g.dtype),v=tt({inputs:{x:y},backend:e,attrs:{shape:s.shape}});return e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(y),v}};class F1e{constructor(n,e){this.variableNames=["A"];const r=new Array(n.length);for(let i=0;i<r.length;i++)r[i]=n[i]*e[i];this.outputShape=r,this.rank=r.length;const s=kn(this.rank),o=function O1e(t){const n=t.length;if(n>5)throw Error(`Tile for rank ${n} is not yet supported`);if(1===n)return`imod(resRC, ${t[0]})`;const e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let s=0;s<t.length;s++)r.push(`imod(${e[s]}, ${t[s]})`);return r.join()}(n);this.userCode=`\n      void main() {\n        ${s} resRC = getOutputCoords();\n        setOutput(getA(${o}));\n      }\n    `}}function ZB(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{reps:o}=r;if("string"===s.dtype||s.shape.length>5){const l=e.readSync(s.dataId),u="string"===s.dtype?l.map(h=>Ua(h)):l,c=en(s.shape,s.dtype,u),d=Mye(c,o);return e.makeTensorInfo(d.shape,d.dtype,d.values)}const i=new F1e(s.shape,o);return e.runWebGLProgram(i,[s],s.dtype)}const P1e={kernelName:kp,backendName:"webgl",kernelFunc:ZB};class M1e{constructor(n){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=n,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}class $1e{constructor(n){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=n,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}}function vu(t,n){null!==n&&t.disposeIntermediateTensorInfo(n)}function QB(t){let n=1;for(;n<t;)n*=2;return n}const V1e={kernelName:FC,backendName:"webgl",kernelFunc:function L1e(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{k:o,sorted:i}=r,a=pe().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=pe().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),u=s.shape,c=u[u.length-1];if(e.shouldExecuteOnCPU([s])||c<a||o>l){const Y=e.readSync(s.dataId),[se,fe]=$ye(Y,u,s.dtype,o,i);return[e.makeTensorInfo(se.shape,se.dtype,se.values),e.makeTensorInfo(fe.shape,fe.dtype,fe.values)]}if(0===o)return u[u.length-1]=0,[e.makeTensorInfo(u,s.dtype,[]),e.makeTensorInfo(u,"int32",[])];if(1===c)return[s,If({attrs:{shape:u,dtype:"int32",value:0},backend:e})];const d=e.texData.get(s.dataId),h=null!==d&&d.isPacked,p=h?e.unpackTensor(s):s,g=_e(u)/c,m=tt({inputs:{x:p},attrs:{shape:[g,c]},backend:e});h&&vu(e,p);const y=QB(o),v=QB(c);let b=null;const x=()=>null===b?[m,m]:[m,b],w=(Y,se,fe)=>{const ve=x(),be=new M1e(fe),Ne=b;b=e.runWebGLProgram(be,ve,"int32",[[c],[null===b?1:0],[Number.NEGATIVE_INFINITY],[Y],[se]]),vu(e,Ne)};for(let Y=1;Y<y;Y*=2){const se=2*Y;for(let fe=Y;fe>=1;fe/=2)w(se,fe,[g,v])}for(let Y=v;Y>y;Y/=2){const se=x(),fe=new $1e([g,Y/2]),xe=b;b=e.runWebGLProgram(fe,se,"int32",[[c],[null===b?1:0],[y]]),vu(e,xe);const De=y/2,Ne=2*De;for(let we=De;we>=1;we/=2)w(Ne,we,b.shape)}let k=b;b=ld({inputs:{x:b},backend:e,attrs:{begin:0,size:[g,o]}}),vu(e,k);let V=BB({inputs:{x:m,indices:b},backend:e,attrs:{axis:1,batchDims:1}});vu(e,m);const z=u.slice(0,-1);z.push(o),k=b,b=tt({inputs:{x:b},attrs:{shape:z},backend:e}),vu(e,k);const K=V;return V=tt({inputs:{x:V},attrs:{shape:z},backend:e}),vu(e,K),[V,b]}};class B1e{constructor(n,e,r,s,o,i){this.variableNames=["Image","Transforms"],this.outputShape=i;const a="nearest"===r?1:2;let l;switch(s){case"constant":default:l=1;break;case"reflect":l=2;break;case"wrap":l=3;break;case"nearest":l=4}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${l} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${l} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${l} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${n} && 0 <= coordX && coordX < ${e}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${o});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${o});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${e}));\n                float mapY = mapCoord(inY, float(${n}));\n\n                if (${a} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}const U1e={kernelName:OC,backendName:"webgl",kernelFunc:function z1e(t){const{inputs:n,backend:e,attrs:r}=t,{image:s,transforms:o}=n,{interpolation:i,fillMode:a,fillValue:l,outputShape:u}=r,[c,d,h,p]=s.shape,[f,g]=u??[d,h],y=new B1e(d,h,i,a,l,[c,f,g,p]);return e.runWebGLProgram(y,[s,o],"float32")}},G1e={kernelName:PC,backendName:"webgl",kernelFunc:function W1e(t){const{inputs:n,attrs:e,backend:r}=t,{axis:s}=e,{x:o}=n;vf(o,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const i=r.readSync(o.dataId),{outputValues:a,outputShape:l,indices:u}=Lye(i,s,o.shape,o.dtype);return[r.makeTensorInfo(l,o.dtype,a),r.makeTensorInfo([u.length],"int32",u)]}},j1e={kernelName:$y,backendName:"webgl",kernelFunc:function H1e(t){const{inputs:n,backend:e,attrs:r}=t,{value:s}=n;let{axis:o}=r;o<0&&(o+=s.shape.length);const i=s,a=i.shape.length,l=s.shape[o],u=new Array(a-1);let c=0;for(let g=0;g<a;g++)g!==o&&(u[c++]=i.shape[g]);const d=[],h=new Array(a).fill(0),p=i.shape.slice();p[o]=1;const f=new Array(l);for(let g=0;g<f.length;g++){h[o]=g;const m=ld({inputs:{x:i},backend:e,attrs:{begin:h,size:p}}),y=tt({inputs:{x:m},backend:e,attrs:{shape:u}});f[g]=y,d.push(m)}return d.forEach(g=>e.disposeIntermediateTensorInfo(g)),f}};class q1e{constructor(n,e){this.variableNames=["x","segmentIds"];const r=n.windowSize,s=n.batchSize,o=n.inSize,i=n.numSegments,a=i*Math.ceil(o/r);this.outputShape=[s,a];const c=4*Math.floor(r/4),d=r%4,h="\n        sumValue += dot(values, segFilter);\n    ";let p="";o%r>0&&(p=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return initializationValue;\n        }\n      `);let f="";o%r>0&&(f=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${p}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${f}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${i})) * float(${r}));\n        int currentSeg = int(mod(float(outIdx), float(${i})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${c}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${h}\n        }\n\n        int inIdx = inOffset + ${c};\n        if (${1===d}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${h}\n        } else if (${2===d}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${h}\n        } else if (${3===d}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${h}\n        }\n        setOutput(sumValue);\n      }\n    `}}const Y1e=[Rve,Ove,$ve,Bve,Uve,Hve,qve,Xve,Jve,tbe,sbe,abe,cbe,fbe,ybe,bbe,wbe,Ibe,Tbe,Ebe,Rbe,Lbe,Bbe,Ube,qbe,Xbe,Jbe,mve,n0e,a0e,d0e,y0e,x0e,_0e,S0e,D0e,N0e,R0e,O0e,M0e,L0e,B0e,W0e,H0e,X0e,Z0e,exe,rxe,oxe,axe,cxe,hxe,mxe,yxe,vxe,xxe,_xe,Sxe,Dxe,kxe,Nxe,Fxe,Mxe,Lxe,zxe,Gxe,jxe,Kxe,fve,Yxe,o0e,Qxe,ewe,nwe,yve,swe,iwe,lwe,dwe,fwe,gwe,vwe,xwe,Cwe,Iwe,Twe,Awe,Fwe,Pwe,Vwe,zwe,Wwe,Hwe,qwe,Zwe,e_e,s_e,c_e,xve,f_e,y_e,x_e,C_e,Wbe,I_e,T_e,E_e,R_e,M_e,bve,L_e,B_e,U_e,G_e,H_e,Gbe,i_e,q_e,Y_e,J_e,_ve,rCe,iCe,cCe,pCe,yCe,bCe,wCe,CCe,DCe,ECe,RCe,PCe,LCe,BCe,GCe,jCe,$be,l_e,KCe,XCe,ZCe,JCe,t1e,r1e,o1e,a1e,u1e,d1e,p1e,m1e,y1e,x1e,_1e,S1e,D1e,a_e,Eve,k1e,N1e,R1e,P1e,V1e,U1e,Nve,G1e,j1e,{kernelName:Ly,backendName:"webgl",kernelFunc:function K1e(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,segmentIds:o}=n,{numSegments:i}=r,a=s.shape.length,l=[];let u=0;const c=Qn([u],a);let d=s;null!=c&&(d=ws({inputs:{x:s},backend:e,attrs:{perm:c}}),l.push(d),u=fr(1,a)[0]);const h=QM(d.shape,u,i),p=_e([d.shape[u]]),f=tt({inputs:{x:d},backend:e,attrs:{shape:[-1,p]}});l.push(f);const g=GC(s.dtype),m=(x,w,k,V,z)=>{const K=x.shape[0],Y=x.shape[1],se=ZM(Y,z),ve=new q1e({windowSize:se,inSize:Y,batchSize:K,numSegments:z},w),be=e.compileAndRun(ve,[x,k],V);if(l.push(be),be.shape[1]===z)return be;const xe=KB({backend:e,attrs:{start:0,stop:z,step:1,dtype:"float32"}}),De=ZB({inputs:{x:xe},backend:e,attrs:{reps:[Y/se]}});return l.push(xe),l.push(De),m(be,w,De,V,z)},v=tt({inputs:{x:m(f,"unsortedSegmentSum",o,g,i)},backend:e,attrs:{shape:h}});let b=v;if(null!=c){l.push(v);const x=Ka(c);b=ws({inputs:{x:b},backend:e,attrs:{perm:x}})}return l.forEach(x=>e.disposeIntermediateTensorInfo(x)),b}},D_e];for(const t of Y1e)BC(t);const Q1e=function(t,n,e,r){return{"text-align":t,"background-color":n,color:e,"font-family":r}},JB=function(t,n){return{color:t,"font-family":n}},J1e=function(t){return{"text-align":t}};let eSe=(()=>{class t{constructor(){this.width=400,this.height=400,this.modelo=null,this.facingMode="user",this.category="Cargando...",this.output=0}ngOnInit(){this.video=document.getElementById("video"),this.canvas=document.getElementById("canvas"),this.ctx=this.canvas.getContext("2d",{willReadFrequently:!0}),this.loadModel()}loadModel(){var e=this;return $e(function*(){console.log("Cargando modelo..."),e.modelo=yield function Rae(t,n){return QS.apply(this,arguments)}(e.configuration.modelURL),console.log("Modelo cargado.")})()}onLoad(){this.mostrarCamara()}mostrarCamara(){navigator.mediaDevices.getUserMedia?navigator.mediaDevices.getUserMedia({audio:!1,video:{facingMode:"user",width:this.width,height:this.height}}).then(r=>{this.currentStream=r,this.video.srcObject=r,this.video.onloadedmetadata=()=>{this.video.play()},this.procesarCamara(),this.predecir()}).catch(function(r){alert("No se ha podido utilizar la c\xe1mara."),console.log(r),alert(r)}):alert("No existe la funcion getUserMedia.")}cambiarCamara(){this.currentStream&&this.currentStream.getTracks().forEach(r=>{r.stop()}),this.facingMode="user"==this.facingMode?"environment":"user",navigator.mediaDevices.getUserMedia({audio:!1,video:{facingMode:this.facingMode,width:this.width,height:this.height}}).then(r=>{this.currentStream=r,this.video.srcObject=r}).catch(function(r){console.log("No se ha podido cambiar la c\xe1mara.",r)})}procesarCamara(){this.ctx.drawImage(this.video,0,0,this.width,this.height,0,0,this.width,this.height),setTimeout(this.procesarCamara.bind(this),20)}predecir(){if(null!=this.modelo){let e=this.ctx.getImageData(0,0,this.width,this.height),r=TQ(e).toFloat(),a=Za.resizeBilinear(r,[this.configuration.height,this.configuration.width]).mean(2,!0).div(255).reshape([1,this.configuration.width,this.configuration.height,1]);this.output=this.modelo.predict(a).dataSync();for(const l of this.configuration.categories)this.output>=l.minValue&&this.output<l.maxValue&&(this.category=l.name)}setTimeout(this.predecir.bind(this),100)}getTextAlign(){return Ma[this.configuration.style.textAlign]}getCamAlign(){return Ma[this.configuration.style.camAlign]}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275cmp=yl({type:t,selectors:[["app-preview"]],hostBindings:function(e,r){1&e&&at("load",function(){return r.onLoad()},0,wk)},inputs:{configuration:"configuration"},decls:13,vars:21,consts:[[2,"padding","10px",3,"ngStyle"],[3,"ngStyle"],["id","video","autoplay","","loop","","muted","","playsinline","","hidden",""],["id","canvas","width","400","height","400",2,"max-width","100%"],["id","cambiarCamara","aria-label","Rotar c\xe1mara",1,"btn","btn-light",3,"click"],[1,"bi","bi-arrow-repeat"],["color","primary",3,"ngStyle"]],template:function(e,r){1&e&&(Re(0,"div",0)(1,"h1",1),bt(2),Ee(),Re(3,"p"),bt(4),Ee(),Re(5,"div",1),sn(6,"video",2)(7,"canvas",3),Re(8,"button",4),at("click",function(){return r.cambiarCamara()}),sn(9,"i",5),Ee()(),Re(10,"h2",6),bt(11),Ee(),bt(12),Ee()),2&e&&(nt("ngStyle",jN(8,Q1e,r.getTextAlign(),r.configuration.style.backgroundColor,r.configuration.style.contentColor,r.configuration.style.contentFontFamily)),Ke(1),nt("ngStyle",Nm(13,JB,r.configuration.style.titleColor,r.configuration.style.titleFontFamily)),Ke(1),Io("",r.configuration.title," "),Ke(2),kl(r.configuration.description),Ke(1),nt("ngStyle",Em(16,J1e,r.getCamAlign())),Ke(5),nt("ngStyle",Nm(18,JB,r.configuration.style.titleColor,r.configuration.style.titleFontFamily)),Ke(1),Io(" Resultado: ",r.category,""),Ke(1),Io(" ",r.output,"\n"))},dependencies:[x2],styles:["i.bi[_ngcontent-%COMP%]{font-size:25px}#cambiarCamara[_ngcontent-%COMP%]{position:absolute;margin-top:10px;margin-left:-50px;border-radius:100%;padding:1px 7px 0}"]}),t})();const tSe=["description"],nSe=["title"];function rSe(t,n){if(1&t&&(Re(0,"option",41),bt(1),Ee()),2&t){const e=n.$implicit,r=ot();nt("selected",e.name===r.configuration.style.titleFontFamily),Ke(1),Io("",e.name," ")}}function sSe(t,n){if(1&t&&(Re(0,"option",41),bt(1),Ee()),2&t){const e=n.$implicit,r=ot();nt("selected",e.name===r.configuration.style.contentFontFamily),Ke(1),Io("",e.name," ")}}function oSe(t,n){if(1&t){const e=ar();Re(0,"li",42)(1,"div",31)(2,"div",43)(3,"span",16),bt(4),Ee(),Re(5,"input",44),at("ngModelChange",function(s){return It(St(e).$implicit.name=s)}),Ee()(),Re(6,"div",43)(7,"span",16),bt(8,"Rango de valores:"),Ee(),Re(9,"span",16),bt(10,">"),Ee(),Re(11,"input",45),at("ngModelChange",function(s){return It(St(e).$implicit.minValue=s)}),Ee(),Re(12,"span",16),bt(13,"<="),Ee(),Re(14,"input",45),at("ngModelChange",function(s){return It(St(e).$implicit.maxValue=s)}),Ee()(),Re(15,"div",46)(16,"button",47),at("click",function(){const o=St(e).$implicit;return It(ot().deleteCategory(o))}),sn(17,"i",48),Ee()()()()}if(2&t){const e=n.$implicit,r=n.index;Ke(4),Io("Nombre de la categor\xeda ",r,":"),Ke(1),nt("ngModel",e.name),Ke(6),nt("ngModel",e.minValue),Ke(3),nt("ngModel",e.maxValue)}}const iSe=function(t,n){return{"alert-danger":t,"alert-success":n}};function aSe(t,n){if(1&t){const e=ar();Re(0,"div",49),bt(1),Re(2,"button",50),at("click",function(){return St(e),It(ot().closeMessage())}),Re(3,"span"),bt(4,"\xd7"),Ee()()()}if(2&t){const e=ot();nt("ngClass",Nm(2,iSe,!1===e.success,!0===e.success)),Ke(1),Io("",e.message," ")}}const ez=function(t){return{"is-invalid":t}};let tz=(()=>{class t{constructor(e,r){this.fb=e,this.appsService=r,this.Align=Ma,this.message="",this.success=!0,this.fontList=[{name:"Arial",value:"Arial, sans-serif"},{name:"Verdana",value:"Verdana, sans-serif"},{name:"Helvetica",value:"Helvetica, sans-serif"},{name:"Times New Roman",value:"Times New Roman, serif"},{name:"Courier New",value:"Courier New, monospace"}]}ngOnInit(){this.form=this.fb.group({title:[this.configuration.title,Ih.compose([Ih.required,Ih.maxLength(30)])],description:[this.configuration.description,Ih.compose([Ih.maxLength(300)])]})}setTextAlign(e){this.configuration.style.textAlign=e}setCamAlign(e){this.configuration.style.camAlign=e}setTitle(e){this.form.controls.title.errors||(this.configuration.title=e)}setDescription(e){this.form.controls.description.errors||(this.configuration.description=e)}onFileSelected(e){const r=e.target.files,o=[];let i;for(let a=0;a<r.length;a++){const l=r[a],u=l.name.split(".").pop();"json"==u&&(i=l),"bin"==u&&o.push(l)}this.configuration.modelURL=i.webkitRelativePath}download(){const e="<div id='main'>\n<h1>"+this.configuration.title+"</h1>\n<p>"+this.configuration.description+"</p>\n</div>\n",r="body {background-color:"+this.configuration.style.backgroundColor+"; color: "+this.configuration.style.contentColor+"}\nh1 {color: "+this.configuration.style.titleColor+"}";var o=new(zX());o.file("index.html",e),o.file("style.css",r),o.file("script.js",""),o.generateAsync({type:"blob"}).then(function(i){(0,UX.saveAs)(i,"app.zip")})}addConfig(){this.appsService.addConfig(this.configuration)?(this.message="Se ha a\xf1adido correctamente la aplicaci\xf3n actual a la lista.",this.success=!0):(this.message="La configuraci\xf3n actual no puede a\xf1adirse a la lista, ya existe otra configuraci\xf3n con el mismo t\xedtulo.",this.success=!1)}addCategory(){this.configuration.categories.push(new N_("Nombre categor\xeda",null,null))}closeMessage(){this.message=""}deleteCategory(e){const r=this.configuration.categories.indexOf(e);-1!==r&&this.configuration.categories.splice(r,1)}}return t.\u0275fac=function(e){return new(e||t)(Pe(MX),Pe(A_))},t.\u0275cmp=yl({type:t,selectors:[["app-config"]],viewQuery:function(e,r){if(1&e&&(ac(tSe,5),ac(nSe,5)),2&e){let s;Nl(s=Al())&&(r.description=s.first),Nl(s=Al())&&(r.title=s.first)}},inputs:{configuration:"configuration"},decls:107,vars:45,consts:[["id","config"],[3,"configuration"],["tabindex","-1","id","offcanvasBottom","aria-labelledby","offcanvasBottomLabel",1,"offcanvas","offcanvas-bottom"],[1,"offcanvas-header"],["id","offcanvasBottomLabel",1,"offcanvas-title"],["type","button","data-bs-dismiss","offcanvas","aria-label","Close",1,"btn-close","text-reset"],[1,"offcanvas-body","small"],[3,"formGroup"],[1,"row"],["type","file","accept",".json,.bin","webkitdirectory","","directory","","multiple","",1,"form-control-file",3,"change"],[1,"row","g-2"],[1,"col-md"],[1,"input-group"],["id","inputGroup-sizing-default",1,"input-group-text"],["type","text","formControlName","title","placeholder","T\xedtulo de la aplicaci\xf3n",1,"form-control",3,"ngClass","ngModelChange"],["title",""],[1,"input-group-text"],["type","text","formControlName","description","placeholder","Descripci\xf3n de la aplicaci\xf3n",1,"form-control",3,"ngClass","ngModelChange"],["description",""],[1,"card"],[1,"card-header"],[1,"card-body"],[1,"btn-group","btn-group-toggle"],[1,"btn","btn-secondary",3,"click"],[1,"bi","bi-text-left"],[1,"bi","bi-text-center"],[1,"bi","bi-text-right"],[1,"bi","bi-justify"],[1,"input-group","input-group-sm","col-md"],[1,"form-select","form-select-sm",3,"ngModel","ngModelChange"],[3,"selected",4,"ngFor","ngForOf"],[1,"row","g-3"],["readonly","",1,"colorPicker",3,"value","cpPosition","colorPicker","colorPickerChange"],[1,"list-group"],["class","list-group-item",4,"ngFor","ngForOf"],["type","button",1,"btn","btn-primary","btn-sm",3,"click"],[1,"buttons"],["type","button","data-bs-toggle","offcanvas","data-bs-target","#offcanvasBottom","aria-controls","offcanvasBottom",1,"btn","btn-primary"],["type","button","id","downloadBtn",1,"btn","btn-secondary",3,"click"],["type","button",1,"btn","btn-warning",3,"click"],["class","alert","role","alert",3,"ngClass",4,"ngIf"],[3,"selected"],[1,"list-group-item"],[1,"input-group","col-sm"],["type","text",1,"form-control",3,"ngModel","ngModelChange"],["type","number","step","0.1",1,"form-control",3,"ngModel","ngModelChange"],[1,"col-sm-1"],[1,"btn","btn-danger",3,"click"],[1,"bi","bi-trash3-fill"],["role","alert",1,"alert",3,"ngClass"],["type","button","data-dismiss","alert","aria-label","Close",1,"close",3,"click"]],template:function(e,r){if(1&e){const s=ar();Re(0,"div",0),bt(1," Vista previa de la aplicaci\xf3n: "),sn(2,"app-preview",1),Re(3,"div",2)(4,"div",3)(5,"h5",4),bt(6,"Configuraci\xf3n de la vista de la aplicaci\xf3n"),Ee(),sn(7,"button",5),Ee(),Re(8,"div",6)(9,"form",7)(10,"div",8)(11,"label"),bt(12,"Selecciona un nuevo modelo:"),sn(13,"br"),Ee(),Re(14,"input",9),at("change",function(i){return r.onFileSelected(i)}),Ee(),Re(15,"label"),bt(16,"Debes seleccionar un directorio que contenga el archivo model.json y los .bin correspondientes."),Ee()(),sn(17,"br"),Re(18,"div",10)(19,"div",11)(20,"div",12)(21,"span",13),bt(22,"T\xedtulo de la aplicaci\xf3n"),Ee(),Re(23,"input",14,15),at("ngModelChange",function(){St(s);const i=dx(24);return It(r.setTitle(i.value))}),Ee()()(),Re(25,"div",11)(26,"div",12)(27,"span",16),bt(28,"Descripci\xf3n"),Ee(),Re(29,"textarea",17,18),at("ngModelChange",function(){St(s);const i=dx(30);return It(r.setDescription(i.value))}),Ee()()()()(),sn(31,"br"),Re(32,"div",19)(33,"div",20),bt(34,"Estilo"),Ee(),Re(35,"div",21)(36,"div",10)(37,"div",11)(38,"label"),bt(39,"Selecciona la alineaci\xf3n de la c\xe1mara:\xa0\xa0"),Ee(),Re(40,"div",22)(41,"button",23),at("click",function(){return r.setCamAlign(r.Align.left)}),sn(42,"i",24),Ee(),Re(43,"button",23),at("click",function(){return r.setCamAlign(r.Align.center)}),sn(44,"i",25),Ee(),Re(45,"button",23),at("click",function(){return r.setCamAlign(r.Align.right)}),sn(46,"i",26),Ee(),Re(47,"button",23),at("click",function(){return r.setCamAlign(r.Align.justify)}),sn(48,"i",27),Ee()()(),Re(49,"div",11)(50,"label"),bt(51,"Selecciona la alineaci\xf3n del texto:\xa0\xa0"),Ee(),Re(52,"div",22)(53,"button",23),at("click",function(){return r.setTextAlign(r.Align.left)}),sn(54,"i",24),Ee(),Re(55,"button",23),at("click",function(){return r.setTextAlign(r.Align.center)}),sn(56,"i",25),Ee(),Re(57,"button",23),at("click",function(){return r.setTextAlign(r.Align.right)}),sn(58,"i",26),Ee(),Re(59,"button",23),at("click",function(){return r.setTextAlign(r.Align.justify)}),sn(60,"i",27),Ee()()()(),sn(61,"br"),Re(62,"div",10)(63,"div",28)(64,"span",16),bt(65,"Selecciona la fuente de los t\xedtulos:"),Ee(),Re(66,"select",29),at("ngModelChange",function(i){return r.configuration.style.titleFontFamily=i}),ln(67,rSe,2,2,"option",30),Ee()(),Re(68,"div",28)(69,"span",16),bt(70,"Selecciona la fuente del contenido:"),Ee(),Re(71,"select",29),at("ngModelChange",function(i){return r.configuration.style.contentFontFamily=i}),ln(72,sSe,2,2,"option",30),Ee()()(),sn(73,"br"),Re(74,"div",31)(75,"div",28)(76,"span",16),bt(77,"Color de fondo:"),Ee(),Re(78,"input",32),at("colorPickerChange",function(i){return r.configuration.style.backgroundColor=i}),Ee()(),Re(79,"div",28)(80,"span",16),bt(81,"Color de los t\xedtulos:"),Ee(),Re(82,"input",32),at("colorPickerChange",function(i){return r.configuration.style.titleColor=i}),Ee()(),Re(83,"div",28)(84,"span",16),bt(85,"Color del contenido:"),Ee(),Re(86,"input",32),at("colorPickerChange",function(i){return r.configuration.style.contentColor=i}),Ee()()()()(),sn(87,"br")(88,"br"),Re(89,"div",19)(90,"div",20),bt(91,"Categor\xedas:"),Ee(),Re(92,"div",21)(93,"ul",33),ln(94,oSe,18,4,"li",34),Ee(),sn(95,"br"),Re(96,"button",35),at("click",function(){return r.addCategory()}),bt(97,"A\xf1adir nueva categor\xeda"),Ee()()(),sn(98,"br"),Ee()(),Re(99,"div",36)(100,"button",37),bt(101,"Configuraci\xf3n de la vista"),Ee(),Re(102,"button",38),at("click",function(){return r.download()}),bt(103,"Descargar app actual"),Ee(),Re(104,"button",39),at("click",function(){return r.addConfig()}),bt(105,"A\xf1adir a la lista"),Ee()(),ln(106,aSe,5,5,"div",40),Ee()}2&e&&(Ke(2),nt("configuration",r.configuration),Ke(7),nt("formGroup",r.form),Ke(14),nt("ngClass",Em(41,ez,r.form.controls.title.errors)),Ke(6),nt("ngClass",Em(43,ez,r.form.controls.description.errors)),Ke(12),Ts("active",r.configuration.style.camAlign===r.Align.left),Ke(2),Ts("active",r.configuration.style.camAlign===r.Align.center),Ke(2),Ts("active",r.configuration.style.camAlign===r.Align.right),Ke(2),Ts("active",r.configuration.style.camAlign===r.Align.justify),Ke(6),Ts("active",r.configuration.style.textAlign===r.Align.left),Ke(2),Ts("active",r.configuration.style.textAlign===r.Align.center),Ke(2),Ts("active",r.configuration.style.textAlign===r.Align.right),Ke(2),Ts("active",r.configuration.style.textAlign===r.Align.justify),Ke(7),nt("ngModel",r.configuration.style.titleFontFamily),Ke(1),nt("ngForOf",r.fontList),Ke(4),nt("ngModel",r.configuration.style.contentFontFamily),Ke(1),nt("ngForOf",r.fontList),Ke(6),vr("background",r.configuration.style.backgroundColor),nt("value",r.configuration.style.backgroundColor)("cpPosition","top")("colorPicker",r.configuration.style.backgroundColor),Ke(4),vr("background",r.configuration.style.titleColor),nt("value",r.configuration.style.titleColor)("cpPosition","top")("colorPicker",r.configuration.style.titleColor),Ke(4),vr("background",r.configuration.style.contentColor),nt("value",r.configuration.style.contentColor)("cpPosition","top")("colorPicker",r.configuration.style.contentColor),Ke(8),nt("ngForOf",r.configuration.categories),Ke(12),nt("ngIf",""!=r.message))},dependencies:[f2,Ym,yw,ZF,sO,iO,Sg,C_,Mg,$F,LF,__,Pg,T_,EY,eSe],styles:["#config[_ngcontent-%COMP%]{margin:10px}.buttons[_ngcontent-%COMP%]   button[_ngcontent-%COMP%], .buttons[_ngcontent-%COMP%]   .alert[_ngcontent-%COMP%]{margin-top:10px;margin-right:10px}.buttons[_ngcontent-%COMP%]   .alert[_ngcontent-%COMP%]{display:inlne-block;padding:5px}#offcanvasBottom[_ngcontent-%COMP%]{--bs-offcanvas-height: 60vh}.colorPicker[_ngcontent-%COMP%]{border:2px solid black;display:inline-block;padding:0 5px;margin:0 5px;color:#6a6a6a}.color-picker[_ngcontent-%COMP%]{position:relative}div.alert[_ngcontent-%COMP%]{display:inline-block;padding-top:5px;padding-bottom:5px;margin-top:10px;margin-bottom:0}.alert[_ngcontent-%COMP%]   button.close[_ngcontent-%COMP%]{color:inherit;background-color:transparent;border:0;-webkit-appearance:none;float:right;font-size:1.5rem;font-weight:700;text-shadow:0 1px 0 #fff;opacity:.5;line-height:1;margin-top:-2.5px;margin-right:-10px;margin-left:10px}.alert[_ngcontent-%COMP%]   button.close[_ngcontent-%COMP%]:hover{color:#000}.card[_ngcontent-%COMP%]{padding:0}input.colorPicker[_ngcontent-%COMP%]{border-radius:0px .375rem .375rem 0px!important;border:var(--bs-border-width) solid var(--bs-border-color)}"]}),t})();const lSe=[{path:"",component:tz},{path:"help",component:(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275cmp=yl({type:t,selectors:[["app-help"]],decls:2,vars:0,template:function(e,r){1&e&&(Re(0,"p"),bt(1,"Ayuda"),Ee())}}),t})()}];let uSe=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=wo({type:t}),t.\u0275inj=Zs({imports:[cF.forRoot(lSe),cF]}),t})();function cSe(t,n){if(1&t){const e=ar();Re(0,"a",18),at("click",function(){const o=St(e).$implicit;return It(ot().onSelect(o))}),bt(1),Ee()}if(2&t){const e=n.$implicit,r=ot();Ts("active",e.title===r.getSelected().title),Ke(1),Io(" ",e.title," ")}}let dSe=(()=>{class t{constructor(e){this.appsService=e,this.title="meta-app-models",this.configurations=[],this.selectedConfig=structuredClone(this.appsService.configs[0])}ngOnInit(){this.configurations=this.appsService.configs}onSelect(e){this.selectedConfig=structuredClone(e)}getSelected(){return this.selectedConfig}}return t.\u0275fac=function(e){return new(e||t)(Pe(A_))},t.\u0275cmp=yl({type:t,selectors:[["app-root"]],decls:26,vars:2,consts:[[1,"navbar","navbar-dark","bg-dark"],["href","#",1,"navbar-brand"],[1,"bi","bi-boxes"],["type","button","data-bs-toggle","offcanvas","data-bs-target","#offcanvasRight","aria-controls","offcanvasRight","aria-expanded","false","aria-label","Toggle navigation",1,"navbar-toggler","navbar-toggler-right"],[1,"navbar-toggler-icon"],[3,"configuration"],["tabindex","-1","id","offcanvasRight","aria-labelledby","offcanvasRightLabel",1,"offcanvas","offcanvas-end"],[1,"offcanvas-header"],["id","offcanvasRightLabel"],["type","button","data-bs-dismiss","offcanvas","aria-label","Close",1,"btn-close","text-reset"],[1,"offcanvas-body"],[1,"list-group"],["class","list-group-item list-group-item-action",3,"active","click",4,"ngFor","ngForOf"],[1,"d-flex","flex-wrap","justify-content-center","align-items-center","py-3","my-4","border-top"],[1,"nav","justify-content-center"],[1,"nav-item"],["href","#",1,"nav-link","px-2","link-dark"],["href","help",1,"nav-link","px-2","link-dark"],[1,"list-group-item","list-group-item-action",3,"click"]],template:function(e,r){1&e&&(Re(0,"nav",0)(1,"a",1),sn(2,"i",2),bt(3," Incrustado de modelos "),Ee(),Re(4,"button",3),sn(5,"span",4),Ee()(),sn(6,"app-config",5),Re(7,"div",6)(8,"div",7)(9,"h5",8),bt(10,"Lista de aplicaciones"),Ee(),sn(11,"button",9),Ee(),Re(12,"div",10)(13,"div",11),ln(14,cSe,2,3,"a",12),Ee()()(),Re(15,"footer",13)(16,"ul",14)(17,"li",15)(18,"a",16),bt(19,"Home"),Ee()(),Re(20,"li",15)(21,"a",17),bt(22,"Help"),Ee()(),Re(23,"li",15)(24,"a",16),bt(25,"About"),Ee()()()()),2&e&&(Ke(6),nt("configuration",r.selectedConfig),Ke(8),nt("ngForOf",r.configurations))},dependencies:[Ym,tz],styles:[".navbar[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{margin-right:10px}.navbar-dark[_ngcontent-%COMP%]   .navbar-toggler-icon[_ngcontent-%COMP%]{background-image:url(\"data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 30 30'%3e%3cpath stroke='rgba%28255, 255, 255, 0.95%29' stroke-linecap='round' stroke-miterlimit='10' stroke-width='2' d='M4 7h22M4 15h22M4 23h22'/%3e%3c/svg%3e\")}div#offcanvasRight[_ngcontent-%COMP%]{width:250px}.navbar-brand[_ngcontent-%COMP%]{margin-left:12px}nav[_ngcontent-%COMP%]   i.bi.bi-boxes[_ngcontent-%COMP%]{margin-right:5px}"]}),t})(),hSe=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=wo({type:t,bootstrap:[dSe]}),t.\u0275inj=Zs({providers:[A_],imports:[Qq,uSe,$X,LX,NY]}),t})();Zq().bootstrapModule(hSe).catch(t=>console.error(t))},327:function(jt,q){var ne,U;void 0!==(U="function"==typeof(ne=function(){"use strict";function F(I,A,S){var D=new XMLHttpRequest;D.open("GET",I),D.responseType="blob",D.onload=function(){T(D.response,A,S)},D.onerror=function(){console.error("could not download file")},D.send()}function P(I){var A=new XMLHttpRequest;A.open("HEAD",I,!1);try{A.send()}catch{}return 200<=A.status&&299>=A.status}function G(I){try{I.dispatchEvent(new MouseEvent("click"))}catch{var A=document.createEvent("MouseEvents");A.initMouseEvent("click",!0,!0,window,0,0,0,80,20,!1,!1,!1,!1,0,null),I.dispatchEvent(A)}}var j="object"==typeof window&&window.window===window?window:"object"==typeof self&&self.self===self?self:"object"==typeof global&&global.global===global?global:void 0,B=j.navigator&&/Macintosh/.test(navigator.userAgent)&&/AppleWebKit/.test(navigator.userAgent)&&!/Safari/.test(navigator.userAgent),T=j.saveAs||("object"!=typeof window||window!==j?function(){}:"download"in HTMLAnchorElement.prototype&&!B?function(I,A,S){var D=j.URL||j.webkitURL,N=document.createElement("a");N.download=A=A||I.name||"download",N.rel="noopener","string"==typeof I?(N.href=I,N.origin===location.origin?G(N):P(N.href)?F(I,A,S):G(N,N.target="_blank")):(N.href=D.createObjectURL(I),setTimeout(function(){D.revokeObjectURL(N.href)},4e4),setTimeout(function(){G(N)},0))}:"msSaveOrOpenBlob"in navigator?function(I,A,S){if(A=A||I.name||"download","string"!=typeof I)navigator.msSaveOrOpenBlob(function M(I,A){return typeof A>"u"?A={autoBom:!1}:"object"!=typeof A&&(console.warn("Deprecated: Expected third argument to be a object"),A={autoBom:!A}),A.autoBom&&/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(I.type)?new Blob(["\ufeff",I],{type:I.type}):I}(I,S),A);else if(P(I))F(I,A,S);else{var D=document.createElement("a");D.href=I,D.target="_blank",setTimeout(function(){G(D)})}}:function(I,A,S,D){if((D=D||open("","_blank"))&&(D.document.title=D.document.body.innerText="downloading..."),"string"==typeof I)return F(I,A,S);var N="application/octet-stream"===I.type,L=/constructor/i.test(j.HTMLElement)||j.safari,Z=/CriOS\/[\d]+/.test(navigator.userAgent);if((Z||N&&L||B)&&typeof FileReader<"u"){var ie=new FileReader;ie.onloadend=function(){var Se=ie.result;Se=Z?Se:Se.replace(/^data:[^;]*;/,"data:attachment/file;"),D?D.location.href=Se:location=Se,D=null},ie.readAsDataURL(I)}else{var oe=j.URL||j.webkitURL,Fe=oe.createObjectURL(I);D?D.location=Fe:location.href=Fe,D=null,setTimeout(function(){oe.revokeObjectURL(Fe)},4e4)}});j.saveAs=T.saveAs=T,jt.exports=T})?ne.apply(q,[]):ne)&&(jt.exports=U)},650:jt=>{jt.exports=function q(ne,X,U){function M(G,j){if(!X[G]){if(!ne[G]){if(F)return F(G,!0);var T=new Error("Cannot find module '"+G+"'");throw T.code="MODULE_NOT_FOUND",T}var I=X[G]={exports:{}};ne[G][0].call(I.exports,function(A){return M(ne[G][1][A]||A)},I,I.exports,q,ne,X,U)}return X[G].exports}for(var F=void 0,P=0;P<U.length;P++)M(U[P]);return M}({1:[function(q,ne,X){"use strict";var U=q("./utils"),M=q("./support"),F="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";X.encode=function(P){for(var G,j,B,I,A,S,D=[],N=0,L=P.length,Z=L,ie="string"!==U.getTypeOf(P);N<P.length;)Z=L-N,B=ie?(G=P[N++],j=N<L?P[N++]:0,N<L?P[N++]:0):(G=P.charCodeAt(N++),j=N<L?P.charCodeAt(N++):0,N<L?P.charCodeAt(N++):0),I=(3&G)<<4|j>>4,A=1<Z?(15&j)<<2|B>>6:64,S=2<Z?63&B:64,D.push(F.charAt(G>>2)+F.charAt(I)+F.charAt(A)+F.charAt(S));return D.join("")},X.decode=function(P){var G,j,B,T,I,A,S=0,D=0,N="data:";if(P.substr(0,N.length)===N)throw new Error("Invalid base64 input, it looks like a data url.");var L,Z=3*(P=P.replace(/[^A-Za-z0-9+/=]/g,"")).length/4;if(P.charAt(P.length-1)===F.charAt(64)&&Z--,P.charAt(P.length-2)===F.charAt(64)&&Z--,Z%1!=0)throw new Error("Invalid base64 input, bad content length.");for(L=M.uint8array?new Uint8Array(0|Z):new Array(0|Z);S<P.length;)G=F.indexOf(P.charAt(S++))<<2|(T=F.indexOf(P.charAt(S++)))>>4,j=(15&T)<<4|(I=F.indexOf(P.charAt(S++)))>>2,B=(3&I)<<6|(A=F.indexOf(P.charAt(S++))),L[D++]=G,64!==I&&(L[D++]=j),64!==A&&(L[D++]=B);return L}},{"./support":30,"./utils":32}],2:[function(q,ne,X){"use strict";var U=q("./external"),M=q("./stream/DataWorker"),F=q("./stream/Crc32Probe"),P=q("./stream/DataLengthProbe");function G(j,B,T,I,A){this.compressedSize=j,this.uncompressedSize=B,this.crc32=T,this.compression=I,this.compressedContent=A}G.prototype={getContentWorker:function(){var j=new M(U.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new P("data_length")),B=this;return j.on("end",function(){if(this.streamInfo.data_length!==B.uncompressedSize)throw new Error("Bug : uncompressed data size mismatch")}),j},getCompressedWorker:function(){return new M(U.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize",this.compressedSize).withStreamInfo("uncompressedSize",this.uncompressedSize).withStreamInfo("crc32",this.crc32).withStreamInfo("compression",this.compression)}},G.createWorkerFrom=function(j,B,T){return j.pipe(new F).pipe(new P("uncompressedSize")).pipe(B.compressWorker(T)).pipe(new P("compressedSize")).withStreamInfo("compression",B)},ne.exports=G},{"./external":6,"./stream/Crc32Probe":25,"./stream/DataLengthProbe":26,"./stream/DataWorker":27}],3:[function(q,ne,X){"use strict";var U=q("./stream/GenericWorker");X.STORE={magic:"\0\0",compressWorker:function(){return new U("STORE compression")},uncompressWorker:function(){return new U("STORE decompression")}},X.DEFLATE=q("./flate")},{"./flate":7,"./stream/GenericWorker":28}],4:[function(q,ne,X){"use strict";var U=q("./utils"),M=function(){for(var F,P=[],G=0;G<256;G++){F=G;for(var j=0;j<8;j++)F=1&F?3988292384^F>>>1:F>>>1;P[G]=F}return P}();ne.exports=function(F,P){return void 0!==F&&F.length?"string"!==U.getTypeOf(F)?function(G,j,B,T){var I=M,A=0+B;G^=-1;for(var S=0;S<A;S++)G=G>>>8^I[255&(G^j[S])];return-1^G}(0|P,F,F.length):function(G,j,B,T){var I=M,A=0+B;G^=-1;for(var S=0;S<A;S++)G=G>>>8^I[255&(G^j.charCodeAt(S))];return-1^G}(0|P,F,F.length):0}},{"./utils":32}],5:[function(q,ne,X){"use strict";X.base64=!1,X.binary=!1,X.dir=!1,X.createFolders=!0,X.date=null,X.compression=null,X.compressionOptions=null,X.comment=null,X.unixPermissions=null,X.dosPermissions=null},{}],6:[function(q,ne,X){"use strict";var U;U=typeof Promise<"u"?Promise:q("lie"),ne.exports={Promise:U}},{lie:37}],7:[function(q,ne,X){"use strict";var U=typeof Uint8Array<"u"&&typeof Uint16Array<"u"&&typeof Uint32Array<"u",M=q("pako"),F=q("./utils"),P=q("./stream/GenericWorker"),G=U?"uint8array":"array";function j(B,T){P.call(this,"FlateWorker/"+B),this._pako=null,this._pakoAction=B,this._pakoOptions=T,this.meta={}}X.magic="\b\0",F.inherits(j,P),j.prototype.processChunk=function(B){this.meta=B.meta,null===this._pako&&this._createPako(),this._pako.push(F.transformTo(G,B.data),!1)},j.prototype.flush=function(){P.prototype.flush.call(this),null===this._pako&&this._createPako(),this._pako.push([],!0)},j.prototype.cleanUp=function(){P.prototype.cleanUp.call(this),this._pako=null},j.prototype._createPako=function(){this._pako=new M[this._pakoAction]({raw:!0,level:this._pakoOptions.level||-1});var B=this;this._pako.onData=function(T){B.push({data:T,meta:B.meta})}},X.compressWorker=function(B){return new j("Deflate",B)},X.uncompressWorker=function(){return new j("Inflate",{})}},{"./stream/GenericWorker":28,"./utils":32,pako:38}],8:[function(q,ne,X){"use strict";function U(I,A){var S,D="";for(S=0;S<A;S++)D+=String.fromCharCode(255&I),I>>>=8;return D}function M(I,A,S,D,N,L){var Z,ie,oe=I.file,Fe=I.compression,Se=L!==G.utf8encode,Te=F.transformTo("string",L(oe.name)),de=F.transformTo("string",G.utf8encode(oe.name)),Oe=oe.comment,me=F.transformTo("string",L(Oe)),O=F.transformTo("string",G.utf8encode(Oe)),E=de.length!==oe.name.length,_=O.length!==Oe.length,ue="",et="",ke="",ut=oe.dir,Me=oe.date,dt={crc32:0,compressedSize:0,uncompressedSize:0};A&&!S||(dt.crc32=I.crc32,dt.compressedSize=I.compressedSize,dt.uncompressedSize=I.uncompressedSize);var ce=0;A&&(ce|=8),Se||!E&&!_||(ce|=2048);var qe,Ur,le=0,ft=0;ut&&(le|=16),"UNIX"===N?(ft=798,le|=(Ur=qe=oe.unixPermissions,qe||(Ur=ut?16893:33204),(65535&Ur)<<16)):(ft=20,le|=function(qe){return 63&(qe||0)}(oe.dosPermissions)),Z=Me.getUTCHours(),Z<<=6,Z|=Me.getUTCMinutes(),Z<<=5,Z|=Me.getUTCSeconds()/2,ie=Me.getUTCFullYear()-1980,ie<<=4,ie|=Me.getUTCMonth()+1,ie<<=5,ie|=Me.getUTCDate(),E&&(et=U(1,1)+U(j(Te),4)+de,ue+="up"+U(et.length,2)+et),_&&(ke=U(1,1)+U(j(me),4)+O,ue+="uc"+U(ke.length,2)+ke);var Ve="";return Ve+="\n\0",Ve+=U(ce,2),Ve+=Fe.magic,Ve+=U(Z,2),Ve+=U(ie,2),Ve+=U(dt.crc32,4),Ve+=U(dt.compressedSize,4),Ve+=U(dt.uncompressedSize,4),Ve+=U(Te.length,2),Ve+=U(ue.length,2),{fileRecord:B.LOCAL_FILE_HEADER+Ve+Te+ue,dirRecord:B.CENTRAL_FILE_HEADER+U(ft,2)+Ve+U(me.length,2)+"\0\0\0\0"+U(le,4)+U(D,4)+Te+ue+me}}var F=q("../utils"),P=q("../stream/GenericWorker"),G=q("../utf8"),j=q("../crc32"),B=q("../signature");function T(I,A,S,D){P.call(this,"ZipFileWorker"),this.bytesWritten=0,this.zipComment=A,this.zipPlatform=S,this.encodeFileName=D,this.streamFiles=I,this.accumulate=!1,this.contentBuffer=[],this.dirRecords=[],this.currentSourceOffset=0,this.entriesCount=0,this.currentFile=null,this._sources=[]}F.inherits(T,P),T.prototype.push=function(I){var A=I.meta.percent||0,S=this.entriesCount,D=this._sources.length;this.accumulate?this.contentBuffer.push(I):(this.bytesWritten+=I.data.length,P.prototype.push.call(this,{data:I.data,meta:{currentFile:this.currentFile,percent:S?(A+100*(S-D-1))/S:100}}))},T.prototype.openedSource=function(I){this.currentSourceOffset=this.bytesWritten,this.currentFile=I.file.name;var A=this.streamFiles&&!I.file.dir;if(A){var S=M(I,A,!1,this.currentSourceOffset,this.zipPlatform,this.encodeFileName);this.push({data:S.fileRecord,meta:{percent:0}})}else this.accumulate=!0},T.prototype.closedSource=function(I){this.accumulate=!1;var D,A=this.streamFiles&&!I.file.dir,S=M(I,A,!0,this.currentSourceOffset,this.zipPlatform,this.encodeFileName);if(this.dirRecords.push(S.dirRecord),A)this.push({data:(D=I,B.DATA_DESCRIPTOR+U(D.crc32,4)+U(D.compressedSize,4)+U(D.uncompressedSize,4)),meta:{percent:100}});else for(this.push({data:S.fileRecord,meta:{percent:0}});this.contentBuffer.length;)this.push(this.contentBuffer.shift());this.currentFile=null},T.prototype.flush=function(){for(var I=this.bytesWritten,A=0;A<this.dirRecords.length;A++)this.push({data:this.dirRecords[A],meta:{percent:100}});var N,L,Z,Fe,D=(N=this.dirRecords.length,L=this.bytesWritten-I,Z=I,Fe=F.transformTo("string",(0,this.encodeFileName)(this.zipComment)),B.CENTRAL_DIRECTORY_END+"\0\0\0\0"+U(N,2)+U(N,2)+U(L,4)+U(Z,4)+U(Fe.length,2)+Fe);this.push({data:D,meta:{percent:100}})},T.prototype.prepareNextSource=function(){this.previous=this._sources.shift(),this.openedSource(this.previous.streamInfo),this.isPaused?this.previous.pause():this.previous.resume()},T.prototype.registerPrevious=function(I){this._sources.push(I);var A=this;return I.on("data",function(S){A.processChunk(S)}),I.on("end",function(){A.closedSource(A.previous.streamInfo),A._sources.length?A.prepareNextSource():A.end()}),I.on("error",function(S){A.error(S)}),this},T.prototype.resume=function(){return!!P.prototype.resume.call(this)&&(!this.previous&&this._sources.length?(this.prepareNextSource(),!0):this.previous||this._sources.length||this.generatedError?void 0:(this.end(),!0))},T.prototype.error=function(I){var A=this._sources;if(!P.prototype.error.call(this,I))return!1;for(var S=0;S<A.length;S++)try{A[S].error(I)}catch{}return!0},T.prototype.lock=function(){P.prototype.lock.call(this);for(var I=this._sources,A=0;A<I.length;A++)I[A].lock()},ne.exports=T},{"../crc32":4,"../signature":23,"../stream/GenericWorker":28,"../utf8":31,"../utils":32}],9:[function(q,ne,X){"use strict";var U=q("../compressions"),M=q("./ZipFileWorker");X.generateWorker=function(F,P,G){var j=new M(P.streamFiles,G,P.platform,P.encodeFileName),B=0;try{F.forEach(function(T,I){B++;var A=function(L,Z){var ie=L||Z,oe=U[ie];if(!oe)throw new Error(ie+" is not a valid compression method !");return oe}(I.options.compression,P.compression),D=I.dir,N=I.date;I._compressWorker(A,I.options.compressionOptions||P.compressionOptions||{}).withStreamInfo("file",{name:T,dir:D,date:N,comment:I.comment||"",unixPermissions:I.unixPermissions,dosPermissions:I.dosPermissions}).pipe(j)}),j.entriesCount=B}catch(T){j.error(T)}return j}},{"../compressions":3,"./ZipFileWorker":8}],10:[function(q,ne,X){"use strict";function U(){if(!(this instanceof U))return new U;if(arguments.length)throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");this.files=Object.create(null),this.comment=null,this.root="",this.clone=function(){var M=new U;for(var F in this)"function"!=typeof this[F]&&(M[F]=this[F]);return M}}(U.prototype=q("./object")).loadAsync=q("./load"),U.support=q("./support"),U.defaults=q("./defaults"),U.version="3.10.1",U.loadAsync=function(M,F){return(new U).loadAsync(M,F)},U.external=q("./external"),ne.exports=U},{"./defaults":5,"./external":6,"./load":11,"./object":15,"./support":30}],11:[function(q,ne,X){"use strict";var U=q("./utils"),M=q("./external"),F=q("./utf8"),P=q("./zipEntries"),G=q("./stream/Crc32Probe"),j=q("./nodejsUtils");function B(T){return new M.Promise(function(I,A){var S=T.decompressed.getContentWorker().pipe(new G);S.on("error",function(D){A(D)}).on("end",function(){S.streamInfo.crc32!==T.decompressed.crc32?A(new Error("Corrupted zip : CRC32 mismatch")):I()}).resume()})}ne.exports=function(T,I){var A=this;return I=U.extend(I||{},{base64:!1,checkCRC32:!1,optimizedBinaryString:!1,createFolders:!1,decodeFileName:F.utf8decode}),j.isNode&&j.isStream(T)?M.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")):U.prepareContent("the loaded zip file",T,!0,I.optimizedBinaryString,I.base64).then(function(S){var D=new P(I);return D.load(S),D}).then(function(S){var D=[M.Promise.resolve(S)],N=S.files;if(I.checkCRC32)for(var L=0;L<N.length;L++)D.push(B(N[L]));return M.Promise.all(D)}).then(function(S){for(var D=S.shift(),N=D.files,L=0;L<N.length;L++){var Z=N[L],ie=Z.fileNameStr,oe=U.resolve(Z.fileNameStr);A.file(oe,Z.decompressed,{binary:!0,optimizedBinaryString:!0,date:Z.date,dir:Z.dir,comment:Z.fileCommentStr.length?Z.fileCommentStr:null,unixPermissions:Z.unixPermissions,dosPermissions:Z.dosPermissions,createFolders:I.createFolders}),Z.dir||(A.file(oe).unsafeOriginalName=ie)}return D.zipComment.length&&(A.comment=D.zipComment),A})}},{"./external":6,"./nodejsUtils":14,"./stream/Crc32Probe":25,"./utf8":31,"./utils":32,"./zipEntries":33}],12:[function(q,ne,X){"use strict";var U=q("../utils"),M=q("../stream/GenericWorker");function F(P,G){M.call(this,"Nodejs stream input adapter for "+P),this._upstreamEnded=!1,this._bindStream(G)}U.inherits(F,M),F.prototype._bindStream=function(P){var G=this;(this._stream=P).pause(),P.on("data",function(j){G.push({data:j,meta:{percent:0}})}).on("error",function(j){G.isPaused?this.generatedError=j:G.error(j)}).on("end",function(){G.isPaused?G._upstreamEnded=!0:G.end()})},F.prototype.pause=function(){return!!M.prototype.pause.call(this)&&(this._stream.pause(),!0)},F.prototype.resume=function(){return!!M.prototype.resume.call(this)&&(this._upstreamEnded?this.end():this._stream.resume(),!0)},ne.exports=F},{"../stream/GenericWorker":28,"../utils":32}],13:[function(q,ne,X){"use strict";var U=q("readable-stream").Readable;function M(F,P,G){U.call(this,P),this._helper=F;var j=this;F.on("data",function(B,T){j.push(B)||j._helper.pause(),G&&G(T)}).on("error",function(B){j.emit("error",B)}).on("end",function(){j.push(null)})}q("../utils").inherits(M,U),M.prototype._read=function(){this._helper.resume()},ne.exports=M},{"../utils":32,"readable-stream":16}],14:[function(q,ne,X){"use strict";ne.exports={isNode:typeof Buffer<"u",newBufferFrom:function(U,M){if(Buffer.from&&Buffer.from!==Uint8Array.from)return Buffer.from(U,M);if("number"==typeof U)throw new Error('The "data" argument must not be a number');return new Buffer(U,M)},allocBuffer:function(U){if(Buffer.alloc)return Buffer.alloc(U);var M=new Buffer(U);return M.fill(0),M},isBuffer:function(U){return Buffer.isBuffer(U)},isStream:function(U){return U&&"function"==typeof U.on&&"function"==typeof U.pause&&"function"==typeof U.resume}}},{}],15:[function(q,ne,X){"use strict";function U(oe,Fe,Se){var Te,de=F.getTypeOf(Fe),Oe=F.extend(Se||{},j);Oe.date=Oe.date||new Date,null!==Oe.compression&&(Oe.compression=Oe.compression.toUpperCase()),"string"==typeof Oe.unixPermissions&&(Oe.unixPermissions=parseInt(Oe.unixPermissions,8)),Oe.unixPermissions&&16384&Oe.unixPermissions&&(Oe.dir=!0),Oe.dosPermissions&&16&Oe.dosPermissions&&(Oe.dir=!0),Oe.dir&&(oe=N(oe)),Oe.createFolders&&(Te=D(oe))&&L.call(this,Te,!0),Se&&void 0!==Se.binary||(Oe.binary=!("string"===de&&!1===Oe.binary&&!1===Oe.base64)),(Fe instanceof B&&0===Fe.uncompressedSize||Oe.dir||!Fe||0===Fe.length)&&(Oe.base64=!1,Oe.binary=!0,Fe="",Oe.compression="STORE",de="string");var O;O=Fe instanceof B||Fe instanceof P?Fe:A.isNode&&A.isStream(Fe)?new S(oe,Fe):F.prepareContent(oe,Fe,Oe.binary,Oe.optimizedBinaryString,Oe.base64);var E=new T(oe,O,Oe);this.files[oe]=E}var M=q("./utf8"),F=q("./utils"),P=q("./stream/GenericWorker"),G=q("./stream/StreamHelper"),j=q("./defaults"),B=q("./compressedObject"),T=q("./zipObject"),I=q("./generate"),A=q("./nodejsUtils"),S=q("./nodejs/NodejsStreamInputAdapter"),D=function(oe){"/"===oe.slice(-1)&&(oe=oe.substring(0,oe.length-1));var Fe=oe.lastIndexOf("/");return 0<Fe?oe.substring(0,Fe):""},N=function(oe){return"/"!==oe.slice(-1)&&(oe+="/"),oe},L=function(oe,Fe){return Fe=void 0!==Fe?Fe:j.createFolders,oe=N(oe),this.files[oe]||U.call(this,oe,null,{dir:!0,createFolders:Fe}),this.files[oe]};function Z(oe){return"[object RegExp]"===Object.prototype.toString.call(oe)}var ie={load:function(){throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")},forEach:function(oe){var Fe,Se,Te;for(Fe in this.files)Te=this.files[Fe],(Se=Fe.slice(this.root.length,Fe.length))&&Fe.slice(0,this.root.length)===this.root&&oe(Se,Te)},filter:function(oe){var Fe=[];return this.forEach(function(Se,Te){oe(Se,Te)&&Fe.push(Te)}),Fe},file:function(oe,Fe,Se){if(1!==arguments.length)return U.call(this,oe=this.root+oe,Fe,Se),this;if(Z(oe)){var Te=oe;return this.filter(function(Oe,me){return!me.dir&&Te.test(Oe)})}var de=this.files[this.root+oe];return de&&!de.dir?de:null},folder:function(oe){if(!oe)return this;if(Z(oe))return this.filter(function(de,Oe){return Oe.dir&&oe.test(de)});var Se=L.call(this,this.root+oe),Te=this.clone();return Te.root=Se.name,Te},remove:function(oe){var Fe=this.files[oe=this.root+oe];if(Fe||("/"!==oe.slice(-1)&&(oe+="/"),Fe=this.files[oe]),Fe&&!Fe.dir)delete this.files[oe];else for(var Se=this.filter(function(de,Oe){return Oe.name.slice(0,oe.length)===oe}),Te=0;Te<Se.length;Te++)delete this.files[Se[Te].name];return this},generate:function(){throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")},generateInternalStream:function(oe){var Fe,Se={};try{if((Se=F.extend(oe||{},{streamFiles:!1,compression:"STORE",compressionOptions:null,type:"",platform:"DOS",comment:null,mimeType:"application/zip",encodeFileName:M.utf8encode})).type=Se.type.toLowerCase(),Se.compression=Se.compression.toUpperCase(),"binarystring"===Se.type&&(Se.type="string"),!Se.type)throw new Error("No output type specified.");F.checkSupport(Se.type),"darwin"!==Se.platform&&"freebsd"!==Se.platform&&"linux"!==Se.platform&&"sunos"!==Se.platform||(Se.platform="UNIX"),"win32"===Se.platform&&(Se.platform="DOS"),Fe=I.generateWorker(this,Se,Se.comment||this.comment||"")}catch(de){(Fe=new P("error")).error(de)}return new G(Fe,Se.type||"string",Se.mimeType)},generateAsync:function(oe,Fe){return this.generateInternalStream(oe).accumulate(Fe)},generateNodeStream:function(oe,Fe){return(oe=oe||{}).type||(oe.type="nodebuffer"),this.generateInternalStream(oe).toNodejsStream(Fe)}};ne.exports=ie},{"./compressedObject":2,"./defaults":5,"./generate":9,"./nodejs/NodejsStreamInputAdapter":12,"./nodejsUtils":14,"./stream/GenericWorker":28,"./stream/StreamHelper":29,"./utf8":31,"./utils":32,"./zipObject":35}],16:[function(q,ne,X){"use strict";ne.exports=q("stream")},{stream:void 0}],17:[function(q,ne,X){"use strict";var U=q("./DataReader");function M(F){U.call(this,F);for(var P=0;P<this.data.length;P++)F[P]=255&F[P]}q("../utils").inherits(M,U),M.prototype.byteAt=function(F){return this.data[this.zero+F]},M.prototype.lastIndexOfSignature=function(F){for(var P=F.charCodeAt(0),G=F.charCodeAt(1),j=F.charCodeAt(2),B=F.charCodeAt(3),T=this.length-4;0<=T;--T)if(this.data[T]===P&&this.data[T+1]===G&&this.data[T+2]===j&&this.data[T+3]===B)return T-this.zero;return-1},M.prototype.readAndCheckSignature=function(F){var P=F.charCodeAt(0),G=F.charCodeAt(1),j=F.charCodeAt(2),B=F.charCodeAt(3),T=this.readData(4);return P===T[0]&&G===T[1]&&j===T[2]&&B===T[3]},M.prototype.readData=function(F){if(this.checkOffset(F),0===F)return[];var P=this.data.slice(this.zero+this.index,this.zero+this.index+F);return this.index+=F,P},ne.exports=M},{"../utils":32,"./DataReader":18}],18:[function(q,ne,X){"use strict";var U=q("../utils");function M(F){this.data=F,this.length=F.length,this.index=0,this.zero=0}M.prototype={checkOffset:function(F){this.checkIndex(this.index+F)},checkIndex:function(F){if(this.length<this.zero+F||F<0)throw new Error("End of data reached (data length = "+this.length+", asked index = "+F+"). Corrupted zip ?")},setIndex:function(F){this.checkIndex(F),this.index=F},skip:function(F){this.setIndex(this.index+F)},byteAt:function(){},readInt:function(F){var P,G=0;for(this.checkOffset(F),P=this.index+F-1;P>=this.index;P--)G=(G<<8)+this.byteAt(P);return this.index+=F,G},readString:function(F){return U.transformTo("string",this.readData(F))},readData:function(){},lastIndexOfSignature:function(){},readAndCheckSignature:function(){},readDate:function(){var F=this.readInt(4);return new Date(Date.UTC(1980+(F>>25&127),(F>>21&15)-1,F>>16&31,F>>11&31,F>>5&63,(31&F)<<1))}},ne.exports=M},{"../utils":32}],19:[function(q,ne,X){"use strict";var U=q("./Uint8ArrayReader");function M(F){U.call(this,F)}q("../utils").inherits(M,U),M.prototype.readData=function(F){this.checkOffset(F);var P=this.data.slice(this.zero+this.index,this.zero+this.index+F);return this.index+=F,P},ne.exports=M},{"../utils":32,"./Uint8ArrayReader":21}],20:[function(q,ne,X){"use strict";var U=q("./DataReader");function M(F){U.call(this,F)}q("../utils").inherits(M,U),M.prototype.byteAt=function(F){return this.data.charCodeAt(this.zero+F)},M.prototype.lastIndexOfSignature=function(F){return this.data.lastIndexOf(F)-this.zero},M.prototype.readAndCheckSignature=function(F){return F===this.readData(4)},M.prototype.readData=function(F){this.checkOffset(F);var P=this.data.slice(this.zero+this.index,this.zero+this.index+F);return this.index+=F,P},ne.exports=M},{"../utils":32,"./DataReader":18}],21:[function(q,ne,X){"use strict";var U=q("./ArrayReader");function M(F){U.call(this,F)}q("../utils").inherits(M,U),M.prototype.readData=function(F){if(this.checkOffset(F),0===F)return new Uint8Array(0);var P=this.data.subarray(this.zero+this.index,this.zero+this.index+F);return this.index+=F,P},ne.exports=M},{"../utils":32,"./ArrayReader":17}],22:[function(q,ne,X){"use strict";var U=q("../utils"),M=q("../support"),F=q("./ArrayReader"),P=q("./StringReader"),G=q("./NodeBufferReader"),j=q("./Uint8ArrayReader");ne.exports=function(B){var T=U.getTypeOf(B);return U.checkSupport(T),"string"!==T||M.uint8array?"nodebuffer"===T?new G(B):M.uint8array?new j(U.transformTo("uint8array",B)):new F(U.transformTo("array",B)):new P(B)}},{"../support":30,"../utils":32,"./ArrayReader":17,"./NodeBufferReader":19,"./StringReader":20,"./Uint8ArrayReader":21}],23:[function(q,ne,X){"use strict";X.LOCAL_FILE_HEADER="PK\x03\x04",X.CENTRAL_FILE_HEADER="PK\x01\x02",X.CENTRAL_DIRECTORY_END="PK\x05\x06",X.ZIP64_CENTRAL_DIRECTORY_LOCATOR="PK\x06\x07",X.ZIP64_CENTRAL_DIRECTORY_END="PK\x06\x06",X.DATA_DESCRIPTOR="PK\x07\b"},{}],24:[function(q,ne,X){"use strict";var U=q("./GenericWorker"),M=q("../utils");function F(P){U.call(this,"ConvertWorker to "+P),this.destType=P}M.inherits(F,U),F.prototype.processChunk=function(P){this.push({data:M.transformTo(this.destType,P.data),meta:P.meta})},ne.exports=F},{"../utils":32,"./GenericWorker":28}],25:[function(q,ne,X){"use strict";var U=q("./GenericWorker"),M=q("../crc32");function F(){U.call(this,"Crc32Probe"),this.withStreamInfo("crc32",0)}q("../utils").inherits(F,U),F.prototype.processChunk=function(P){this.streamInfo.crc32=M(P.data,this.streamInfo.crc32||0),this.push(P)},ne.exports=F},{"../crc32":4,"../utils":32,"./GenericWorker":28}],26:[function(q,ne,X){"use strict";var U=q("../utils"),M=q("./GenericWorker");function F(P){M.call(this,"DataLengthProbe for "+P),this.propName=P,this.withStreamInfo(P,0)}U.inherits(F,M),F.prototype.processChunk=function(P){P&&(this.streamInfo[this.propName]=(this.streamInfo[this.propName]||0)+P.data.length),M.prototype.processChunk.call(this,P)},ne.exports=F},{"../utils":32,"./GenericWorker":28}],27:[function(q,ne,X){"use strict";var U=q("../utils"),M=q("./GenericWorker");function F(P){M.call(this,"DataWorker");var G=this;this.dataIsReady=!1,this.index=0,this.max=0,this.data=null,this.type="",this._tickScheduled=!1,P.then(function(j){G.dataIsReady=!0,G.data=j,G.max=j&&j.length||0,G.type=U.getTypeOf(j),G.isPaused||G._tickAndRepeat()},function(j){G.error(j)})}U.inherits(F,M),F.prototype.cleanUp=function(){M.prototype.cleanUp.call(this),this.data=null},F.prototype.resume=function(){return!!M.prototype.resume.call(this)&&(!this._tickScheduled&&this.dataIsReady&&(this._tickScheduled=!0,U.delay(this._tickAndRepeat,[],this)),!0)},F.prototype._tickAndRepeat=function(){this._tickScheduled=!1,this.isPaused||this.isFinished||(this._tick(),this.isFinished||(U.delay(this._tickAndRepeat,[],this),this._tickScheduled=!0))},F.prototype._tick=function(){if(this.isPaused||this.isFinished)return!1;var P=null,G=Math.min(this.max,this.index+16384);if(this.index>=this.max)return this.end();switch(this.type){case"string":P=this.data.substring(this.index,G);break;case"uint8array":P=this.data.subarray(this.index,G);break;case"array":case"nodebuffer":P=this.data.slice(this.index,G)}return this.index=G,this.push({data:P,meta:{percent:this.max?this.index/this.max*100:0}})},ne.exports=F},{"../utils":32,"./GenericWorker":28}],28:[function(q,ne,X){"use strict";function U(M){this.name=M||"default",this.streamInfo={},this.generatedError=null,this.extraStreamInfo={},this.isPaused=!0,this.isFinished=!1,this.isLocked=!1,this._listeners={data:[],end:[],error:[]},this.previous=null}U.prototype={push:function(M){this.emit("data",M)},end:function(){if(this.isFinished)return!1;this.flush();try{this.emit("end"),this.cleanUp(),this.isFinished=!0}catch(M){this.emit("error",M)}return!0},error:function(M){return!this.isFinished&&(this.isPaused?this.generatedError=M:(this.isFinished=!0,this.emit("error",M),this.previous&&this.previous.error(M),this.cleanUp()),!0)},on:function(M,F){return this._listeners[M].push(F),this},cleanUp:function(){this.streamInfo=this.generatedError=this.extraStreamInfo=null,this._listeners=[]},emit:function(M,F){if(this._listeners[M])for(var P=0;P<this._listeners[M].length;P++)this._listeners[M][P].call(this,F)},pipe:function(M){return M.registerPrevious(this)},registerPrevious:function(M){if(this.isLocked)throw new Error("The stream '"+this+"' has already been used.");this.streamInfo=M.streamInfo,this.mergeStreamInfo(),this.previous=M;var F=this;return M.on("data",function(P){F.processChunk(P)}),M.on("end",function(){F.end()}),M.on("error",function(P){F.error(P)}),this},pause:function(){return!this.isPaused&&!this.isFinished&&(this.isPaused=!0,this.previous&&this.previous.pause(),!0)},resume:function(){if(!this.isPaused||this.isFinished)return!1;var M=this.isPaused=!1;return this.generatedError&&(this.error(this.generatedError),M=!0),this.previous&&this.previous.resume(),!M},flush:function(){},processChunk:function(M){this.push(M)},withStreamInfo:function(M,F){return this.extraStreamInfo[M]=F,this.mergeStreamInfo(),this},mergeStreamInfo:function(){for(var M in this.extraStreamInfo)Object.prototype.hasOwnProperty.call(this.extraStreamInfo,M)&&(this.streamInfo[M]=this.extraStreamInfo[M])},lock:function(){if(this.isLocked)throw new Error("The stream '"+this+"' has already been used.");this.isLocked=!0,this.previous&&this.previous.lock()},toString:function(){var M="Worker "+this.name;return this.previous?this.previous+" -> "+M:M}},ne.exports=U},{}],29:[function(q,ne,X){"use strict";var U=q("../utils"),M=q("./ConvertWorker"),F=q("./GenericWorker"),P=q("../base64"),G=q("../support"),j=q("../external"),B=null;if(G.nodestream)try{B=q("../nodejs/NodejsStreamOutputAdapter")}catch{}function I(A,S,D){var N=S;switch(S){case"blob":case"arraybuffer":N="uint8array";break;case"base64":N="string"}try{this._internalType=N,this._outputType=S,this._mimeType=D,U.checkSupport(N),this._worker=A.pipe(new M(N)),A.lock()}catch(L){this._worker=new F("error"),this._worker.error(L)}}I.prototype={accumulate:function(A){return function T(A,S){return new j.Promise(function(D,N){var L=[],Z=A._internalType,ie=A._outputType,oe=A._mimeType;A.on("data",function(Fe,Se){L.push(Fe),S&&S(Se)}).on("error",function(Fe){L=[],N(Fe)}).on("end",function(){try{var Fe=function(Se,Te,de){switch(Se){case"blob":return U.newBlob(U.transformTo("arraybuffer",Te),de);case"base64":return P.encode(Te);default:return U.transformTo(Se,Te)}}(ie,function(Se,Te){var de,Oe=0,me=null,O=0;for(de=0;de<Te.length;de++)O+=Te[de].length;switch(Se){case"string":return Te.join("");case"array":return Array.prototype.concat.apply([],Te);case"uint8array":for(me=new Uint8Array(O),de=0;de<Te.length;de++)me.set(Te[de],Oe),Oe+=Te[de].length;return me;case"nodebuffer":return Buffer.concat(Te);default:throw new Error("concat : unsupported type '"+Se+"'")}}(Z,L),oe);D(Fe)}catch(Se){N(Se)}L=[]}).resume()})}(this,A)},on:function(A,S){var D=this;return this._worker.on(A,"data"===A?function(N){S.call(D,N.data,N.meta)}:function(){U.delay(S,arguments,D)}),this},resume:function(){return U.delay(this._worker.resume,[],this._worker),this},pause:function(){return this._worker.pause(),this},toNodejsStream:function(A){if(U.checkSupport("nodestream"),"nodebuffer"!==this._outputType)throw new Error(this._outputType+" is not supported by this method");return new B(this,{objectMode:"nodebuffer"!==this._outputType},A)}},ne.exports=I},{"../base64":1,"../external":6,"../nodejs/NodejsStreamOutputAdapter":13,"../support":30,"../utils":32,"./ConvertWorker":24,"./GenericWorker":28}],30:[function(q,ne,X){"use strict";if(X.base64=!0,X.array=!0,X.string=!0,X.arraybuffer=typeof ArrayBuffer<"u"&&typeof Uint8Array<"u",X.nodebuffer=typeof Buffer<"u",X.uint8array=typeof Uint8Array<"u",typeof ArrayBuffer>"u")X.blob=!1;else{var U=new ArrayBuffer(0);try{X.blob=0===new Blob([U],{type:"application/zip"}).size}catch{try{var M=new(self.BlobBuilder||self.WebKitBlobBuilder||self.MozBlobBuilder||self.MSBlobBuilder);M.append(U),X.blob=0===M.getBlob("application/zip").size}catch{X.blob=!1}}}try{X.nodestream=!!q("readable-stream").Readable}catch{X.nodestream=!1}},{"readable-stream":16}],31:[function(q,ne,X){"use strict";for(var U=q("./utils"),M=q("./support"),F=q("./nodejsUtils"),P=q("./stream/GenericWorker"),G=new Array(256),j=0;j<256;j++)G[j]=252<=j?6:248<=j?5:240<=j?4:224<=j?3:192<=j?2:1;function B(){P.call(this,"utf-8 decode"),this.leftOver=null}function T(){P.call(this,"utf-8 encode")}G[254]=G[254]=1,X.utf8encode=function(I){return M.nodebuffer?F.newBufferFrom(I,"utf-8"):function(A){var S,D,N,L,Z,ie=A.length,oe=0;for(L=0;L<ie;L++)55296==(64512&(D=A.charCodeAt(L)))&&L+1<ie&&56320==(64512&(N=A.charCodeAt(L+1)))&&(D=65536+(D-55296<<10)+(N-56320),L++),oe+=D<128?1:D<2048?2:D<65536?3:4;for(S=M.uint8array?new Uint8Array(oe):new Array(oe),L=Z=0;Z<oe;L++)55296==(64512&(D=A.charCodeAt(L)))&&L+1<ie&&56320==(64512&(N=A.charCodeAt(L+1)))&&(D=65536+(D-55296<<10)+(N-56320),L++),D<128?S[Z++]=D:(D<2048?S[Z++]=192|D>>>6:(D<65536?S[Z++]=224|D>>>12:(S[Z++]=240|D>>>18,S[Z++]=128|D>>>12&63),S[Z++]=128|D>>>6&63),S[Z++]=128|63&D);return S}(I)},X.utf8decode=function(I){return M.nodebuffer?U.transformTo("nodebuffer",I).toString("utf-8"):function(A){var S,D,N,L,Z=A.length,ie=new Array(2*Z);for(S=D=0;S<Z;)if((N=A[S++])<128)ie[D++]=N;else if(4<(L=G[N]))ie[D++]=65533,S+=L-1;else{for(N&=2===L?31:3===L?15:7;1<L&&S<Z;)N=N<<6|63&A[S++],L--;1<L?ie[D++]=65533:N<65536?ie[D++]=N:(ie[D++]=55296|(N-=65536)>>10&1023,ie[D++]=56320|1023&N)}return ie.length!==D&&(ie.subarray?ie=ie.subarray(0,D):ie.length=D),U.applyFromCharCode(ie)}(I=U.transformTo(M.uint8array?"uint8array":"array",I))},U.inherits(B,P),B.prototype.processChunk=function(I){var A=U.transformTo(M.uint8array?"uint8array":"array",I.data);if(this.leftOver&&this.leftOver.length){if(M.uint8array){var S=A;(A=new Uint8Array(S.length+this.leftOver.length)).set(this.leftOver,0),A.set(S,this.leftOver.length)}else A=this.leftOver.concat(A);this.leftOver=null}var D=function(L,Z){var ie;for((Z=Z||L.length)>L.length&&(Z=L.length),ie=Z-1;0<=ie&&128==(192&L[ie]);)ie--;return ie<0||0===ie?Z:ie+G[L[ie]]>Z?ie:Z}(A),N=A;D!==A.length&&(M.uint8array?(N=A.subarray(0,D),this.leftOver=A.subarray(D,A.length)):(N=A.slice(0,D),this.leftOver=A.slice(D,A.length))),this.push({data:X.utf8decode(N),meta:I.meta})},B.prototype.flush=function(){this.leftOver&&this.leftOver.length&&(this.push({data:X.utf8decode(this.leftOver),meta:{}}),this.leftOver=null)},X.Utf8DecodeWorker=B,U.inherits(T,P),T.prototype.processChunk=function(I){this.push({data:X.utf8encode(I.data),meta:I.meta})},X.Utf8EncodeWorker=T},{"./nodejsUtils":14,"./stream/GenericWorker":28,"./support":30,"./utils":32}],32:[function(q,ne,X){"use strict";var U=q("./support"),M=q("./base64"),F=q("./nodejsUtils"),P=q("./external");function G(S){return S}function j(S,D){for(var N=0;N<S.length;++N)D[N]=255&S.charCodeAt(N);return D}q("setimmediate"),X.newBlob=function(S,D){X.checkSupport("blob");try{return new Blob([S],{type:D})}catch{try{var N=new(self.BlobBuilder||self.WebKitBlobBuilder||self.MozBlobBuilder||self.MSBlobBuilder);return N.append(S),N.getBlob(D)}catch{throw new Error("Bug : can't construct the Blob.")}}};var B={stringifyByChunk:function(S,D,N){var L=[],Z=0,ie=S.length;if(ie<=N)return String.fromCharCode.apply(null,S);for(;Z<ie;)L.push(String.fromCharCode.apply(null,"array"===D||"nodebuffer"===D?S.slice(Z,Math.min(Z+N,ie)):S.subarray(Z,Math.min(Z+N,ie)))),Z+=N;return L.join("")},stringifyByChar:function(S){for(var D="",N=0;N<S.length;N++)D+=String.fromCharCode(S[N]);return D},applyCanBeUsed:{uint8array:function(){try{return U.uint8array&&1===String.fromCharCode.apply(null,new Uint8Array(1)).length}catch{return!1}}(),nodebuffer:function(){try{return U.nodebuffer&&1===String.fromCharCode.apply(null,F.allocBuffer(1)).length}catch{return!1}}()}};function T(S){var D=65536,N=X.getTypeOf(S),L=!0;if("uint8array"===N?L=B.applyCanBeUsed.uint8array:"nodebuffer"===N&&(L=B.applyCanBeUsed.nodebuffer),L)for(;1<D;)try{return B.stringifyByChunk(S,N,D)}catch{D=Math.floor(D/2)}return B.stringifyByChar(S)}function I(S,D){for(var N=0;N<S.length;N++)D[N]=S[N];return D}X.applyFromCharCode=T;var A={};A.string={string:G,array:function(S){return j(S,new Array(S.length))},arraybuffer:function(S){return A.string.uint8array(S).buffer},uint8array:function(S){return j(S,new Uint8Array(S.length))},nodebuffer:function(S){return j(S,F.allocBuffer(S.length))}},A.array={string:T,array:G,arraybuffer:function(S){return new Uint8Array(S).buffer},uint8array:function(S){return new Uint8Array(S)},nodebuffer:function(S){return F.newBufferFrom(S)}},A.arraybuffer={string:function(S){return T(new Uint8Array(S))},array:function(S){return I(new Uint8Array(S),new Array(S.byteLength))},arraybuffer:G,uint8array:function(S){return new Uint8Array(S)},nodebuffer:function(S){return F.newBufferFrom(new Uint8Array(S))}},A.uint8array={string:T,array:function(S){return I(S,new Array(S.length))},arraybuffer:function(S){return S.buffer},uint8array:G,nodebuffer:function(S){return F.newBufferFrom(S)}},A.nodebuffer={string:T,array:function(S){return I(S,new Array(S.length))},arraybuffer:function(S){return A.nodebuffer.uint8array(S).buffer},uint8array:function(S){return I(S,new Uint8Array(S.length))},nodebuffer:G},X.transformTo=function(S,D){if(D=D||"",!S)return D;X.checkSupport(S);var N=X.getTypeOf(D);return A[N][S](D)},X.resolve=function(S){for(var D=S.split("/"),N=[],L=0;L<D.length;L++){var Z=D[L];"."===Z||""===Z&&0!==L&&L!==D.length-1||(".."===Z?N.pop():N.push(Z))}return N.join("/")},X.getTypeOf=function(S){return"string"==typeof S?"string":"[object Array]"===Object.prototype.toString.call(S)?"array":U.nodebuffer&&F.isBuffer(S)?"nodebuffer":U.uint8array&&S instanceof Uint8Array?"uint8array":U.arraybuffer&&S instanceof ArrayBuffer?"arraybuffer":void 0},X.checkSupport=function(S){if(!U[S.toLowerCase()])throw new Error(S+" is not supported by this platform")},X.MAX_VALUE_16BITS=65535,X.MAX_VALUE_32BITS=-1,X.pretty=function(S){var D,N,L="";for(N=0;N<(S||"").length;N++)L+="\\x"+((D=S.charCodeAt(N))<16?"0":"")+D.toString(16).toUpperCase();return L},X.delay=function(S,D,N){setImmediate(function(){S.apply(N||null,D||[])})},X.inherits=function(S,D){function N(){}N.prototype=D.prototype,S.prototype=new N},X.extend=function(){var S,D,N={};for(S=0;S<arguments.length;S++)for(D in arguments[S])Object.prototype.hasOwnProperty.call(arguments[S],D)&&void 0===N[D]&&(N[D]=arguments[S][D]);return N},X.prepareContent=function(S,D,N,L,Z){return P.Promise.resolve(D).then(function(ie){return U.blob&&(ie instanceof Blob||-1!==["[object File]","[object Blob]"].indexOf(Object.prototype.toString.call(ie)))&&typeof FileReader<"u"?new P.Promise(function(oe,Fe){var Se=new FileReader;Se.onload=function(Te){oe(Te.target.result)},Se.onerror=function(Te){Fe(Te.target.error)},Se.readAsArrayBuffer(ie)}):ie}).then(function(ie){var Fe,oe=X.getTypeOf(ie);return oe?("arraybuffer"===oe?ie=X.transformTo("uint8array",ie):"string"===oe&&(Z?ie=M.decode(ie):N&&!0!==L&&(ie=j(Fe=ie,U.uint8array?new Uint8Array(Fe.length):new Array(Fe.length)))),ie):P.Promise.reject(new Error("Can't read the data of '"+S+"'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"))})}},{"./base64":1,"./external":6,"./nodejsUtils":14,"./support":30,setimmediate:54}],33:[function(q,ne,X){"use strict";var U=q("./reader/readerFor"),M=q("./utils"),F=q("./signature"),P=q("./zipEntry"),G=q("./support");function j(B){this.files=[],this.loadOptions=B}j.prototype={checkSignature:function(B){if(!this.reader.readAndCheckSignature(B)){this.reader.index-=4;var T=this.reader.readString(4);throw new Error("Corrupted zip or bug: unexpected signature ("+M.pretty(T)+", expected "+M.pretty(B)+")")}},isSignature:function(B,T){var I=this.reader.index;this.reader.setIndex(B);var A=this.reader.readString(4)===T;return this.reader.setIndex(I),A},readBlockEndOfCentral:function(){this.diskNumber=this.reader.readInt(2),this.diskWithCentralDirStart=this.reader.readInt(2),this.centralDirRecordsOnThisDisk=this.reader.readInt(2),this.centralDirRecords=this.reader.readInt(2),this.centralDirSize=this.reader.readInt(4),this.centralDirOffset=this.reader.readInt(4),this.zipCommentLength=this.reader.readInt(2);var B=this.reader.readData(this.zipCommentLength),I=M.transformTo(G.uint8array?"uint8array":"array",B);this.zipComment=this.loadOptions.decodeFileName(I)},readBlockZip64EndOfCentral:function(){this.zip64EndOfCentralSize=this.reader.readInt(8),this.reader.skip(4),this.diskNumber=this.reader.readInt(4),this.diskWithCentralDirStart=this.reader.readInt(4),this.centralDirRecordsOnThisDisk=this.reader.readInt(8),this.centralDirRecords=this.reader.readInt(8),this.centralDirSize=this.reader.readInt(8),this.centralDirOffset=this.reader.readInt(8),this.zip64ExtensibleData={};for(var B,T,I,A=this.zip64EndOfCentralSize-44;0<A;)B=this.reader.readInt(2),T=this.reader.readInt(4),I=this.reader.readData(T),this.zip64ExtensibleData[B]={id:B,length:T,value:I}},readBlockZip64EndOfCentralLocator:function(){if(this.diskWithZip64CentralDirStart=this.reader.readInt(4),this.relativeOffsetEndOfZip64CentralDir=this.reader.readInt(8),this.disksCount=this.reader.readInt(4),1<this.disksCount)throw new Error("Multi-volumes zip are not supported")},readLocalFiles:function(){var B,T;for(B=0;B<this.files.length;B++)this.reader.setIndex((T=this.files[B]).localHeaderOffset),this.checkSignature(F.LOCAL_FILE_HEADER),T.readLocalPart(this.reader),T.handleUTF8(),T.processAttributes()},readCentralDir:function(){var B;for(this.reader.setIndex(this.centralDirOffset);this.reader.readAndCheckSignature(F.CENTRAL_FILE_HEADER);)(B=new P({zip64:this.zip64},this.loadOptions)).readCentralPart(this.reader),this.files.push(B);if(this.centralDirRecords!==this.files.length&&0!==this.centralDirRecords&&0===this.files.length)throw new Error("Corrupted zip or bug: expected "+this.centralDirRecords+" records in central dir, got "+this.files.length)},readEndOfCentral:function(){var B=this.reader.lastIndexOfSignature(F.CENTRAL_DIRECTORY_END);if(B<0)throw this.isSignature(0,F.LOCAL_FILE_HEADER)?new Error("Corrupted zip: can't find end of central directory"):new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");this.reader.setIndex(B);var T=B;if(this.checkSignature(F.CENTRAL_DIRECTORY_END),this.readBlockEndOfCentral(),this.diskNumber===M.MAX_VALUE_16BITS||this.diskWithCentralDirStart===M.MAX_VALUE_16BITS||this.centralDirRecordsOnThisDisk===M.MAX_VALUE_16BITS||this.centralDirRecords===M.MAX_VALUE_16BITS||this.centralDirSize===M.MAX_VALUE_32BITS||this.centralDirOffset===M.MAX_VALUE_32BITS){if(this.zip64=!0,(B=this.reader.lastIndexOfSignature(F.ZIP64_CENTRAL_DIRECTORY_LOCATOR))<0)throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");if(this.reader.setIndex(B),this.checkSignature(F.ZIP64_CENTRAL_DIRECTORY_LOCATOR),this.readBlockZip64EndOfCentralLocator(),!this.isSignature(this.relativeOffsetEndOfZip64CentralDir,F.ZIP64_CENTRAL_DIRECTORY_END)&&(this.relativeOffsetEndOfZip64CentralDir=this.reader.lastIndexOfSignature(F.ZIP64_CENTRAL_DIRECTORY_END),this.relativeOffsetEndOfZip64CentralDir<0))throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir),this.checkSignature(F.ZIP64_CENTRAL_DIRECTORY_END),this.readBlockZip64EndOfCentral()}var I=this.centralDirOffset+this.centralDirSize;this.zip64&&(I+=20,I+=12+this.zip64EndOfCentralSize);var A=T-I;if(0<A)this.isSignature(T,F.CENTRAL_FILE_HEADER)||(this.reader.zero=A);else if(A<0)throw new Error("Corrupted zip: missing "+Math.abs(A)+" bytes.")},prepareReader:function(B){this.reader=U(B)},load:function(B){this.prepareReader(B),this.readEndOfCentral(),this.readCentralDir(),this.readLocalFiles()}},ne.exports=j},{"./reader/readerFor":22,"./signature":23,"./support":30,"./utils":32,"./zipEntry":34}],34:[function(q,ne,X){"use strict";var U=q("./reader/readerFor"),M=q("./utils"),F=q("./compressedObject"),P=q("./crc32"),G=q("./utf8"),j=q("./compressions"),B=q("./support");function T(I,A){this.options=I,this.loadOptions=A}T.prototype={isEncrypted:function(){return 1==(1&this.bitFlag)},useUTF8:function(){return 2048==(2048&this.bitFlag)},readLocalPart:function(I){var A,S;if(I.skip(22),this.fileNameLength=I.readInt(2),S=I.readInt(2),this.fileName=I.readData(this.fileNameLength),I.skip(S),-1===this.compressedSize||-1===this.uncompressedSize)throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");if(null===(A=function(D){for(var N in j)if(Object.prototype.hasOwnProperty.call(j,N)&&j[N].magic===D)return j[N];return null}(this.compressionMethod)))throw new Error("Corrupted zip : compression "+M.pretty(this.compressionMethod)+" unknown (inner file : "+M.transformTo("string",this.fileName)+")");this.decompressed=new F(this.compressedSize,this.uncompressedSize,this.crc32,A,I.readData(this.compressedSize))},readCentralPart:function(I){this.versionMadeBy=I.readInt(2),I.skip(2),this.bitFlag=I.readInt(2),this.compressionMethod=I.readString(2),this.date=I.readDate(),this.crc32=I.readInt(4),this.compressedSize=I.readInt(4),this.uncompressedSize=I.readInt(4);var A=I.readInt(2);if(this.extraFieldsLength=I.readInt(2),this.fileCommentLength=I.readInt(2),this.diskNumberStart=I.readInt(2),this.internalFileAttributes=I.readInt(2),this.externalFileAttributes=I.readInt(4),this.localHeaderOffset=I.readInt(4),this.isEncrypted())throw new Error("Encrypted zip are not supported");I.skip(A),this.readExtraFields(I),this.parseZIP64ExtraField(I),this.fileComment=I.readData(this.fileCommentLength)},processAttributes:function(){this.unixPermissions=null,this.dosPermissions=null;var I=this.versionMadeBy>>8;this.dir=!!(16&this.externalFileAttributes),0==I&&(this.dosPermissions=63&this.externalFileAttributes),3==I&&(this.unixPermissions=this.externalFileAttributes>>16&65535),this.dir||"/"!==this.fileNameStr.slice(-1)||(this.dir=!0)},parseZIP64ExtraField:function(){if(this.extraFields[1]){var I=U(this.extraFields[1].value);this.uncompressedSize===M.MAX_VALUE_32BITS&&(this.uncompressedSize=I.readInt(8)),this.compressedSize===M.MAX_VALUE_32BITS&&(this.compressedSize=I.readInt(8)),this.localHeaderOffset===M.MAX_VALUE_32BITS&&(this.localHeaderOffset=I.readInt(8)),this.diskNumberStart===M.MAX_VALUE_32BITS&&(this.diskNumberStart=I.readInt(4))}},readExtraFields:function(I){var A,S,D,N=I.index+this.extraFieldsLength;for(this.extraFields||(this.extraFields={});I.index+4<N;)A=I.readInt(2),S=I.readInt(2),D=I.readData(S),this.extraFields[A]={id:A,length:S,value:D};I.setIndex(N)},handleUTF8:function(){var I=B.uint8array?"uint8array":"array";if(this.useUTF8())this.fileNameStr=G.utf8decode(this.fileName),this.fileCommentStr=G.utf8decode(this.fileComment);else{var A=this.findExtraFieldUnicodePath();if(null!==A)this.fileNameStr=A;else{var S=M.transformTo(I,this.fileName);this.fileNameStr=this.loadOptions.decodeFileName(S)}var D=this.findExtraFieldUnicodeComment();if(null!==D)this.fileCommentStr=D;else{var N=M.transformTo(I,this.fileComment);this.fileCommentStr=this.loadOptions.decodeFileName(N)}}},findExtraFieldUnicodePath:function(){var I=this.extraFields[28789];if(I){var A=U(I.value);return 1!==A.readInt(1)||P(this.fileName)!==A.readInt(4)?null:G.utf8decode(A.readData(I.length-5))}return null},findExtraFieldUnicodeComment:function(){var I=this.extraFields[25461];if(I){var A=U(I.value);return 1!==A.readInt(1)||P(this.fileComment)!==A.readInt(4)?null:G.utf8decode(A.readData(I.length-5))}return null}},ne.exports=T},{"./compressedObject":2,"./compressions":3,"./crc32":4,"./reader/readerFor":22,"./support":30,"./utf8":31,"./utils":32}],35:[function(q,ne,X){"use strict";function U(A,S,D){this.name=A,this.dir=D.dir,this.date=D.date,this.comment=D.comment,this.unixPermissions=D.unixPermissions,this.dosPermissions=D.dosPermissions,this._data=S,this._dataBinary=D.binary,this.options={compression:D.compression,compressionOptions:D.compressionOptions}}var M=q("./stream/StreamHelper"),F=q("./stream/DataWorker"),P=q("./utf8"),G=q("./compressedObject"),j=q("./stream/GenericWorker");U.prototype={internalStream:function(A){var S=null,D="string";try{if(!A)throw new Error("No output type specified.");var N="string"===(D=A.toLowerCase())||"text"===D;"binarystring"!==D&&"text"!==D||(D="string"),S=this._decompressWorker();var L=!this._dataBinary;L&&!N&&(S=S.pipe(new P.Utf8EncodeWorker)),!L&&N&&(S=S.pipe(new P.Utf8DecodeWorker))}catch(Z){(S=new j("error")).error(Z)}return new M(S,D,"")},async:function(A,S){return this.internalStream(A).accumulate(S)},nodeStream:function(A,S){return this.internalStream(A||"nodebuffer").toNodejsStream(S)},_compressWorker:function(A,S){if(this._data instanceof G&&this._data.compression.magic===A.magic)return this._data.getCompressedWorker();var D=this._decompressWorker();return this._dataBinary||(D=D.pipe(new P.Utf8EncodeWorker)),G.createWorkerFrom(D,A,S)},_decompressWorker:function(){return this._data instanceof G?this._data.getContentWorker():this._data instanceof j?this._data:new F(this._data)}};for(var B=["asText","asBinary","asNodeBuffer","asUint8Array","asArrayBuffer"],T=function(){throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")},I=0;I<B.length;I++)U.prototype[B[I]]=T;ne.exports=U},{"./compressedObject":2,"./stream/DataWorker":27,"./stream/GenericWorker":28,"./stream/StreamHelper":29,"./utf8":31}],36:[function(q,ne,X){(function(U){"use strict";var M,F,P=U.MutationObserver||U.WebKitMutationObserver;if(P){var G=0,j=new P(A),B=U.document.createTextNode("");j.observe(B,{characterData:!0}),M=function(){B.data=G=++G%2}}else if(U.setImmediate||void 0===U.MessageChannel)M="document"in U&&"onreadystatechange"in U.document.createElement("script")?function(){var S=U.document.createElement("script");S.onreadystatechange=function(){A(),S.onreadystatechange=null,S.parentNode.removeChild(S),S=null},U.document.documentElement.appendChild(S)}:function(){setTimeout(A,0)};else{var T=new U.MessageChannel;T.port1.onmessage=A,M=function(){T.port2.postMessage(0)}}var I=[];function A(){var S,D;F=!0;for(var N=I.length;N;){for(D=I,I=[],S=-1;++S<N;)D[S]();N=I.length}F=!1}ne.exports=function(S){1!==I.push(S)||F||M()}}).call(this,typeof global<"u"?global:typeof self<"u"?self:typeof window<"u"?window:{})},{}],37:[function(q,ne,X){"use strict";var U=q("immediate");function M(){}var F={},P=["REJECTED"],G=["FULFILLED"],j=["PENDING"];function B(N){if("function"!=typeof N)throw new TypeError("resolver must be a function");this.state=j,this.queue=[],this.outcome=void 0,N!==M&&S(this,N)}function T(N,L,Z){this.promise=N,"function"==typeof L&&(this.onFulfilled=L,this.callFulfilled=this.otherCallFulfilled),"function"==typeof Z&&(this.onRejected=Z,this.callRejected=this.otherCallRejected)}function I(N,L,Z){U(function(){var ie;try{ie=L(Z)}catch(oe){return F.reject(N,oe)}ie===N?F.reject(N,new TypeError("Cannot resolve promise with itself")):F.resolve(N,ie)})}function A(N){var L=N&&N.then;if(N&&("object"==typeof N||"function"==typeof N)&&"function"==typeof L)return function(){L.apply(N,arguments)}}function S(N,L){var Z=!1;function ie(Se){Z||(Z=!0,F.reject(N,Se))}function oe(Se){Z||(Z=!0,F.resolve(N,Se))}var Fe=D(function(){L(oe,ie)});"error"===Fe.status&&ie(Fe.value)}function D(N,L){var Z={};try{Z.value=N(L),Z.status="success"}catch(ie){Z.status="error",Z.value=ie}return Z}(ne.exports=B).prototype.finally=function(N){if("function"!=typeof N)return this;var L=this.constructor;return this.then(function(Z){return L.resolve(N()).then(function(){return Z})},function(Z){return L.resolve(N()).then(function(){throw Z})})},B.prototype.catch=function(N){return this.then(null,N)},B.prototype.then=function(N,L){if("function"!=typeof N&&this.state===G||"function"!=typeof L&&this.state===P)return this;var Z=new this.constructor(M);return this.state!==j?I(Z,this.state===G?N:L,this.outcome):this.queue.push(new T(Z,N,L)),Z},T.prototype.callFulfilled=function(N){F.resolve(this.promise,N)},T.prototype.otherCallFulfilled=function(N){I(this.promise,this.onFulfilled,N)},T.prototype.callRejected=function(N){F.reject(this.promise,N)},T.prototype.otherCallRejected=function(N){I(this.promise,this.onRejected,N)},F.resolve=function(N,L){var Z=D(A,L);if("error"===Z.status)return F.reject(N,Z.value);var ie=Z.value;if(ie)S(N,ie);else{N.state=G,N.outcome=L;for(var oe=-1,Fe=N.queue.length;++oe<Fe;)N.queue[oe].callFulfilled(L)}return N},F.reject=function(N,L){N.state=P,N.outcome=L;for(var Z=-1,ie=N.queue.length;++Z<ie;)N.queue[Z].callRejected(L);return N},B.resolve=function(N){return N instanceof this?N:F.resolve(new this(M),N)},B.reject=function(N){var L=new this(M);return F.reject(L,N)},B.all=function(N){var L=this;if("[object Array]"!==Object.prototype.toString.call(N))return this.reject(new TypeError("must be an array"));var Z=N.length,ie=!1;if(!Z)return this.resolve([]);for(var oe=new Array(Z),Fe=0,Se=-1,Te=new this(M);++Se<Z;)de(N[Se],Se);return Te;function de(Oe,me){L.resolve(Oe).then(function(O){oe[me]=O,++Fe!==Z||ie||(ie=!0,F.resolve(Te,oe))},function(O){ie||(ie=!0,F.reject(Te,O))})}},B.race=function(N){if("[object Array]"!==Object.prototype.toString.call(N))return this.reject(new TypeError("must be an array"));var Z=N.length,ie=!1;if(!Z)return this.resolve([]);for(var oe=-1,Fe=new this(M);++oe<Z;)this.resolve(N[oe]).then(function(Te){ie||(ie=!0,F.resolve(Fe,Te))},function(Te){ie||(ie=!0,F.reject(Fe,Te))});return Fe}},{immediate:36}],38:[function(q,ne,X){"use strict";var U={};(0,q("./lib/utils/common").assign)(U,q("./lib/deflate"),q("./lib/inflate"),q("./lib/zlib/constants")),ne.exports=U},{"./lib/deflate":39,"./lib/inflate":40,"./lib/utils/common":41,"./lib/zlib/constants":44}],39:[function(q,ne,X){"use strict";var U=q("./zlib/deflate"),M=q("./utils/common"),F=q("./utils/strings"),P=q("./zlib/messages"),G=q("./zlib/zstream"),j=Object.prototype.toString,B=0,T=-1,I=0,A=8;function S(N){if(!(this instanceof S))return new S(N);this.options=M.assign({level:T,method:A,chunkSize:16384,windowBits:15,memLevel:8,strategy:I,to:""},N||{});var L=this.options;L.raw&&0<L.windowBits?L.windowBits=-L.windowBits:L.gzip&&0<L.windowBits&&L.windowBits<16&&(L.windowBits+=16),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new G,this.strm.avail_out=0;var Z=U.deflateInit2(this.strm,L.level,L.method,L.windowBits,L.memLevel,L.strategy);if(Z!==B)throw new Error(P[Z]);if(L.header&&U.deflateSetHeader(this.strm,L.header),L.dictionary){var ie;if(ie="string"==typeof L.dictionary?F.string2buf(L.dictionary):"[object ArrayBuffer]"===j.call(L.dictionary)?new Uint8Array(L.dictionary):L.dictionary,(Z=U.deflateSetDictionary(this.strm,ie))!==B)throw new Error(P[Z]);this._dict_set=!0}}function D(N,L){var Z=new S(L);if(Z.push(N,!0),Z.err)throw Z.msg||P[Z.err];return Z.result}S.prototype.push=function(N,L){var Z,ie,oe=this.strm,Fe=this.options.chunkSize;if(this.ended)return!1;ie=L===~~L?L:!0===L?4:0,oe.input="string"==typeof N?F.string2buf(N):"[object ArrayBuffer]"===j.call(N)?new Uint8Array(N):N,oe.next_in=0,oe.avail_in=oe.input.length;do{if(0===oe.avail_out&&(oe.output=new M.Buf8(Fe),oe.next_out=0,oe.avail_out=Fe),1!==(Z=U.deflate(oe,ie))&&Z!==B)return this.onEnd(Z),!(this.ended=!0);0!==oe.avail_out&&(0!==oe.avail_in||4!==ie&&2!==ie)||this.onData("string"===this.options.to?F.buf2binstring(M.shrinkBuf(oe.output,oe.next_out)):M.shrinkBuf(oe.output,oe.next_out))}while((0<oe.avail_in||0===oe.avail_out)&&1!==Z);return 4===ie?(Z=U.deflateEnd(this.strm),this.onEnd(Z),this.ended=!0,Z===B):2!==ie||(this.onEnd(B),!(oe.avail_out=0))},S.prototype.onData=function(N){this.chunks.push(N)},S.prototype.onEnd=function(N){N===B&&(this.result="string"===this.options.to?this.chunks.join(""):M.flattenChunks(this.chunks)),this.chunks=[],this.err=N,this.msg=this.strm.msg},X.Deflate=S,X.deflate=D,X.deflateRaw=function(N,L){return(L=L||{}).raw=!0,D(N,L)},X.gzip=function(N,L){return(L=L||{}).gzip=!0,D(N,L)}},{"./utils/common":41,"./utils/strings":42,"./zlib/deflate":46,"./zlib/messages":51,"./zlib/zstream":53}],40:[function(q,ne,X){"use strict";var U=q("./zlib/inflate"),M=q("./utils/common"),F=q("./utils/strings"),P=q("./zlib/constants"),G=q("./zlib/messages"),j=q("./zlib/zstream"),B=q("./zlib/gzheader"),T=Object.prototype.toString;function I(S){if(!(this instanceof I))return new I(S);this.options=M.assign({chunkSize:16384,windowBits:0,to:""},S||{});var D=this.options;D.raw&&0<=D.windowBits&&D.windowBits<16&&(D.windowBits=-D.windowBits,0===D.windowBits&&(D.windowBits=-15)),!(0<=D.windowBits&&D.windowBits<16)||S&&S.windowBits||(D.windowBits+=32),15<D.windowBits&&D.windowBits<48&&!(15&D.windowBits)&&(D.windowBits|=15),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new j,this.strm.avail_out=0;var N=U.inflateInit2(this.strm,D.windowBits);if(N!==P.Z_OK)throw new Error(G[N]);this.header=new B,U.inflateGetHeader(this.strm,this.header)}function A(S,D){var N=new I(D);if(N.push(S,!0),N.err)throw N.msg||G[N.err];return N.result}I.prototype.push=function(S,D){var N,L,Z,ie,oe,Fe,Se=this.strm,Te=this.options.chunkSize,de=this.options.dictionary,Oe=!1;if(this.ended)return!1;L=D===~~D?D:!0===D?P.Z_FINISH:P.Z_NO_FLUSH,Se.input="string"==typeof S?F.binstring2buf(S):"[object ArrayBuffer]"===T.call(S)?new Uint8Array(S):S,Se.next_in=0,Se.avail_in=Se.input.length;do{if(0===Se.avail_out&&(Se.output=new M.Buf8(Te),Se.next_out=0,Se.avail_out=Te),(N=U.inflate(Se,P.Z_NO_FLUSH))===P.Z_NEED_DICT&&de&&(Fe="string"==typeof de?F.string2buf(de):"[object ArrayBuffer]"===T.call(de)?new Uint8Array(de):de,N=U.inflateSetDictionary(this.strm,Fe)),N===P.Z_BUF_ERROR&&!0===Oe&&(N=P.Z_OK,Oe=!1),N!==P.Z_STREAM_END&&N!==P.Z_OK)return this.onEnd(N),!(this.ended=!0);Se.next_out&&(0!==Se.avail_out&&N!==P.Z_STREAM_END&&(0!==Se.avail_in||L!==P.Z_FINISH&&L!==P.Z_SYNC_FLUSH)||("string"===this.options.to?(Z=F.utf8border(Se.output,Se.next_out),ie=Se.next_out-Z,oe=F.buf2string(Se.output,Z),Se.next_out=ie,Se.avail_out=Te-ie,ie&&M.arraySet(Se.output,Se.output,Z,ie,0),this.onData(oe)):this.onData(M.shrinkBuf(Se.output,Se.next_out)))),0===Se.avail_in&&0===Se.avail_out&&(Oe=!0)}while((0<Se.avail_in||0===Se.avail_out)&&N!==P.Z_STREAM_END);return N===P.Z_STREAM_END&&(L=P.Z_FINISH),L===P.Z_FINISH?(N=U.inflateEnd(this.strm),this.onEnd(N),this.ended=!0,N===P.Z_OK):L!==P.Z_SYNC_FLUSH||(this.onEnd(P.Z_OK),!(Se.avail_out=0))},I.prototype.onData=function(S){this.chunks.push(S)},I.prototype.onEnd=function(S){S===P.Z_OK&&(this.result="string"===this.options.to?this.chunks.join(""):M.flattenChunks(this.chunks)),this.chunks=[],this.err=S,this.msg=this.strm.msg},X.Inflate=I,X.inflate=A,X.inflateRaw=function(S,D){return(D=D||{}).raw=!0,A(S,D)},X.ungzip=A},{"./utils/common":41,"./utils/strings":42,"./zlib/constants":44,"./zlib/gzheader":47,"./zlib/inflate":49,"./zlib/messages":51,"./zlib/zstream":53}],41:[function(q,ne,X){"use strict";var U=typeof Uint8Array<"u"&&typeof Uint16Array<"u"&&typeof Int32Array<"u";X.assign=function(P){for(var G=Array.prototype.slice.call(arguments,1);G.length;){var j=G.shift();if(j){if("object"!=typeof j)throw new TypeError(j+"must be non-object");for(var B in j)j.hasOwnProperty(B)&&(P[B]=j[B])}}return P},X.shrinkBuf=function(P,G){return P.length===G?P:P.subarray?P.subarray(0,G):(P.length=G,P)};var M={arraySet:function(P,G,j,B,T){if(G.subarray&&P.subarray)P.set(G.subarray(j,j+B),T);else for(var I=0;I<B;I++)P[T+I]=G[j+I]},flattenChunks:function(P){var G,j,B,T,I,A;for(G=B=0,j=P.length;G<j;G++)B+=P[G].length;for(A=new Uint8Array(B),G=T=0,j=P.length;G<j;G++)A.set(I=P[G],T),T+=I.length;return A}},F={arraySet:function(P,G,j,B,T){for(var I=0;I<B;I++)P[T+I]=G[j+I]},flattenChunks:function(P){return[].concat.apply([],P)}};X.setTyped=function(P){P?(X.Buf8=Uint8Array,X.Buf16=Uint16Array,X.Buf32=Int32Array,X.assign(X,M)):(X.Buf8=Array,X.Buf16=Array,X.Buf32=Array,X.assign(X,F))},X.setTyped(U)},{}],42:[function(q,ne,X){"use strict";var U=q("./common"),M=!0,F=!0;try{String.fromCharCode.apply(null,[0])}catch{M=!1}try{String.fromCharCode.apply(null,new Uint8Array(1))}catch{F=!1}for(var P=new U.Buf8(256),G=0;G<256;G++)P[G]=252<=G?6:248<=G?5:240<=G?4:224<=G?3:192<=G?2:1;function j(B,T){if(T<65537&&(B.subarray&&F||!B.subarray&&M))return String.fromCharCode.apply(null,U.shrinkBuf(B,T));for(var I="",A=0;A<T;A++)I+=String.fromCharCode(B[A]);return I}P[254]=P[254]=1,X.string2buf=function(B){var T,I,A,S,D,N=B.length,L=0;for(S=0;S<N;S++)55296==(64512&(I=B.charCodeAt(S)))&&S+1<N&&56320==(64512&(A=B.charCodeAt(S+1)))&&(I=65536+(I-55296<<10)+(A-56320),S++),L+=I<128?1:I<2048?2:I<65536?3:4;for(T=new U.Buf8(L),S=D=0;D<L;S++)55296==(64512&(I=B.charCodeAt(S)))&&S+1<N&&56320==(64512&(A=B.charCodeAt(S+1)))&&(I=65536+(I-55296<<10)+(A-56320),S++),I<128?T[D++]=I:(I<2048?T[D++]=192|I>>>6:(I<65536?T[D++]=224|I>>>12:(T[D++]=240|I>>>18,T[D++]=128|I>>>12&63),T[D++]=128|I>>>6&63),T[D++]=128|63&I);return T},X.buf2binstring=function(B){return j(B,B.length)},X.binstring2buf=function(B){for(var T=new U.Buf8(B.length),I=0,A=T.length;I<A;I++)T[I]=B.charCodeAt(I);return T},X.buf2string=function(B,T){var I,A,S,D,N=T||B.length,L=new Array(2*N);for(I=A=0;I<N;)if((S=B[I++])<128)L[A++]=S;else if(4<(D=P[S]))L[A++]=65533,I+=D-1;else{for(S&=2===D?31:3===D?15:7;1<D&&I<N;)S=S<<6|63&B[I++],D--;1<D?L[A++]=65533:S<65536?L[A++]=S:(L[A++]=55296|(S-=65536)>>10&1023,L[A++]=56320|1023&S)}return j(L,A)},X.utf8border=function(B,T){var I;for((T=T||B.length)>B.length&&(T=B.length),I=T-1;0<=I&&128==(192&B[I]);)I--;return I<0||0===I?T:I+P[B[I]]>T?I:T}},{"./common":41}],43:[function(q,ne,X){"use strict";ne.exports=function(U,M,F,P){for(var G=65535&U|0,j=U>>>16&65535|0,B=0;0!==F;){for(F-=B=2e3<F?2e3:F;j=j+(G=G+M[P++]|0)|0,--B;);G%=65521,j%=65521}return G|j<<16|0}},{}],44:[function(q,ne,X){"use strict";ne.exports={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8}},{}],45:[function(q,ne,X){"use strict";var U=function(){for(var M,F=[],P=0;P<256;P++){M=P;for(var G=0;G<8;G++)M=1&M?3988292384^M>>>1:M>>>1;F[P]=M}return F}();ne.exports=function(M,F,P,G){var j=U,B=G+P;M^=-1;for(var T=G;T<B;T++)M=M>>>8^j[255&(M^F[T])];return-1^M}},{}],46:[function(q,ne,X){"use strict";var U,M=q("../utils/common"),F=q("./trees"),P=q("./adler32"),G=q("./crc32"),j=q("./messages"),B=0,T=4,I=0,A=-2,S=-1,D=4,N=2,L=8,Z=9,ie=286,oe=30,Fe=19,Se=2*ie+1,Te=15,de=3,Oe=258,me=Oe+de+1,O=42,E=113,_=1,ue=2,et=3,ke=4;function ut(C,ye){return C.msg=j[ye],ye}function Me(C){return(C<<1)-(4<C?9:0)}function dt(C){for(var ye=C.length;0<=--ye;)C[ye]=0}function ce(C){var ye=C.state,Ie=ye.pending;Ie>C.avail_out&&(Ie=C.avail_out),0!==Ie&&(M.arraySet(C.output,ye.pending_buf,ye.pending_out,Ie,C.next_out),C.next_out+=Ie,ye.pending_out+=Ie,C.total_out+=Ie,C.avail_out-=Ie,ye.pending-=Ie,0===ye.pending&&(ye.pending_out=0))}function le(C,ye){F._tr_flush_block(C,0<=C.block_start?C.block_start:-1,C.strstart-C.block_start,ye),C.block_start=C.strstart,ce(C.strm)}function ft(C,ye){C.pending_buf[C.pending++]=ye}function Ve(C,ye){C.pending_buf[C.pending++]=ye>>>8&255,C.pending_buf[C.pending++]=255&ye}function qe(C,ye){var Ie,H,W=C.max_chain_length,ae=C.strstart,Be=C.prev_length,We=C.nice_match,ge=C.strstart>C.w_size-me?C.strstart-(C.w_size-me):0,Ze=C.window,pt=C.w_mask,Qe=C.prev,Dt=C.strstart+Oe,An=Ze[ae+Be-1],un=Ze[ae+Be];C.prev_length>=C.good_match&&(W>>=2),We>C.lookahead&&(We=C.lookahead);do{if(Ze[(Ie=ye)+Be]===un&&Ze[Ie+Be-1]===An&&Ze[Ie]===Ze[ae]&&Ze[++Ie]===Ze[ae+1]){ae+=2,Ie++;do{}while(Ze[++ae]===Ze[++Ie]&&Ze[++ae]===Ze[++Ie]&&Ze[++ae]===Ze[++Ie]&&Ze[++ae]===Ze[++Ie]&&Ze[++ae]===Ze[++Ie]&&Ze[++ae]===Ze[++Ie]&&Ze[++ae]===Ze[++Ie]&&Ze[++ae]===Ze[++Ie]&&ae<Dt);if(H=Oe-(Dt-ae),ae=Dt-Oe,Be<H){if(C.match_start=ye,We<=(Be=H))break;An=Ze[ae+Be-1],un=Ze[ae+Be]}}}while((ye=Qe[ye&pt])>ge&&0!=--W);return Be<=C.lookahead?Be:C.lookahead}function Nn(C){var ye,Ie,H,W,ae,Be,We,ge,Ze,pt,Qe=C.w_size;do{if(W=C.window_size-C.lookahead-C.strstart,C.strstart>=Qe+(Qe-me)){for(M.arraySet(C.window,C.window,Qe,Qe,0),C.match_start-=Qe,C.strstart-=Qe,C.block_start-=Qe,ye=Ie=C.hash_size;H=C.head[--ye],C.head[ye]=Qe<=H?H-Qe:0,--Ie;);for(ye=Ie=Qe;H=C.prev[--ye],C.prev[ye]=Qe<=H?H-Qe:0,--Ie;);W+=Qe}if(0===C.strm.avail_in)break;if(We=C.window,ge=C.strstart+C.lookahead,pt=void 0,(Ze=W)<(pt=(Be=C.strm).avail_in)&&(pt=Ze),Ie=0===pt?0:(Be.avail_in-=pt,M.arraySet(We,Be.input,Be.next_in,pt,ge),1===Be.state.wrap?Be.adler=P(Be.adler,We,pt,ge):2===Be.state.wrap&&(Be.adler=G(Be.adler,We,pt,ge)),Be.next_in+=pt,Be.total_in+=pt,pt),C.lookahead+=Ie,C.lookahead+C.insert>=de)for(C.ins_h=C.window[ae=C.strstart-C.insert],C.ins_h=(C.ins_h<<C.hash_shift^C.window[ae+1])&C.hash_mask;C.insert&&(C.ins_h=(C.ins_h<<C.hash_shift^C.window[ae+de-1])&C.hash_mask,C.prev[ae&C.w_mask]=C.head[C.ins_h],C.head[C.ins_h]=ae,ae++,C.insert--,!(C.lookahead+C.insert<de)););}while(C.lookahead<me&&0!==C.strm.avail_in)}function Ur(C,ye){for(var Ie,H;;){if(C.lookahead<me){if(Nn(C),C.lookahead<me&&ye===B)return _;if(0===C.lookahead)break}if(Ie=0,C.lookahead>=de&&(C.ins_h=(C.ins_h<<C.hash_shift^C.window[C.strstart+de-1])&C.hash_mask,Ie=C.prev[C.strstart&C.w_mask]=C.head[C.ins_h],C.head[C.ins_h]=C.strstart),0!==Ie&&C.strstart-Ie<=C.w_size-me&&(C.match_length=qe(C,Ie)),C.match_length>=de)if(H=F._tr_tally(C,C.strstart-C.match_start,C.match_length-de),C.lookahead-=C.match_length,C.match_length<=C.max_lazy_match&&C.lookahead>=de){for(C.match_length--;C.strstart++,C.ins_h=(C.ins_h<<C.hash_shift^C.window[C.strstart+de-1])&C.hash_mask,Ie=C.prev[C.strstart&C.w_mask]=C.head[C.ins_h],C.head[C.ins_h]=C.strstart,0!=--C.match_length;);C.strstart++}else C.strstart+=C.match_length,C.match_length=0,C.ins_h=C.window[C.strstart],C.ins_h=(C.ins_h<<C.hash_shift^C.window[C.strstart+1])&C.hash_mask;else H=F._tr_tally(C,0,C.window[C.strstart]),C.lookahead--,C.strstart++;if(H&&(le(C,!1),0===C.strm.avail_out))return _}return C.insert=C.strstart<de-1?C.strstart:de-1,ye===T?(le(C,!0),0===C.strm.avail_out?et:ke):C.last_lit&&(le(C,!1),0===C.strm.avail_out)?_:ue}function an(C,ye){for(var Ie,H,W;;){if(C.lookahead<me){if(Nn(C),C.lookahead<me&&ye===B)return _;if(0===C.lookahead)break}if(Ie=0,C.lookahead>=de&&(C.ins_h=(C.ins_h<<C.hash_shift^C.window[C.strstart+de-1])&C.hash_mask,Ie=C.prev[C.strstart&C.w_mask]=C.head[C.ins_h],C.head[C.ins_h]=C.strstart),C.prev_length=C.match_length,C.prev_match=C.match_start,C.match_length=de-1,0!==Ie&&C.prev_length<C.max_lazy_match&&C.strstart-Ie<=C.w_size-me&&(C.match_length=qe(C,Ie),C.match_length<=5&&(1===C.strategy||C.match_length===de&&4096<C.strstart-C.match_start)&&(C.match_length=de-1)),C.prev_length>=de&&C.match_length<=C.prev_length){for(W=C.strstart+C.lookahead-de,H=F._tr_tally(C,C.strstart-1-C.prev_match,C.prev_length-de),C.lookahead-=C.prev_length-1,C.prev_length-=2;++C.strstart<=W&&(C.ins_h=(C.ins_h<<C.hash_shift^C.window[C.strstart+de-1])&C.hash_mask,Ie=C.prev[C.strstart&C.w_mask]=C.head[C.ins_h],C.head[C.ins_h]=C.strstart),0!=--C.prev_length;);if(C.match_available=0,C.match_length=de-1,C.strstart++,H&&(le(C,!1),0===C.strm.avail_out))return _}else if(C.match_available){if((H=F._tr_tally(C,0,C.window[C.strstart-1]))&&le(C,!1),C.strstart++,C.lookahead--,0===C.strm.avail_out)return _}else C.match_available=1,C.strstart++,C.lookahead--}return C.match_available&&(H=F._tr_tally(C,0,C.window[C.strstart-1]),C.match_available=0),C.insert=C.strstart<de-1?C.strstart:de-1,ye===T?(le(C,!0),0===C.strm.avail_out?et:ke):C.last_lit&&(le(C,!1),0===C.strm.avail_out)?_:ue}function Zt(C,ye,Ie,H,W){this.good_length=C,this.max_lazy=ye,this.nice_length=Ie,this.max_chain=H,this.func=W}function gr(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=L,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new M.Buf16(2*Se),this.dyn_dtree=new M.Buf16(2*(2*oe+1)),this.bl_tree=new M.Buf16(2*(2*Fe+1)),dt(this.dyn_ltree),dt(this.dyn_dtree),dt(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new M.Buf16(Te+1),this.heap=new M.Buf16(2*ie+1),dt(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new M.Buf16(2*ie+1),dt(this.depth),this.l_buf=0,this.lit_bufsize=0,this.last_lit=0,this.d_buf=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}function Xn(C){var ye;return C&&C.state?(C.total_in=C.total_out=0,C.data_type=N,(ye=C.state).pending=0,ye.pending_out=0,ye.wrap<0&&(ye.wrap=-ye.wrap),ye.status=ye.wrap?O:E,C.adler=2===ye.wrap?0:1,ye.last_flush=B,F._tr_init(ye),I):ut(C,A)}function In(C){var Ie,ye=Xn(C);return ye===I&&((Ie=C.state).window_size=2*Ie.w_size,dt(Ie.head),Ie.max_lazy_match=U[Ie.level].max_lazy,Ie.good_match=U[Ie.level].good_length,Ie.nice_match=U[Ie.level].nice_length,Ie.max_chain_length=U[Ie.level].max_chain,Ie.strstart=0,Ie.block_start=0,Ie.lookahead=0,Ie.insert=0,Ie.match_length=Ie.prev_length=de-1,Ie.match_available=0,Ie.ins_h=0),ye}function vn(C,ye,Ie,H,W,ae){if(!C)return A;var Be=1;if(ye===S&&(ye=6),H<0?(Be=0,H=-H):15<H&&(Be=2,H-=16),W<1||Z<W||Ie!==L||H<8||15<H||ye<0||9<ye||ae<0||D<ae)return ut(C,A);8===H&&(H=9);var We=new gr;return(C.state=We).strm=C,We.wrap=Be,We.gzhead=null,We.w_bits=H,We.w_size=1<<We.w_bits,We.w_mask=We.w_size-1,We.hash_bits=W+7,We.hash_size=1<<We.hash_bits,We.hash_mask=We.hash_size-1,We.hash_shift=~~((We.hash_bits+de-1)/de),We.window=new M.Buf8(2*We.w_size),We.head=new M.Buf16(We.hash_size),We.prev=new M.Buf16(We.w_size),We.lit_bufsize=1<<W+6,We.pending_buf_size=4*We.lit_bufsize,We.pending_buf=new M.Buf8(We.pending_buf_size),We.d_buf=1*We.lit_bufsize,We.l_buf=3*We.lit_bufsize,We.level=ye,We.strategy=ae,We.method=Ie,In(C)}U=[new Zt(0,0,0,0,function(C,ye){var Ie=65535;for(Ie>C.pending_buf_size-5&&(Ie=C.pending_buf_size-5);;){if(C.lookahead<=1){if(Nn(C),0===C.lookahead&&ye===B)return _;if(0===C.lookahead)break}C.strstart+=C.lookahead,C.lookahead=0;var H=C.block_start+Ie;if((0===C.strstart||C.strstart>=H)&&(C.lookahead=C.strstart-H,C.strstart=H,le(C,!1),0===C.strm.avail_out)||C.strstart-C.block_start>=C.w_size-me&&(le(C,!1),0===C.strm.avail_out))return _}return C.insert=0,ye===T?(le(C,!0),0===C.strm.avail_out?et:ke):(C.strstart>C.block_start&&le(C,!1),_)}),new Zt(4,4,8,4,Ur),new Zt(4,5,16,8,Ur),new Zt(4,6,32,32,Ur),new Zt(4,4,16,16,an),new Zt(8,16,32,32,an),new Zt(8,16,128,128,an),new Zt(8,32,128,256,an),new Zt(32,128,258,1024,an),new Zt(32,258,258,4096,an)],X.deflateInit=function(C,ye){return vn(C,ye,L,15,8,0)},X.deflateInit2=vn,X.deflateReset=In,X.deflateResetKeep=Xn,X.deflateSetHeader=function(C,ye){return C&&C.state?2!==C.state.wrap?A:(C.state.gzhead=ye,I):A},X.deflate=function(C,ye){var Ie,H,W,ae;if(!C||!C.state||5<ye||ye<0)return C?ut(C,A):A;if(H=C.state,!C.output||!C.input&&0!==C.avail_in||666===H.status&&ye!==T)return ut(C,0===C.avail_out?-5:A);if(H.strm=C,Ie=H.last_flush,H.last_flush=ye,H.status===O)if(2===H.wrap)C.adler=0,ft(H,31),ft(H,139),ft(H,8),H.gzhead?(ft(H,(H.gzhead.text?1:0)+(H.gzhead.hcrc?2:0)+(H.gzhead.extra?4:0)+(H.gzhead.name?8:0)+(H.gzhead.comment?16:0)),ft(H,255&H.gzhead.time),ft(H,H.gzhead.time>>8&255),ft(H,H.gzhead.time>>16&255),ft(H,H.gzhead.time>>24&255),ft(H,9===H.level?2:2<=H.strategy||H.level<2?4:0),ft(H,255&H.gzhead.os),H.gzhead.extra&&H.gzhead.extra.length&&(ft(H,255&H.gzhead.extra.length),ft(H,H.gzhead.extra.length>>8&255)),H.gzhead.hcrc&&(C.adler=G(C.adler,H.pending_buf,H.pending,0)),H.gzindex=0,H.status=69):(ft(H,0),ft(H,0),ft(H,0),ft(H,0),ft(H,0),ft(H,9===H.level?2:2<=H.strategy||H.level<2?4:0),ft(H,3),H.status=E);else{var Be=L+(H.w_bits-8<<4)<<8;Be|=(2<=H.strategy||H.level<2?0:H.level<6?1:6===H.level?2:3)<<6,0!==H.strstart&&(Be|=32),Be+=31-Be%31,H.status=E,Ve(H,Be),0!==H.strstart&&(Ve(H,C.adler>>>16),Ve(H,65535&C.adler)),C.adler=1}if(69===H.status)if(H.gzhead.extra){for(W=H.pending;H.gzindex<(65535&H.gzhead.extra.length)&&(H.pending!==H.pending_buf_size||(H.gzhead.hcrc&&H.pending>W&&(C.adler=G(C.adler,H.pending_buf,H.pending-W,W)),ce(C),W=H.pending,H.pending!==H.pending_buf_size));)ft(H,255&H.gzhead.extra[H.gzindex]),H.gzindex++;H.gzhead.hcrc&&H.pending>W&&(C.adler=G(C.adler,H.pending_buf,H.pending-W,W)),H.gzindex===H.gzhead.extra.length&&(H.gzindex=0,H.status=73)}else H.status=73;if(73===H.status)if(H.gzhead.name){W=H.pending;do{if(H.pending===H.pending_buf_size&&(H.gzhead.hcrc&&H.pending>W&&(C.adler=G(C.adler,H.pending_buf,H.pending-W,W)),ce(C),W=H.pending,H.pending===H.pending_buf_size)){ae=1;break}ae=H.gzindex<H.gzhead.name.length?255&H.gzhead.name.charCodeAt(H.gzindex++):0,ft(H,ae)}while(0!==ae);H.gzhead.hcrc&&H.pending>W&&(C.adler=G(C.adler,H.pending_buf,H.pending-W,W)),0===ae&&(H.gzindex=0,H.status=91)}else H.status=91;if(91===H.status)if(H.gzhead.comment){W=H.pending;do{if(H.pending===H.pending_buf_size&&(H.gzhead.hcrc&&H.pending>W&&(C.adler=G(C.adler,H.pending_buf,H.pending-W,W)),ce(C),W=H.pending,H.pending===H.pending_buf_size)){ae=1;break}ae=H.gzindex<H.gzhead.comment.length?255&H.gzhead.comment.charCodeAt(H.gzindex++):0,ft(H,ae)}while(0!==ae);H.gzhead.hcrc&&H.pending>W&&(C.adler=G(C.adler,H.pending_buf,H.pending-W,W)),0===ae&&(H.status=103)}else H.status=103;if(103===H.status&&(H.gzhead.hcrc?(H.pending+2>H.pending_buf_size&&ce(C),H.pending+2<=H.pending_buf_size&&(ft(H,255&C.adler),ft(H,C.adler>>8&255),C.adler=0,H.status=E)):H.status=E),0!==H.pending){if(ce(C),0===C.avail_out)return H.last_flush=-1,I}else if(0===C.avail_in&&Me(ye)<=Me(Ie)&&ye!==T)return ut(C,-5);if(666===H.status&&0!==C.avail_in)return ut(C,-5);if(0!==C.avail_in||0!==H.lookahead||ye!==B&&666!==H.status){var We=2===H.strategy?function(ge,Ze){for(var pt;;){if(0===ge.lookahead&&(Nn(ge),0===ge.lookahead)){if(Ze===B)return _;break}if(ge.match_length=0,pt=F._tr_tally(ge,0,ge.window[ge.strstart]),ge.lookahead--,ge.strstart++,pt&&(le(ge,!1),0===ge.strm.avail_out))return _}return ge.insert=0,Ze===T?(le(ge,!0),0===ge.strm.avail_out?et:ke):ge.last_lit&&(le(ge,!1),0===ge.strm.avail_out)?_:ue}(H,ye):3===H.strategy?function(ge,Ze){for(var pt,Qe,Dt,An,un=ge.window;;){if(ge.lookahead<=Oe){if(Nn(ge),ge.lookahead<=Oe&&Ze===B)return _;if(0===ge.lookahead)break}if(ge.match_length=0,ge.lookahead>=de&&0<ge.strstart&&(Qe=un[Dt=ge.strstart-1])===un[++Dt]&&Qe===un[++Dt]&&Qe===un[++Dt]){An=ge.strstart+Oe;do{}while(Qe===un[++Dt]&&Qe===un[++Dt]&&Qe===un[++Dt]&&Qe===un[++Dt]&&Qe===un[++Dt]&&Qe===un[++Dt]&&Qe===un[++Dt]&&Qe===un[++Dt]&&Dt<An);ge.match_length=Oe-(An-Dt),ge.match_length>ge.lookahead&&(ge.match_length=ge.lookahead)}if(ge.match_length>=de?(pt=F._tr_tally(ge,1,ge.match_length-de),ge.lookahead-=ge.match_length,ge.strstart+=ge.match_length,ge.match_length=0):(pt=F._tr_tally(ge,0,ge.window[ge.strstart]),ge.lookahead--,ge.strstart++),pt&&(le(ge,!1),0===ge.strm.avail_out))return _}return ge.insert=0,Ze===T?(le(ge,!0),0===ge.strm.avail_out?et:ke):ge.last_lit&&(le(ge,!1),0===ge.strm.avail_out)?_:ue}(H,ye):U[H.level].func(H,ye);if(We!==et&&We!==ke||(H.status=666),We===_||We===et)return 0===C.avail_out&&(H.last_flush=-1),I;if(We===ue&&(1===ye?F._tr_align(H):5!==ye&&(F._tr_stored_block(H,0,0,!1),3===ye&&(dt(H.head),0===H.lookahead&&(H.strstart=0,H.block_start=0,H.insert=0))),ce(C),0===C.avail_out))return H.last_flush=-1,I}return ye!==T?I:H.wrap<=0?1:(2===H.wrap?(ft(H,255&C.adler),ft(H,C.adler>>8&255),ft(H,C.adler>>16&255),ft(H,C.adler>>24&255),ft(H,255&C.total_in),ft(H,C.total_in>>8&255),ft(H,C.total_in>>16&255),ft(H,C.total_in>>24&255)):(Ve(H,C.adler>>>16),Ve(H,65535&C.adler)),ce(C),0<H.wrap&&(H.wrap=-H.wrap),0!==H.pending?I:1)},X.deflateEnd=function(C){var ye;return C&&C.state?(ye=C.state.status)!==O&&69!==ye&&73!==ye&&91!==ye&&103!==ye&&ye!==E&&666!==ye?ut(C,A):(C.state=null,ye===E?ut(C,-3):I):A},X.deflateSetDictionary=function(C,ye){var Ie,H,W,ae,Be,We,ge,Ze,pt=ye.length;if(!C||!C.state||2===(ae=(Ie=C.state).wrap)||1===ae&&Ie.status!==O||Ie.lookahead)return A;for(1===ae&&(C.adler=P(C.adler,ye,pt,0)),Ie.wrap=0,pt>=Ie.w_size&&(0===ae&&(dt(Ie.head),Ie.strstart=0,Ie.block_start=0,Ie.insert=0),Ze=new M.Buf8(Ie.w_size),M.arraySet(Ze,ye,pt-Ie.w_size,Ie.w_size,0),ye=Ze,pt=Ie.w_size),Be=C.avail_in,We=C.next_in,ge=C.input,C.avail_in=pt,C.next_in=0,C.input=ye,Nn(Ie);Ie.lookahead>=de;){for(H=Ie.strstart,W=Ie.lookahead-(de-1);Ie.ins_h=(Ie.ins_h<<Ie.hash_shift^Ie.window[H+de-1])&Ie.hash_mask,Ie.prev[H&Ie.w_mask]=Ie.head[Ie.ins_h],Ie.head[Ie.ins_h]=H,H++,--W;);Ie.strstart=H,Ie.lookahead=de-1,Nn(Ie)}return Ie.strstart+=Ie.lookahead,Ie.block_start=Ie.strstart,Ie.insert=Ie.lookahead,Ie.lookahead=0,Ie.match_length=Ie.prev_length=de-1,Ie.match_available=0,C.next_in=We,C.input=ge,C.avail_in=Be,Ie.wrap=ae,I},X.deflateInfo="pako deflate (from Nodeca project)"},{"../utils/common":41,"./adler32":43,"./crc32":45,"./messages":51,"./trees":52}],47:[function(q,ne,X){"use strict";ne.exports=function(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1}},{}],48:[function(q,ne,X){"use strict";ne.exports=function(U,M){var F,P,G,j,B,T,I,A,S,D,N,L,Z,ie,oe,Fe,Se,Te,de,Oe,me,O,E,_,ue;_=U.input,G=(P=U.next_in)+(U.avail_in-5),ue=U.output,B=(j=U.next_out)-(M-U.avail_out),T=j+(U.avail_out-257),I=(F=U.state).dmax,A=F.wsize,S=F.whave,D=F.wnext,N=F.window,L=F.hold,Z=F.bits,ie=F.lencode,oe=F.distcode,Fe=(1<<F.lenbits)-1,Se=(1<<F.distbits)-1;e:do{Z<15&&(L+=_[P++]<<Z,L+=_[P++]<<(Z+=8),Z+=8),Te=ie[L&Fe];t:for(;;){if(L>>>=de=Te>>>24,Z-=de,0==(de=Te>>>16&255))ue[j++]=65535&Te;else{if(!(16&de)){if(!(64&de)){Te=ie[(65535&Te)+(L&(1<<de)-1)];continue t}if(32&de){F.mode=12;break e}U.msg="invalid literal/length code",F.mode=30;break e}Oe=65535&Te,(de&=15)&&(Z<de&&(L+=_[P++]<<Z,Z+=8),Oe+=L&(1<<de)-1,L>>>=de,Z-=de),Z<15&&(L+=_[P++]<<Z,L+=_[P++]<<(Z+=8),Z+=8),Te=oe[L&Se];n:for(;;){if(L>>>=de=Te>>>24,Z-=de,!(16&(de=Te>>>16&255))){if(!(64&de)){Te=oe[(65535&Te)+(L&(1<<de)-1)];continue n}U.msg="invalid distance code",F.mode=30;break e}if(me=65535&Te,Z<(de&=15)&&(L+=_[P++]<<Z,(Z+=8)<de&&(L+=_[P++]<<Z,Z+=8)),I<(me+=L&(1<<de)-1)){U.msg="invalid distance too far back",F.mode=30;break e}if(L>>>=de,Z-=de,(de=j-B)<me){if(S<(de=me-de)&&F.sane){U.msg="invalid distance too far back",F.mode=30;break e}if(E=N,(O=0)===D){if(O+=A-de,de<Oe){for(Oe-=de;ue[j++]=N[O++],--de;);O=j-me,E=ue}}else if(D<de){if(O+=A+D-de,(de-=D)<Oe){for(Oe-=de;ue[j++]=N[O++],--de;);if(O=0,D<Oe){for(Oe-=de=D;ue[j++]=N[O++],--de;);O=j-me,E=ue}}}else if(O+=D-de,de<Oe){for(Oe-=de;ue[j++]=N[O++],--de;);O=j-me,E=ue}for(;2<Oe;)ue[j++]=E[O++],ue[j++]=E[O++],ue[j++]=E[O++],Oe-=3;Oe&&(ue[j++]=E[O++],1<Oe&&(ue[j++]=E[O++]))}else{for(O=j-me;ue[j++]=ue[O++],ue[j++]=ue[O++],ue[j++]=ue[O++],2<(Oe-=3););Oe&&(ue[j++]=ue[O++],1<Oe&&(ue[j++]=ue[O++]))}break}}break}}while(P<G&&j<T);P-=Oe=Z>>3,L&=(1<<(Z-=Oe<<3))-1,U.next_in=P,U.next_out=j,U.avail_in=P<G?G-P+5:5-(P-G),U.avail_out=j<T?T-j+257:257-(j-T),F.hold=L,F.bits=Z}},{}],49:[function(q,ne,X){"use strict";var U=q("../utils/common"),M=q("./adler32"),F=q("./crc32"),P=q("./inffast"),G=q("./inftrees"),j=1,B=2,T=0,I=-2,A=1,S=852,D=592;function N(O){return(O>>>24&255)+(O>>>8&65280)+((65280&O)<<8)+((255&O)<<24)}function L(){this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new U.Buf16(320),this.work=new U.Buf16(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}function Z(O){var E;return O&&O.state?(O.total_in=O.total_out=(E=O.state).total=0,O.msg="",E.wrap&&(O.adler=1&E.wrap),E.mode=A,E.last=0,E.havedict=0,E.dmax=32768,E.head=null,E.hold=0,E.bits=0,E.lencode=E.lendyn=new U.Buf32(S),E.distcode=E.distdyn=new U.Buf32(D),E.sane=1,E.back=-1,T):I}function ie(O){var E;return O&&O.state?((E=O.state).wsize=0,E.whave=0,E.wnext=0,Z(O)):I}function oe(O,E){var _,ue;return O&&O.state?(ue=O.state,E<0?(_=0,E=-E):(_=1+(E>>4),E<48&&(E&=15)),E&&(E<8||15<E)?I:(null!==ue.window&&ue.wbits!==E&&(ue.window=null),ue.wrap=_,ue.wbits=E,ie(O))):I}function Fe(O,E){var _,ue;return O?(ue=new L,(O.state=ue).window=null,(_=oe(O,E))!==T&&(O.state=null),_):I}var Se,Te,de=!0;function Oe(O){if(de){var E;for(Se=new U.Buf32(512),Te=new U.Buf32(32),E=0;E<144;)O.lens[E++]=8;for(;E<256;)O.lens[E++]=9;for(;E<280;)O.lens[E++]=7;for(;E<288;)O.lens[E++]=8;for(G(j,O.lens,0,288,Se,0,O.work,{bits:9}),E=0;E<32;)O.lens[E++]=5;G(B,O.lens,0,32,Te,0,O.work,{bits:5}),de=!1}O.lencode=Se,O.lenbits=9,O.distcode=Te,O.distbits=5}function me(O,E,_,ue){var et,ke=O.state;return null===ke.window&&(ke.wsize=1<<ke.wbits,ke.wnext=0,ke.whave=0,ke.window=new U.Buf8(ke.wsize)),ue>=ke.wsize?(U.arraySet(ke.window,E,_-ke.wsize,ke.wsize,0),ke.wnext=0,ke.whave=ke.wsize):(ue<(et=ke.wsize-ke.wnext)&&(et=ue),U.arraySet(ke.window,E,_-ue,et,ke.wnext),(ue-=et)?(U.arraySet(ke.window,E,_-ue,ue,0),ke.wnext=ue,ke.whave=ke.wsize):(ke.wnext+=et,ke.wnext===ke.wsize&&(ke.wnext=0),ke.whave<ke.wsize&&(ke.whave+=et))),0}X.inflateReset=ie,X.inflateReset2=oe,X.inflateResetKeep=Z,X.inflateInit=function(O){return Fe(O,15)},X.inflateInit2=Fe,X.inflate=function(O,E){var _,ue,et,ke,ut,Me,dt,ce,le,ft,Ve,qe,Nn,Ur,an,Zt,gr,Xn,In,vn,C,ye,Ie,H,W=0,ae=new U.Buf8(4),Be=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];if(!O||!O.state||!O.output||!O.input&&0!==O.avail_in)return I;12===(_=O.state).mode&&(_.mode=13),ut=O.next_out,et=O.output,ke=O.next_in,ue=O.input,ce=_.hold,le=_.bits,ft=Me=O.avail_in,Ve=dt=O.avail_out,ye=T;e:for(;;)switch(_.mode){case A:if(0===_.wrap){_.mode=13;break}for(;le<16;){if(0===Me)break e;Me--,ce+=ue[ke++]<<le,le+=8}if(2&_.wrap&&35615===ce){ae[_.check=0]=255&ce,ae[1]=ce>>>8&255,_.check=F(_.check,ae,2,0),le=ce=0,_.mode=2;break}if(_.flags=0,_.head&&(_.head.done=!1),!(1&_.wrap)||(((255&ce)<<8)+(ce>>8))%31){O.msg="incorrect header check",_.mode=30;break}if(8!=(15&ce)){O.msg="unknown compression method",_.mode=30;break}if(le-=4,C=8+(15&(ce>>>=4)),0===_.wbits)_.wbits=C;else if(C>_.wbits){O.msg="invalid window size",_.mode=30;break}_.dmax=1<<C,O.adler=_.check=1,_.mode=512&ce?10:12,le=ce=0;break;case 2:for(;le<16;){if(0===Me)break e;Me--,ce+=ue[ke++]<<le,le+=8}if(_.flags=ce,8!=(255&_.flags)){O.msg="unknown compression method",_.mode=30;break}if(57344&_.flags){O.msg="unknown header flags set",_.mode=30;break}_.head&&(_.head.text=ce>>8&1),512&_.flags&&(ae[0]=255&ce,ae[1]=ce>>>8&255,_.check=F(_.check,ae,2,0)),le=ce=0,_.mode=3;case 3:for(;le<32;){if(0===Me)break e;Me--,ce+=ue[ke++]<<le,le+=8}_.head&&(_.head.time=ce),512&_.flags&&(ae[0]=255&ce,ae[1]=ce>>>8&255,ae[2]=ce>>>16&255,ae[3]=ce>>>24&255,_.check=F(_.check,ae,4,0)),le=ce=0,_.mode=4;case 4:for(;le<16;){if(0===Me)break e;Me--,ce+=ue[ke++]<<le,le+=8}_.head&&(_.head.xflags=255&ce,_.head.os=ce>>8),512&_.flags&&(ae[0]=255&ce,ae[1]=ce>>>8&255,_.check=F(_.check,ae,2,0)),le=ce=0,_.mode=5;case 5:if(1024&_.flags){for(;le<16;){if(0===Me)break e;Me--,ce+=ue[ke++]<<le,le+=8}_.length=ce,_.head&&(_.head.extra_len=ce),512&_.flags&&(ae[0]=255&ce,ae[1]=ce>>>8&255,_.check=F(_.check,ae,2,0)),le=ce=0}else _.head&&(_.head.extra=null);_.mode=6;case 6:if(1024&_.flags&&(Me<(qe=_.length)&&(qe=Me),qe&&(_.head&&(C=_.head.extra_len-_.length,_.head.extra||(_.head.extra=new Array(_.head.extra_len)),U.arraySet(_.head.extra,ue,ke,qe,C)),512&_.flags&&(_.check=F(_.check,ue,qe,ke)),Me-=qe,ke+=qe,_.length-=qe),_.length))break e;_.length=0,_.mode=7;case 7:if(2048&_.flags){if(0===Me)break e;for(qe=0;C=ue[ke+qe++],_.head&&C&&_.length<65536&&(_.head.name+=String.fromCharCode(C)),C&&qe<Me;);if(512&_.flags&&(_.check=F(_.check,ue,qe,ke)),Me-=qe,ke+=qe,C)break e}else _.head&&(_.head.name=null);_.length=0,_.mode=8;case 8:if(4096&_.flags){if(0===Me)break e;for(qe=0;C=ue[ke+qe++],_.head&&C&&_.length<65536&&(_.head.comment+=String.fromCharCode(C)),C&&qe<Me;);if(512&_.flags&&(_.check=F(_.check,ue,qe,ke)),Me-=qe,ke+=qe,C)break e}else _.head&&(_.head.comment=null);_.mode=9;case 9:if(512&_.flags){for(;le<16;){if(0===Me)break e;Me--,ce+=ue[ke++]<<le,le+=8}if(ce!==(65535&_.check)){O.msg="header crc mismatch",_.mode=30;break}le=ce=0}_.head&&(_.head.hcrc=_.flags>>9&1,_.head.done=!0),O.adler=_.check=0,_.mode=12;break;case 10:for(;le<32;){if(0===Me)break e;Me--,ce+=ue[ke++]<<le,le+=8}O.adler=_.check=N(ce),le=ce=0,_.mode=11;case 11:if(0===_.havedict)return O.next_out=ut,O.avail_out=dt,O.next_in=ke,O.avail_in=Me,_.hold=ce,_.bits=le,2;O.adler=_.check=1,_.mode=12;case 12:if(5===E||6===E)break e;case 13:if(_.last){ce>>>=7&le,le-=7&le,_.mode=27;break}for(;le<3;){if(0===Me)break e;Me--,ce+=ue[ke++]<<le,le+=8}switch(_.last=1&ce,le-=1,3&(ce>>>=1)){case 0:_.mode=14;break;case 1:if(Oe(_),_.mode=20,6!==E)break;ce>>>=2,le-=2;break e;case 2:_.mode=17;break;case 3:O.msg="invalid block type",_.mode=30}ce>>>=2,le-=2;break;case 14:for(ce>>>=7&le,le-=7&le;le<32;){if(0===Me)break e;Me--,ce+=ue[ke++]<<le,le+=8}if((65535&ce)!=(ce>>>16^65535)){O.msg="invalid stored block lengths",_.mode=30;break}if(_.length=65535&ce,le=ce=0,_.mode=15,6===E)break e;case 15:_.mode=16;case 16:if(qe=_.length){if(Me<qe&&(qe=Me),dt<qe&&(qe=dt),0===qe)break e;U.arraySet(et,ue,ke,qe,ut),Me-=qe,ke+=qe,dt-=qe,ut+=qe,_.length-=qe;break}_.mode=12;break;case 17:for(;le<14;){if(0===Me)break e;Me--,ce+=ue[ke++]<<le,le+=8}if(_.nlen=257+(31&ce),le-=5,_.ndist=1+(31&(ce>>>=5)),le-=5,_.ncode=4+(15&(ce>>>=5)),ce>>>=4,le-=4,286<_.nlen||30<_.ndist){O.msg="too many length or distance symbols",_.mode=30;break}_.have=0,_.mode=18;case 18:for(;_.have<_.ncode;){for(;le<3;){if(0===Me)break e;Me--,ce+=ue[ke++]<<le,le+=8}_.lens[Be[_.have++]]=7&ce,ce>>>=3,le-=3}for(;_.have<19;)_.lens[Be[_.have++]]=0;if(_.lencode=_.lendyn,_.lenbits=7,ye=G(0,_.lens,0,19,_.lencode,0,_.work,Ie={bits:_.lenbits}),_.lenbits=Ie.bits,ye){O.msg="invalid code lengths set",_.mode=30;break}_.have=0,_.mode=19;case 19:for(;_.have<_.nlen+_.ndist;){for(;Zt=(W=_.lencode[ce&(1<<_.lenbits)-1])>>>16&255,gr=65535&W,!((an=W>>>24)<=le);){if(0===Me)break e;Me--,ce+=ue[ke++]<<le,le+=8}if(gr<16)ce>>>=an,le-=an,_.lens[_.have++]=gr;else{if(16===gr){for(H=an+2;le<H;){if(0===Me)break e;Me--,ce+=ue[ke++]<<le,le+=8}if(ce>>>=an,le-=an,0===_.have){O.msg="invalid bit length repeat",_.mode=30;break}C=_.lens[_.have-1],qe=3+(3&ce),ce>>>=2,le-=2}else if(17===gr){for(H=an+3;le<H;){if(0===Me)break e;Me--,ce+=ue[ke++]<<le,le+=8}le-=an,C=0,qe=3+(7&(ce>>>=an)),ce>>>=3,le-=3}else{for(H=an+7;le<H;){if(0===Me)break e;Me--,ce+=ue[ke++]<<le,le+=8}le-=an,C=0,qe=11+(127&(ce>>>=an)),ce>>>=7,le-=7}if(_.have+qe>_.nlen+_.ndist){O.msg="invalid bit length repeat",_.mode=30;break}for(;qe--;)_.lens[_.have++]=C}}if(30===_.mode)break;if(0===_.lens[256]){O.msg="invalid code -- missing end-of-block",_.mode=30;break}if(_.lenbits=9,ye=G(j,_.lens,0,_.nlen,_.lencode,0,_.work,Ie={bits:_.lenbits}),_.lenbits=Ie.bits,ye){O.msg="invalid literal/lengths set",_.mode=30;break}if(_.distbits=6,_.distcode=_.distdyn,ye=G(B,_.lens,_.nlen,_.ndist,_.distcode,0,_.work,Ie={bits:_.distbits}),_.distbits=Ie.bits,ye){O.msg="invalid distances set",_.mode=30;break}if(_.mode=20,6===E)break e;case 20:_.mode=21;case 21:if(6<=Me&&258<=dt){O.next_out=ut,O.avail_out=dt,O.next_in=ke,O.avail_in=Me,_.hold=ce,_.bits=le,P(O,Ve),ut=O.next_out,et=O.output,dt=O.avail_out,ke=O.next_in,ue=O.input,Me=O.avail_in,ce=_.hold,le=_.bits,12===_.mode&&(_.back=-1);break}for(_.back=0;Zt=(W=_.lencode[ce&(1<<_.lenbits)-1])>>>16&255,gr=65535&W,!((an=W>>>24)<=le);){if(0===Me)break e;Me--,ce+=ue[ke++]<<le,le+=8}if(Zt&&!(240&Zt)){for(Xn=an,In=Zt,vn=gr;Zt=(W=_.lencode[vn+((ce&(1<<Xn+In)-1)>>Xn)])>>>16&255,gr=65535&W,!(Xn+(an=W>>>24)<=le);){if(0===Me)break e;Me--,ce+=ue[ke++]<<le,le+=8}ce>>>=Xn,le-=Xn,_.back+=Xn}if(ce>>>=an,le-=an,_.back+=an,_.length=gr,0===Zt){_.mode=26;break}if(32&Zt){_.back=-1,_.mode=12;break}if(64&Zt){O.msg="invalid literal/length code",_.mode=30;break}_.extra=15&Zt,_.mode=22;case 22:if(_.extra){for(H=_.extra;le<H;){if(0===Me)break e;Me--,ce+=ue[ke++]<<le,le+=8}_.length+=ce&(1<<_.extra)-1,ce>>>=_.extra,le-=_.extra,_.back+=_.extra}_.was=_.length,_.mode=23;case 23:for(;Zt=(W=_.distcode[ce&(1<<_.distbits)-1])>>>16&255,gr=65535&W,!((an=W>>>24)<=le);){if(0===Me)break e;Me--,ce+=ue[ke++]<<le,le+=8}if(!(240&Zt)){for(Xn=an,In=Zt,vn=gr;Zt=(W=_.distcode[vn+((ce&(1<<Xn+In)-1)>>Xn)])>>>16&255,gr=65535&W,!(Xn+(an=W>>>24)<=le);){if(0===Me)break e;Me--,ce+=ue[ke++]<<le,le+=8}ce>>>=Xn,le-=Xn,_.back+=Xn}if(ce>>>=an,le-=an,_.back+=an,64&Zt){O.msg="invalid distance code",_.mode=30;break}_.offset=gr,_.extra=15&Zt,_.mode=24;case 24:if(_.extra){for(H=_.extra;le<H;){if(0===Me)break e;Me--,ce+=ue[ke++]<<le,le+=8}_.offset+=ce&(1<<_.extra)-1,ce>>>=_.extra,le-=_.extra,_.back+=_.extra}if(_.offset>_.dmax){O.msg="invalid distance too far back",_.mode=30;break}_.mode=25;case 25:if(0===dt)break e;if(_.offset>(qe=Ve-dt)){if((qe=_.offset-qe)>_.whave&&_.sane){O.msg="invalid distance too far back",_.mode=30;break}Nn=qe>_.wnext?_.wsize-(qe-=_.wnext):_.wnext-qe,qe>_.length&&(qe=_.length),Ur=_.window}else Ur=et,Nn=ut-_.offset,qe=_.length;for(dt<qe&&(qe=dt),dt-=qe,_.length-=qe;et[ut++]=Ur[Nn++],--qe;);0===_.length&&(_.mode=21);break;case 26:if(0===dt)break e;et[ut++]=_.length,dt--,_.mode=21;break;case 27:if(_.wrap){for(;le<32;){if(0===Me)break e;Me--,ce|=ue[ke++]<<le,le+=8}if(O.total_out+=Ve-=dt,_.total+=Ve,Ve&&(O.adler=_.check=_.flags?F(_.check,et,Ve,ut-Ve):M(_.check,et,Ve,ut-Ve)),Ve=dt,(_.flags?ce:N(ce))!==_.check){O.msg="incorrect data check",_.mode=30;break}le=ce=0}_.mode=28;case 28:if(_.wrap&&_.flags){for(;le<32;){if(0===Me)break e;Me--,ce+=ue[ke++]<<le,le+=8}if(ce!==(4294967295&_.total)){O.msg="incorrect length check",_.mode=30;break}le=ce=0}_.mode=29;case 29:ye=1;break e;case 30:ye=-3;break e;case 31:return-4;default:return I}return O.next_out=ut,O.avail_out=dt,O.next_in=ke,O.avail_in=Me,_.hold=ce,_.bits=le,(_.wsize||Ve!==O.avail_out&&_.mode<30&&(_.mode<27||4!==E))&&me(O,O.output,O.next_out,Ve-O.avail_out)?(_.mode=31,-4):(Ve-=O.avail_out,O.total_in+=ft-=O.avail_in,O.total_out+=Ve,_.total+=Ve,_.wrap&&Ve&&(O.adler=_.check=_.flags?F(_.check,et,Ve,O.next_out-Ve):M(_.check,et,Ve,O.next_out-Ve)),O.data_type=_.bits+(_.last?64:0)+(12===_.mode?128:0)+(20===_.mode||15===_.mode?256:0),(0==ft&&0===Ve||4===E)&&ye===T&&(ye=-5),ye)},X.inflateEnd=function(O){if(!O||!O.state)return I;var E=O.state;return E.window&&(E.window=null),O.state=null,T},X.inflateGetHeader=function(O,E){var _;return O&&O.state&&2&(_=O.state).wrap?((_.head=E).done=!1,T):I},X.inflateSetDictionary=function(O,E){var _,ue=E.length;return O&&O.state?0!==(_=O.state).wrap&&11!==_.mode?I:11===_.mode&&M(1,E,ue,0)!==_.check?-3:me(O,E,ue,ue)?(_.mode=31,-4):(_.havedict=1,T):I},X.inflateInfo="pako inflate (from Nodeca project)"},{"../utils/common":41,"./adler32":43,"./crc32":45,"./inffast":48,"./inftrees":50}],50:[function(q,ne,X){"use strict";var U=q("../utils/common"),M=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],F=[16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78],P=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0],G=[16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64];ne.exports=function(j,B,T,I,A,S,D,N){var L,Z,ie,oe,Fe,Se,Te,de,Oe,me=N.bits,O=0,E=0,_=0,ue=0,et=0,ke=0,ut=0,Me=0,dt=0,ce=0,le=null,ft=0,Ve=new U.Buf16(16),qe=new U.Buf16(16),Nn=null,Ur=0;for(O=0;O<=15;O++)Ve[O]=0;for(E=0;E<I;E++)Ve[B[T+E]]++;for(et=me,ue=15;1<=ue&&0===Ve[ue];ue--);if(ue<et&&(et=ue),0===ue)return A[S++]=20971520,A[S++]=20971520,N.bits=1,0;for(_=1;_<ue&&0===Ve[_];_++);for(et<_&&(et=_),O=Me=1;O<=15;O++)if(Me<<=1,(Me-=Ve[O])<0)return-1;if(0<Me&&(0===j||1!==ue))return-1;for(qe[1]=0,O=1;O<15;O++)qe[O+1]=qe[O]+Ve[O];for(E=0;E<I;E++)0!==B[T+E]&&(D[qe[B[T+E]]++]=E);if(Se=0===j?(le=Nn=D,19):1===j?(le=M,ft-=257,Nn=F,Ur-=257,256):(le=P,Nn=G,-1),O=_,Fe=S,ut=E=ce=0,ie=-1,oe=(dt=1<<(ke=et))-1,1===j&&852<dt||2===j&&592<dt)return 1;for(;;){for(Te=O-ut,Oe=D[E]<Se?(de=0,D[E]):D[E]>Se?(de=Nn[Ur+D[E]],le[ft+D[E]]):(de=96,0),L=1<<O-ut,_=Z=1<<ke;A[Fe+(ce>>ut)+(Z-=L)]=Te<<24|de<<16|Oe|0,0!==Z;);for(L=1<<O-1;ce&L;)L>>=1;if(0!==L?(ce&=L-1,ce+=L):ce=0,E++,0==--Ve[O]){if(O===ue)break;O=B[T+D[E]]}if(et<O&&(ce&oe)!==ie){for(0===ut&&(ut=et),Fe+=_,Me=1<<(ke=O-ut);ke+ut<ue&&!((Me-=Ve[ke+ut])<=0);)ke++,Me<<=1;if(dt+=1<<ke,1===j&&852<dt||2===j&&592<dt)return 1;A[ie=ce&oe]=et<<24|ke<<16|Fe-S|0}}return 0!==ce&&(A[Fe+ce]=O-ut<<24|64<<16|0),N.bits=et,0}},{"../utils/common":41}],51:[function(q,ne,X){"use strict";ne.exports={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"}},{}],52:[function(q,ne,X){"use strict";var U=q("../utils/common");function P(W){for(var ae=W.length;0<=--ae;)W[ae]=0}var G=0,B=256,T=B+1+29,I=30,A=19,S=2*T+1,D=15,N=16,Z=256,ie=16,oe=17,Fe=18,Se=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],Te=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],de=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],Oe=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],me=new Array(2*(T+2));P(me);var O=new Array(2*I);P(O);var E=new Array(512);P(E);var _=new Array(256);P(_);var ue=new Array(29);P(ue);var et,ke,ut,Me=new Array(I);function dt(W,ae,Be,We,ge){this.static_tree=W,this.extra_bits=ae,this.extra_base=Be,this.elems=We,this.max_length=ge,this.has_stree=W&&W.length}function ce(W,ae){this.dyn_tree=W,this.max_code=0,this.stat_desc=ae}function le(W){return W<256?E[W]:E[256+(W>>>7)]}function ft(W,ae){W.pending_buf[W.pending++]=255&ae,W.pending_buf[W.pending++]=ae>>>8&255}function Ve(W,ae,Be){W.bi_valid>N-Be?(W.bi_buf|=ae<<W.bi_valid&65535,ft(W,W.bi_buf),W.bi_buf=ae>>N-W.bi_valid,W.bi_valid+=Be-N):(W.bi_buf|=ae<<W.bi_valid&65535,W.bi_valid+=Be)}function qe(W,ae,Be){Ve(W,Be[2*ae],Be[2*ae+1])}function Nn(W,ae){for(var Be=0;Be|=1&W,W>>>=1,Be<<=1,0<--ae;);return Be>>>1}function Ur(W,ae,Be){var We,ge,Ze=new Array(D+1),pt=0;for(We=1;We<=D;We++)Ze[We]=pt=pt+Be[We-1]<<1;for(ge=0;ge<=ae;ge++){var Qe=W[2*ge+1];0!==Qe&&(W[2*ge]=Nn(Ze[Qe]++,Qe))}}function an(W){var ae;for(ae=0;ae<T;ae++)W.dyn_ltree[2*ae]=0;for(ae=0;ae<I;ae++)W.dyn_dtree[2*ae]=0;for(ae=0;ae<A;ae++)W.bl_tree[2*ae]=0;W.dyn_ltree[2*Z]=1,W.opt_len=W.static_len=0,W.last_lit=W.matches=0}function Zt(W){8<W.bi_valid?ft(W,W.bi_buf):0<W.bi_valid&&(W.pending_buf[W.pending++]=W.bi_buf),W.bi_buf=0,W.bi_valid=0}function gr(W,ae,Be,We){var ge=2*ae,Ze=2*Be;return W[ge]<W[Ze]||W[ge]===W[Ze]&&We[ae]<=We[Be]}function Xn(W,ae,Be){for(var We=W.heap[Be],ge=Be<<1;ge<=W.heap_len&&(ge<W.heap_len&&gr(ae,W.heap[ge+1],W.heap[ge],W.depth)&&ge++,!gr(ae,We,W.heap[ge],W.depth));)W.heap[Be]=W.heap[ge],Be=ge,ge<<=1;W.heap[Be]=We}function In(W,ae,Be){var We,ge,Ze,pt,Qe=0;if(0!==W.last_lit)for(;We=W.pending_buf[W.d_buf+2*Qe]<<8|W.pending_buf[W.d_buf+2*Qe+1],ge=W.pending_buf[W.l_buf+Qe],Qe++,0===We?qe(W,ge,ae):(qe(W,(Ze=_[ge])+B+1,ae),0!==(pt=Se[Ze])&&Ve(W,ge-=ue[Ze],pt),qe(W,Ze=le(--We),Be),0!==(pt=Te[Ze])&&Ve(W,We-=Me[Ze],pt)),Qe<W.last_lit;);qe(W,Z,ae)}function vn(W,ae){var Be,We,ge,Ze=ae.dyn_tree,pt=ae.stat_desc.static_tree,Qe=ae.stat_desc.has_stree,Dt=ae.stat_desc.elems,An=-1;for(W.heap_len=0,W.heap_max=S,Be=0;Be<Dt;Be++)0!==Ze[2*Be]?(W.heap[++W.heap_len]=An=Be,W.depth[Be]=0):Ze[2*Be+1]=0;for(;W.heap_len<2;)Ze[2*(ge=W.heap[++W.heap_len]=An<2?++An:0)]=1,W.depth[ge]=0,W.opt_len--,Qe&&(W.static_len-=pt[2*ge+1]);for(ae.max_code=An,Be=W.heap_len>>1;1<=Be;Be--)Xn(W,Ze,Be);for(ge=Dt;Be=W.heap[1],W.heap[1]=W.heap[W.heap_len--],Xn(W,Ze,1),We=W.heap[1],W.heap[--W.heap_max]=Be,W.heap[--W.heap_max]=We,Ze[2*ge]=Ze[2*Be]+Ze[2*We],W.depth[ge]=(W.depth[Be]>=W.depth[We]?W.depth[Be]:W.depth[We])+1,Ze[2*Be+1]=Ze[2*We+1]=ge,W.heap[1]=ge++,Xn(W,Ze,1),2<=W.heap_len;);W.heap[--W.heap_max]=W.heap[1],function(un,_s){var xu,Xs,gl,or,dd,Tf,Kr=_s.dyn_tree,kf=_s.max_code,QI=_s.stat_desc.static_tree,Ib=_s.stat_desc.has_stree,JI=_s.stat_desc.extra_bits,Ef=_s.stat_desc.extra_base,wu=_s.stat_desc.max_length,hd=0;for(or=0;or<=D;or++)un.bl_count[or]=0;for(Kr[2*un.heap[un.heap_max]+1]=0,xu=un.heap_max+1;xu<S;xu++)wu<(or=Kr[2*Kr[2*(Xs=un.heap[xu])+1]+1]+1)&&(or=wu,hd++),Kr[2*Xs+1]=or,kf<Xs||(un.bl_count[or]++,dd=0,Ef<=Xs&&(dd=JI[Xs-Ef]),un.opt_len+=(Tf=Kr[2*Xs])*(or+dd),Ib&&(un.static_len+=Tf*(QI[2*Xs+1]+dd)));if(0!==hd){do{for(or=wu-1;0===un.bl_count[or];)or--;un.bl_count[or]--,un.bl_count[or+1]+=2,un.bl_count[wu]--,hd-=2}while(0<hd);for(or=wu;0!==or;or--)for(Xs=un.bl_count[or];0!==Xs;)kf<(gl=un.heap[--xu])||(Kr[2*gl+1]!==or&&(un.opt_len+=(or-Kr[2*gl+1])*Kr[2*gl],Kr[2*gl+1]=or),Xs--)}}(W,ae),Ur(Ze,An,W.bl_count)}function C(W,ae,Be){var We,ge,Ze=-1,pt=ae[1],Qe=0,Dt=7,An=4;for(0===pt&&(Dt=138,An=3),ae[2*(Be+1)+1]=65535,We=0;We<=Be;We++)ge=pt,pt=ae[2*(We+1)+1],++Qe<Dt&&ge===pt||(Qe<An?W.bl_tree[2*ge]+=Qe:0!==ge?(ge!==Ze&&W.bl_tree[2*ge]++,W.bl_tree[2*ie]++):Qe<=10?W.bl_tree[2*oe]++:W.bl_tree[2*Fe]++,Ze=ge,An=(Qe=0)===pt?(Dt=138,3):ge===pt?(Dt=6,3):(Dt=7,4))}function ye(W,ae,Be){var We,ge,Ze=-1,pt=ae[1],Qe=0,Dt=7,An=4;for(0===pt&&(Dt=138,An=3),We=0;We<=Be;We++)if(ge=pt,pt=ae[2*(We+1)+1],!(++Qe<Dt&&ge===pt)){if(Qe<An)for(;qe(W,ge,W.bl_tree),0!=--Qe;);else 0!==ge?(ge!==Ze&&(qe(W,ge,W.bl_tree),Qe--),qe(W,ie,W.bl_tree),Ve(W,Qe-3,2)):Qe<=10?(qe(W,oe,W.bl_tree),Ve(W,Qe-3,3)):(qe(W,Fe,W.bl_tree),Ve(W,Qe-11,7));Ze=ge,An=(Qe=0)===pt?(Dt=138,3):ge===pt?(Dt=6,3):(Dt=7,4)}}P(Me);var Ie=!1;function H(W,ae,Be,We){var ge,Ze,pt;Ve(W,(G<<1)+(We?1:0),3),Ze=ae,pt=Be,Zt(ge=W),ft(ge,pt),ft(ge,~pt),U.arraySet(ge.pending_buf,ge.window,Ze,pt,ge.pending),ge.pending+=pt}X._tr_init=function(W){Ie||(function(){var ae,Be,We,ge,Ze,pt=new Array(D+1);for(ge=We=0;ge<28;ge++)for(ue[ge]=We,ae=0;ae<1<<Se[ge];ae++)_[We++]=ge;for(_[We-1]=ge,ge=Ze=0;ge<16;ge++)for(Me[ge]=Ze,ae=0;ae<1<<Te[ge];ae++)E[Ze++]=ge;for(Ze>>=7;ge<I;ge++)for(Me[ge]=Ze<<7,ae=0;ae<1<<Te[ge]-7;ae++)E[256+Ze++]=ge;for(Be=0;Be<=D;Be++)pt[Be]=0;for(ae=0;ae<=143;)me[2*ae+1]=8,ae++,pt[8]++;for(;ae<=255;)me[2*ae+1]=9,ae++,pt[9]++;for(;ae<=279;)me[2*ae+1]=7,ae++,pt[7]++;for(;ae<=287;)me[2*ae+1]=8,ae++,pt[8]++;for(Ur(me,T+1,pt),ae=0;ae<I;ae++)O[2*ae+1]=5,O[2*ae]=Nn(ae,5);et=new dt(me,Se,B+1,T,D),ke=new dt(O,Te,0,I,D),ut=new dt(new Array(0),de,0,A,7)}(),Ie=!0),W.l_desc=new ce(W.dyn_ltree,et),W.d_desc=new ce(W.dyn_dtree,ke),W.bl_desc=new ce(W.bl_tree,ut),W.bi_buf=0,W.bi_valid=0,an(W)},X._tr_stored_block=H,X._tr_flush_block=function(W,ae,Be,We){var ge,Ze,pt=0;0<W.level?(2===W.strm.data_type&&(W.strm.data_type=function(Qe){var Dt,An=4093624447;for(Dt=0;Dt<=31;Dt++,An>>>=1)if(1&An&&0!==Qe.dyn_ltree[2*Dt])return 0;if(0!==Qe.dyn_ltree[18]||0!==Qe.dyn_ltree[20]||0!==Qe.dyn_ltree[26])return 1;for(Dt=32;Dt<B;Dt++)if(0!==Qe.dyn_ltree[2*Dt])return 1;return 0}(W)),vn(W,W.l_desc),vn(W,W.d_desc),pt=function(Qe){var Dt;for(C(Qe,Qe.dyn_ltree,Qe.l_desc.max_code),C(Qe,Qe.dyn_dtree,Qe.d_desc.max_code),vn(Qe,Qe.bl_desc),Dt=A-1;3<=Dt&&0===Qe.bl_tree[2*Oe[Dt]+1];Dt--);return Qe.opt_len+=3*(Dt+1)+5+5+4,Dt}(W),(Ze=W.static_len+3+7>>>3)<=(ge=W.opt_len+3+7>>>3)&&(ge=Ze)):ge=Ze=Be+5,Be+4<=ge&&-1!==ae?H(W,ae,Be,We):4===W.strategy||Ze===ge?(Ve(W,2+(We?1:0),3),In(W,me,O)):(Ve(W,4+(We?1:0),3),function(Qe,Dt,An,un){var _s;for(Ve(Qe,Dt-257,5),Ve(Qe,An-1,5),Ve(Qe,un-4,4),_s=0;_s<un;_s++)Ve(Qe,Qe.bl_tree[2*Oe[_s]+1],3);ye(Qe,Qe.dyn_ltree,Dt-1),ye(Qe,Qe.dyn_dtree,An-1)}(W,W.l_desc.max_code+1,W.d_desc.max_code+1,pt+1),In(W,W.dyn_ltree,W.dyn_dtree)),an(W),We&&Zt(W)},X._tr_tally=function(W,ae,Be){return W.pending_buf[W.d_buf+2*W.last_lit]=ae>>>8&255,W.pending_buf[W.d_buf+2*W.last_lit+1]=255&ae,W.pending_buf[W.l_buf+W.last_lit]=255&Be,W.last_lit++,0===ae?W.dyn_ltree[2*Be]++:(W.matches++,ae--,W.dyn_ltree[2*(_[Be]+B+1)]++,W.dyn_dtree[2*le(ae)]++),W.last_lit===W.lit_bufsize-1},X._tr_align=function(W){var ae;Ve(W,2,3),qe(W,Z,me),16===(ae=W).bi_valid?(ft(ae,ae.bi_buf),ae.bi_buf=0,ae.bi_valid=0):8<=ae.bi_valid&&(ae.pending_buf[ae.pending++]=255&ae.bi_buf,ae.bi_buf>>=8,ae.bi_valid-=8)}},{"../utils/common":41}],53:[function(q,ne,X){"use strict";ne.exports=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0}},{}],54:[function(q,ne,X){(function(U){!function(M,F){"use strict";if(!M.setImmediate){var P,G,j,B,T=1,I={},A=!1,S=M.document,D=Object.getPrototypeOf&&Object.getPrototypeOf(M);D=D&&D.setTimeout?D:M,P="[object process]"==={}.toString.call(M.process)?function(ie){process.nextTick(function(){L(ie)})}:function(){if(M.postMessage&&!M.importScripts){var ie=!0,oe=M.onmessage;return M.onmessage=function(){ie=!1},M.postMessage("","*"),M.onmessage=oe,ie}}()?(B="setImmediate$"+Math.random()+"$",M.addEventListener?M.addEventListener("message",Z,!1):M.attachEvent("onmessage",Z),function(ie){M.postMessage(B+ie,"*")}):M.MessageChannel?((j=new MessageChannel).port1.onmessage=function(ie){L(ie.data)},function(ie){j.port2.postMessage(ie)}):S&&"onreadystatechange"in S.createElement("script")?(G=S.documentElement,function(ie){var oe=S.createElement("script");oe.onreadystatechange=function(){L(ie),oe.onreadystatechange=null,G.removeChild(oe),oe=null},G.appendChild(oe)}):function(ie){setTimeout(L,0,ie)},D.setImmediate=function(ie){"function"!=typeof ie&&(ie=new Function(""+ie));for(var oe=new Array(arguments.length-1),Fe=0;Fe<oe.length;Fe++)oe[Fe]=arguments[Fe+1];return I[T]={callback:ie,args:oe},P(T),T++},D.clearImmediate=N}function N(ie){delete I[ie]}function L(ie){if(A)setTimeout(L,0,ie);else{var oe=I[ie];if(oe){A=!0;try{!function(Fe){var Se=Fe.callback,Te=Fe.args;switch(Te.length){case 0:Se();break;case 1:Se(Te[0]);break;case 2:Se(Te[0],Te[1]);break;case 3:Se(Te[0],Te[1],Te[2]);break;default:Se.apply(F,Te)}}(oe)}finally{N(ie),A=!1}}}}function Z(ie){ie.source===M&&"string"==typeof ie.data&&0===ie.data.indexOf(B)&&L(+ie.data.slice(B.length))}}(typeof self>"u"?void 0===U?this:U:self)}).call(this,typeof global<"u"?global:typeof self<"u"?self:typeof window<"u"?window:{})},{}]},{},[10])(10)},658:jt=>{jt.exports=ne;var q=null;try{q=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function ne(O,E,_){this.low=0|O,this.high=0|E,this.unsigned=!!_}function X(O){return!0===(O&&O.__isLong__)}Object.defineProperty(ne.prototype,"__isLong__",{value:!0}),ne.isLong=X;var U={},M={};function F(O,E){var _,ue,et;return E?(et=0<=(O>>>=0)&&O<256)&&(ue=M[O])?ue:(_=G(O,(0|O)<0?-1:0,!0),et&&(M[O]=_),_):(et=-128<=(O|=0)&&O<128)&&(ue=U[O])?ue:(_=G(O,O<0?-1:0,!1),et&&(U[O]=_),_)}function P(O,E){if(isNaN(O))return E?ie:Z;if(E){if(O<0)return ie;if(O>=D)return de}else{if(O<=-N)return Oe;if(O+1>=N)return Te}return O<0?P(-O,E).neg():G(O%S|0,O/S|0,E)}function G(O,E,_){return new ne(O,E,_)}ne.fromInt=F,ne.fromNumber=P,ne.fromBits=G;var j=Math.pow;function B(O,E,_){if(0===O.length)throw Error("empty string");if("NaN"===O||"Infinity"===O||"+Infinity"===O||"-Infinity"===O)return Z;if("number"==typeof E?(_=E,E=!1):E=!!E,(_=_||10)<2||36<_)throw RangeError("radix");var ue;if((ue=O.indexOf("-"))>0)throw Error("interior hyphen");if(0===ue)return B(O.substring(1),E,_).neg();for(var et=P(j(_,8)),ke=Z,ut=0;ut<O.length;ut+=8){var Me=Math.min(8,O.length-ut),dt=parseInt(O.substring(ut,ut+Me),_);if(Me<8){var ce=P(j(_,Me));ke=ke.mul(ce).add(P(dt))}else ke=(ke=ke.mul(et)).add(P(dt))}return ke.unsigned=E,ke}function T(O,E){return"number"==typeof O?P(O,E):"string"==typeof O?B(O,E):G(O.low,O.high,"boolean"==typeof E?E:O.unsigned)}ne.fromString=B,ne.fromValue=T;var S=4294967296,D=S*S,N=D/2,L=F(1<<24),Z=F(0);ne.ZERO=Z;var ie=F(0,!0);ne.UZERO=ie;var oe=F(1);ne.ONE=oe;var Fe=F(1,!0);ne.UONE=Fe;var Se=F(-1);ne.NEG_ONE=Se;var Te=G(-1,2147483647,!1);ne.MAX_VALUE=Te;var de=G(-1,-1,!0);ne.MAX_UNSIGNED_VALUE=de;var Oe=G(0,-2147483648,!1);ne.MIN_VALUE=Oe;var me=ne.prototype;me.toInt=function(){return this.unsigned?this.low>>>0:this.low},me.toNumber=function(){return this.unsigned?(this.high>>>0)*S+(this.low>>>0):this.high*S+(this.low>>>0)},me.toString=function(E){if((E=E||10)<2||36<E)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(Oe)){var _=P(E),ue=this.div(_),et=ue.mul(_).sub(this);return ue.toString(E)+et.toInt().toString(E)}return"-"+this.neg().toString(E)}for(var ke=P(j(E,6),this.unsigned),ut=this,Me="";;){var dt=ut.div(ke),le=(ut.sub(dt.mul(ke)).toInt()>>>0).toString(E);if((ut=dt).isZero())return le+Me;for(;le.length<6;)le="0"+le;Me=""+le+Me}},me.getHighBits=function(){return this.high},me.getHighBitsUnsigned=function(){return this.high>>>0},me.getLowBits=function(){return this.low},me.getLowBitsUnsigned=function(){return this.low>>>0},me.getNumBitsAbs=function(){if(this.isNegative())return this.eq(Oe)?64:this.neg().getNumBitsAbs();for(var E=0!=this.high?this.high:this.low,_=31;_>0&&!(E&1<<_);_--);return 0!=this.high?_+33:_+1},me.isZero=function(){return 0===this.high&&0===this.low},me.eqz=me.isZero,me.isNegative=function(){return!this.unsigned&&this.high<0},me.isPositive=function(){return this.unsigned||this.high>=0},me.isOdd=function(){return 1==(1&this.low)},me.isEven=function(){return 0==(1&this.low)},me.equals=function(E){return X(E)||(E=T(E)),(this.unsigned===E.unsigned||this.high>>>31!=1||E.high>>>31!=1)&&this.high===E.high&&this.low===E.low},me.eq=me.equals,me.notEquals=function(E){return!this.eq(E)},me.neq=me.notEquals,me.ne=me.notEquals,me.lessThan=function(E){return this.comp(E)<0},me.lt=me.lessThan,me.lessThanOrEqual=function(E){return this.comp(E)<=0},me.lte=me.lessThanOrEqual,me.le=me.lessThanOrEqual,me.greaterThan=function(E){return this.comp(E)>0},me.gt=me.greaterThan,me.greaterThanOrEqual=function(E){return this.comp(E)>=0},me.gte=me.greaterThanOrEqual,me.ge=me.greaterThanOrEqual,me.compare=function(E){if(X(E)||(E=T(E)),this.eq(E))return 0;var _=this.isNegative(),ue=E.isNegative();return _&&!ue?-1:!_&&ue?1:this.unsigned?E.high>>>0>this.high>>>0||E.high===this.high&&E.low>>>0>this.low>>>0?-1:1:this.sub(E).isNegative()?-1:1},me.comp=me.compare,me.negate=function(){return!this.unsigned&&this.eq(Oe)?Oe:this.not().add(oe)},me.neg=me.negate,me.add=function(E){X(E)||(E=T(E));var le=0,ft=0,Ve=0,qe=0;return Ve+=(qe+=(65535&this.low)+(65535&E.low))>>>16,ft+=(Ve+=(this.low>>>16)+(E.low>>>16))>>>16,le+=(ft+=(65535&this.high)+(65535&E.high))>>>16,le+=(this.high>>>16)+(E.high>>>16),G((Ve&=65535)<<16|(qe&=65535),(le&=65535)<<16|(ft&=65535),this.unsigned)},me.subtract=function(E){return X(E)||(E=T(E)),this.add(E.neg())},me.sub=me.subtract,me.multiply=function(E){if(this.isZero())return Z;if(X(E)||(E=T(E)),q)return G(q.mul(this.low,this.high,E.low,E.high),q.get_high(),this.unsigned);if(E.isZero())return Z;if(this.eq(Oe))return E.isOdd()?Oe:Z;if(E.eq(Oe))return this.isOdd()?Oe:Z;if(this.isNegative())return E.isNegative()?this.neg().mul(E.neg()):this.neg().mul(E).neg();if(E.isNegative())return this.mul(E.neg()).neg();if(this.lt(L)&&E.lt(L))return P(this.toNumber()*E.toNumber(),this.unsigned);var et=65535&this.high,ke=this.low>>>16,ut=65535&this.low,dt=65535&E.high,ce=E.low>>>16,le=65535&E.low,ft=0,Ve=0,qe=0,Nn=0;return qe+=(Nn+=ut*le)>>>16,Ve+=(qe+=ke*le)>>>16,qe&=65535,Ve+=(qe+=ut*ce)>>>16,ft+=(Ve+=et*le)>>>16,Ve&=65535,ft+=(Ve+=ke*ce)>>>16,Ve&=65535,ft+=(Ve+=ut*dt)>>>16,ft+=(this.high>>>16)*le+et*ce+ke*dt+ut*(E.high>>>16),G((qe&=65535)<<16|(Nn&=65535),(ft&=65535)<<16|(Ve&=65535),this.unsigned)},me.mul=me.multiply,me.divide=function(E){if(X(E)||(E=T(E)),E.isZero())throw Error("division by zero");var ue,et,ke;if(q)return this.unsigned||-2147483648!==this.high||-1!==E.low||-1!==E.high?G((this.unsigned?q.div_u:q.div_s)(this.low,this.high,E.low,E.high),q.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?ie:Z;if(this.unsigned){if(E.unsigned||(E=E.toUnsigned()),E.gt(this))return ie;if(E.gt(this.shru(1)))return Fe;ke=ie}else{if(this.eq(Oe))return E.eq(oe)||E.eq(Se)?Oe:E.eq(Oe)?oe:(ue=this.shr(1).div(E).shl(1)).eq(Z)?E.isNegative()?oe:Se:(et=this.sub(E.mul(ue)),ke=ue.add(et.div(E)));if(E.eq(Oe))return this.unsigned?ie:Z;if(this.isNegative())return E.isNegative()?this.neg().div(E.neg()):this.neg().div(E).neg();if(E.isNegative())return this.div(E.neg()).neg();ke=Z}for(et=this;et.gte(E);){ue=Math.max(1,Math.floor(et.toNumber()/E.toNumber()));for(var Me=Math.ceil(Math.log(ue)/Math.LN2),dt=Me<=48?1:j(2,Me-48),ce=P(ue),le=ce.mul(E);le.isNegative()||le.gt(et);)le=(ce=P(ue-=dt,this.unsigned)).mul(E);ce.isZero()&&(ce=oe),ke=ke.add(ce),et=et.sub(le)}return ke},me.div=me.divide,me.modulo=function(E){return X(E)||(E=T(E)),q?G((this.unsigned?q.rem_u:q.rem_s)(this.low,this.high,E.low,E.high),q.get_high(),this.unsigned):this.sub(this.div(E).mul(E))},me.mod=me.modulo,me.rem=me.modulo,me.not=function(){return G(~this.low,~this.high,this.unsigned)},me.and=function(E){return X(E)||(E=T(E)),G(this.low&E.low,this.high&E.high,this.unsigned)},me.or=function(E){return X(E)||(E=T(E)),G(this.low|E.low,this.high|E.high,this.unsigned)},me.xor=function(E){return X(E)||(E=T(E)),G(this.low^E.low,this.high^E.high,this.unsigned)},me.shiftLeft=function(E){return X(E)&&(E=E.toInt()),0==(E&=63)?this:E<32?G(this.low<<E,this.high<<E|this.low>>>32-E,this.unsigned):G(0,this.low<<E-32,this.unsigned)},me.shl=me.shiftLeft,me.shiftRight=function(E){return X(E)&&(E=E.toInt()),0==(E&=63)?this:E<32?G(this.low>>>E|this.high<<32-E,this.high>>E,this.unsigned):G(this.high>>E-32,this.high>=0?0:-1,this.unsigned)},me.shr=me.shiftRight,me.shiftRightUnsigned=function(E){if(X(E)&&(E=E.toInt()),0==(E&=63))return this;var _=this.high;return E<32?G(this.low>>>E|_<<32-E,_>>>E,this.unsigned):G(32===E?_:_>>>E-32,0,this.unsigned)},me.shru=me.shiftRightUnsigned,me.shr_u=me.shiftRightUnsigned,me.toSigned=function(){return this.unsigned?G(this.low,this.high,!1):this},me.toUnsigned=function(){return this.unsigned?this:G(this.low,this.high,!0)},me.toBytes=function(E){return E?this.toBytesLE():this.toBytesBE()},me.toBytesLE=function(){var E=this.high,_=this.low;return[255&_,_>>>8&255,_>>>16&255,_>>>24,255&E,E>>>8&255,E>>>16&255,E>>>24]},me.toBytesBE=function(){var E=this.high,_=this.low;return[E>>>24,E>>>16&255,E>>>8&255,255&E,_>>>24,_>>>16&255,_>>>8&255,255&_]},ne.fromBytes=function(E,_,ue){return ue?ne.fromBytesLE(E,_):ne.fromBytesBE(E,_)},ne.fromBytesLE=function(E,_){return new ne(E[0]|E[1]<<8|E[2]<<16|E[3]<<24,E[4]|E[5]<<8|E[6]<<16|E[7]<<24,_)},ne.fromBytesBE=function(E,_){return new ne(E[4]<<24|E[5]<<16|E[6]<<8|E[7],E[0]<<24|E[1]<<16|E[2]<<8|E[3],_)}},340:(jt,q,ne)=>{var X=ne(471),U=ne(992),M=ne(657),F=ne(583),P=ne(929),G=ne(83),j=ne(818);j.alea=X,j.xor128=U,j.xorwow=M,j.xorshift7=F,j.xor4096=P,j.tychei=G,jt.exports=j},471:function(jt,q,ne){var X;!function(U,M,F){function P(T){var I=this,A=function B(){var T=4022871197;return function(A){A=String(A);for(var S=0;S<A.length;S++){var D=.02519603282416938*(T+=A.charCodeAt(S));D-=T=D>>>0,T=(D*=T)>>>0,T+=4294967296*(D-=T)}return 2.3283064365386963e-10*(T>>>0)}}();I.next=function(){var S=2091639*I.s0+2.3283064365386963e-10*I.c;return I.s0=I.s1,I.s1=I.s2,I.s2=S-(I.c=0|S)},I.c=1,I.s0=A(" "),I.s1=A(" "),I.s2=A(" "),I.s0-=A(T),I.s0<0&&(I.s0+=1),I.s1-=A(T),I.s1<0&&(I.s1+=1),I.s2-=A(T),I.s2<0&&(I.s2+=1),A=null}function G(T,I){return I.c=T.c,I.s0=T.s0,I.s1=T.s1,I.s2=T.s2,I}function j(T,I){var A=new P(T),S=I&&I.state,D=A.next;return D.int32=function(){return 4294967296*A.next()|0},D.double=function(){return D()+11102230246251565e-32*(2097152*D()|0)},D.quick=D,S&&("object"==typeof S&&G(S,A),D.state=function(){return G(A,{})}),D}M&&M.exports?M.exports=j:ne.amdD&&ne.amdO?void 0!==(X=function(){return j}.call(q,ne,q,M))&&(M.exports=X):this.alea=j}(0,jt=ne.nmd(jt))},83:function(jt,q,ne){var X;!function(U,M,F){function P(B){var T=this,I="";T.next=function(){var S=T.b,D=T.c,N=T.d,L=T.a;return S=S<<25^S>>>7^D,D=D-N|0,N=N<<24^N>>>8^L,L=L-S|0,T.b=S=S<<20^S>>>12^D,T.c=D=D-N|0,T.d=N<<16^D>>>16^L,T.a=L-S|0},T.a=0,T.b=0,T.c=-1640531527,T.d=1367130551,B===Math.floor(B)?(T.a=B/4294967296|0,T.b=0|B):I+=B;for(var A=0;A<I.length+20;A++)T.b^=0|I.charCodeAt(A),T.next()}function G(B,T){return T.a=B.a,T.b=B.b,T.c=B.c,T.d=B.d,T}function j(B,T){var I=new P(B),A=T&&T.state,S=function(){return(I.next()>>>0)/4294967296};return S.double=function(){do{var L=((I.next()>>>11)+(I.next()>>>0)/4294967296)/(1<<21)}while(0===L);return L},S.int32=I.next,S.quick=S,A&&("object"==typeof A&&G(A,I),S.state=function(){return G(I,{})}),S}M&&M.exports?M.exports=j:ne.amdD&&ne.amdO?void 0!==(X=function(){return j}.call(q,ne,q,M))&&(M.exports=X):this.tychei=j}(0,jt=ne.nmd(jt))},992:function(jt,q,ne){var X;!function(U,M,F){function P(B){var T=this,I="";T.x=0,T.y=0,T.z=0,T.w=0,T.next=function(){var S=T.x^T.x<<11;return T.x=T.y,T.y=T.z,T.z=T.w,T.w^=T.w>>>19^S^S>>>8},B===(0|B)?T.x=B:I+=B;for(var A=0;A<I.length+64;A++)T.x^=0|I.charCodeAt(A),T.next()}function G(B,T){return T.x=B.x,T.y=B.y,T.z=B.z,T.w=B.w,T}function j(B,T){var I=new P(B),A=T&&T.state,S=function(){return(I.next()>>>0)/4294967296};return S.double=function(){do{var L=((I.next()>>>11)+(I.next()>>>0)/4294967296)/(1<<21)}while(0===L);return L},S.int32=I.next,S.quick=S,A&&("object"==typeof A&&G(A,I),S.state=function(){return G(I,{})}),S}M&&M.exports?M.exports=j:ne.amdD&&ne.amdO?void 0!==(X=function(){return j}.call(q,ne,q,M))&&(M.exports=X):this.xor128=j}(0,jt=ne.nmd(jt))},929:function(jt,q,ne){var X;!function(U,M,F){function P(B){var T=this;T.next=function(){var N,L,A=T.w,S=T.X,D=T.i;return T.w=A=A+1640531527|0,L=S[D+34&127],N=S[D=D+1&127],L^=L<<13,N^=N<<17,L=S[D]=(L^=L>>>15)^(N^=N>>>12),T.i=D,L+(A^A>>>16)|0},function I(A,S){var D,N,L,Z,ie,oe=[],Fe=128;for(S===(0|S)?(N=S,S=null):(S+="\0",N=0,Fe=Math.max(Fe,S.length)),L=0,Z=-32;Z<Fe;++Z)S&&(N^=S.charCodeAt((Z+32)%S.length)),0===Z&&(ie=N),N^=N<<10,N^=N>>>15,N^=N<<4,N^=N>>>13,Z>=0&&(L=0==(D=oe[127&Z]^=N+(ie=ie+1640531527|0))?L+1:0);for(L>=128&&(oe[127&(S&&S.length||0)]=-1),L=127,Z=512;Z>0;--Z)N=oe[L+34&127],D=oe[L=L+1&127],N^=N<<13,D^=D<<17,oe[L]=(N^=N>>>15)^(D^=D>>>12);A.w=ie,A.X=oe,A.i=L}(T,B)}function G(B,T){return T.i=B.i,T.w=B.w,T.X=B.X.slice(),T}function j(B,T){null==B&&(B=+new Date);var I=new P(B),A=T&&T.state,S=function(){return(I.next()>>>0)/4294967296};return S.double=function(){do{var L=((I.next()>>>11)+(I.next()>>>0)/4294967296)/(1<<21)}while(0===L);return L},S.int32=I.next,S.quick=S,A&&(A.X&&G(A,I),S.state=function(){return G(I,{})}),S}M&&M.exports?M.exports=j:ne.amdD&&ne.amdO?void 0!==(X=function(){return j}.call(q,ne,q,M))&&(M.exports=X):this.xor4096=j}(0,jt=ne.nmd(jt))},583:function(jt,q,ne){var X;!function(U,M,F){function P(B){var T=this;T.next=function(){var D,N,A=T.x,S=T.i;return D=A[S],N=(D^=D>>>7)^D<<24,N^=(D=A[S+1&7])^D>>>10,N^=(D=A[S+3&7])^D>>>3,N^=(D=A[S+4&7])^D<<7,D=A[S+7&7],A[S]=N^=(D^=D<<13)^D<<9,T.i=S+1&7,N},function I(A,S){var D,L=[];if(S===(0|S))L[0]=S;else for(S=""+S,D=0;D<S.length;++D)L[7&D]=L[7&D]<<15^S.charCodeAt(D)+L[D+1&7]<<13;for(;L.length<8;)L.push(0);for(D=0;D<8&&0===L[D];++D);for(8==D&&(L[7]=-1),A.x=L,A.i=0,D=256;D>0;--D)A.next()}(T,B)}function G(B,T){return T.x=B.x.slice(),T.i=B.i,T}function j(B,T){null==B&&(B=+new Date);var I=new P(B),A=T&&T.state,S=function(){return(I.next()>>>0)/4294967296};return S.double=function(){do{var L=((I.next()>>>11)+(I.next()>>>0)/4294967296)/(1<<21)}while(0===L);return L},S.int32=I.next,S.quick=S,A&&(A.x&&G(A,I),S.state=function(){return G(I,{})}),S}M&&M.exports?M.exports=j:ne.amdD&&ne.amdO?void 0!==(X=function(){return j}.call(q,ne,q,M))&&(M.exports=X):this.xorshift7=j}(0,jt=ne.nmd(jt))},657:function(jt,q,ne){var X;!function(U,M,F){function P(B){var T=this,I="";T.next=function(){var S=T.x^T.x>>>2;return T.x=T.y,T.y=T.z,T.z=T.w,T.w=T.v,(T.d=T.d+362437|0)+(T.v=T.v^T.v<<4^S^S<<1)|0},T.x=0,T.y=0,T.z=0,T.w=0,T.v=0,B===(0|B)?T.x=B:I+=B;for(var A=0;A<I.length+64;A++)T.x^=0|I.charCodeAt(A),A==I.length&&(T.d=T.x<<10^T.x>>>4),T.next()}function G(B,T){return T.x=B.x,T.y=B.y,T.z=B.z,T.w=B.w,T.v=B.v,T.d=B.d,T}function j(B,T){var I=new P(B),A=T&&T.state,S=function(){return(I.next()>>>0)/4294967296};return S.double=function(){do{var L=((I.next()>>>11)+(I.next()>>>0)/4294967296)/(1<<21)}while(0===L);return L},S.int32=I.next,S.quick=S,A&&("object"==typeof A&&G(A,I),S.state=function(){return G(I,{})}),S}M&&M.exports?M.exports=j:ne.amdD&&ne.amdO?void 0!==(X=function(){return j}.call(q,ne,q,M))&&(M.exports=X):this.xorwow=j}(0,jt=ne.nmd(jt))},818:function(jt,q,ne){var X;!function(U,M,F){var D,P=256,G=6,B="random",T=F.pow(P,G),I=F.pow(2,52),A=2*I,S=P-1;function N(Te,de,Oe){var me=[],O=oe(ie((de=1==de?{entropy:!0}:de||{}).entropy?[Te,Se(M)]:Te??function Fe(){try{var Te;return D&&(Te=D.randomBytes)?Te=Te(P):(Te=new Uint8Array(P),(U.crypto||U.msCrypto).getRandomValues(Te)),Se(Te)}catch{var de=U.navigator,Oe=de&&de.plugins;return[+new Date,U,Oe,U.screen,Se(M)]}}(),3),me),E=new L(me),_=function(){for(var ue=E.g(G),et=T,ke=0;ue<I;)ue=(ue+ke)*P,et*=P,ke=E.g(1);for(;ue>=A;)ue/=2,et/=2,ke>>>=1;return(ue+ke)/et};return _.int32=function(){return 0|E.g(4)},_.quick=function(){return E.g(4)/4294967296},_.double=_,oe(Se(E.S),M),(de.pass||Oe||function(ue,et,ke,ut){return ut&&(ut.S&&Z(ut,E),ue.state=function(){return Z(E,{})}),ke?(F[B]=ue,et):ue})(_,O,"global"in de?de.global:this==F,de.state)}function L(Te){var de,Oe=Te.length,me=this,O=0,E=me.i=me.j=0,_=me.S=[];for(Oe||(Te=[Oe++]);O<P;)_[O]=O++;for(O=0;O<P;O++)_[O]=_[E=S&E+Te[O%Oe]+(de=_[O])],_[E]=de;(me.g=function(ue){for(var et,ke=0,ut=me.i,Me=me.j,dt=me.S;ue--;)et=dt[ut=S&ut+1],ke=ke*P+dt[S&(dt[ut]=dt[Me=S&Me+et])+(dt[Me]=et)];return me.i=ut,me.j=Me,ke})(P)}function Z(Te,de){return de.i=Te.i,de.j=Te.j,de.S=Te.S.slice(),de}function ie(Te,de){var O,Oe=[],me=typeof Te;if(de&&"object"==me)for(O in Te)try{Oe.push(ie(Te[O],de-1))}catch{}return Oe.length?Oe:"string"==me?Te:Te+"\0"}function oe(Te,de){for(var me,Oe=Te+"",O=0;O<Oe.length;)de[S&O]=S&(me^=19*de[S&O])+Oe.charCodeAt(O++);return Se(de)}function Se(Te){return String.fromCharCode.apply(0,Te)}if(oe(F.random(),M),jt.exports){jt.exports=N;try{D=ne(42)}catch{}}else void 0!==(X=function(){return N}.call(q,ne,q,jt))&&(jt.exports=X)}(typeof self<"u"?self:this,[],Math)},410:()=>{},628:()=>{},601:()=>{},792:()=>{},977:()=>{},42:()=>{}},jt=>{jt(jt.s=106)}]);