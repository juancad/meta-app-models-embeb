(self.webpackChunkmeta_app_models=self.webpackChunkmeta_app_models||[]).push([[179],{240:(Et,It,de)=>{"use strict";var Ke={};de.r(Ke),de.d(Ke,{assertParamsValid:()=>M_,computeFlatOffset:()=>$_,computeOutShape:()=>P_,getNormalizedAxes:()=>JZ,isSliceContinous:()=>O_,maskToAxes:()=>QZ,parseSliceParams:()=>Iy,sliceInfo:()=>L_,startForAxis:()=>mP,startIndicesWithElidedDims:()=>hP,stopForAxis:()=>gP,stopIndicesWithElidedDims:()=>pP,stridesForAxis:()=>fP,stridesWithElidedDims:()=>uP});var qn={};de.r(qn),de.d(qn,{collectGatherOpShapeInfo:()=>$S,computeOutShape:()=>vO,segOpComputeOptimalWindowSize:()=>bO});var et={};de.r(et),de.d(et,{ERF_A1:()=>_S,ERF_A2:()=>SS,ERF_A3:()=>IS,ERF_A4:()=>DS,ERF_A5:()=>TS,ERF_P:()=>CS,PARALLELIZE_THRESHOLD:()=>yS,RowPartitionType:()=>uo,SELU_SCALE:()=>Gy,SELU_SCALEALPHA:()=>Wy,applyActivation:()=>$y,assertAndGetBroadcastShape:()=>st,assertAxesAreInnerMostDims:()=>xr,assertParamsConsistent:()=>gS,assignToTypedArray:()=>nO,axesAreInnerMostDims:()=>K_,calculateShapes:()=>Fl,checkEinsumDimSizes:()=>RS,checkPadOnDimRoundingMode:()=>Hr,combineLocations:()=>IP,combineRaggedTensorToTensorShapes:()=>KP,complexWithEvenIndex:()=>eO,complexWithOddIndex:()=>tO,computeConv2DInfo:()=>cr,computeConv3DInfo:()=>Ca,computeDefaultPad:()=>B_,computeDilation2DInfo:()=>pp,computeOptimalWindowSize:()=>Uy,computeOutAndReduceShapes:()=>dr,computeOutShape:()=>ii,computePool2DInfo:()=>so,computePool3DInfo:()=>Bi,convertConv2DDataFormat:()=>zi,decodeEinsumEquation:()=>kS,eitherStridesOrDilationsAreOne:()=>vr,expandShapeToKeepDim:()=>On,exponent:()=>sO,exponents:()=>rO,fromStringArrayToUint8:()=>xO,fromUint8ToStringArray:()=>ji,getAxesPermutation:()=>Cn,getBroadcastDims:()=>dc,getComplexWithIndex:()=>ES,getEinsumComputePath:()=>FS,getEinsumPermutation:()=>AS,getFusedBiasGradient:()=>Oy,getFusedDyActivation:()=>Py,getImageCenter:()=>bS,getInnerMostAxes:()=>$n,getPermuted:()=>_p,getRaggedRank:()=>YP,getReductionAxes:()=>Qn,getReshaped:()=>Cp,getReshapedPermuted:()=>Sp,getRowPartitionTypesHelper:()=>XP,getSliceBeginCoords:()=>vS,getSliceSize:()=>xS,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>aO,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>lO,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>uO,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>hO,getSparseReshapeInputOutputMismatchErrorMessage:()=>fO,getSparseReshapeInputOutputMultipleErrorMessage:()=>pO,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>cO,getSparseReshapeNegativeOutputDimErrorMessage:()=>dO,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>yO,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>OS,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>mO,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>gO,getUndoAxesPermutation:()=>Sa,isIdentityPermutation:()=>MS,log:()=>CY,mergeRealAndImagArrays:()=>Hi,prepareAndValidate:()=>wS,prepareSplitSize:()=>PS,segment_util:()=>qn,shouldFuse:()=>Ly,slice_util:()=>Ke,splitRealAndImagArrays:()=>JP,stridesOrDilationsArePositive:()=>Tl,tupleValuesAreOne:()=>_a,upcastType:()=>ys,validateDefaultValueShape:()=>ZP,validateInput:()=>Zte,validateUpdateShape:()=>QP,warn:()=>Ps});var hn={};function Fe(t){return"function"==typeof t}function Ve(t){const e=t(r=>{Error.call(r),r.stack=(new Error).stack});return e.prototype=Object.create(Error.prototype),e.prototype.constructor=e,e}de.r(hn),de.d(hn,{addImpl:()=>qL,bincountImpl:()=>WI,bincountReduceImpl:()=>JL,castImpl:()=>jL,ceilImpl:()=>eV,concatImpl:()=>tV,equalImpl:()=>sV,expImpl:()=>iV,expm1Impl:()=>lV,floorDivImpl:()=>hV,floorImpl:()=>dV,gatherNdImpl:()=>pV,gatherV2Impl:()=>fV,greaterEqualImpl:()=>gV,greaterImpl:()=>mV,lessEqualImpl:()=>bV,lessImpl:()=>yV,linSpaceImpl:()=>vV,logImpl:()=>xV,maxImpl:()=>wV,maximumImpl:()=>_V,minimumImpl:()=>SV,multiplyImpl:()=>GI,negImpl:()=>DV,notEqualImpl:()=>TV,prodImpl:()=>AV,raggedGatherImpl:()=>FV,raggedRangeImpl:()=>PV,raggedTensorToTensorImpl:()=>LV,rangeImpl:()=>VV,rsqrtImpl:()=>BV,scatterImpl:()=>Wl,sigmoidImpl:()=>yle,simpleAbsImpl:()=>XL,sliceImpl:()=>QL,sparseFillEmptyRowsImpl:()=>UV,sparseReshapeImpl:()=>WV,sparseSegmentReductionImpl:()=>YI,sqrtImpl:()=>Vpe,squaredDifferenceImpl:()=>GV,staticRegexReplaceImpl:()=>HV,stridedSliceImpl:()=>jV,stringNGramsImpl:()=>qV,stringSplitImpl:()=>KV,stringToHashBucketFastImpl:()=>XV,subImpl:()=>uV,tileImpl:()=>YV,topKImpl:()=>QV,transposeImpl:()=>zI,uniqueImpl:()=>e3});const ct=Ve(t=>function(e){t(this),this.message=e?`${e.length} errors occurred during unsubscription:\n${e.map((r,s)=>`${s+1}) ${r.toString()}`).join("\n  ")}`:"",this.name="UnsubscriptionError",this.errors=e});function Ie(t,n){if(t){const e=t.indexOf(n);0<=e&&t.splice(e,1)}}class O{constructor(n){this.initialTeardown=n,this.closed=!1,this._parentage=null,this._finalizers=null}unsubscribe(){let n;if(!this.closed){this.closed=!0;const{_parentage:e}=this;if(e)if(this._parentage=null,Array.isArray(e))for(const o of e)o.remove(this);else e.remove(this);const{initialTeardown:r}=this;if(Fe(r))try{r()}catch(o){n=o instanceof ct?o.errors:[o]}const{_finalizers:s}=this;if(s){this._finalizers=null;for(const o of s)try{Z(o)}catch(i){n=n??[],i instanceof ct?n=[...n,...i.errors]:n.push(i)}}if(n)throw new ct(n)}}add(n){var e;if(n&&n!==this)if(this.closed)Z(n);else{if(n instanceof O){if(n.closed||n._hasParent(this))return;n._addParent(this)}(this._finalizers=null!==(e=this._finalizers)&&void 0!==e?e:[]).push(n)}}_hasParent(n){const{_parentage:e}=this;return e===n||Array.isArray(e)&&e.includes(n)}_addParent(n){const{_parentage:e}=this;this._parentage=Array.isArray(e)?(e.push(n),e):e?[e,n]:n}_removeParent(n){const{_parentage:e}=this;e===n?this._parentage=null:Array.isArray(e)&&Ie(e,n)}remove(n){const{_finalizers:e}=this;e&&Ie(e,n),n instanceof O&&n._removeParent(this)}}O.EMPTY=(()=>{const t=new O;return t.closed=!0,t})();const ue=O.EMPTY;function ye(t){return t instanceof O||t&&"closed"in t&&Fe(t.remove)&&Fe(t.add)&&Fe(t.unsubscribe)}function Z(t){Fe(t)?t():t.unsubscribe()}const oe={onUnhandledError:null,onStoppedNotification:null,Promise:void 0,useDeprecatedSynchronousErrorHandling:!1,useDeprecatedNextContext:!1},Te={setTimeout(t,n,...e){const{delegate:r}=Te;return r?.setTimeout?r.setTimeout(t,n,...e):setTimeout(t,n,...e)},clearTimeout(t){const{delegate:n}=Te;return(n?.clearTimeout||clearTimeout)(t)},delegate:void 0};function Me(t){Te.setTimeout(()=>{const{onUnhandledError:n}=oe;if(!n)throw t;n(t)})}function Xt(){}const gr=_s("C",void 0,void 0);function _s(t,n,e){return{kind:t,value:n,error:e}}let gt=null;function Mt(t){if(oe.useDeprecatedSynchronousErrorHandling){const n=!gt;if(n&&(gt={errorThrown:!1,error:null}),t(),n){const{errorThrown:e,error:r}=gt;if(gt=null,e)throw r}}else t()}class re extends O{constructor(n){super(),this.isStopped=!1,n?(this.destination=n,ye(n)&&n.add(this)):this.destination=Vn}static create(n,e,r){return new Ue(n,e,r)}next(n){this.isStopped?Lt(function Vo(t){return _s("N",t,void 0)}(n),this):this._next(n)}error(n){this.isStopped?Lt(function rr(t){return _s("E",void 0,t)}(n),this):(this.isStopped=!0,this._error(n))}complete(){this.isStopped?Lt(gr,this):(this.isStopped=!0,this._complete())}unsubscribe(){this.closed||(this.isStopped=!0,super.unsubscribe(),this.destination=null)}_next(n){this.destination.next(n)}_error(n){try{this.destination.error(n)}finally{this.unsubscribe()}}_complete(){try{this.destination.complete()}finally{this.unsubscribe()}}}const X=Function.prototype.bind;function T(t,n){return X.call(t,n)}class ve{constructor(n){this.partialObserver=n}next(n){const{partialObserver:e}=this;if(e.next)try{e.next(n)}catch(r){Dt(r)}}error(n){const{partialObserver:e}=this;if(e.error)try{e.error(n)}catch(r){Dt(r)}else Dt(n)}complete(){const{partialObserver:n}=this;if(n.complete)try{n.complete()}catch(e){Dt(e)}}}class Ue extends re{constructor(n,e,r){let s;if(super(),Fe(n)||!n)s={next:n??void 0,error:e??void 0,complete:r??void 0};else{let o;this&&oe.useDeprecatedNextContext?(o=Object.create(n),o.unsubscribe=()=>this.unsubscribe(),s={next:n.next&&T(n.next,o),error:n.error&&T(n.error,o),complete:n.complete&&T(n.complete,o)}):s=n}this.destination=new ve(s)}}function Dt(t){oe.useDeprecatedSynchronousErrorHandling?function Ut(t){oe.useDeprecatedSynchronousErrorHandling&&gt&&(gt.errorThrown=!0,gt.error=t)}(t):Me(t)}function Lt(t,n){const{onStoppedNotification:e}=oe;e&&Te.setTimeout(()=>e(t,n))}const Vn={closed:!0,next:Xt,error:function Ct(t){throw t},complete:Xt},Nn="function"==typeof Symbol&&Symbol.observable||"@@observable";function vn(t){return t}function Zr(t){return 0===t.length?vn:1===t.length?t[0]:function(e){return t.reduce((r,s)=>s(r),e)}}let xt=(()=>{class t{constructor(e){e&&(this._subscribe=e)}lift(e){const r=new t;return r.source=this,r.operator=e,r}subscribe(e,r,s){const o=function _B(t){return t&&t instanceof re||function Yl(t){return t&&Fe(t.next)&&Fe(t.error)&&Fe(t.complete)}(t)&&ye(t)}(e)?e:new Ue(e,r,s);return Mt(()=>{const{operator:i,source:a}=this;o.add(i?i.call(o,a):a?this._subscribe(o):this._trySubscribe(o))}),o}_trySubscribe(e){try{return this._subscribe(e)}catch(r){e.error(r)}}forEach(e,r){return new(r=Fr(r))((s,o)=>{const i=new Ue({next:a=>{try{e(a)}catch(l){o(l),i.unsubscribe()}},error:o,complete:s});this.subscribe(i)})}_subscribe(e){var r;return null===(r=this.source)||void 0===r?void 0:r.subscribe(e)}[Nn](){return this}pipe(...e){return Zr(e)(this)}toPromise(e){return new(e=Fr(e))((r,s)=>{let o;this.subscribe(i=>o=i,i=>s(i),()=>r(o))})}}return t.create=n=>new t(n),t})();function Fr(t){var n;return null!==(n=t??oe.Promise)&&void 0!==n?n:Promise}const SB=Ve(t=>function(){t(this),this.name="ObjectUnsubscribedError",this.message="object unsubscribed"});let yi=(()=>{class t extends xt{constructor(){super(),this.closed=!1,this.currentObservers=null,this.observers=[],this.isStopped=!1,this.hasError=!1,this.thrownError=null}lift(e){const r=new g1(this,this);return r.operator=e,r}_throwIfClosed(){if(this.closed)throw new SB}next(e){Mt(()=>{if(this._throwIfClosed(),!this.isStopped){this.currentObservers||(this.currentObservers=Array.from(this.observers));for(const r of this.currentObservers)r.next(e)}})}error(e){Mt(()=>{if(this._throwIfClosed(),!this.isStopped){this.hasError=this.isStopped=!0,this.thrownError=e;const{observers:r}=this;for(;r.length;)r.shift().error(e)}})}complete(){Mt(()=>{if(this._throwIfClosed(),!this.isStopped){this.isStopped=!0;const{observers:e}=this;for(;e.length;)e.shift().complete()}})}unsubscribe(){this.isStopped=this.closed=!0,this.observers=this.currentObservers=null}get observed(){var e;return(null===(e=this.observers)||void 0===e?void 0:e.length)>0}_trySubscribe(e){return this._throwIfClosed(),super._trySubscribe(e)}_subscribe(e){return this._throwIfClosed(),this._checkFinalizedStatuses(e),this._innerSubscribe(e)}_innerSubscribe(e){const{hasError:r,isStopped:s,observers:o}=this;return r||s?ue:(this.currentObservers=null,o.push(e),new O(()=>{this.currentObservers=null,Ie(o,e)}))}_checkFinalizedStatuses(e){const{hasError:r,thrownError:s,isStopped:o}=this;r?e.error(s):o&&e.complete()}asObservable(){const e=new xt;return e.source=this,e}}return t.create=(n,e)=>new g1(n,e),t})();class g1 extends yi{constructor(n,e){super(),this.destination=n,this.source=e}next(n){var e,r;null===(r=null===(e=this.destination)||void 0===e?void 0:e.next)||void 0===r||r.call(e,n)}error(n){var e,r;null===(r=null===(e=this.destination)||void 0===e?void 0:e.error)||void 0===r||r.call(e,n)}complete(){var n,e;null===(e=null===(n=this.destination)||void 0===n?void 0:n.complete)||void 0===e||e.call(n)}_subscribe(n){var e,r;return null!==(r=null===(e=this.source)||void 0===e?void 0:e.subscribe(n))&&void 0!==r?r:ue}}function y1(t){return Fe(t?.lift)}function yr(t){return n=>{if(y1(n))return n.lift(function(e){try{return t(e,this)}catch(r){this.error(r)}});throw new TypeError("Unable to lift unknown Observable type")}}function sr(t,n,e,r,s){return new IB(t,n,e,r,s)}class IB extends re{constructor(n,e,r,s,o,i){super(n),this.onFinalize=o,this.shouldUnsubscribe=i,this._next=e?function(a){try{e(a)}catch(l){n.error(l)}}:super._next,this._error=s?function(a){try{s(a)}catch(l){n.error(l)}finally{this.unsubscribe()}}:super._error,this._complete=r?function(){try{r()}catch(a){n.error(a)}finally{this.unsubscribe()}}:super._complete}unsubscribe(){var n;if(!this.shouldUnsubscribe||this.shouldUnsubscribe()){const{closed:e}=this;super.unsubscribe(),!e&&(null===(n=this.onFinalize)||void 0===n||n.call(this))}}}function Nt(t,n){return yr((e,r)=>{let s=0;e.subscribe(sr(r,o=>{r.next(t.call(n,o,s++))}))})}function Ha(t){return this instanceof Ha?(this.v=t,this):new Ha(t)}function NB(t){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var e,n=t[Symbol.asyncIterator];return n?n.call(t):(t=function x1(t){var n="function"==typeof Symbol&&Symbol.iterator,e=n&&t[n],r=0;if(e)return e.call(t);if(t&&"number"==typeof t.length)return{next:function(){return t&&r>=t.length&&(t=void 0),{value:t&&t[r++],done:!t}}};throw new TypeError(n?"Object is not iterable.":"Symbol.iterator is not defined.")}(t),e={},r("next"),r("throw"),r("return"),e[Symbol.asyncIterator]=function(){return this},e);function r(o){e[o]=t[o]&&function(i){return new Promise(function(a,l){!function s(o,i,a,l){Promise.resolve(l).then(function(u){o({value:u,done:a})},i)}(a,l,(i=t[o](i)).done,i.value)})}}}const w1=t=>t&&"number"==typeof t.length&&"function"!=typeof t;function C1(t){return Fe(t?.then)}function _1(t){return Fe(t[Nn])}function S1(t){return Symbol.asyncIterator&&Fe(t?.[Symbol.asyncIterator])}function I1(t){return new TypeError(`You provided ${null!==t&&"object"==typeof t?"an invalid object":`'${t}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`)}const D1=function AB(){return"function"==typeof Symbol&&Symbol.iterator?Symbol.iterator:"@@iterator"}();function T1(t){return Fe(t?.[D1])}function E1(t){return function EB(t,n,e){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var s,r=e.apply(t,n||[]),o=[];return s={},i("next"),i("throw"),i("return"),s[Symbol.asyncIterator]=function(){return this},s;function i(h){r[h]&&(s[h]=function(p){return new Promise(function(f,g){o.push([h,p,f,g])>1||a(h,p)})})}function a(h,p){try{!function l(h){h.value instanceof Ha?Promise.resolve(h.value.v).then(u,c):d(o[0][2],h)}(r[h](p))}catch(f){d(o[0][3],f)}}function u(h){a("next",h)}function c(h){a("throw",h)}function d(h,p){h(p),o.shift(),o.length&&a(o[0][0],o[0][1])}}(this,arguments,function*(){const e=t.getReader();try{for(;;){const{value:r,done:s}=yield Ha(e.read());if(s)return yield Ha(void 0);yield yield Ha(r)}}finally{e.releaseLock()}})}function N1(t){return Fe(t?.getReader)}function Gs(t){if(t instanceof xt)return t;if(null!=t){if(_1(t))return function RB(t){return new xt(n=>{const e=t[Nn]();if(Fe(e.subscribe))return e.subscribe(n);throw new TypeError("Provided object does not correctly implement Symbol.observable")})}(t);if(w1(t))return function FB(t){return new xt(n=>{for(let e=0;e<t.length&&!n.closed;e++)n.next(t[e]);n.complete()})}(t);if(C1(t))return function MB(t){return new xt(n=>{t.then(e=>{n.closed||(n.next(e),n.complete())},e=>n.error(e)).then(null,Me)})}(t);if(S1(t))return k1(t);if(T1(t))return function PB(t){return new xt(n=>{for(const e of t)if(n.next(e),n.closed)return;n.complete()})}(t);if(N1(t))return function OB(t){return k1(E1(t))}(t)}throw I1(t)}function k1(t){return new xt(n=>{(function $B(t,n){var e,r,s,o;return function DB(t,n,e,r){return new(e||(e=Promise))(function(o,i){function a(c){try{u(r.next(c))}catch(d){i(d)}}function l(c){try{u(r.throw(c))}catch(d){i(d)}}function u(c){c.done?o(c.value):function s(o){return o instanceof e?o:new e(function(i){i(o)})}(c.value).then(a,l)}u((r=r.apply(t,n||[])).next())})}(this,void 0,void 0,function*(){try{for(e=NB(t);!(r=yield e.next()).done;)if(n.next(r.value),n.closed)return}catch(i){s={error:i}}finally{try{r&&!r.done&&(o=e.return)&&(yield o.call(e))}finally{if(s)throw s.error}}n.complete()})})(t,n).catch(e=>n.error(e))})}function bi(t,n,e,r=0,s=!1){const o=n.schedule(function(){e(),s?t.add(this.schedule(null,r)):this.unsubscribe()},r);if(t.add(o),!s)return o}function _r(t,n,e=1/0){return Fe(n)?_r((r,s)=>Nt((o,i)=>n(r,o,s,i))(Gs(t(r,s))),e):("number"==typeof n&&(e=n),yr((r,s)=>function LB(t,n,e,r,s,o,i,a){const l=[];let u=0,c=0,d=!1;const h=()=>{d&&!l.length&&!u&&n.complete()},p=g=>u<r?f(g):l.push(g),f=g=>{o&&n.next(g),u++;let m=!1;Gs(e(g,c++)).subscribe(sr(n,y=>{s?.(y),o?p(y):n.next(y)},()=>{m=!0},void 0,()=>{if(m)try{for(u--;l.length&&u<r;){const y=l.shift();i?bi(n,i,()=>f(y)):f(y)}h()}catch(y){n.error(y)}}))};return t.subscribe(sr(n,p,()=>{d=!0,h()})),()=>{a?.()}}(r,s,t,e)))}function Zl(t=1/0){return _r(vn,t)}const Bo=new xt(t=>t.complete());function Xb(t){return t[t.length-1]}function A1(t){return Fe(Xb(t))?t.pop():void 0}function Bc(t){return function BB(t){return t&&Fe(t.schedule)}(Xb(t))?t.pop():void 0}function R1(t,n=0){return yr((e,r)=>{e.subscribe(sr(r,s=>bi(r,t,()=>r.next(s),n),()=>bi(r,t,()=>r.complete(),n),s=>bi(r,t,()=>r.error(s),n)))})}function F1(t,n=0){return yr((e,r)=>{r.add(t.schedule(()=>e.subscribe(r),n))})}function M1(t,n){if(!t)throw new Error("Iterable cannot be null");return new xt(e=>{bi(e,n,()=>{const r=t[Symbol.asyncIterator]();bi(e,n,()=>{r.next().then(s=>{s.done?e.complete():e.next(s.value)})},0,!0)})})}function Kn(t,n){return n?function qB(t,n){if(null!=t){if(_1(t))return function UB(t,n){return Gs(t).pipe(F1(n),R1(n))}(t,n);if(w1(t))return function GB(t,n){return new xt(e=>{let r=0;return n.schedule(function(){r===t.length?e.complete():(e.next(t[r++]),e.closed||this.schedule())})})}(t,n);if(C1(t))return function WB(t,n){return Gs(t).pipe(F1(n),R1(n))}(t,n);if(S1(t))return M1(t,n);if(T1(t))return function HB(t,n){return new xt(e=>{let r;return bi(e,n,()=>{r=t[D1](),bi(e,n,()=>{let s,o;try{({value:s,done:o}=r.next())}catch(i){return void e.error(i)}o?e.complete():e.next(s)},0,!0)}),()=>Fe(r?.return)&&r.return()})}(t,n);if(N1(t))return function jB(t,n){return M1(E1(t),n)}(t,n)}throw I1(t)}(t,n):Gs(t)}function Yb(t,n,...e){if(!0===n)return void t();if(!1===n)return;const r=new Ue({next:()=>{r.unsubscribe(),t()}});return Gs(n(...e)).subscribe(r)}function tn(t){for(let n in t)if(t[n]===tn)return n;throw Error("Could not find renamed property on target object.")}function Zb(t,n){for(const e in n)n.hasOwnProperty(e)&&!t.hasOwnProperty(e)&&(t[e]=n[e])}function un(t){if("string"==typeof t)return t;if(Array.isArray(t))return"["+t.map(un).join(", ")+"]";if(null==t)return""+t;if(t.overriddenName)return`${t.overriddenName}`;if(t.name)return`${t.name}`;const n=t.toString();if(null==n)return""+n;const e=n.indexOf("\n");return-1===e?n:n.substring(0,e)}function Qb(t,n){return null==t||""===t?null===n?"":n:null==n||""===n?t:t+" "+n}const YB=tn({__forward_ref__:tn});function cn(t){return t.__forward_ref__=cn,t.toString=function(){return un(this())},t}function Xe(t){return Jb(t)?t():t}function Jb(t){return"function"==typeof t&&t.hasOwnProperty(YB)&&t.__forward_ref__===cn}function ev(t){return t&&!!t.\u0275providers}class ce extends Error{constructor(n,e){super(Qp(n,e)),this.code=n}}function Qp(t,n){return`NG0${Math.abs(t)}${n?": "+n.trim():""}`}function ot(t){return"string"==typeof t?t:null==t?"":String(t)}function Jp(t,n){throw new ce(-201,!1)}function Hs(t,n){null==t&&function Ht(t,n,e,r){throw new Error(`ASSERTION ERROR: ${t}`+(null==r?"":` [Expected=> ${e} ${r} ${n} <=Actual]`))}(n,t,null,"!=")}function We(t){return{token:t.token,providedIn:t.providedIn||null,factory:t.factory,value:void 0}}function Is(t){return{providers:t.providers||[],imports:t.imports||[]}}function ef(t){return O1(t,nf)||O1(t,L1)}function O1(t,n){return t.hasOwnProperty(n)?t[n]:null}function $1(t){return t&&(t.hasOwnProperty(tv)||t.hasOwnProperty(oz))?t[tv]:null}const nf=tn({\u0275prov:tn}),tv=tn({\u0275inj:tn}),L1=tn({ngInjectableDef:tn}),oz=tn({ngInjectorDef:tn});var Ye=(()=>((Ye=Ye||{})[Ye.Default=0]="Default",Ye[Ye.Host=1]="Host",Ye[Ye.Self=2]="Self",Ye[Ye.SkipSelf=4]="SkipSelf",Ye[Ye.Optional=8]="Optional",Ye))();let nv;function js(t){const n=nv;return nv=t,n}function V1(t,n,e){const r=ef(t);return r&&"root"==r.providedIn?void 0===r.value?r.value=r.factory():r.value:e&Ye.Optional?null:void 0!==n?n:void Jp(un(t))}const pn=(()=>typeof globalThis<"u"&&globalThis||typeof global<"u"&&global||typeof window<"u"&&window||typeof self<"u"&&typeof WorkerGlobalScope<"u"&&self instanceof WorkerGlobalScope&&self)(),zc={},rv="__NG_DI_FLAG__",rf="ngTempTokenPath",az="ngTokenPath",lz=/\n/gm,uz="\u0275",B1="__source";let Uc;function Ql(t){const n=Uc;return Uc=t,n}function cz(t,n=Ye.Default){if(void 0===Uc)throw new ce(-203,!1);return null===Uc?V1(t,void 0,n):Uc.get(t,n&Ye.Optional?null:void 0,n)}function Ge(t,n=Ye.Default){return(function iz(){return nv}()||cz)(Xe(t),n)}function kt(t,n=Ye.Default){return Ge(t,sf(n))}function sf(t){return typeof t>"u"||"number"==typeof t?t:0|(t.optional&&8)|(t.host&&1)|(t.self&&2)|(t.skipSelf&&4)}function sv(t){const n=[];for(let e=0;e<t.length;e++){const r=Xe(t[e]);if(Array.isArray(r)){if(0===r.length)throw new ce(900,!1);let s,o=Ye.Default;for(let i=0;i<r.length;i++){const a=r[i],l=dz(a);"number"==typeof l?-1===l?s=a.token:o|=l:s=a}n.push(Ge(s,o))}else n.push(Ge(r))}return n}function Wc(t,n){return t[rv]=n,t.prototype[rv]=n,t}function dz(t){return t[rv]}function vi(t){return{toString:t}.toString()}var zo=(()=>((zo=zo||{})[zo.OnPush=0]="OnPush",zo[zo.Default=1]="Default",zo))(),Uo=(()=>{return(t=Uo||(Uo={}))[t.Emulated=0]="Emulated",t[t.None=2]="None",t[t.ShadowDom=3]="ShadowDom",Uo;var t})();const xi={},Wt=[],af=tn({\u0275cmp:tn}),ov=tn({\u0275dir:tn}),iv=tn({\u0275pipe:tn}),U1=tn({\u0275mod:tn}),wi=tn({\u0275fac:tn}),Gc=tn({__NG_ELEMENT_ID__:tn});let fz=0;function ja(t){return vi(()=>{const n=G1(t),e={...n,decls:t.decls,vars:t.vars,template:t.template,consts:t.consts||null,ngContentSelectors:t.ngContentSelectors,onPush:t.changeDetection===zo.OnPush,directiveDefs:null,pipeDefs:null,dependencies:n.standalone&&t.dependencies||null,getStandaloneInjector:null,data:t.data||{},encapsulation:t.encapsulation||Uo.Emulated,id:"c"+fz++,styles:t.styles||Wt,_:null,schemas:t.schemas||null,tView:null};H1(e);const r=t.dependencies;return e.directiveDefs=lf(r,!1),e.pipeDefs=lf(r,!0),e})}function gz(t){return jt(t)||Mr(t)}function yz(t){return null!==t}function qs(t){return vi(()=>({type:t.type,bootstrap:t.bootstrap||Wt,declarations:t.declarations||Wt,imports:t.imports||Wt,exports:t.exports||Wt,transitiveCompileScopes:null,schemas:t.schemas||null,id:t.id||null}))}function W1(t,n){if(null==t)return xi;const e={};for(const r in t)if(t.hasOwnProperty(r)){let s=t[r],o=s;Array.isArray(s)&&(o=s[1],s=s[0]),e[s]=r,n&&(n[s]=o)}return e}function Ze(t){return vi(()=>{const n=G1(t);return H1(n),n})}function jt(t){return t[af]||null}function Mr(t){return t[ov]||null}function hs(t){return t[iv]||null}function Ds(t,n){const e=t[U1]||null;if(!e&&!0===n)throw new Error(`Type ${un(t)} does not have '\u0275mod' property.`);return e}function G1(t){const n={};return{type:t.type,providersResolver:null,factory:null,hostBindings:t.hostBindings||null,hostVars:t.hostVars||0,hostAttrs:t.hostAttrs||null,contentQueries:t.contentQueries||null,declaredInputs:n,exportAs:t.exportAs||null,standalone:!0===t.standalone,selectors:t.selectors||Wt,viewQuery:t.viewQuery||null,features:t.features||null,setInput:null,findHostDirectiveDefs:null,hostDirectives:null,inputs:W1(t.inputs,n),outputs:W1(t.outputs)}}function H1(t){t.features?.forEach(n=>n(t))}function lf(t,n){if(!t)return null;const e=n?hs:gz;return()=>("function"==typeof t?t():t).map(r=>e(r)).filter(yz)}const Ci=0,De=1,ht=2,An=3,go=4,qa=5,Pr=6,eu=7,Bn=8,uf=9,cf=10,yt=11,av=12,Hc=13,j1=14,tu=15,Or=16,jc=17,nu=18,Wo=19,qc=20,q1=21,fn=22,lv=1,K1=2,df=7,hf=8,ru=9,Qr=10;function Ts(t){return Array.isArray(t)&&"object"==typeof t[lv]}function yo(t){return Array.isArray(t)&&!0===t[lv]}function uv(t){return 0!=(4&t.flags)}function Kc(t){return t.componentOffset>-1}function pf(t){return 1==(1&t.flags)}function bo(t){return!!t.template}function vz(t){return 0!=(256&t[ht])}function Ka(t,n){return t.hasOwnProperty(wi)?t[wi]:null}class Cz{constructor(n,e,r){this.previousValue=n,this.currentValue=e,this.firstChange=r}isFirstChange(){return this.firstChange}}function Es(){return Z1}function Z1(t){return t.type.prototype.ngOnChanges&&(t.setInput=Sz),_z}function _z(){const t=J1(this),n=t?.current;if(n){const e=t.previous;if(e===xi)t.previous=n;else for(let r in n)e[r]=n[r];t.current=null,this.ngOnChanges(n)}}function Sz(t,n,e,r){const s=this.declaredInputs[e],o=J1(t)||function Iz(t,n){return t[Q1]=n}(t,{previous:xi,current:null}),i=o.current||(o.current={}),a=o.previous,l=a[s];i[s]=new Cz(l&&l.currentValue,n,a===xi),t[r]=n}Es.ngInherit=!0;const Q1="__ngSimpleChanges__";function J1(t){return t[Q1]||null}const Ks=function(t,n,e){},eD="svg";function Sr(t){for(;Array.isArray(t);)t=t[Ci];return t}function ff(t,n){return Sr(n[t])}function Ns(t,n){return Sr(n[t.index])}function nD(t,n){return t.data[n]}function ks(t,n){const e=n[t];return Ts(e)?e:e[Ci]}function mf(t){return 64==(64&t[ht])}function Qi(t,n){return null==n?null:t[n]}function rD(t){t[nu]=0}function dv(t,n){t[qa]+=n;let e=t,r=t[An];for(;null!==r&&(1===n&&1===e[qa]||-1===n&&0===e[qa]);)r[qa]+=n,e=r,r=r[An]}const it={lFrame:pD(null),bindingsEnabled:!0};function oD(){return it.bindingsEnabled}function ee(){return it.lFrame.lView}function Pt(){return it.lFrame.tView}function Qe(t){return it.lFrame.contextLView=t,t[Bn]}function Je(t){return it.lFrame.contextLView=null,t}function Ir(){let t=iD();for(;null!==t&&64===t.type;)t=t.parent;return t}function iD(){return it.lFrame.currentTNode}function Go(t,n){const e=it.lFrame;e.currentTNode=t,e.isParent=n}function hv(){return it.lFrame.isParent}function pv(){it.lFrame.isParent=!1}function Jr(){const t=it.lFrame;let n=t.bindingRootIndex;return-1===n&&(n=t.bindingRootIndex=t.tView.bindingStartIndex),n}function ou(){return it.lFrame.bindingIndex++}function Si(t){const n=it.lFrame,e=n.bindingIndex;return n.bindingIndex=n.bindingIndex+t,e}function Lz(t,n){const e=it.lFrame;e.bindingIndex=e.bindingRootIndex=t,fv(n)}function fv(t){it.lFrame.currentDirectiveIndex=t}function cD(){return it.lFrame.currentQueryIndex}function gv(t){it.lFrame.currentQueryIndex=t}function Bz(t){const n=t[De];return 2===n.type?n.declTNode:1===n.type?t[Pr]:null}function dD(t,n,e){if(e&Ye.SkipSelf){let s=n,o=t;for(;!(s=s.parent,null!==s||e&Ye.Host||(s=Bz(o),null===s||(o=o[tu],10&s.type))););if(null===s)return!1;n=s,t=o}const r=it.lFrame=hD();return r.currentTNode=n,r.lView=t,!0}function yv(t){const n=hD(),e=t[De];it.lFrame=n,n.currentTNode=e.firstChild,n.lView=t,n.tView=e,n.contextLView=t,n.bindingIndex=e.bindingStartIndex,n.inI18n=!1}function hD(){const t=it.lFrame,n=null===t?null:t.child;return null===n?pD(t):n}function pD(t){const n={currentTNode:null,isParent:!0,lView:null,tView:null,selectedIndex:-1,contextLView:null,elementDepthCount:0,currentNamespace:null,currentDirectiveIndex:-1,bindingRootIndex:-1,bindingIndex:-1,currentQueryIndex:0,parent:t,child:null,inI18n:!1};return null!==t&&(t.child=n),n}function fD(){const t=it.lFrame;return it.lFrame=t.parent,t.currentTNode=null,t.lView=null,t}const mD=fD;function bv(){const t=fD();t.isParent=!0,t.tView=null,t.selectedIndex=-1,t.contextLView=null,t.elementDepthCount=0,t.currentDirectiveIndex=-1,t.currentNamespace=null,t.bindingRootIndex=-1,t.bindingIndex=-1,t.currentQueryIndex=0}function es(){return it.lFrame.selectedIndex}function Xa(t){it.lFrame.selectedIndex=t}function In(){const t=it.lFrame;return nD(t.tView,t.selectedIndex)}function gf(t,n){for(let e=n.directiveStart,r=n.directiveEnd;e<r;e++){const o=t.data[e].type.prototype,{ngAfterContentInit:i,ngAfterContentChecked:a,ngAfterViewInit:l,ngAfterViewChecked:u,ngOnDestroy:c}=o;i&&(t.contentHooks||(t.contentHooks=[])).push(-e,i),a&&((t.contentHooks||(t.contentHooks=[])).push(e,a),(t.contentCheckHooks||(t.contentCheckHooks=[])).push(e,a)),l&&(t.viewHooks||(t.viewHooks=[])).push(-e,l),u&&((t.viewHooks||(t.viewHooks=[])).push(e,u),(t.viewCheckHooks||(t.viewCheckHooks=[])).push(e,u)),null!=c&&(t.destroyHooks||(t.destroyHooks=[])).push(e,c)}}function yf(t,n,e){yD(t,n,3,e)}function bf(t,n,e,r){(3&t[ht])===e&&yD(t,n,e,r)}function vv(t,n){let e=t[ht];(3&e)===n&&(e&=2047,e+=1,t[ht]=e)}function yD(t,n,e,r){const o=r??-1,i=n.length-1;let a=0;for(let l=void 0!==r?65535&t[nu]:0;l<i;l++)if("number"==typeof n[l+1]){if(a=n[l],null!=r&&a>=r)break}else n[l]<0&&(t[nu]+=65536),(a<o||-1==o)&&(Kz(t,e,n,l),t[nu]=(4294901760&t[nu])+l+2),l++}function Kz(t,n,e,r){const s=e[r]<0,o=e[r+1],a=t[s?-e[r]:e[r]];if(s){if(t[ht]>>11<t[nu]>>16&&(3&t[ht])===n){t[ht]+=2048,Ks(4,a,o);try{o.call(a)}finally{Ks(5,a,o)}}}else{Ks(4,a,o);try{o.call(a)}finally{Ks(5,a,o)}}}const iu=-1;class Yc{constructor(n,e,r){this.factory=n,this.resolving=!1,this.canSeeViewProviders=e,this.injectImpl=r}}function wv(t,n,e){let r=0;for(;r<e.length;){const s=e[r];if("number"==typeof s){if(0!==s)break;r++;const o=e[r++],i=e[r++],a=e[r++];t.setAttribute(n,i,a,o)}else{const o=s,i=e[++r];vD(o)?t.setProperty(n,o,i):t.setAttribute(n,o,i),r++}}return r}function bD(t){return 3===t||4===t||6===t}function vD(t){return 64===t.charCodeAt(0)}function Zc(t,n){if(null!==n&&0!==n.length)if(null===t||0===t.length)t=n.slice();else{let e=-1;for(let r=0;r<n.length;r++){const s=n[r];"number"==typeof s?e=s:0===e||xD(t,e,s,null,-1===e||2===e?n[++r]:null)}}return t}function xD(t,n,e,r,s){let o=0,i=t.length;if(-1===n)i=-1;else for(;o<t.length;){const a=t[o++];if("number"==typeof a){if(a===n){i=-1;break}if(a>n){i=o-1;break}}}for(;o<t.length;){const a=t[o];if("number"==typeof a)break;if(a===e){if(null===r)return void(null!==s&&(t[o+1]=s));if(r===t[o+1])return void(t[o+2]=s)}o++,null!==r&&o++,null!==s&&o++}-1!==i&&(t.splice(i,0,n),o=i+1),t.splice(o++,0,e),null!==r&&t.splice(o++,0,r),null!==s&&t.splice(o++,0,s)}function wD(t){return t!==iu}function vf(t){return 32767&t}function xf(t,n){let e=function Qz(t){return t>>16}(t),r=n;for(;e>0;)r=r[tu],e--;return r}let Cv=!0;function wf(t){const n=Cv;return Cv=t,n}const CD=255,_D=5;let Jz=0;const Ho={};function Cf(t,n){const e=SD(t,n);if(-1!==e)return e;const r=n[De];r.firstCreatePass&&(t.injectorIndex=n.length,_v(r.data,t),_v(n,null),_v(r.blueprint,null));const s=Sv(t,n),o=t.injectorIndex;if(wD(s)){const i=vf(s),a=xf(s,n),l=a[De].data;for(let u=0;u<8;u++)n[o+u]=a[i+u]|l[i+u]}return n[o+8]=s,o}function _v(t,n){t.push(0,0,0,0,0,0,0,0,n)}function SD(t,n){return-1===t.injectorIndex||t.parent&&t.parent.injectorIndex===t.injectorIndex||null===n[t.injectorIndex+8]?-1:t.injectorIndex}function Sv(t,n){if(t.parent&&-1!==t.parent.injectorIndex)return t.parent.injectorIndex;let e=0,r=null,s=n;for(;null!==s;){if(r=AD(s),null===r)return iu;if(e++,s=s[tu],-1!==r.injectorIndex)return r.injectorIndex|e<<16}return iu}function Iv(t,n,e){!function eU(t,n,e){let r;"string"==typeof e?r=e.charCodeAt(0)||0:e.hasOwnProperty(Gc)&&(r=e[Gc]),null==r&&(r=e[Gc]=Jz++);const s=r&CD;n.data[t+(s>>_D)]|=1<<s}(t,n,e)}function ID(t,n,e){if(e&Ye.Optional||void 0!==t)return t;Jp()}function DD(t,n,e,r){if(e&Ye.Optional&&void 0===r&&(r=null),!(e&(Ye.Self|Ye.Host))){const s=t[uf],o=js(void 0);try{return s?s.get(n,r,e&Ye.Optional):V1(n,r,e&Ye.Optional)}finally{js(o)}}return ID(r,0,e)}function TD(t,n,e,r=Ye.Default,s){if(null!==t){if(1024&n[ht]){const i=function oU(t,n,e,r,s){let o=t,i=n;for(;null!==o&&null!==i&&1024&i[ht]&&!(256&i[ht]);){const a=ED(o,i,e,r|Ye.Self,Ho);if(a!==Ho)return a;let l=o.parent;if(!l){const u=i[q1];if(u){const c=u.get(e,Ho,r);if(c!==Ho)return c}l=AD(i),i=i[tu]}o=l}return s}(t,n,e,r,Ho);if(i!==Ho)return i}const o=ED(t,n,e,r,Ho);if(o!==Ho)return o}return DD(n,e,r,s)}function ED(t,n,e,r,s){const o=function rU(t){if("string"==typeof t)return t.charCodeAt(0)||0;const n=t.hasOwnProperty(Gc)?t[Gc]:void 0;return"number"==typeof n?n>=0?n&CD:sU:n}(e);if("function"==typeof o){if(!dD(n,t,r))return r&Ye.Host?ID(s,0,r):DD(n,e,r,s);try{const i=o(r);if(null!=i||r&Ye.Optional)return i;Jp()}finally{mD()}}else if("number"==typeof o){let i=null,a=SD(t,n),l=iu,u=r&Ye.Host?n[Or][Pr]:null;for((-1===a||r&Ye.SkipSelf)&&(l=-1===a?Sv(t,n):n[a+8],l!==iu&&kD(r,!1)?(i=n[De],a=vf(l),n=xf(l,n)):a=-1);-1!==a;){const c=n[De];if(ND(o,a,c.data)){const d=nU(a,n,e,i,r,u);if(d!==Ho)return d}l=n[a+8],l!==iu&&kD(r,n[De].data[a+8]===u)&&ND(o,a,n)?(i=c,a=vf(l),n=xf(l,n)):a=-1}}return s}function nU(t,n,e,r,s,o){const i=n[De],a=i.data[t+8],c=_f(a,i,e,null==r?Kc(a)&&Cv:r!=i&&0!=(3&a.type),s&Ye.Host&&o===a);return null!==c?Ya(n,i,c,a):Ho}function _f(t,n,e,r,s){const o=t.providerIndexes,i=n.data,a=1048575&o,l=t.directiveStart,c=o>>20,h=s?a+c:t.directiveEnd;for(let p=r?a:a+c;p<h;p++){const f=i[p];if(p<l&&e===f||p>=l&&f.type===e)return p}if(s){const p=i[l];if(p&&bo(p)&&p.type===e)return l}return null}function Ya(t,n,e,r){let s=t[e];const o=n.data;if(function Xz(t){return t instanceof Yc}(s)){const i=s;i.resolving&&function ZB(t,n){const e=n?`. Dependency path: ${n.join(" > ")} > ${t}`:"";throw new ce(-200,`Circular dependency in DI detected for ${t}${e}`)}(function Gt(t){return"function"==typeof t?t.name||t.toString():"object"==typeof t&&null!=t&&"function"==typeof t.type?t.type.name||t.type.toString():ot(t)}(o[e]));const a=wf(i.canSeeViewProviders);i.resolving=!0;const l=i.injectImpl?js(i.injectImpl):null;dD(t,r,Ye.Default);try{s=t[e]=i.factory(void 0,o,t,r),n.firstCreatePass&&e>=r.directiveStart&&function qz(t,n,e){const{ngOnChanges:r,ngOnInit:s,ngDoCheck:o}=n.type.prototype;if(r){const i=Z1(n);(e.preOrderHooks||(e.preOrderHooks=[])).push(t,i),(e.preOrderCheckHooks||(e.preOrderCheckHooks=[])).push(t,i)}s&&(e.preOrderHooks||(e.preOrderHooks=[])).push(0-t,s),o&&((e.preOrderHooks||(e.preOrderHooks=[])).push(t,o),(e.preOrderCheckHooks||(e.preOrderCheckHooks=[])).push(t,o))}(e,o[e],n)}finally{null!==l&&js(l),wf(a),i.resolving=!1,mD()}}return s}function ND(t,n,e){return!!(e[n+(t>>_D)]&1<<t)}function kD(t,n){return!(t&Ye.Self||t&Ye.Host&&n)}class au{constructor(n,e){this._tNode=n,this._lView=e}get(n,e,r){return TD(this._tNode,this._lView,n,sf(r),e)}}function sU(){return new au(Ir(),ee())}function Dr(t){return vi(()=>{const n=t.prototype.constructor,e=n[wi]||Dv(n),r=Object.prototype;let s=Object.getPrototypeOf(t.prototype).constructor;for(;s&&s!==r;){const o=s[wi]||Dv(s);if(o&&o!==e)return o;s=Object.getPrototypeOf(s)}return o=>new o})}function Dv(t){return Jb(t)?()=>{const n=Dv(Xe(t));return n&&n()}:Ka(t)}function AD(t){const n=t[De],e=n.type;return 2===e?n.declTNode:1===e?t[Pr]:null}const uu="__parameters__";function du(t,n,e){return vi(()=>{const r=function Tv(t){return function(...e){if(t){const r=t(...e);for(const s in r)this[s]=r[s]}}}(n);function s(...o){if(this instanceof s)return r.apply(this,o),this;const i=new s(...o);return a.annotation=i,a;function a(l,u,c){const d=l.hasOwnProperty(uu)?l[uu]:Object.defineProperty(l,uu,{value:[]})[uu];for(;d.length<=c;)d.push(null);return(d[c]=d[c]||[]).push(i),l}}return e&&(s.prototype=Object.create(e.prototype)),s.prototype.ngMetadataName=t,s.annotationCls=s,s})}class Le{constructor(n,e){this._desc=n,this.ngMetadataName="InjectionToken",this.\u0275prov=void 0,"number"==typeof e?this.__NG_ELEMENT_ID__=e:void 0!==e&&(this.\u0275prov=We({token:this,providedIn:e.providedIn||"root",factory:e.factory}))}get multi(){return this}toString(){return`InjectionToken ${this._desc}`}}function Za(t,n){t.forEach(e=>Array.isArray(e)?Za(e,n):n(e))}function FD(t,n,e){n>=t.length?t.push(e):t.splice(n,0,e)}function If(t,n){return n>=t.length-1?t.pop():t.splice(n,1)[0]}function As(t,n,e){let r=hu(t,n);return r>=0?t[1|r]=e:(r=~r,function uU(t,n,e,r){let s=t.length;if(s==n)t.push(e,r);else if(1===s)t.push(r,t[0]),t[0]=e;else{for(s--,t.push(t[s-1],t[s]);s>n;)t[s]=t[s-2],s--;t[n]=e,t[n+1]=r}}(t,r,n,e)),r}function Nv(t,n){const e=hu(t,n);if(e>=0)return t[1|e]}function hu(t,n){return function MD(t,n,e){let r=0,s=t.length>>e;for(;s!==r;){const o=r+(s-r>>1),i=t[o<<e];if(n===i)return o<<e;i>n?s=o:r=o+1}return~(s<<e)}(t,n,1)}const td=Wc(du("Optional"),8),nd=Wc(du("SkipSelf"),4);var ps=(()=>((ps=ps||{})[ps.Important=1]="Important",ps[ps.DashCase=2]="DashCase",ps))();const Pv=new Map;let AU=0;const $v="__ngContext__";function $r(t,n){Ts(n)?(t[$v]=n[qc],function FU(t){Pv.set(t[qc],t)}(n)):t[$v]=n}let Lv;function Vv(t,n){return Lv(t,n)}function id(t){const n=t[An];return yo(n)?n[An]:n}function Bv(t){return eT(t[Hc])}function zv(t){return eT(t[go])}function eT(t){for(;null!==t&&!yo(t);)t=t[go];return t}function fu(t,n,e,r,s){if(null!=r){let o,i=!1;yo(r)?o=r:Ts(r)&&(i=!0,r=r[Ci]);const a=Sr(r);0===t&&null!==e?null==s?iT(n,e,a):Qa(n,e,a,s||null,!0):1===t&&null!==e?Qa(n,e,a,s||null,!0):2===t?function Kv(t,n,e){const r=Nf(t,n);r&&function JU(t,n,e,r){t.removeChild(n,e,r)}(t,r,n,e)}(n,a,i):3===t&&n.destroyNode(a),null!=o&&function n4(t,n,e,r,s){const o=e[df];o!==Sr(e)&&fu(n,t,r,o,s);for(let a=Qr;a<e.length;a++){const l=e[a];ad(l[De],l,t,n,r,o)}}(n,t,o,e,s)}}function Wv(t,n,e){return t.createElement(n,e)}function nT(t,n){const e=t[ru],r=e.indexOf(n),s=n[An];512&n[ht]&&(n[ht]&=-513,dv(s,-1)),e.splice(r,1)}function Gv(t,n){if(t.length<=Qr)return;const e=Qr+n,r=t[e];if(r){const s=r[jc];null!==s&&s!==t&&nT(s,r),n>0&&(t[e-1][go]=r[go]);const o=If(t,Qr+n);!function HU(t,n){ad(t,n,n[yt],2,null,null),n[Ci]=null,n[Pr]=null}(r[De],r);const i=o[Wo];null!==i&&i.detachView(o[De]),r[An]=null,r[go]=null,r[ht]&=-65}return r}function rT(t,n){if(!(128&n[ht])){const e=n[yt];e.destroyNode&&ad(t,n,e,3,null,null),function KU(t){let n=t[Hc];if(!n)return Hv(t[De],t);for(;n;){let e=null;if(Ts(n))e=n[Hc];else{const r=n[Qr];r&&(e=r)}if(!e){for(;n&&!n[go]&&n!==t;)Ts(n)&&Hv(n[De],n),n=n[An];null===n&&(n=t),Ts(n)&&Hv(n[De],n),e=n&&n[go]}n=e}}(n)}}function Hv(t,n){if(!(128&n[ht])){n[ht]&=-65,n[ht]|=128,function QU(t,n){let e;if(null!=t&&null!=(e=t.destroyHooks))for(let r=0;r<e.length;r+=2){const s=n[e[r]];if(!(s instanceof Yc)){const o=e[r+1];if(Array.isArray(o))for(let i=0;i<o.length;i+=2){const a=s[o[i]],l=o[i+1];Ks(4,a,l);try{l.call(a)}finally{Ks(5,a,l)}}else{Ks(4,s,o);try{o.call(s)}finally{Ks(5,s,o)}}}}}(t,n),function ZU(t,n){const e=t.cleanup,r=n[eu];let s=-1;if(null!==e)for(let o=0;o<e.length-1;o+=2)if("string"==typeof e[o]){const i=e[o+3];i>=0?r[s=i]():r[s=-i].unsubscribe(),o+=2}else{const i=r[s=e[o+1]];e[o].call(i)}if(null!==r){for(let o=s+1;o<r.length;o++)(0,r[o])();n[eu]=null}}(t,n),1===n[De].type&&n[yt].destroy();const e=n[jc];if(null!==e&&yo(n[An])){e!==n[An]&&nT(e,n);const r=n[Wo];null!==r&&r.detachView(t)}!function MU(t){Pv.delete(t[qc])}(n)}}function sT(t,n,e){return function oT(t,n,e){let r=n;for(;null!==r&&40&r.type;)r=(n=r).parent;if(null===r)return e[Ci];{const{componentOffset:s}=r;if(s>-1){const{encapsulation:o}=t.data[r.directiveStart+s];if(o===Uo.None||o===Uo.Emulated)return null}return Ns(r,e)}}(t,n.parent,e)}function Qa(t,n,e,r,s){t.insertBefore(n,e,r,s)}function iT(t,n,e){t.appendChild(n,e)}function aT(t,n,e,r,s){null!==r?Qa(t,n,e,r,s):iT(t,n,e)}function Nf(t,n){return t.parentNode(n)}let jv,Zv,cT=function uT(t,n,e){return 40&t.type?Ns(t,e):null};function kf(t,n,e,r){const s=sT(t,r,n),o=n[yt],a=function lT(t,n,e){return cT(t,n,e)}(r.parent||n[Pr],r,n);if(null!=s)if(Array.isArray(e))for(let l=0;l<e.length;l++)aT(o,s,e[l],a,!1);else aT(o,s,e,a,!1);void 0!==jv&&jv(o,r,n,e,s)}function Af(t,n){if(null!==n){const e=n.type;if(3&e)return Ns(n,t);if(4&e)return qv(-1,t[n.index]);if(8&e){const r=n.child;if(null!==r)return Af(t,r);{const s=t[n.index];return yo(s)?qv(-1,s):Sr(s)}}if(32&e)return Vv(n,t)()||Sr(t[n.index]);{const r=hT(t,n);return null!==r?Array.isArray(r)?r[0]:Af(id(t[Or]),r):Af(t,n.next)}}return null}function hT(t,n){return null!==n?t[Or][Pr].projection[n.projection]:null}function qv(t,n){const e=Qr+t+1;if(e<n.length){const r=n[e],s=r[De].firstChild;if(null!==s)return Af(r,s)}return n[df]}function Xv(t,n,e,r,s,o,i){for(;null!=e;){const a=r[e.index],l=e.type;if(i&&0===n&&(a&&$r(Sr(a),r),e.flags|=2),32!=(32&e.flags))if(8&l)Xv(t,n,e.child,r,s,o,!1),fu(n,t,s,a,o);else if(32&l){const u=Vv(e,r);let c;for(;c=u();)fu(n,t,s,c,o);fu(n,t,s,a,o)}else 16&l?pT(t,n,r,e,s,o):fu(n,t,s,a,o);e=i?e.projectionNext:e.next}}function ad(t,n,e,r,s,o){Xv(e,r,t.firstChild,n,s,o,!1)}function pT(t,n,e,r,s,o){const i=e[Or],l=i[Pr].projection[r.projection];if(Array.isArray(l))for(let u=0;u<l.length;u++)fu(n,t,s,l[u],o);else Xv(t,n,l,i[An],s,o,!0)}function fT(t,n,e){""===e?t.removeAttribute(n,"class"):t.setAttribute(n,"class",e)}function mT(t,n,e){const{mergedAttrs:r,classes:s,styles:o}=e;null!==r&&wv(t,n,r),null!==s&&fT(t,n,s),null!==o&&function s4(t,n,e){t.setAttribute(n,"style",e)}(t,n,o)}class xT{constructor(n){this.changingThisBreaksApplicationSecurity=n}toString(){return`SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see https://g.co/ng/security#xss)`}}function Ji(t){return t instanceof xT?t.changingThisBreaksApplicationSecurity:t}const Pf=new Le("ENVIRONMENT_INITIALIZER"),kT=new Le("INJECTOR",-1),AT=new Le("INJECTOR_DEF_TYPES");class RT{get(n,e=zc){if(e===zc){const r=new Error(`NullInjectorError: No provider for ${un(n)}!`);throw r.name="NullInjectorError",r}return e}}function A4(...t){return{\u0275providers:FT(0,t),\u0275fromNgModule:!0}}function FT(t,...n){const e=[],r=new Set;let s;return Za(n,o=>{const i=o;rx(i,e,[],r)&&(s||(s=[]),s.push(i))}),void 0!==s&&MT(s,e),e}function MT(t,n){for(let e=0;e<t.length;e++){const{providers:s}=t[e];sx(s,o=>{n.push(o)})}}function rx(t,n,e,r){if(!(t=Xe(t)))return!1;let s=null,o=$1(t);const i=!o&&jt(t);if(o||i){if(i&&!i.standalone)return!1;s=t}else{const l=t.ngModule;if(o=$1(l),!o)return!1;s=l}const a=r.has(s);if(i){if(a)return!1;if(r.add(s),i.dependencies){const l="function"==typeof i.dependencies?i.dependencies():i.dependencies;for(const u of l)rx(u,n,e,r)}}else{if(!o)return!1;{if(null!=o.imports&&!a){let u;r.add(s);try{Za(o.imports,c=>{rx(c,n,e,r)&&(u||(u=[]),u.push(c))})}finally{}void 0!==u&&MT(u,n)}if(!a){const u=Ka(s)||(()=>new s);n.push({provide:s,useFactory:u,deps:Wt},{provide:AT,useValue:s,multi:!0},{provide:Pf,useValue:()=>Ge(s),multi:!0})}const l=o.providers;null==l||a||sx(l,c=>{n.push(c)})}}return s!==t&&void 0!==t.providers}function sx(t,n){for(let e of t)ev(e)&&(e=e.\u0275providers),Array.isArray(e)?sx(e,n):n(e)}const R4=tn({provide:String,useValue:tn});function ox(t){return null!==t&&"object"==typeof t&&R4 in t}function Ja(t){return"function"==typeof t}const ix=new Le("Set Injector scope."),Of={},M4={};let ax;function $f(){return void 0===ax&&(ax=new RT),ax}class Di{}class $T extends Di{get destroyed(){return this._destroyed}constructor(n,e,r,s){super(),this.parent=e,this.source=r,this.scopes=s,this.records=new Map,this._ngOnDestroyHooks=new Set,this._onDestroyHooks=[],this._destroyed=!1,ux(n,i=>this.processProvider(i)),this.records.set(kT,gu(void 0,this)),s.has("environment")&&this.records.set(Di,gu(void 0,this));const o=this.records.get(ix);null!=o&&"string"==typeof o.value&&this.scopes.add(o.value),this.injectorDefTypes=new Set(this.get(AT.multi,Wt,Ye.Self))}destroy(){this.assertNotDestroyed(),this._destroyed=!0;try{for(const n of this._ngOnDestroyHooks)n.ngOnDestroy();for(const n of this._onDestroyHooks)n()}finally{this.records.clear(),this._ngOnDestroyHooks.clear(),this.injectorDefTypes.clear(),this._onDestroyHooks.length=0}}onDestroy(n){this._onDestroyHooks.push(n)}runInContext(n){this.assertNotDestroyed();const e=Ql(this),r=js(void 0);try{return n()}finally{Ql(e),js(r)}}get(n,e=zc,r=Ye.Default){this.assertNotDestroyed(),r=sf(r);const s=Ql(this),o=js(void 0);try{if(!(r&Ye.SkipSelf)){let a=this.records.get(n);if(void 0===a){const l=function V4(t){return"function"==typeof t||"object"==typeof t&&t instanceof Le}(n)&&ef(n);a=l&&this.injectableDefInScope(l)?gu(lx(n),Of):null,this.records.set(n,a)}if(null!=a)return this.hydrate(n,a)}return(r&Ye.Self?$f():this.parent).get(n,e=r&Ye.Optional&&e===zc?null:e)}catch(i){if("NullInjectorError"===i.name){if((i[rf]=i[rf]||[]).unshift(un(n)),s)throw i;return function hz(t,n,e,r){const s=t[rf];throw n[B1]&&s.unshift(n[B1]),t.message=function pz(t,n,e,r=null){t=t&&"\n"===t.charAt(0)&&t.charAt(1)==uz?t.slice(2):t;let s=un(n);if(Array.isArray(n))s=n.map(un).join(" -> ");else if("object"==typeof n){let o=[];for(let i in n)if(n.hasOwnProperty(i)){let a=n[i];o.push(i+":"+("string"==typeof a?JSON.stringify(a):un(a)))}s=`{${o.join(", ")}}`}return`${e}${r?"("+r+")":""}[${s}]: ${t.replace(lz,"\n  ")}`}("\n"+t.message,s,e,r),t[az]=s,t[rf]=null,t}(i,n,"R3InjectorError",this.source)}throw i}finally{js(o),Ql(s)}}resolveInjectorInitializers(){const n=Ql(this),e=js(void 0);try{const r=this.get(Pf.multi,Wt,Ye.Self);for(const s of r)s()}finally{Ql(n),js(e)}}toString(){const n=[],e=this.records;for(const r of e.keys())n.push(un(r));return`R3Injector[${n.join(", ")}]`}assertNotDestroyed(){if(this._destroyed)throw new ce(205,!1)}processProvider(n){let e=Ja(n=Xe(n))?n:Xe(n&&n.provide);const r=function O4(t){return ox(t)?gu(void 0,t.useValue):gu(LT(t),Of)}(n);if(Ja(n)||!0!==n.multi)this.records.get(e);else{let s=this.records.get(e);s||(s=gu(void 0,Of,!0),s.factory=()=>sv(s.multi),this.records.set(e,s)),e=n,s.multi.push(n)}this.records.set(e,r)}hydrate(n,e){return e.value===Of&&(e.value=M4,e.value=e.factory()),"object"==typeof e.value&&e.value&&function L4(t){return null!==t&&"object"==typeof t&&"function"==typeof t.ngOnDestroy}(e.value)&&this._ngOnDestroyHooks.add(e.value),e.value}injectableDefInScope(n){if(!n.providedIn)return!1;const e=Xe(n.providedIn);return"string"==typeof e?"any"===e||this.scopes.has(e):this.injectorDefTypes.has(e)}}function lx(t){const n=ef(t),e=null!==n?n.factory:Ka(t);if(null!==e)return e;if(t instanceof Le)throw new ce(204,!1);if(t instanceof Function)return function P4(t){const n=t.length;if(n>0)throw function ed(t,n){const e=[];for(let r=0;r<t;r++)e.push(n);return e}(n,"?"),new ce(204,!1);const e=function rz(t){const n=t&&(t[nf]||t[L1]);return n?(function sz(t){if(t.hasOwnProperty("name"))return t.name;(""+t).match(/^function\s*([^\s(]+)/)}(t),n):null}(t);return null!==e?()=>e.factory(t):()=>new t}(t);throw new ce(204,!1)}function LT(t,n,e){let r;if(Ja(t)){const s=Xe(t);return Ka(s)||lx(s)}if(ox(t))r=()=>Xe(t.useValue);else if(function OT(t){return!(!t||!t.useFactory)}(t))r=()=>t.useFactory(...sv(t.deps||[]));else if(function PT(t){return!(!t||!t.useExisting)}(t))r=()=>Ge(Xe(t.useExisting));else{const s=Xe(t&&(t.useClass||t.provide));if(!function $4(t){return!!t.deps}(t))return Ka(s)||lx(s);r=()=>new s(...sv(t.deps))}return r}function gu(t,n,e=!1){return{factory:t,value:n,multi:e?[]:void 0}}function ux(t,n){for(const e of t)Array.isArray(e)?ux(e,n):e&&ev(e)?ux(e.\u0275providers,n):n(e)}class B4{}class VT{}class U4{resolveComponentFactory(n){throw function z4(t){const n=Error(`No component factory found for ${un(t)}. Did you add it to @NgModule.entryComponents?`);return n.ngComponent=t,n}(n)}}let yu=(()=>{class t{}return t.NULL=new U4,t})();function W4(){return bu(Ir(),ee())}function bu(t,n){return new Lr(Ns(t,n))}let Lr=(()=>{class t{constructor(e){this.nativeElement=e}}return t.__NG_ELEMENT_ID__=W4,t})();function G4(t){return t instanceof Lr?t.nativeElement:t}class zT{}let Ti=(()=>{class t{}return t.__NG_ELEMENT_ID__=()=>function H4(){const t=ee(),e=ks(Ir().index,t);return(Ts(e)?e:t)[yt]}(),t})(),j4=(()=>{class t{}return t.\u0275prov=We({token:t,providedIn:"root",factory:()=>null}),t})();class dd{constructor(n){this.full=n,this.major=n.split(".")[0],this.minor=n.split(".")[1],this.patch=n.split(".").slice(2).join(".")}}const q4=new dd("15.2.3"),cx={},dx="ngOriginalError";function hx(t){return t[dx]}class vu{constructor(){this._console=console}handleError(n){const e=this._findOriginalError(n);this._console.error("ERROR",n),e&&this._console.error("ORIGINAL ERROR",e)}_findOriginalError(n){let e=n&&hx(n);for(;e&&hx(e);)e=hx(e);return e||null}}function UT(t){return t.ownerDocument.defaultView}function px(t){return t.ownerDocument}function Ei(t){return t instanceof Function?t():t}function GT(t,n,e){let r=t.length;for(;;){const s=t.indexOf(n,e);if(-1===s)return s;if(0===s||t.charCodeAt(s-1)<=32){const o=n.length;if(s+o===r||t.charCodeAt(s+o)<=32)return s}e=s+1}}const HT="ng-template";function nW(t,n,e){let r=0;for(;r<t.length;){let s=t[r++];if(e&&"class"===s){if(s=t[r],-1!==GT(s.toLowerCase(),n,0))return!0}else if(1===s){for(;r<t.length&&"string"==typeof(s=t[r++]);)if(s.toLowerCase()===n)return!0;return!1}}return!1}function jT(t){return 4===t.type&&t.value!==HT}function rW(t,n,e){return n===(4!==t.type||e?t.value:HT)}function sW(t,n,e){let r=4;const s=t.attrs||[],o=function aW(t){for(let n=0;n<t.length;n++)if(bD(t[n]))return n;return t.length}(s);let i=!1;for(let a=0;a<n.length;a++){const l=n[a];if("number"!=typeof l){if(!i)if(4&r){if(r=2|1&r,""!==l&&!rW(t,l,e)||""===l&&1===n.length){if(vo(r))return!1;i=!0}}else{const u=8&r?l:n[++a];if(8&r&&null!==t.attrs){if(!nW(t.attrs,u,e)){if(vo(r))return!1;i=!0}continue}const d=oW(8&r?"class":l,s,jT(t),e);if(-1===d){if(vo(r))return!1;i=!0;continue}if(""!==u){let h;h=d>o?"":s[d+1].toLowerCase();const p=8&r?h:null;if(p&&-1!==GT(p,u,0)||2&r&&u!==h){if(vo(r))return!1;i=!0}}}}else{if(!i&&!vo(r)&&!vo(l))return!1;if(i&&vo(l))continue;i=!1,r=l|1&r}}return vo(r)||i}function vo(t){return 0==(1&t)}function oW(t,n,e,r){if(null===n)return-1;let s=0;if(r||!e){let o=!1;for(;s<n.length;){const i=n[s];if(i===t)return s;if(3===i||6===i)o=!0;else{if(1===i||2===i){let a=n[++s];for(;"string"==typeof a;)a=n[++s];continue}if(4===i)break;if(0===i){s+=4;continue}}s+=o?1:2}return-1}return function lW(t,n){let e=t.indexOf(4);if(e>-1)for(e++;e<t.length;){const r=t[e];if("number"==typeof r)return-1;if(r===n)return e;e++}return-1}(n,t)}function qT(t,n,e=!1){for(let r=0;r<n.length;r++)if(sW(t,n[r],e))return!0;return!1}function KT(t,n){return t?":not("+n.trim()+")":n}function cW(t){let n=t[0],e=1,r=2,s="",o=!1;for(;e<t.length;){let i=t[e];if("string"==typeof i)if(2&r){const a=t[++e];s+="["+i+(a.length>0?'="'+a+'"':"")+"]"}else 8&r?s+="."+i:4&r&&(s+=" "+i);else""!==s&&!vo(i)&&(n+=KT(o,s),s=""),r=i,o=o||!vo(r);e++}return""!==s&&(n+=KT(o,s)),n}const at={};function me(t){XT(Pt(),ee(),es()+t,!1)}function XT(t,n,e,r){if(!r)if(3==(3&n[ht])){const o=t.preOrderCheckHooks;null!==o&&yf(n,o,e)}else{const o=t.preOrderHooks;null!==o&&bf(n,o,0,e)}Xa(e)}function JT(t,n=null,e=null,r){const s=eE(t,n,e,r);return s.resolveInjectorInitializers(),s}function eE(t,n=null,e=null,r,s=new Set){const o=[e||Wt,A4(t)];return r=r||("object"==typeof t?void 0:un(t)),new $T(o,n||$f(),r||null,s)}let ts=(()=>{class t{static create(e,r){if(Array.isArray(e))return JT({name:""},r,e,"");{const s=e.name??"";return JT({name:s},e.parent,e.providers,s)}}}return t.THROW_IF_NOT_FOUND=zc,t.NULL=new RT,t.\u0275prov=We({token:t,providedIn:"any",factory:()=>Ge(kT)}),t.__NG_ELEMENT_ID__=-1,t})();function Y(t,n=Ye.Default){const e=ee();return null===e?Ge(t,n):TD(Ir(),e,Xe(t),n)}function lE(t,n){const e=t.contentQueries;if(null!==e)for(let r=0;r<e.length;r+=2){const o=e[r+1];if(-1!==o){const i=t.data[o];gv(e[r]),i.contentQueries(2,n[o],o)}}}function Vf(t,n,e,r,s,o,i,a,l,u,c){const d=n.blueprint.slice();return d[Ci]=s,d[ht]=76|r,(null!==c||t&&1024&t[ht])&&(d[ht]|=1024),rD(d),d[An]=d[tu]=t,d[Bn]=e,d[cf]=i||t&&t[cf],d[yt]=a||t&&t[yt],d[av]=l||t&&t[av]||null,d[uf]=u||t&&t[uf]||null,d[Pr]=o,d[qc]=function RU(){return AU++}(),d[q1]=c,d[Or]=2==n.type?t[Or]:d,d}function Cu(t,n,e,r,s){let o=t.data[n];if(null===o)o=function bx(t,n,e,r,s){const o=iD(),i=hv(),l=t.data[n]=function OW(t,n,e,r,s,o){return{type:e,index:r,insertBeforeIndex:null,injectorIndex:n?n.injectorIndex:-1,directiveStart:-1,directiveEnd:-1,directiveStylingLast:-1,componentOffset:-1,propertyBindings:null,flags:0,providerIndexes:0,value:s,attrs:o,mergedAttrs:null,localNames:null,initialInputs:void 0,inputs:null,outputs:null,tView:null,next:null,prev:null,projectionNext:null,child:null,parent:n,projection:null,styles:null,stylesWithoutHost:null,residualStyles:void 0,classes:null,classesWithoutHost:null,residualClasses:void 0,classBindings:0,styleBindings:0}}(0,i?o:o&&o.parent,e,n,r,s);return null===t.firstChild&&(t.firstChild=l),null!==o&&(i?null==o.child&&null!==l.parent&&(o.child=l):null===o.next&&(o.next=l,l.prev=o)),l}(t,n,e,r,s),function $z(){return it.lFrame.inI18n}()&&(o.flags|=32);else if(64&o.type){o.type=e,o.value=r,o.attrs=s;const i=function Xc(){const t=it.lFrame,n=t.currentTNode;return t.isParent?n:n.parent}();o.injectorIndex=null===i?-1:i.injectorIndex}return Go(o,!0),o}function hd(t,n,e,r){if(0===e)return-1;const s=n.length;for(let o=0;o<e;o++)n.push(r),t.blueprint.push(r),t.data.push(null);return s}function vx(t,n,e){yv(n);try{const r=t.viewQuery;null!==r&&Nx(1,r,e);const s=t.template;null!==s&&uE(t,n,s,1,e),t.firstCreatePass&&(t.firstCreatePass=!1),t.staticContentQueries&&lE(t,n),t.staticViewQueries&&Nx(2,t.viewQuery,e);const o=t.components;null!==o&&function FW(t,n){for(let e=0;e<n.length;e++)tG(t,n[e])}(n,o)}catch(r){throw t.firstCreatePass&&(t.incompleteFirstPass=!0,t.firstCreatePass=!1),r}finally{n[ht]&=-5,bv()}}function Bf(t,n,e,r){const s=n[ht];if(128!=(128&s)){yv(n);try{rD(n),function lD(t){return it.lFrame.bindingIndex=t}(t.bindingStartIndex),null!==e&&uE(t,n,e,2,r);const i=3==(3&s);if(i){const u=t.preOrderCheckHooks;null!==u&&yf(n,u,null)}else{const u=t.preOrderHooks;null!==u&&bf(n,u,0,null),vv(n,0)}if(function JW(t){for(let n=Bv(t);null!==n;n=zv(n)){if(!n[K1])continue;const e=n[ru];for(let r=0;r<e.length;r++){const s=e[r];512&s[ht]||dv(s[An],1),s[ht]|=512}}}(n),function QW(t){for(let n=Bv(t);null!==n;n=zv(n))for(let e=Qr;e<n.length;e++){const r=n[e],s=r[De];mf(r)&&Bf(s,r,s.template,r[Bn])}}(n),null!==t.contentQueries&&lE(t,n),i){const u=t.contentCheckHooks;null!==u&&yf(n,u)}else{const u=t.contentHooks;null!==u&&bf(n,u,1),vv(n,1)}!function AW(t,n){const e=t.hostBindingOpCodes;if(null!==e)try{for(let r=0;r<e.length;r++){const s=e[r];if(s<0)Xa(~s);else{const o=s,i=e[++r],a=e[++r];Lz(i,o),a(2,n[o])}}}finally{Xa(-1)}}(t,n);const a=t.components;null!==a&&function RW(t,n){for(let e=0;e<n.length;e++)eG(t,n[e])}(n,a);const l=t.viewQuery;if(null!==l&&Nx(2,l,r),i){const u=t.viewCheckHooks;null!==u&&yf(n,u)}else{const u=t.viewHooks;null!==u&&bf(n,u,2),vv(n,2)}!0===t.firstUpdatePass&&(t.firstUpdatePass=!1),n[ht]&=-41,512&n[ht]&&(n[ht]&=-513,dv(n[An],-1))}finally{bv()}}}function uE(t,n,e,r,s){const o=es(),i=2&r;try{Xa(-1),i&&n.length>fn&&XT(t,n,fn,!1),Ks(i?2:0,s),e(r,s)}finally{Xa(o),Ks(i?3:1,s)}}function xx(t,n,e){if(uv(n)){const s=n.directiveEnd;for(let o=n.directiveStart;o<s;o++){const i=t.data[o];i.contentQueries&&i.contentQueries(1,e[o],o)}}}function wx(t,n,e){oD()&&(function UW(t,n,e,r){const s=e.directiveStart,o=e.directiveEnd;Kc(e)&&function XW(t,n,e){const r=Ns(n,t),s=cE(e),o=t[cf],i=zf(t,Vf(t,s,null,e.onPush?32:16,r,n,o,o.createRenderer(r,e),null,null,null));t[n.index]=i}(n,e,t.data[s+e.componentOffset]),t.firstCreatePass||Cf(e,n),$r(r,n);const i=e.initialInputs;for(let a=s;a<o;a++){const l=t.data[a],u=Ya(n,t,a,e);$r(u,n),null!==i&&YW(0,a-s,u,l,0,i),bo(l)&&(ks(e.index,n)[Bn]=Ya(n,t,a,e))}}(t,n,e,Ns(e,n)),64==(64&e.flags)&&gE(t,n,e))}function Cx(t,n,e=Ns){const r=n.localNames;if(null!==r){let s=n.index+1;for(let o=0;o<r.length;o+=2){const i=r[o+1],a=-1===i?e(n,t):t[i];t[s++]=a}}}function cE(t){const n=t.tView;return null===n||n.incompleteFirstPass?t.tView=_x(1,null,t.template,t.decls,t.vars,t.directiveDefs,t.pipeDefs,t.viewQuery,t.schemas,t.consts):n}function _x(t,n,e,r,s,o,i,a,l,u){const c=fn+r,d=c+s,h=function MW(t,n){const e=[];for(let r=0;r<n;r++)e.push(r<t?null:at);return e}(c,d),p="function"==typeof u?u():u;return h[De]={type:t,blueprint:h,template:e,queries:null,viewQuery:a,declTNode:n,data:h.slice().fill(null,c),bindingStartIndex:c,expandoStartIndex:d,hostBindingOpCodes:null,firstCreatePass:!0,firstUpdatePass:!0,staticViewQueries:!1,staticContentQueries:!1,preOrderHooks:null,preOrderCheckHooks:null,contentHooks:null,contentCheckHooks:null,viewHooks:null,viewCheckHooks:null,destroyHooks:null,cleanup:null,contentQueries:null,components:null,directiveRegistry:"function"==typeof o?o():o,pipeRegistry:"function"==typeof i?i():i,firstChild:null,schemas:l,consts:p,incompleteFirstPass:!1}}function dE(t,n,e,r){const s=bE(n);null===e?s.push(r):(s.push(e),t.firstCreatePass&&vE(t).push(r,s.length-1))}function hE(t,n,e,r){for(let s in t)if(t.hasOwnProperty(s)){e=null===e?{}:e;const o=t[s];null===r?pE(e,n,s,o):r.hasOwnProperty(s)&&pE(e,n,r[s],o)}return e}function pE(t,n,e,r){t.hasOwnProperty(e)?t[e].push(n,r):t[e]=[n,r]}function Rs(t,n,e,r,s,o,i,a){const l=Ns(n,e);let c,u=n.inputs;!a&&null!=u&&(c=u[r])?(kx(t,e,c,r,s),Kc(n)&&fE(e,n.index)):3&n.type&&(r=function LW(t){return"class"===t?"className":"for"===t?"htmlFor":"formaction"===t?"formAction":"innerHtml"===t?"innerHTML":"readonly"===t?"readOnly":"tabindex"===t?"tabIndex":t}(r),s=null!=i?i(s,n.value||"",r):s,o.setProperty(l,r,s))}function fE(t,n){const e=ks(n,t);16&e[ht]||(e[ht]|=32)}function Sx(t,n,e,r){if(oD()){const s=null===r?null:{"":-1},o=function GW(t,n){const e=t.directiveRegistry;let r=null,s=null;if(e)for(let o=0;o<e.length;o++){const i=e[o];if(qT(n,i.selectors,!1))if(r||(r=[]),bo(i))if(null!==i.findHostDirectiveDefs){const a=[];s=s||new Map,i.findHostDirectiveDefs(i,a,s),r.unshift(...a,i),Ix(t,n,a.length)}else r.unshift(i),Ix(t,n,0);else s=s||new Map,i.findHostDirectiveDefs?.(i,r,s),r.push(i)}return null===r?null:[r,s]}(t,e);let i,a;null===o?i=a=null:[i,a]=o,null!==i&&mE(t,n,e,i,s,a),s&&function HW(t,n,e){if(n){const r=t.localNames=[];for(let s=0;s<n.length;s+=2){const o=e[n[s+1]];if(null==o)throw new ce(-301,!1);r.push(n[s],o)}}}(e,r,s)}e.mergedAttrs=Zc(e.mergedAttrs,e.attrs)}function mE(t,n,e,r,s,o){for(let u=0;u<r.length;u++)Iv(Cf(e,n),t,r[u].type);!function qW(t,n,e){t.flags|=1,t.directiveStart=n,t.directiveEnd=n+e,t.providerIndexes=n}(e,t.data.length,r.length);for(let u=0;u<r.length;u++){const c=r[u];c.providersResolver&&c.providersResolver(c)}let i=!1,a=!1,l=hd(t,n,r.length,null);for(let u=0;u<r.length;u++){const c=r[u];e.mergedAttrs=Zc(e.mergedAttrs,c.hostAttrs),KW(t,e,n,l,c),jW(l,c,s),null!==c.contentQueries&&(e.flags|=4),(null!==c.hostBindings||null!==c.hostAttrs||0!==c.hostVars)&&(e.flags|=64);const d=c.type.prototype;!i&&(d.ngOnChanges||d.ngOnInit||d.ngDoCheck)&&((t.preOrderHooks||(t.preOrderHooks=[])).push(e.index),i=!0),!a&&(d.ngOnChanges||d.ngDoCheck)&&((t.preOrderCheckHooks||(t.preOrderCheckHooks=[])).push(e.index),a=!0),l++}!function $W(t,n,e){const s=n.directiveEnd,o=t.data,i=n.attrs,a=[];let l=null,u=null;for(let c=n.directiveStart;c<s;c++){const d=o[c],h=e?e.get(d):null,f=h?h.outputs:null;l=hE(d.inputs,c,l,h?h.inputs:null),u=hE(d.outputs,c,u,f);const g=null===l||null===i||jT(n)?null:ZW(l,c,i);a.push(g)}null!==l&&(l.hasOwnProperty("class")&&(n.flags|=8),l.hasOwnProperty("style")&&(n.flags|=16)),n.initialInputs=a,n.inputs=l,n.outputs=u}(t,e,o)}function gE(t,n,e){const r=e.directiveStart,s=e.directiveEnd,o=e.index,i=function Vz(){return it.lFrame.currentDirectiveIndex}();try{Xa(o);for(let a=r;a<s;a++){const l=t.data[a],u=n[a];fv(a),(null!==l.hostBindings||0!==l.hostVars||null!==l.hostAttrs)&&WW(l,u)}}finally{Xa(-1),fv(i)}}function WW(t,n){null!==t.hostBindings&&t.hostBindings(1,n)}function Ix(t,n,e){n.componentOffset=e,(t.components||(t.components=[])).push(n.index)}function jW(t,n,e){if(e){if(n.exportAs)for(let r=0;r<n.exportAs.length;r++)e[n.exportAs[r]]=t;bo(n)&&(e[""]=t)}}function KW(t,n,e,r,s){t.data[r]=s;const o=s.factory||(s.factory=Ka(s.type)),i=new Yc(o,bo(s),Y);t.blueprint[r]=i,e[r]=i,function BW(t,n,e,r,s){const o=s.hostBindings;if(o){let i=t.hostBindingOpCodes;null===i&&(i=t.hostBindingOpCodes=[]);const a=~n.index;(function zW(t){let n=t.length;for(;n>0;){const e=t[--n];if("number"==typeof e&&e<0)return e}return 0})(i)!=a&&i.push(a),i.push(e,r,o)}}(t,n,r,hd(t,e,s.hostVars,at),s)}function YW(t,n,e,r,s,o){const i=o[n];if(null!==i){const a=r.setInput;for(let l=0;l<i.length;){const u=i[l++],c=i[l++],d=i[l++];null!==a?r.setInput(e,d,u,c):e[c]=d}}}function ZW(t,n,e){let r=null,s=0;for(;s<e.length;){const o=e[s];if(0!==o)if(5!==o){if("number"==typeof o)break;if(t.hasOwnProperty(o)){null===r&&(r=[]);const i=t[o];for(let a=0;a<i.length;a+=2)if(i[a]===n){r.push(o,i[a+1],e[s+1]);break}}s+=2}else s+=2;else s+=4}return r}function yE(t,n,e,r){return[t,!0,!1,n,null,0,r,e,null,null]}function eG(t,n){const e=ks(n,t);if(mf(e)){const r=e[De];48&e[ht]?Bf(r,e,r.template,e[Bn]):e[qa]>0&&Tx(e)}}function Tx(t){for(let r=Bv(t);null!==r;r=zv(r))for(let s=Qr;s<r.length;s++){const o=r[s];if(mf(o))if(512&o[ht]){const i=o[De];Bf(i,o,i.template,o[Bn])}else o[qa]>0&&Tx(o)}const e=t[De].components;if(null!==e)for(let r=0;r<e.length;r++){const s=ks(e[r],t);mf(s)&&s[qa]>0&&Tx(s)}}function tG(t,n){const e=ks(n,t),r=e[De];(function nG(t,n){for(let e=n.length;e<t.blueprint.length;e++)n.push(t.blueprint[e])})(r,e),vx(r,e,e[Bn])}function zf(t,n){return t[Hc]?t[j1][go]=n:t[Hc]=n,t[j1]=n,n}function Ex(t){for(;t;){t[ht]|=32;const n=id(t);if(vz(t)&&!n)return t;t=n}return null}function Uf(t,n,e,r=!0){const s=n[cf];s.begin&&s.begin();try{Bf(t,n,t.template,e)}catch(i){throw r&&wE(n,i),i}finally{s.end&&s.end()}}function Nx(t,n,e){gv(0),n(t,e)}function bE(t){return t[eu]||(t[eu]=[])}function vE(t){return t.cleanup||(t.cleanup=[])}function wE(t,n){const e=t[uf],r=e?e.get(vu,null):null;r&&r.handleError(n)}function kx(t,n,e,r,s){for(let o=0;o<e.length;){const i=e[o++],a=e[o++],l=n[i],u=t.data[i];null!==u.setInput?u.setInput(l,s,r,a):l[a]=s}}function Wf(t,n,e){let r=e?t.styles:null,s=e?t.classes:null,o=0;if(null!==n)for(let i=0;i<n.length;i++){const a=n[i];"number"==typeof a?o=a:1==o?s=Qb(s,a):2==o&&(r=Qb(r,a+": "+n[++i]+";"))}e?t.styles=r:t.stylesWithoutHost=r,e?t.classes=s:t.classesWithoutHost=s}function Gf(t,n,e,r,s=!1){for(;null!==e;){const o=n[e.index];if(null!==o&&r.push(Sr(o)),yo(o))for(let a=Qr;a<o.length;a++){const l=o[a],u=l[De].firstChild;null!==u&&Gf(l[De],l,u,r)}const i=e.type;if(8&i)Gf(t,n,e.child,r);else if(32&i){const a=Vv(e,n);let l;for(;l=a();)r.push(l)}else if(16&i){const a=hT(n,e);if(Array.isArray(a))r.push(...a);else{const l=id(n[Or]);Gf(l[De],l,a,r,!0)}}e=s?e.projectionNext:e.next}return r}class pd{get rootNodes(){const n=this._lView,e=n[De];return Gf(e,n,e.firstChild,[])}constructor(n,e){this._lView=n,this._cdRefInjectingView=e,this._appRef=null,this._attachedToViewContainer=!1}get context(){return this._lView[Bn]}set context(n){this._lView[Bn]=n}get destroyed(){return 128==(128&this._lView[ht])}destroy(){if(this._appRef)this._appRef.detachView(this);else if(this._attachedToViewContainer){const n=this._lView[An];if(yo(n)){const e=n[hf],r=e?e.indexOf(this):-1;r>-1&&(Gv(n,r),If(e,r))}this._attachedToViewContainer=!1}rT(this._lView[De],this._lView)}onDestroy(n){dE(this._lView[De],this._lView,null,n)}markForCheck(){Ex(this._cdRefInjectingView||this._lView)}detach(){this._lView[ht]&=-65}reattach(){this._lView[ht]|=64}detectChanges(){Uf(this._lView[De],this._lView,this.context)}checkNoChanges(){}attachToViewContainerRef(){if(this._appRef)throw new ce(902,!1);this._attachedToViewContainer=!0}detachFromAppRef(){this._appRef=null,function qU(t,n){ad(t,n,n[yt],2,null,null)}(this._lView[De],this._lView)}attachToAppRef(n){if(this._attachedToViewContainer)throw new ce(902,!1);this._appRef=n}}class rG extends pd{constructor(n){super(n),this._view=n}detectChanges(){const n=this._view;Uf(n[De],n,n[Bn],!1)}checkNoChanges(){}get context(){return null}}class CE extends yu{constructor(n){super(),this.ngModule=n}resolveComponentFactory(n){const e=jt(n);return new fd(e,this.ngModule)}}function _E(t){const n=[];for(let e in t)t.hasOwnProperty(e)&&n.push({propName:t[e],templateName:e});return n}class oG{constructor(n,e){this.injector=n,this.parentInjector=e}get(n,e,r){r=sf(r);const s=this.injector.get(n,cx,r);return s!==cx||e===cx?s:this.parentInjector.get(n,e,r)}}class fd extends VT{get inputs(){return _E(this.componentDef.inputs)}get outputs(){return _E(this.componentDef.outputs)}constructor(n,e){super(),this.componentDef=n,this.ngModule=e,this.componentType=n.type,this.selector=function dW(t){return t.map(cW).join(",")}(n.selectors),this.ngContentSelectors=n.ngContentSelectors?n.ngContentSelectors:[],this.isBoundToModule=!!e}create(n,e,r,s){let o=(s=s||this.ngModule)instanceof Di?s:s?.injector;o&&null!==this.componentDef.getStandaloneInjector&&(o=this.componentDef.getStandaloneInjector(o)||o);const i=o?new oG(n,o):n,a=i.get(zT,null);if(null===a)throw new ce(407,!1);const l=i.get(j4,null),u=a.createRenderer(null,this.componentDef),c=this.componentDef.selectors[0][0]||"div",d=r?function PW(t,n,e){return t.selectRootElement(n,e===Uo.ShadowDom)}(u,r,this.componentDef.encapsulation):Wv(u,c,function sG(t){const n=t.toLowerCase();return"svg"===n?eD:"math"===n?"math":null}(c)),h=this.componentDef.onPush?288:272,p=_x(0,null,null,1,0,null,null,null,null,null),f=Vf(null,p,null,h,null,null,a,u,l,i,null);let g,m;yv(f);try{const y=this.componentDef;let b,v=null;y.findHostDirectiveDefs?(b=[],v=new Map,y.findHostDirectiveDefs(y,b,v),b.push(y)):b=[y];const x=function aG(t,n){const e=t[De],r=fn;return t[r]=n,Cu(e,r,2,"#host",null)}(f,d),w=function lG(t,n,e,r,s,o,i,a){const l=s[De];!function uG(t,n,e,r){for(const s of t)n.mergedAttrs=Zc(n.mergedAttrs,s.hostAttrs);null!==n.mergedAttrs&&(Wf(n,n.mergedAttrs,!0),null!==e&&mT(r,e,n))}(r,t,n,i);const u=o.createRenderer(n,e),c=Vf(s,cE(e),null,e.onPush?32:16,s[t.index],t,o,u,a||null,null,null);return l.firstCreatePass&&Ix(l,t,r.length-1),zf(s,c),s[t.index]=c}(x,d,y,b,f,a,u);m=nD(p,fn),d&&function dG(t,n,e,r){if(r)wv(t,e,["ng-version",q4.full]);else{const{attrs:s,classes:o}=function hW(t){const n=[],e=[];let r=1,s=2;for(;r<t.length;){let o=t[r];if("string"==typeof o)2===s?""!==o&&n.push(o,t[++r]):8===s&&e.push(o);else{if(!vo(s))break;s=o}r++}return{attrs:n,classes:e}}(n.selectors[0]);s&&wv(t,e,s),o&&o.length>0&&fT(t,e,o.join(" "))}}(u,y,d,r),void 0!==e&&function hG(t,n,e){const r=t.projection=[];for(let s=0;s<n.length;s++){const o=e[s];r.push(null!=o?Array.from(o):null)}}(m,this.ngContentSelectors,e),g=function cG(t,n,e,r,s,o){const i=Ir(),a=s[De],l=Ns(i,s);mE(a,s,i,e,null,r);for(let c=0;c<e.length;c++)$r(Ya(s,a,i.directiveStart+c,i),s);gE(a,s,i),l&&$r(l,s);const u=Ya(s,a,i.directiveStart+i.componentOffset,i);if(t[Bn]=s[Bn]=u,null!==o)for(const c of o)c(u,n);return xx(a,i,t),u}(w,y,b,v,f,[pG]),vx(p,f,null)}finally{bv()}return new iG(this.componentType,g,bu(m,f),f,m)}}class iG extends B4{constructor(n,e,r,s,o){super(),this.location=r,this._rootLView=s,this._tNode=o,this.instance=e,this.hostView=this.changeDetectorRef=new rG(s),this.componentType=n}setInput(n,e){const r=this._tNode.inputs;let s;if(null!==r&&(s=r[n])){const o=this._rootLView;kx(o[De],o,s,n,e),fE(o,this._tNode.index)}}get injector(){return new au(this._tNode,this._rootLView)}destroy(){this.hostView.destroy()}onDestroy(n){this.hostView.onDestroy(n)}}function pG(){const t=Ir();gf(ee()[De],t)}function Yt(t){let n=function SE(t){return Object.getPrototypeOf(t.prototype).constructor}(t.type),e=!0;const r=[t];for(;n;){let s;if(bo(t))s=n.\u0275cmp||n.\u0275dir;else{if(n.\u0275cmp)throw new ce(903,!1);s=n.\u0275dir}if(s){if(e){r.push(s);const i=t;i.inputs=Ax(t.inputs),i.declaredInputs=Ax(t.declaredInputs),i.outputs=Ax(t.outputs);const a=s.hostBindings;a&&yG(t,a);const l=s.viewQuery,u=s.contentQueries;if(l&&mG(t,l),u&&gG(t,u),Zb(t.inputs,s.inputs),Zb(t.declaredInputs,s.declaredInputs),Zb(t.outputs,s.outputs),bo(s)&&s.data.animation){const c=t.data;c.animation=(c.animation||[]).concat(s.data.animation)}}const o=s.features;if(o)for(let i=0;i<o.length;i++){const a=o[i];a&&a.ngInherit&&a(t),a===Yt&&(e=!1)}}n=Object.getPrototypeOf(n)}!function fG(t){let n=0,e=null;for(let r=t.length-1;r>=0;r--){const s=t[r];s.hostVars=n+=s.hostVars,s.hostAttrs=Zc(s.hostAttrs,e=Zc(e,s.hostAttrs))}}(r)}function Ax(t){return t===xi?{}:t===Wt?[]:t}function mG(t,n){const e=t.viewQuery;t.viewQuery=e?(r,s)=>{n(r,s),e(r,s)}:n}function gG(t,n){const e=t.contentQueries;t.contentQueries=e?(r,s,o)=>{n(r,s,o),e(r,s,o)}:n}function yG(t,n){const e=t.hostBindings;t.hostBindings=e?(r,s)=>{n(r,s),e(r,s)}:n}function Hf(t){return!!Rx(t)&&(Array.isArray(t)||!(t instanceof Map)&&Symbol.iterator in t)}function Rx(t){return null!==t&&("function"==typeof t||"object"==typeof t)}function qo(t,n,e){return t[n]=e}function Vr(t,n,e){return!Object.is(t[n],e)&&(t[n]=e,!0)}function el(t,n,e,r){const s=Vr(t,n,e);return Vr(t,n+1,r)||s}function Su(t,n,e,r){return Vr(t,ou(),e)?n+ot(e)+r:at}function Ot(t,n,e,r,s,o,i,a){const l=ee(),u=Pt(),c=t+fn,d=u.firstCreatePass?function TG(t,n,e,r,s,o,i,a,l){const u=n.consts,c=Cu(n,t,4,i||null,Qi(u,a));Sx(n,e,c,Qi(u,l)),gf(n,c);const d=c.tView=_x(2,c,r,s,o,n.directiveRegistry,n.pipeRegistry,null,n.schemas,u);return null!==n.queries&&(n.queries.template(n,c),d.queries=n.queries.embeddedTView(c)),c}(c,u,l,n,e,r,s,o,i):u.data[c];Go(d,!1);const h=l[yt].createComment("");kf(u,l,h,d),$r(h,l),zf(l,l[c]=yE(h,l,h,d)),pf(d)&&wx(u,l,d),null!=i&&Cx(l,d,a)}function Fx(t){return function su(t,n){return t[n]}(function Oz(){return it.lFrame.contextLView}(),fn+t)}function _e(t,n,e){const r=ee();return Vr(r,ou(),n)&&Rs(Pt(),In(),r,t,n,r[yt],e,!1),_e}function Mx(t,n,e,r,s){const i=s?"class":"style";kx(t,e,n.inputs[i],i,r)}function te(t,n,e,r){const s=ee(),o=Pt(),i=fn+t,a=s[yt],l=o.firstCreatePass?function NG(t,n,e,r,s,o){const i=n.consts,l=Cu(n,t,2,r,Qi(i,s));return Sx(n,e,l,Qi(i,o)),null!==l.attrs&&Wf(l,l.attrs,!1),null!==l.mergedAttrs&&Wf(l,l.mergedAttrs,!0),null!==n.queries&&n.queries.elementStart(n,l),l}(i,o,s,n,e,r):o.data[i],u=s[i]=Wv(a,n,function jz(){return it.lFrame.currentNamespace}()),c=pf(l);return Go(l,!0),mT(a,u,l),32!=(32&l.flags)&&kf(o,s,u,l),0===function Az(){return it.lFrame.elementDepthCount}()&&$r(u,s),function Rz(){it.lFrame.elementDepthCount++}(),c&&(wx(o,s,l),xx(o,l,s)),null!==r&&Cx(s,l),te}function Q(){let t=Ir();hv()?pv():(t=t.parent,Go(t,!1));const n=t;!function Fz(){it.lFrame.elementDepthCount--}();const e=Pt();return e.firstCreatePass&&(gf(e,t),uv(t)&&e.queries.elementEnd(t)),null!=n.classesWithoutHost&&function Yz(t){return 0!=(8&t.flags)}(n)&&Mx(e,n,ee(),n.classesWithoutHost,!0),null!=n.stylesWithoutHost&&function Zz(t){return 0!=(16&t.flags)}(n)&&Mx(e,n,ee(),n.stylesWithoutHost,!1),Q}function Vt(t,n,e,r){return te(t,n,e,r),Q(),Vt}function Px(t,n,e){const r=ee(),s=Pt(),o=t+fn,i=s.firstCreatePass?function kG(t,n,e,r,s){const o=n.consts,i=Qi(o,r),a=Cu(n,t,8,"ng-container",i);return null!==i&&Wf(a,i,!0),Sx(n,e,a,Qi(o,s)),null!==n.queries&&n.queries.elementStart(n,a),a}(o,s,r,n,e):s.data[o];Go(i,!0);const a=r[o]=r[yt].createComment("");return kf(s,r,a,i),$r(a,r),pf(i)&&(wx(s,r,i),xx(s,i,r)),null!=e&&Cx(r,i),Px}function Ox(){let t=Ir();const n=Pt();return hv()?pv():(t=t.parent,Go(t,!1)),n.firstCreatePass&&(gf(n,t),uv(t)&&n.queries.elementEnd(t)),Ox}function $x(t,n,e){return Px(t,n,e),Ox(),$x}function zn(){return ee()}function gd(t){return!!t&&"function"==typeof t.then}const Lx=function $E(t){return!!t&&"function"==typeof t.subscribe};function Ee(t,n,e,r){const s=ee(),o=Pt(),i=Ir();return function VE(t,n,e,r,s,o,i){const a=pf(r),u=t.firstCreatePass&&vE(t),c=n[Bn],d=bE(n);let h=!0;if(3&r.type||i){const g=Ns(r,n),m=i?i(g):g,y=d.length,b=i?x=>i(Sr(x[r.index])):r.index;let v=null;if(!i&&a&&(v=function AG(t,n,e,r){const s=t.cleanup;if(null!=s)for(let o=0;o<s.length-1;o+=2){const i=s[o];if(i===e&&s[o+1]===r){const a=n[eu],l=s[o+2];return a.length>l?a[l]:null}"string"==typeof i&&(o+=2)}return null}(t,n,s,r.index)),null!==v)(v.__ngLastListenerFn__||v).__ngNextListenerFn__=o,v.__ngLastListenerFn__=o,h=!1;else{o=zE(r,n,c,o,!1);const x=e.listen(m,s,o);d.push(o,x),u&&u.push(s,b,y,y+1)}}else o=zE(r,n,c,o,!1);const p=r.outputs;let f;if(h&&null!==p&&(f=p[s])){const g=f.length;if(g)for(let m=0;m<g;m+=2){const w=n[f[m]][f[m+1]].subscribe(o),C=d.length;d.push(o,w),u&&u.push(s,r.index,C,-(C+1))}}}(o,s,s[yt],i,t,n,r),Ee}function BE(t,n,e,r){try{return Ks(6,n,e),!1!==e(r)}catch(s){return wE(t,s),!1}finally{Ks(7,n,e)}}function zE(t,n,e,r,s){return function o(i){if(i===Function)return r;Ex(t.componentOffset>-1?ks(t.index,n):n);let l=BE(n,e,r,i),u=o.__ngNextListenerFn__;for(;u;)l=BE(n,e,u,i)&&l,u=u.__ngNextListenerFn__;return s&&!1===l&&(i.preventDefault(),i.returnValue=!1),l}}function we(t=1){return function zz(t){return(it.lFrame.contextLView=function Uz(t,n){for(;t>0;)n=n[tu],t--;return n}(t,it.lFrame.contextLView))[Bn]}(t)}function qf(t,n,e){return Vx(t,"",n,"",e),qf}function Vx(t,n,e,r,s){const o=ee(),i=Su(o,n,e,r);return i!==at&&Rs(Pt(),In(),o,t,i,o[yt],s,!1),Vx}function Kf(t,n){return t<<17|n<<2}function ea(t){return t>>17&32767}function Bx(t){return 2|t}function tl(t){return(131068&t)>>2}function zx(t,n){return-131069&t|n<<2}function Ux(t){return 1|t}function YE(t,n,e,r,s){const o=t[e+1],i=null===n;let a=r?ea(o):tl(o),l=!1;for(;0!==a&&(!1===l||i);){const c=t[a+1];BG(t[a],n)&&(l=!0,t[a+1]=r?Ux(c):Bx(c)),a=r?ea(c):tl(c)}l&&(t[e+1]=r?Bx(o):Ux(o))}function BG(t,n){return null===t||null==n||(Array.isArray(t)?t[1]:t)===n||!(!Array.isArray(t)||"string"!=typeof n)&&hu(t,n)>=0}const ir={textEnd:0,key:0,keyEnd:0,value:0,valueEnd:0};function ZE(t){return t.substring(ir.key,ir.keyEnd)}function QE(t,n){const e=ir.textEnd;return e===n?-1:(n=ir.keyEnd=function GG(t,n,e){for(;n<e&&t.charCodeAt(n)>32;)n++;return n}(t,ir.key=n,e),Ru(t,n,e))}function Ru(t,n,e){for(;n<e&&t.charCodeAt(n)<=32;)n++;return n}function Un(t,n,e){return xo(t,n,e,!1),Un}function nl(t,n){return xo(t,n,null,!0),nl}function rl(t){wo(As,Yo,t,!0)}function Yo(t,n){for(let e=function UG(t){return function eN(t){ir.key=0,ir.keyEnd=0,ir.value=0,ir.valueEnd=0,ir.textEnd=t.length}(t),QE(t,Ru(t,0,ir.textEnd))}(n);e>=0;e=QE(n,e))As(t,ZE(n),!0)}function xo(t,n,e,r){const s=ee(),o=Pt(),i=Si(2);o.firstUpdatePass&&sN(o,t,i,r),n!==at&&Vr(s,i,n)&&iN(o,o.data[es()],s,s[yt],t,s[i+1]=function eH(t,n){return null==t||("string"==typeof n?t+=n:"object"==typeof t&&(t=un(Ji(t)))),t}(n,e),r,i)}function wo(t,n,e,r){const s=Pt(),o=Si(2);s.firstUpdatePass&&sN(s,null,o,r);const i=ee();if(e!==at&&Vr(i,o,e)){const a=s.data[es()];if(lN(a,r)&&!rN(s,o)){let l=r?a.classesWithoutHost:a.stylesWithoutHost;null!==l&&(e=Qb(l,e||"")),Mx(s,a,i,e,r)}else!function JG(t,n,e,r,s,o,i,a){s===at&&(s=Wt);let l=0,u=0,c=0<s.length?s[0]:null,d=0<o.length?o[0]:null;for(;null!==c||null!==d;){const h=l<s.length?s[l+1]:void 0,p=u<o.length?o[u+1]:void 0;let g,f=null;c===d?(l+=2,u+=2,h!==p&&(f=d,g=p)):null===d||null!==c&&c<d?(l+=2,f=c):(u+=2,f=d,g=p),null!==f&&iN(t,n,e,r,f,g,i,a),c=l<s.length?s[l]:null,d=u<o.length?o[u]:null}}(s,a,i,i[yt],i[o+1],i[o+1]=function QG(t,n,e){if(null==e||""===e)return Wt;const r=[],s=Ji(e);if(Array.isArray(s))for(let o=0;o<s.length;o++)t(r,s[o],!0);else if("object"==typeof s)for(const o in s)s.hasOwnProperty(o)&&t(r,o,s[o]);else"string"==typeof s&&n(r,s);return r}(t,n,e),r,o)}}function rN(t,n){return n>=t.expandoStartIndex}function sN(t,n,e,r){const s=t.data;if(null===s[e+1]){const o=s[es()],i=rN(t,e);lN(o,r)&&null===n&&!i&&(n=!1),n=function KG(t,n,e,r){const s=function mv(t){const n=it.lFrame.currentDirectiveIndex;return-1===n?null:t[n]}(t);let o=r?n.residualClasses:n.residualStyles;if(null===s)0===(r?n.classBindings:n.styleBindings)&&(e=yd(e=Wx(null,t,n,e,r),n.attrs,r),o=null);else{const i=n.directiveStylingLast;if(-1===i||t[i]!==s)if(e=Wx(s,t,n,e,r),null===o){let l=function XG(t,n,e){const r=e?n.classBindings:n.styleBindings;if(0!==tl(r))return t[ea(r)]}(t,n,r);void 0!==l&&Array.isArray(l)&&(l=Wx(null,t,n,l[1],r),l=yd(l,n.attrs,r),function YG(t,n,e,r){t[ea(e?n.classBindings:n.styleBindings)]=r}(t,n,r,l))}else o=function ZG(t,n,e){let r;const s=n.directiveEnd;for(let o=1+n.directiveStylingLast;o<s;o++)r=yd(r,t[o].hostAttrs,e);return yd(r,n.attrs,e)}(t,n,r)}return void 0!==o&&(r?n.residualClasses=o:n.residualStyles=o),e}(s,o,n,r),function LG(t,n,e,r,s,o){let i=o?n.classBindings:n.styleBindings,a=ea(i),l=tl(i);t[r]=e;let c,u=!1;if(Array.isArray(e)?(c=e[1],(null===c||hu(e,c)>0)&&(u=!0)):c=e,s)if(0!==l){const h=ea(t[a+1]);t[r+1]=Kf(h,a),0!==h&&(t[h+1]=zx(t[h+1],r)),t[a+1]=function OG(t,n){return 131071&t|n<<17}(t[a+1],r)}else t[r+1]=Kf(a,0),0!==a&&(t[a+1]=zx(t[a+1],r)),a=r;else t[r+1]=Kf(l,0),0===a?a=r:t[l+1]=zx(t[l+1],r),l=r;u&&(t[r+1]=Bx(t[r+1])),YE(t,c,r,!0),YE(t,c,r,!1),function VG(t,n,e,r,s){const o=s?t.residualClasses:t.residualStyles;null!=o&&"string"==typeof n&&hu(o,n)>=0&&(e[r+1]=Ux(e[r+1]))}(n,c,t,r,o),i=Kf(a,l),o?n.classBindings=i:n.styleBindings=i}(s,o,n,e,i,r)}}function Wx(t,n,e,r,s){let o=null;const i=e.directiveEnd;let a=e.directiveStylingLast;for(-1===a?a=e.directiveStart:a++;a<i&&(o=n[a],r=yd(r,o.hostAttrs,s),o!==t);)a++;return null!==t&&(e.directiveStylingLast=a),r}function yd(t,n,e){const r=e?1:2;let s=-1;if(null!==n)for(let o=0;o<n.length;o++){const i=n[o];"number"==typeof i?s=i:s===r&&(Array.isArray(t)||(t=void 0===t?[]:["",t]),As(t,i,!!e||n[++o]))}return void 0===t?null:t}function iN(t,n,e,r,s,o,i,a){if(!(3&n.type))return;const l=t.data,u=l[a+1],c=function $G(t){return 1==(1&t)}(u)?aN(l,n,e,s,tl(u),i):void 0;Xf(c)||(Xf(o)||function PG(t){return 2==(2&t)}(u)&&(o=aN(l,null,e,s,a,i)),function r4(t,n,e,r,s){if(n)s?t.addClass(e,r):t.removeClass(e,r);else{let o=-1===r.indexOf("-")?void 0:ps.DashCase;null==s?t.removeStyle(e,r,o):("string"==typeof s&&s.endsWith("!important")&&(s=s.slice(0,-10),o|=ps.Important),t.setStyle(e,r,s,o))}}(r,i,ff(es(),e),s,o))}function aN(t,n,e,r,s,o){const i=null===n;let a;for(;s>0;){const l=t[s],u=Array.isArray(l),c=u?l[1]:l,d=null===c;let h=e[s+1];h===at&&(h=d?Wt:void 0);let p=d?Nv(h,r):c===r?h:void 0;if(u&&!Xf(p)&&(p=Nv(l,r)),Xf(p)&&(a=p,i))return a;const f=t[s+1];s=i?ea(f):tl(f)}if(null!==n){let l=o?n.residualClasses:n.residualStyles;null!=l&&(a=Nv(l,r))}return a}function Xf(t){return void 0!==t}function lN(t,n){return 0!=(t.flags&(n?8:16))}function Be(t,n=""){const e=ee(),r=Pt(),s=t+fn,o=r.firstCreatePass?Cu(r,s,1,n,null):r.data[s],i=e[s]=function Uv(t,n){return t.createText(n)}(e[yt],n);kf(r,e,i,o),Go(o,!1)}function sl(t){return Zs("",t,""),sl}function Zs(t,n,e){const r=ee(),s=Su(r,t,n,e);return s!==at&&function Ni(t,n,e){const r=ff(n,t);!function tT(t,n,e){t.setValue(n,e)}(t[yt],r,e)}(r,es(),s),Zs}const Mu="en-US";let AN=Mu;function jx(t,n,e,r,s){if(t=Xe(t),Array.isArray(t))for(let o=0;o<t.length;o++)jx(t[o],n,e,r,s);else{const o=Pt(),i=ee();let a=Ja(t)?t:Xe(t.provide),l=LT(t);const u=Ir(),c=1048575&u.providerIndexes,d=u.directiveStart,h=u.providerIndexes>>20;if(Ja(t)||!t.multi){const p=new Yc(l,s,Y),f=Kx(a,n,s?c:c+h,d);-1===f?(Iv(Cf(u,i),o,a),qx(o,t,n.length),n.push(a),u.directiveStart++,u.directiveEnd++,s&&(u.providerIndexes+=1048576),e.push(p),i.push(p)):(e[f]=p,i[f]=p)}else{const p=Kx(a,n,c+h,d),f=Kx(a,n,c,c+h),m=f>=0&&e[f];if(s&&!m||!s&&!(p>=0&&e[p])){Iv(Cf(u,i),o,a);const y=function yj(t,n,e,r,s){const o=new Yc(t,e,Y);return o.multi=[],o.index=n,o.componentProviders=0,nk(o,s,r&&!e),o}(s?gj:mj,e.length,s,r,l);!s&&m&&(e[f].providerFactory=y),qx(o,t,n.length,0),n.push(a),u.directiveStart++,u.directiveEnd++,s&&(u.providerIndexes+=1048576),e.push(y),i.push(y)}else qx(o,t,p>-1?p:f,nk(e[s?f:p],l,!s&&r));!s&&r&&m&&e[f].componentProviders++}}}function qx(t,n,e,r){const s=Ja(n),o=function F4(t){return!!t.useClass}(n);if(s||o){const l=(o?Xe(n.useClass):n).prototype.ngOnDestroy;if(l){const u=t.destroyHooks||(t.destroyHooks=[]);if(!s&&n.multi){const c=u.indexOf(e);-1===c?u.push(e,[r,l]):u[c+1].push(r,l)}else u.push(e,l)}}}function nk(t,n,e){return e&&t.componentProviders++,t.multi.push(n)-1}function Kx(t,n,e,r){for(let s=e;s<r;s++)if(n[s]===t)return s;return-1}function mj(t,n,e,r){return Xx(this.multi,[])}function gj(t,n,e,r){const s=this.multi;let o;if(this.providerFactory){const i=this.providerFactory.componentProviders,a=Ya(e,e[De],this.providerFactory.index,r);o=a.slice(0,i),Xx(s,o);for(let l=i;l<a.length;l++)o.push(a[l])}else o=[],Xx(s,o);return o}function Xx(t,n){for(let e=0;e<t.length;e++)n.push((0,t[e])());return n}function xn(t,n=[]){return e=>{e.providersResolver=(r,s)=>function fj(t,n,e){const r=Pt();if(r.firstCreatePass){const s=bo(t);jx(e,r.data,r.blueprint,s,!0),jx(n,r.data,r.blueprint,s,!1)}}(r,s?s(t):t,n)}}class Pu{}class rk{}class sk extends Pu{constructor(n,e){super(),this._parent=e,this._bootstrapComponents=[],this.destroyCbs=[],this.componentFactoryResolver=new CE(this);const r=Ds(n);this._bootstrapComponents=Ei(r.bootstrap),this._r3Injector=eE(n,e,[{provide:Pu,useValue:this},{provide:yu,useValue:this.componentFactoryResolver}],un(n),new Set(["environment"])),this._r3Injector.resolveInjectorInitializers(),this.instance=this._r3Injector.get(n)}get injector(){return this._r3Injector}destroy(){const n=this._r3Injector;!n.destroyed&&n.destroy(),this.destroyCbs.forEach(e=>e()),this.destroyCbs=null}onDestroy(n){this.destroyCbs.push(n)}}class Yx extends rk{constructor(n){super(),this.moduleType=n}create(n){return new sk(this.moduleType,n)}}class vj extends Pu{constructor(n,e,r){super(),this.componentFactoryResolver=new CE(this),this.instance=null;const s=new $T([...n,{provide:Pu,useValue:this},{provide:yu,useValue:this.componentFactoryResolver}],e||$f(),r,new Set(["environment"]));this.injector=s,s.resolveInjectorInitializers()}destroy(){this.injector.destroy()}onDestroy(n){this.injector.onDestroy(n)}}function em(t,n,e=null){return new vj(t,n,e).injector}let xj=(()=>{class t{constructor(e){this._injector=e,this.cachedInjectors=new Map}getOrCreateStandaloneInjector(e){if(!e.standalone)return null;if(!this.cachedInjectors.has(e.id)){const r=FT(0,e.type),s=r.length>0?em([r],this._injector,`Standalone[${e.type.name}]`):null;this.cachedInjectors.set(e.id,s)}return this.cachedInjectors.get(e.id)}ngOnDestroy(){try{for(const e of this.cachedInjectors.values())null!==e&&e.destroy()}finally{this.cachedInjectors.clear()}}}return t.\u0275prov=We({token:t,providedIn:"environment",factory:()=>new t(Ge(Di))}),t})();function ok(t){t.getStandaloneInjector=n=>n.get(xj).getOrCreateStandaloneInjector(t)}function _d(t,n,e,r){return function pk(t,n,e,r,s,o){const i=n+e;return Vr(t,i,s)?qo(t,i+1,o?r.call(o,s):r(s)):Sd(t,i+1)}(ee(),Jr(),t,n,e,r)}function tm(t,n,e,r,s){return function fk(t,n,e,r,s,o,i){const a=n+e;return el(t,a,s,o)?qo(t,a+2,i?r.call(i,s,o):r(s,o)):Sd(t,a+2)}(ee(),Jr(),t,n,e,r,s)}function hk(t,n,e,r,s,o,i){return function gk(t,n,e,r,s,o,i,a,l){const u=n+e;return function Ys(t,n,e,r,s,o){const i=el(t,n,e,r);return el(t,n+2,s,o)||i}(t,u,s,o,i,a)?qo(t,u+4,l?r.call(l,s,o,i,a):r(s,o,i,a)):Sd(t,u+4)}(ee(),Jr(),t,n,e,r,s,o,i)}function Sd(t,n){const e=t[n];return e===at?void 0:e}function Qx(t){return n=>{setTimeout(t,void 0,n)}}const _t=class Wj extends yi{constructor(n=!1){super(),this.__isAsync=n}emit(n){super.next(n)}subscribe(n,e,r){let s=n,o=e||(()=>null),i=r;if(n&&"object"==typeof n){const l=n;s=l.next?.bind(l),o=l.error?.bind(l),i=l.complete?.bind(l)}this.__isAsync&&(o=Qx(o),s&&(s=Qx(s)),i&&(i=Qx(i)));const a=super.subscribe({next:s,error:o,complete:i});return n instanceof O&&n.add(a),a}};function Gj(){return this._results[Symbol.iterator]()}class Jx{get changes(){return this._changes||(this._changes=new _t)}constructor(n=!1){this._emitDistinctChangesOnly=n,this.dirty=!0,this._results=[],this._changesDetected=!1,this._changes=null,this.length=0,this.first=void 0,this.last=void 0;const e=Jx.prototype;e[Symbol.iterator]||(e[Symbol.iterator]=Gj)}get(n){return this._results[n]}map(n){return this._results.map(n)}filter(n){return this._results.filter(n)}find(n){return this._results.find(n)}reduce(n,e){return this._results.reduce(n,e)}forEach(n){this._results.forEach(n)}some(n){return this._results.some(n)}toArray(){return this._results.slice()}toString(){return this._results.toString()}reset(n,e){const r=this;r.dirty=!1;const s=function Xs(t){return t.flat(Number.POSITIVE_INFINITY)}(n);(this._changesDetected=!function aU(t,n,e){if(t.length!==n.length)return!1;for(let r=0;r<t.length;r++){let s=t[r],o=n[r];if(e&&(s=e(s),o=e(o)),o!==s)return!1}return!0}(r._results,s,e))&&(r._results=s,r.length=s.length,r.last=s[this.length-1],r.first=s[0])}notifyOnChanges(){this._changes&&(this._changesDetected||!this._emitDistinctChangesOnly)&&this._changes.emit(this)}setDirty(){this.dirty=!0}destroy(){this.changes.complete(),this.changes.unsubscribe()}}let ki=(()=>{class t{}return t.__NG_ELEMENT_ID__=qj,t})();const Hj=ki,jj=class extends Hj{constructor(n,e,r){super(),this._declarationLView=n,this._declarationTContainer=e,this.elementRef=r}createEmbeddedView(n,e){const r=this._declarationTContainer.tView,s=Vf(this._declarationLView,r,n,16,null,r.declTNode,null,null,null,null,e||null);s[jc]=this._declarationLView[this._declarationTContainer.index];const i=this._declarationLView[Wo];return null!==i&&(s[Wo]=i.createEmbeddedView(r)),vx(r,s,n),new pd(s)}};function qj(){return nm(Ir(),ee())}function nm(t,n){return 4&t.type?new jj(n,t,bu(t,n)):null}let Qs=(()=>{class t{}return t.__NG_ELEMENT_ID__=Kj,t})();function Kj(){return xk(Ir(),ee())}const Xj=Qs,bk=class extends Xj{constructor(n,e,r){super(),this._lContainer=n,this._hostTNode=e,this._hostLView=r}get element(){return bu(this._hostTNode,this._hostLView)}get injector(){return new au(this._hostTNode,this._hostLView)}get parentInjector(){const n=Sv(this._hostTNode,this._hostLView);if(wD(n)){const e=xf(n,this._hostLView),r=vf(n);return new au(e[De].data[r+8],e)}return new au(null,this._hostLView)}clear(){for(;this.length>0;)this.remove(this.length-1)}get(n){const e=vk(this._lContainer);return null!==e&&e[n]||null}get length(){return this._lContainer.length-Qr}createEmbeddedView(n,e,r){let s,o;"number"==typeof r?s=r:null!=r&&(s=r.index,o=r.injector);const i=n.createEmbeddedView(e||{},o);return this.insert(i,s),i}createComponent(n,e,r,s,o){const i=n&&!function Jc(t){return"function"==typeof t}(n);let a;if(i)a=e;else{const d=e||{};a=d.index,r=d.injector,s=d.projectableNodes,o=d.environmentInjector||d.ngModuleRef}const l=i?n:new fd(jt(n)),u=r||this.parentInjector;if(!o&&null==l.ngModule){const h=(i?u:this.parentInjector).get(Di,null);h&&(o=h)}const c=l.create(u,s,void 0,o);return this.insert(c.hostView,a),c}insert(n,e){const r=n._lView,s=r[De];if(function kz(t){return yo(t[An])}(r)){const c=this.indexOf(n);if(-1!==c)this.detach(c);else{const d=r[An],h=new bk(d,d[Pr],d[An]);h.detach(h.indexOf(n))}}const o=this._adjustIndex(e),i=this._lContainer;!function XU(t,n,e,r){const s=Qr+r,o=e.length;r>0&&(e[s-1][go]=n),r<o-Qr?(n[go]=e[s],FD(e,Qr+r,n)):(e.push(n),n[go]=null),n[An]=e;const i=n[jc];null!==i&&e!==i&&function YU(t,n){const e=t[ru];n[Or]!==n[An][An][Or]&&(t[K1]=!0),null===e?t[ru]=[n]:e.push(n)}(i,n);const a=n[Wo];null!==a&&a.insertView(t),n[ht]|=64}(s,r,i,o);const a=qv(o,i),l=r[yt],u=Nf(l,i[df]);return null!==u&&function jU(t,n,e,r,s,o){r[Ci]=s,r[Pr]=n,ad(t,r,e,1,s,o)}(s,i[Pr],l,r,u,a),n.attachToViewContainerRef(),FD(ew(i),o,n),n}move(n,e){return this.insert(n,e)}indexOf(n){const e=vk(this._lContainer);return null!==e?e.indexOf(n):-1}remove(n){const e=this._adjustIndex(n,-1),r=Gv(this._lContainer,e);r&&(If(ew(this._lContainer),e),rT(r[De],r))}detach(n){const e=this._adjustIndex(n,-1),r=Gv(this._lContainer,e);return r&&null!=If(ew(this._lContainer),e)?new pd(r):null}_adjustIndex(n,e=0){return n??this.length+e}};function vk(t){return t[hf]}function ew(t){return t[hf]||(t[hf]=[])}function xk(t,n){let e;const r=n[t.index];if(yo(r))e=r;else{let s;if(8&t.type)s=Sr(r);else{const o=n[yt];s=o.createComment("");const i=Ns(t,n);Qa(o,Nf(o,i),s,function e4(t,n){return t.nextSibling(n)}(o,i),!1)}n[t.index]=e=yE(r,n,s,t),zf(n,e)}return new bk(e,t,n)}class tw{constructor(n){this.queryList=n,this.matches=null}clone(){return new tw(this.queryList)}setDirty(){this.queryList.setDirty()}}class nw{constructor(n=[]){this.queries=n}createEmbeddedView(n){const e=n.queries;if(null!==e){const r=null!==n.contentQueries?n.contentQueries[0]:e.length,s=[];for(let o=0;o<r;o++){const i=e.getByIndex(o);s.push(this.queries[i.indexInDeclarationView].clone())}return new nw(s)}return null}insertView(n){this.dirtyQueriesWithMatches(n)}detachView(n){this.dirtyQueriesWithMatches(n)}dirtyQueriesWithMatches(n){for(let e=0;e<this.queries.length;e++)null!==Dk(n,e).matches&&this.queries[e].setDirty()}}class wk{constructor(n,e,r=null){this.predicate=n,this.flags=e,this.read=r}}class rw{constructor(n=[]){this.queries=n}elementStart(n,e){for(let r=0;r<this.queries.length;r++)this.queries[r].elementStart(n,e)}elementEnd(n){for(let e=0;e<this.queries.length;e++)this.queries[e].elementEnd(n)}embeddedTView(n){let e=null;for(let r=0;r<this.length;r++){const s=null!==e?e.length:0,o=this.getByIndex(r).embeddedTView(n,s);o&&(o.indexInDeclarationView=r,null!==e?e.push(o):e=[o])}return null!==e?new rw(e):null}template(n,e){for(let r=0;r<this.queries.length;r++)this.queries[r].template(n,e)}getByIndex(n){return this.queries[n]}get length(){return this.queries.length}track(n){this.queries.push(n)}}class sw{constructor(n,e=-1){this.metadata=n,this.matches=null,this.indexInDeclarationView=-1,this.crossesNgTemplate=!1,this._appliesToNextNode=!0,this._declarationNodeIndex=e}elementStart(n,e){this.isApplyingToNode(e)&&this.matchTNode(n,e)}elementEnd(n){this._declarationNodeIndex===n.index&&(this._appliesToNextNode=!1)}template(n,e){this.elementStart(n,e)}embeddedTView(n,e){return this.isApplyingToNode(n)?(this.crossesNgTemplate=!0,this.addMatch(-n.index,e),new sw(this.metadata)):null}isApplyingToNode(n){if(this._appliesToNextNode&&1!=(1&this.metadata.flags)){const e=this._declarationNodeIndex;let r=n.parent;for(;null!==r&&8&r.type&&r.index!==e;)r=r.parent;return e===(null!==r?r.index:-1)}return this._appliesToNextNode}matchTNode(n,e){const r=this.metadata.predicate;if(Array.isArray(r))for(let s=0;s<r.length;s++){const o=r[s];this.matchTNodeWithReadOption(n,e,Yj(e,o)),this.matchTNodeWithReadOption(n,e,_f(e,n,o,!1,!1))}else r===ki?4&e.type&&this.matchTNodeWithReadOption(n,e,-1):this.matchTNodeWithReadOption(n,e,_f(e,n,r,!1,!1))}matchTNodeWithReadOption(n,e,r){if(null!==r){const s=this.metadata.read;if(null!==s)if(s===Lr||s===Qs||s===ki&&4&e.type)this.addMatch(e.index,-2);else{const o=_f(e,n,s,!1,!1);null!==o&&this.addMatch(e.index,o)}else this.addMatch(e.index,r)}}addMatch(n,e){null===this.matches?this.matches=[n,e]:this.matches.push(n,e)}}function Yj(t,n){const e=t.localNames;if(null!==e)for(let r=0;r<e.length;r+=2)if(e[r]===n)return e[r+1];return null}function Qj(t,n,e,r){return-1===e?function Zj(t,n){return 11&t.type?bu(t,n):4&t.type?nm(t,n):null}(n,t):-2===e?function Jj(t,n,e){return e===Lr?bu(n,t):e===ki?nm(n,t):e===Qs?xk(n,t):void 0}(t,n,r):Ya(t,t[De],e,n)}function Ck(t,n,e,r){const s=n[Wo].queries[r];if(null===s.matches){const o=t.data,i=e.matches,a=[];for(let l=0;l<i.length;l+=2){const u=i[l];a.push(u<0?null:Qj(n,o[u],i[l+1],e.metadata.read))}s.matches=a}return s.matches}function ow(t,n,e,r){const s=t.queries.getByIndex(e),o=s.matches;if(null!==o){const i=Ck(t,n,s,e);for(let a=0;a<o.length;a+=2){const l=o[a];if(l>0)r.push(i[a/2]);else{const u=o[a+1],c=n[-l];for(let d=Qr;d<c.length;d++){const h=c[d];h[jc]===h[An]&&ow(h[De],h,u,r)}if(null!==c[ru]){const d=c[ru];for(let h=0;h<d.length;h++){const p=d[h];ow(p[De],p,u,r)}}}}}return r}function il(t){const n=ee(),e=Pt(),r=cD();gv(r+1);const s=Dk(e,r);if(t.dirty&&function Nz(t){return 4==(4&t[ht])}(n)===(2==(2&s.metadata.flags))){if(null===s.matches)t.reset([]);else{const o=s.crossesNgTemplate?ow(e,n,r,[]):Ck(e,n,s,r);t.reset(o,G4),t.notifyOnChanges()}return!0}return!1}function Ou(t,n,e){const r=Pt();r.firstCreatePass&&(function Ik(t,n,e){null===t.queries&&(t.queries=new rw),t.queries.track(new sw(n,e))}(r,new wk(t,n,e),-1),2==(2&n)&&(r.staticViewQueries=!0)),function Sk(t,n,e){const r=new Jx(4==(4&e));dE(t,n,r,r.destroy),null===n[Wo]&&(n[Wo]=new nw),n[Wo].queries.push(new tw(r))}(r,ee(),n)}function al(){return function eq(t,n){return t[Wo].queries[n].queryList}(ee(),cD())}function Dk(t,n){return t.queries.getByIndex(n)}function sm(...t){}const om=new Le("Application Initializer");let im=(()=>{class t{constructor(e){this.appInits=e,this.resolve=sm,this.reject=sm,this.initialized=!1,this.done=!1,this.donePromise=new Promise((r,s)=>{this.resolve=r,this.reject=s})}runInitializers(){if(this.initialized)return;const e=[],r=()=>{this.done=!0,this.resolve()};if(this.appInits)for(let s=0;s<this.appInits.length;s++){const o=this.appInits[s]();if(gd(o))e.push(o);else if(Lx(o)){const i=new Promise((a,l)=>{o.subscribe({complete:a,error:l})});e.push(i)}}Promise.all(e).then(()=>{r()}).catch(s=>{this.reject(s)}),0===e.length&&r(),this.initialized=!0}}return t.\u0275fac=function(e){return new(e||t)(Ge(om,8))},t.\u0275prov=We({token:t,factory:t.\u0275fac,providedIn:"root"}),t})();const Td=new Le("AppId",{providedIn:"root",factory:function Gk(){return`${dw()}${dw()}${dw()}`}});function dw(){return String.fromCharCode(97+Math.floor(25*Math.random()))}const Hk=new Le("Platform Initializer"),hw=new Le("Platform ID",{providedIn:"platform",factory:()=>"unknown"});let Cq=(()=>{class t{log(e){console.log(e)}warn(e){console.warn(e)}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=We({token:t,factory:t.\u0275fac,providedIn:"platform"}),t})();const Ai=new Le("LocaleId",{providedIn:"root",factory:()=>kt(Ai,Ye.Optional|Ye.SkipSelf)||function _q(){return typeof $localize<"u"&&$localize.locale||Mu}()});class Iq{constructor(n,e){this.ngModuleFactory=n,this.componentFactories=e}}let jk=(()=>{class t{compileModuleSync(e){return new Yx(e)}compileModuleAsync(e){return Promise.resolve(this.compileModuleSync(e))}compileModuleAndAllComponentsSync(e){const r=this.compileModuleSync(e),o=Ei(Ds(e).declarations).reduce((i,a)=>{const l=jt(a);return l&&i.push(new fd(l)),i},[]);return new Iq(r,o)}compileModuleAndAllComponentsAsync(e){return Promise.resolve(this.compileModuleAndAllComponentsSync(e))}clearCache(){}clearCacheFor(e){}getModuleId(e){}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=We({token:t,factory:t.\u0275fac,providedIn:"root"}),t})();const Eq=(()=>Promise.resolve(0))();function pw(t){typeof Zone>"u"?Eq.then(()=>{t&&t.apply(null,null)}):Zone.current.scheduleMicroTask("scheduleMicrotask",t)}class Fn{constructor({enableLongStackTrace:n=!1,shouldCoalesceEventChangeDetection:e=!1,shouldCoalesceRunChangeDetection:r=!1}){if(this.hasPendingMacrotasks=!1,this.hasPendingMicrotasks=!1,this.isStable=!0,this.onUnstable=new _t(!1),this.onMicrotaskEmpty=new _t(!1),this.onStable=new _t(!1),this.onError=new _t(!1),typeof Zone>"u")throw new ce(908,!1);Zone.assertZonePatched();const s=this;s._nesting=0,s._outer=s._inner=Zone.current,Zone.TaskTrackingZoneSpec&&(s._inner=s._inner.fork(new Zone.TaskTrackingZoneSpec)),n&&Zone.longStackTraceZoneSpec&&(s._inner=s._inner.fork(Zone.longStackTraceZoneSpec)),s.shouldCoalesceEventChangeDetection=!r&&e,s.shouldCoalesceRunChangeDetection=r,s.lastRequestAnimationFrameId=-1,s.nativeRequestAnimationFrame=function Nq(){let t=pn.requestAnimationFrame,n=pn.cancelAnimationFrame;if(typeof Zone<"u"&&t&&n){const e=t[Zone.__symbol__("OriginalDelegate")];e&&(t=e);const r=n[Zone.__symbol__("OriginalDelegate")];r&&(n=r)}return{nativeRequestAnimationFrame:t,nativeCancelAnimationFrame:n}}().nativeRequestAnimationFrame,function Rq(t){const n=()=>{!function Aq(t){t.isCheckStableRunning||-1!==t.lastRequestAnimationFrameId||(t.lastRequestAnimationFrameId=t.nativeRequestAnimationFrame.call(pn,()=>{t.fakeTopEventTask||(t.fakeTopEventTask=Zone.root.scheduleEventTask("fakeTopEventTask",()=>{t.lastRequestAnimationFrameId=-1,mw(t),t.isCheckStableRunning=!0,fw(t),t.isCheckStableRunning=!1},void 0,()=>{},()=>{})),t.fakeTopEventTask.invoke()}),mw(t))}(t)};t._inner=t._inner.fork({name:"angular",properties:{isAngularZone:!0},onInvokeTask:(e,r,s,o,i,a)=>{try{return Xk(t),e.invokeTask(s,o,i,a)}finally{(t.shouldCoalesceEventChangeDetection&&"eventTask"===o.type||t.shouldCoalesceRunChangeDetection)&&n(),Yk(t)}},onInvoke:(e,r,s,o,i,a,l)=>{try{return Xk(t),e.invoke(s,o,i,a,l)}finally{t.shouldCoalesceRunChangeDetection&&n(),Yk(t)}},onHasTask:(e,r,s,o)=>{e.hasTask(s,o),r===s&&("microTask"==o.change?(t._hasPendingMicrotasks=o.microTask,mw(t),fw(t)):"macroTask"==o.change&&(t.hasPendingMacrotasks=o.macroTask))},onHandleError:(e,r,s,o)=>(e.handleError(s,o),t.runOutsideAngular(()=>t.onError.emit(o)),!1)})}(s)}static isInAngularZone(){return typeof Zone<"u"&&!0===Zone.current.get("isAngularZone")}static assertInAngularZone(){if(!Fn.isInAngularZone())throw new ce(909,!1)}static assertNotInAngularZone(){if(Fn.isInAngularZone())throw new ce(909,!1)}run(n,e,r){return this._inner.run(n,e,r)}runTask(n,e,r,s){const o=this._inner,i=o.scheduleEventTask("NgZoneEvent: "+s,n,kq,sm,sm);try{return o.runTask(i,e,r)}finally{o.cancelTask(i)}}runGuarded(n,e,r){return this._inner.runGuarded(n,e,r)}runOutsideAngular(n){return this._outer.run(n)}}const kq={};function fw(t){if(0==t._nesting&&!t.hasPendingMicrotasks&&!t.isStable)try{t._nesting++,t.onMicrotaskEmpty.emit(null)}finally{if(t._nesting--,!t.hasPendingMicrotasks)try{t.runOutsideAngular(()=>t.onStable.emit(null))}finally{t.isStable=!0}}}function mw(t){t.hasPendingMicrotasks=!!(t._hasPendingMicrotasks||(t.shouldCoalesceEventChangeDetection||t.shouldCoalesceRunChangeDetection)&&-1!==t.lastRequestAnimationFrameId)}function Xk(t){t._nesting++,t.isStable&&(t.isStable=!1,t.onUnstable.emit(null))}function Yk(t){t._nesting--,fw(t)}class Fq{constructor(){this.hasPendingMicrotasks=!1,this.hasPendingMacrotasks=!1,this.isStable=!0,this.onUnstable=new _t,this.onMicrotaskEmpty=new _t,this.onStable=new _t,this.onError=new _t}run(n,e,r){return n.apply(e,r)}runGuarded(n,e,r){return n.apply(e,r)}runOutsideAngular(n){return n()}runTask(n,e,r,s){return n.apply(e,r)}}const Zk=new Le(""),am=new Le("");let bw,gw=(()=>{class t{constructor(e,r,s){this._ngZone=e,this.registry=r,this._pendingCount=0,this._isZoneStable=!0,this._didWork=!1,this._callbacks=[],this.taskTrackingZone=null,bw||(function Mq(t){bw=t}(s),s.addToWindow(r)),this._watchAngularEvents(),e.run(()=>{this.taskTrackingZone=typeof Zone>"u"?null:Zone.current.get("TaskTrackingZone")})}_watchAngularEvents(){this._ngZone.onUnstable.subscribe({next:()=>{this._didWork=!0,this._isZoneStable=!1}}),this._ngZone.runOutsideAngular(()=>{this._ngZone.onStable.subscribe({next:()=>{Fn.assertNotInAngularZone(),pw(()=>{this._isZoneStable=!0,this._runCallbacksIfReady()})}})})}increasePendingRequestCount(){return this._pendingCount+=1,this._didWork=!0,this._pendingCount}decreasePendingRequestCount(){if(this._pendingCount-=1,this._pendingCount<0)throw new Error("pending async requests below zero");return this._runCallbacksIfReady(),this._pendingCount}isStable(){return this._isZoneStable&&0===this._pendingCount&&!this._ngZone.hasPendingMacrotasks}_runCallbacksIfReady(){if(this.isStable())pw(()=>{for(;0!==this._callbacks.length;){let e=this._callbacks.pop();clearTimeout(e.timeoutId),e.doneCb(this._didWork)}this._didWork=!1});else{let e=this.getPendingTasks();this._callbacks=this._callbacks.filter(r=>!r.updateCb||!r.updateCb(e)||(clearTimeout(r.timeoutId),!1)),this._didWork=!0}}getPendingTasks(){return this.taskTrackingZone?this.taskTrackingZone.macroTasks.map(e=>({source:e.source,creationLocation:e.creationLocation,data:e.data})):[]}addCallback(e,r,s){let o=-1;r&&r>0&&(o=setTimeout(()=>{this._callbacks=this._callbacks.filter(i=>i.timeoutId!==o),e(this._didWork,this.getPendingTasks())},r)),this._callbacks.push({doneCb:e,timeoutId:o,updateCb:s})}whenStable(e,r,s){if(s&&!this.taskTrackingZone)throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?');this.addCallback(e,r,s),this._runCallbacksIfReady()}getPendingRequestCount(){return this._pendingCount}registerApplication(e){this.registry.registerApplication(e,this)}unregisterApplication(e){this.registry.unregisterApplication(e)}findProviders(e,r,s){return[]}}return t.\u0275fac=function(e){return new(e||t)(Ge(Fn),Ge(yw),Ge(am))},t.\u0275prov=We({token:t,factory:t.\u0275fac}),t})(),yw=(()=>{class t{constructor(){this._applications=new Map}registerApplication(e,r){this._applications.set(e,r)}unregisterApplication(e){this._applications.delete(e)}unregisterAllApplications(){this._applications.clear()}getTestability(e){return this._applications.get(e)||null}getAllTestabilities(){return Array.from(this._applications.values())}getAllRootElements(){return Array.from(this._applications.keys())}findTestabilityInTree(e,r=!0){return bw?.findTestabilityInTree(this,e,r)??null}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=We({token:t,factory:t.\u0275fac,providedIn:"platform"}),t})();const Ri=!1;let ta=null;const Qk=new Le("AllowMultipleToken"),vw=new Le("PlatformDestroyListeners"),Jk=new Le("appBootstrapListener");class eA{constructor(n,e){this.name=n,this.token=e}}function nA(t,n,e=[]){const r=`Platform: ${n}`,s=new Le(r);return(o=[])=>{let i=xw();if(!i||i.injector.get(Qk,!1)){const a=[...e,...o,{provide:s,useValue:!0}];t?t(a):function $q(t){if(ta&&!ta.get(Qk,!1))throw new ce(400,!1);ta=t;const n=t.get(sA);(function tA(t){const n=t.get(Hk,null);n&&n.forEach(e=>e())})(t)}(function rA(t=[],n){return ts.create({name:n,providers:[{provide:ix,useValue:"platform"},{provide:vw,useValue:new Set([()=>ta=null])},...t]})}(a,r))}return function Vq(t){const n=xw();if(!n)throw new ce(401,!1);return n}()}}function xw(){return ta?.get(sA)??null}let sA=(()=>{class t{constructor(e){this._injector=e,this._modules=[],this._destroyListeners=[],this._destroyed=!1}bootstrapModuleFactory(e,r){const s=function iA(t,n){let e;return e="noop"===t?new Fq:("zone.js"===t?void 0:t)||new Fn(n),e}(r?.ngZone,function oA(t){return{enableLongStackTrace:!1,shouldCoalesceEventChangeDetection:!(!t||!t.ngZoneEventCoalescing)||!1,shouldCoalesceRunChangeDetection:!(!t||!t.ngZoneRunCoalescing)||!1}}(r)),o=[{provide:Fn,useValue:s}];return s.run(()=>{const i=ts.create({providers:o,parent:this.injector,name:e.moduleType.name}),a=e.create(i),l=a.injector.get(vu,null);if(!l)throw new ce(402,!1);return s.runOutsideAngular(()=>{const u=s.onError.subscribe({next:c=>{l.handleError(c)}});a.onDestroy(()=>{lm(this._modules,a),u.unsubscribe()})}),function aA(t,n,e){try{const r=e();return gd(r)?r.catch(s=>{throw n.runOutsideAngular(()=>t.handleError(s)),s}):r}catch(r){throw n.runOutsideAngular(()=>t.handleError(r)),r}}(l,s,()=>{const u=a.injector.get(im);return u.runInitializers(),u.donePromise.then(()=>(function RN(t){Hs(t,"Expected localeId to be defined"),"string"==typeof t&&(AN=t.toLowerCase().replace(/_/g,"-"))}(a.injector.get(Ai,Mu)||Mu),this._moduleDoBootstrap(a),a))})})}bootstrapModule(e,r=[]){const s=lA({},r);return function Pq(t,n,e){const r=new Yx(e);return Promise.resolve(r)}(0,0,e).then(o=>this.bootstrapModuleFactory(o,s))}_moduleDoBootstrap(e){const r=e.injector.get(Ed);if(e._bootstrapComponents.length>0)e._bootstrapComponents.forEach(s=>r.bootstrap(s));else{if(!e.instance.ngDoBootstrap)throw new ce(-403,!1);e.instance.ngDoBootstrap(r)}this._modules.push(e)}onDestroy(e){this._destroyListeners.push(e)}get injector(){return this._injector}destroy(){if(this._destroyed)throw new ce(404,!1);this._modules.slice().forEach(r=>r.destroy()),this._destroyListeners.forEach(r=>r());const e=this._injector.get(vw,null);e&&(e.forEach(r=>r()),e.clear()),this._destroyed=!0}get destroyed(){return this._destroyed}}return t.\u0275fac=function(e){return new(e||t)(Ge(ts))},t.\u0275prov=We({token:t,factory:t.\u0275fac,providedIn:"platform"}),t})();function lA(t,n){return Array.isArray(n)?n.reduce(lA,t):{...t,...n}}let Ed=(()=>{class t{get destroyed(){return this._destroyed}get injector(){return this._injector}constructor(e,r,s){this._zone=e,this._injector=r,this._exceptionHandler=s,this._bootstrapListeners=[],this._views=[],this._runningTick=!1,this._stable=!0,this._destroyed=!1,this._destroyListeners=[],this.componentTypes=[],this.components=[],this._onMicrotaskEmptySubscription=this._zone.onMicrotaskEmpty.subscribe({next:()=>{this._zone.run(()=>{this.tick()})}});const o=new xt(a=>{this._stable=this._zone.isStable&&!this._zone.hasPendingMacrotasks&&!this._zone.hasPendingMicrotasks,this._zone.runOutsideAngular(()=>{a.next(this._stable),a.complete()})}),i=new xt(a=>{let l;this._zone.runOutsideAngular(()=>{l=this._zone.onStable.subscribe(()=>{Fn.assertNotInAngularZone(),pw(()=>{!this._stable&&!this._zone.hasPendingMacrotasks&&!this._zone.hasPendingMicrotasks&&(this._stable=!0,a.next(!0))})})});const u=this._zone.onUnstable.subscribe(()=>{Fn.assertInAngularZone(),this._stable&&(this._stable=!1,this._zone.runOutsideAngular(()=>{a.next(!1)}))});return()=>{l.unsubscribe(),u.unsubscribe()}});this.isStable=function KB(...t){const n=Bc(t),e=function zB(t,n){return"number"==typeof Xb(t)?t.pop():n}(t,1/0),r=t;return r.length?1===r.length?Gs(r[0]):Zl(e)(Kn(r,n)):Bo}(o,i.pipe(function XB(t={}){const{connector:n=(()=>new yi),resetOnError:e=!0,resetOnComplete:r=!0,resetOnRefCountZero:s=!0}=t;return o=>{let i,a,l,u=0,c=!1,d=!1;const h=()=>{a?.unsubscribe(),a=void 0},p=()=>{h(),i=l=void 0,c=d=!1},f=()=>{const g=i;p(),g?.unsubscribe()};return yr((g,m)=>{u++,!d&&!c&&h();const y=l=l??n();m.add(()=>{u--,0===u&&!d&&!c&&(a=Yb(f,s))}),y.subscribe(m),!i&&u>0&&(i=new Ue({next:b=>y.next(b),error:b=>{d=!0,h(),a=Yb(p,e,b),y.error(b)},complete:()=>{c=!0,h(),a=Yb(p,r),y.complete()}}),Gs(g).subscribe(i))})(o)}}()))}bootstrap(e,r){const s=e instanceof VT;if(!this._injector.get(im).done){!s&&function Jl(t){const n=jt(t)||Mr(t)||hs(t);return null!==n&&n.standalone}(e);throw new ce(405,Ri)}let i;i=s?e:this._injector.get(yu).resolveComponentFactory(e),this.componentTypes.push(i.componentType);const a=function Oq(t){return t.isBoundToModule}(i)?void 0:this._injector.get(Pu),u=i.create(ts.NULL,[],r||i.selector,a),c=u.location.nativeElement,d=u.injector.get(Zk,null);return d?.registerApplication(c),u.onDestroy(()=>{this.detachView(u.hostView),lm(this.components,u),d?.unregisterApplication(c)}),this._loadComponent(u),u}tick(){if(this._runningTick)throw new ce(101,!1);try{this._runningTick=!0;for(let e of this._views)e.detectChanges()}catch(e){this._zone.runOutsideAngular(()=>this._exceptionHandler.handleError(e))}finally{this._runningTick=!1}}attachView(e){const r=e;this._views.push(r),r.attachToAppRef(this)}detachView(e){const r=e;lm(this._views,r),r.detachFromAppRef()}_loadComponent(e){this.attachView(e.hostView),this.tick(),this.components.push(e);const r=this._injector.get(Jk,[]);r.push(...this._bootstrapListeners),r.forEach(s=>s(e))}ngOnDestroy(){if(!this._destroyed)try{this._destroyListeners.forEach(e=>e()),this._views.slice().forEach(e=>e.destroy()),this._onMicrotaskEmptySubscription.unsubscribe()}finally{this._destroyed=!0,this._views=[],this._bootstrapListeners=[],this._destroyListeners=[]}}onDestroy(e){return this._destroyListeners.push(e),()=>lm(this._destroyListeners,e)}destroy(){if(this._destroyed)throw new ce(406,!1);const e=this._injector;e.destroy&&!e.destroyed&&e.destroy()}get viewCount(){return this._views.length}warnIfDestroyed(){}}return t.\u0275fac=function(e){return new(e||t)(Ge(Fn),Ge(Di),Ge(vu))},t.\u0275prov=We({token:t,factory:t.\u0275fac,providedIn:"root"}),t})();function lm(t,n){const e=t.indexOf(n);e>-1&&t.splice(e,1)}let Nd=(()=>{class t{}return t.__NG_ELEMENT_ID__=zq,t})();function zq(t){return function Uq(t,n,e){if(Kc(t)&&!e){const r=ks(t.index,n);return new pd(r,r)}return 47&t.type?new pd(n[Or],n):null}(Ir(),ee(),16==(16&t))}class pA{constructor(){}supports(n){return Hf(n)}create(n){return new Kq(n)}}const qq=(t,n)=>n;class Kq{constructor(n){this.length=0,this._linkedRecords=null,this._unlinkedRecords=null,this._previousItHead=null,this._itHead=null,this._itTail=null,this._additionsHead=null,this._additionsTail=null,this._movesHead=null,this._movesTail=null,this._removalsHead=null,this._removalsTail=null,this._identityChangesHead=null,this._identityChangesTail=null,this._trackByFn=n||qq}forEachItem(n){let e;for(e=this._itHead;null!==e;e=e._next)n(e)}forEachOperation(n){let e=this._itHead,r=this._removalsHead,s=0,o=null;for(;e||r;){const i=!r||e&&e.currentIndex<mA(r,s,o)?e:r,a=mA(i,s,o),l=i.currentIndex;if(i===r)s--,r=r._nextRemoved;else if(e=e._next,null==i.previousIndex)s++;else{o||(o=[]);const u=a-s,c=l-s;if(u!=c){for(let h=0;h<u;h++){const p=h<o.length?o[h]:o[h]=0,f=p+h;c<=f&&f<u&&(o[h]=p+1)}o[i.previousIndex]=c-u}}a!==l&&n(i,a,l)}}forEachPreviousItem(n){let e;for(e=this._previousItHead;null!==e;e=e._nextPrevious)n(e)}forEachAddedItem(n){let e;for(e=this._additionsHead;null!==e;e=e._nextAdded)n(e)}forEachMovedItem(n){let e;for(e=this._movesHead;null!==e;e=e._nextMoved)n(e)}forEachRemovedItem(n){let e;for(e=this._removalsHead;null!==e;e=e._nextRemoved)n(e)}forEachIdentityChange(n){let e;for(e=this._identityChangesHead;null!==e;e=e._nextIdentityChange)n(e)}diff(n){if(null==n&&(n=[]),!Hf(n))throw new ce(900,!1);return this.check(n)?this:null}onDestroy(){}check(n){this._reset();let s,o,i,e=this._itHead,r=!1;if(Array.isArray(n)){this.length=n.length;for(let a=0;a<this.length;a++)o=n[a],i=this._trackByFn(a,o),null!==e&&Object.is(e.trackById,i)?(r&&(e=this._verifyReinsertion(e,o,i,a)),Object.is(e.item,o)||this._addIdentityChange(e,o)):(e=this._mismatch(e,o,i,a),r=!0),e=e._next}else s=0,function SG(t,n){if(Array.isArray(t))for(let e=0;e<t.length;e++)n(t[e]);else{const e=t[Symbol.iterator]();let r;for(;!(r=e.next()).done;)n(r.value)}}(n,a=>{i=this._trackByFn(s,a),null!==e&&Object.is(e.trackById,i)?(r&&(e=this._verifyReinsertion(e,a,i,s)),Object.is(e.item,a)||this._addIdentityChange(e,a)):(e=this._mismatch(e,a,i,s),r=!0),e=e._next,s++}),this.length=s;return this._truncate(e),this.collection=n,this.isDirty}get isDirty(){return null!==this._additionsHead||null!==this._movesHead||null!==this._removalsHead||null!==this._identityChangesHead}_reset(){if(this.isDirty){let n;for(n=this._previousItHead=this._itHead;null!==n;n=n._next)n._nextPrevious=n._next;for(n=this._additionsHead;null!==n;n=n._nextAdded)n.previousIndex=n.currentIndex;for(this._additionsHead=this._additionsTail=null,n=this._movesHead;null!==n;n=n._nextMoved)n.previousIndex=n.currentIndex;this._movesHead=this._movesTail=null,this._removalsHead=this._removalsTail=null,this._identityChangesHead=this._identityChangesTail=null}}_mismatch(n,e,r,s){let o;return null===n?o=this._itTail:(o=n._prev,this._remove(n)),null!==(n=null===this._unlinkedRecords?null:this._unlinkedRecords.get(r,null))?(Object.is(n.item,e)||this._addIdentityChange(n,e),this._reinsertAfter(n,o,s)):null!==(n=null===this._linkedRecords?null:this._linkedRecords.get(r,s))?(Object.is(n.item,e)||this._addIdentityChange(n,e),this._moveAfter(n,o,s)):n=this._addAfter(new Xq(e,r),o,s),n}_verifyReinsertion(n,e,r,s){let o=null===this._unlinkedRecords?null:this._unlinkedRecords.get(r,null);return null!==o?n=this._reinsertAfter(o,n._prev,s):n.currentIndex!=s&&(n.currentIndex=s,this._addToMoves(n,s)),n}_truncate(n){for(;null!==n;){const e=n._next;this._addToRemovals(this._unlink(n)),n=e}null!==this._unlinkedRecords&&this._unlinkedRecords.clear(),null!==this._additionsTail&&(this._additionsTail._nextAdded=null),null!==this._movesTail&&(this._movesTail._nextMoved=null),null!==this._itTail&&(this._itTail._next=null),null!==this._removalsTail&&(this._removalsTail._nextRemoved=null),null!==this._identityChangesTail&&(this._identityChangesTail._nextIdentityChange=null)}_reinsertAfter(n,e,r){null!==this._unlinkedRecords&&this._unlinkedRecords.remove(n);const s=n._prevRemoved,o=n._nextRemoved;return null===s?this._removalsHead=o:s._nextRemoved=o,null===o?this._removalsTail=s:o._prevRemoved=s,this._insertAfter(n,e,r),this._addToMoves(n,r),n}_moveAfter(n,e,r){return this._unlink(n),this._insertAfter(n,e,r),this._addToMoves(n,r),n}_addAfter(n,e,r){return this._insertAfter(n,e,r),this._additionsTail=null===this._additionsTail?this._additionsHead=n:this._additionsTail._nextAdded=n,n}_insertAfter(n,e,r){const s=null===e?this._itHead:e._next;return n._next=s,n._prev=e,null===s?this._itTail=n:s._prev=n,null===e?this._itHead=n:e._next=n,null===this._linkedRecords&&(this._linkedRecords=new fA),this._linkedRecords.put(n),n.currentIndex=r,n}_remove(n){return this._addToRemovals(this._unlink(n))}_unlink(n){null!==this._linkedRecords&&this._linkedRecords.remove(n);const e=n._prev,r=n._next;return null===e?this._itHead=r:e._next=r,null===r?this._itTail=e:r._prev=e,n}_addToMoves(n,e){return n.previousIndex===e||(this._movesTail=null===this._movesTail?this._movesHead=n:this._movesTail._nextMoved=n),n}_addToRemovals(n){return null===this._unlinkedRecords&&(this._unlinkedRecords=new fA),this._unlinkedRecords.put(n),n.currentIndex=null,n._nextRemoved=null,null===this._removalsTail?(this._removalsTail=this._removalsHead=n,n._prevRemoved=null):(n._prevRemoved=this._removalsTail,this._removalsTail=this._removalsTail._nextRemoved=n),n}_addIdentityChange(n,e){return n.item=e,this._identityChangesTail=null===this._identityChangesTail?this._identityChangesHead=n:this._identityChangesTail._nextIdentityChange=n,n}}class Xq{constructor(n,e){this.item=n,this.trackById=e,this.currentIndex=null,this.previousIndex=null,this._nextPrevious=null,this._prev=null,this._next=null,this._prevDup=null,this._nextDup=null,this._prevRemoved=null,this._nextRemoved=null,this._nextAdded=null,this._nextMoved=null,this._nextIdentityChange=null}}class Yq{constructor(){this._head=null,this._tail=null}add(n){null===this._head?(this._head=this._tail=n,n._nextDup=null,n._prevDup=null):(this._tail._nextDup=n,n._prevDup=this._tail,n._nextDup=null,this._tail=n)}get(n,e){let r;for(r=this._head;null!==r;r=r._nextDup)if((null===e||e<=r.currentIndex)&&Object.is(r.trackById,n))return r;return null}remove(n){const e=n._prevDup,r=n._nextDup;return null===e?this._head=r:e._nextDup=r,null===r?this._tail=e:r._prevDup=e,null===this._head}}class fA{constructor(){this.map=new Map}put(n){const e=n.trackById;let r=this.map.get(e);r||(r=new Yq,this.map.set(e,r)),r.add(n)}get(n,e){const s=this.map.get(n);return s?s.get(n,e):null}remove(n){const e=n.trackById;return this.map.get(e).remove(n)&&this.map.delete(e),n}get isEmpty(){return 0===this.map.size}clear(){this.map.clear()}}function mA(t,n,e){const r=t.previousIndex;if(null===r)return r;let s=0;return e&&r<e.length&&(s=e[r]),r+n+s}class gA{constructor(){}supports(n){return n instanceof Map||Rx(n)}create(){return new Zq}}class Zq{constructor(){this._records=new Map,this._mapHead=null,this._appendAfter=null,this._previousMapHead=null,this._changesHead=null,this._changesTail=null,this._additionsHead=null,this._additionsTail=null,this._removalsHead=null,this._removalsTail=null}get isDirty(){return null!==this._additionsHead||null!==this._changesHead||null!==this._removalsHead}forEachItem(n){let e;for(e=this._mapHead;null!==e;e=e._next)n(e)}forEachPreviousItem(n){let e;for(e=this._previousMapHead;null!==e;e=e._nextPrevious)n(e)}forEachChangedItem(n){let e;for(e=this._changesHead;null!==e;e=e._nextChanged)n(e)}forEachAddedItem(n){let e;for(e=this._additionsHead;null!==e;e=e._nextAdded)n(e)}forEachRemovedItem(n){let e;for(e=this._removalsHead;null!==e;e=e._nextRemoved)n(e)}diff(n){if(n){if(!(n instanceof Map||Rx(n)))throw new ce(900,!1)}else n=new Map;return this.check(n)?this:null}onDestroy(){}check(n){this._reset();let e=this._mapHead;if(this._appendAfter=null,this._forEach(n,(r,s)=>{if(e&&e.key===s)this._maybeAddToChanges(e,r),this._appendAfter=e,e=e._next;else{const o=this._getOrCreateRecordForKey(s,r);e=this._insertBeforeOrAppend(e,o)}}),e){e._prev&&(e._prev._next=null),this._removalsHead=e;for(let r=e;null!==r;r=r._nextRemoved)r===this._mapHead&&(this._mapHead=null),this._records.delete(r.key),r._nextRemoved=r._next,r.previousValue=r.currentValue,r.currentValue=null,r._prev=null,r._next=null}return this._changesTail&&(this._changesTail._nextChanged=null),this._additionsTail&&(this._additionsTail._nextAdded=null),this.isDirty}_insertBeforeOrAppend(n,e){if(n){const r=n._prev;return e._next=n,e._prev=r,n._prev=e,r&&(r._next=e),n===this._mapHead&&(this._mapHead=e),this._appendAfter=n,n}return this._appendAfter?(this._appendAfter._next=e,e._prev=this._appendAfter):this._mapHead=e,this._appendAfter=e,null}_getOrCreateRecordForKey(n,e){if(this._records.has(n)){const s=this._records.get(n);this._maybeAddToChanges(s,e);const o=s._prev,i=s._next;return o&&(o._next=i),i&&(i._prev=o),s._next=null,s._prev=null,s}const r=new Qq(n);return this._records.set(n,r),r.currentValue=e,this._addToAdditions(r),r}_reset(){if(this.isDirty){let n;for(this._previousMapHead=this._mapHead,n=this._previousMapHead;null!==n;n=n._next)n._nextPrevious=n._next;for(n=this._changesHead;null!==n;n=n._nextChanged)n.previousValue=n.currentValue;for(n=this._additionsHead;null!=n;n=n._nextAdded)n.previousValue=n.currentValue;this._changesHead=this._changesTail=null,this._additionsHead=this._additionsTail=null,this._removalsHead=null}}_maybeAddToChanges(n,e){Object.is(e,n.currentValue)||(n.previousValue=n.currentValue,n.currentValue=e,this._addToChanges(n))}_addToAdditions(n){null===this._additionsHead?this._additionsHead=this._additionsTail=n:(this._additionsTail._nextAdded=n,this._additionsTail=n)}_addToChanges(n){null===this._changesHead?this._changesHead=this._changesTail=n:(this._changesTail._nextChanged=n,this._changesTail=n)}_forEach(n,e){n instanceof Map?n.forEach(e):Object.keys(n).forEach(r=>e(n[r],r))}}class Qq{constructor(n){this.key=n,this.previousValue=null,this.currentValue=null,this._nextPrevious=null,this._next=null,this._prev=null,this._nextAdded=null,this._nextRemoved=null,this._nextChanged=null}}function yA(){return new dm([new pA])}let dm=(()=>{class t{constructor(e){this.factories=e}static create(e,r){if(null!=r){const s=r.factories.slice();e=e.concat(s)}return new t(e)}static extend(e){return{provide:t,useFactory:r=>t.create(e,r||yA()),deps:[[t,new nd,new td]]}}find(e){const r=this.factories.find(s=>s.supports(e));if(null!=r)return r;throw new ce(901,!1)}}return t.\u0275prov=We({token:t,providedIn:"root",factory:yA}),t})();function bA(){return new kd([new gA])}let kd=(()=>{class t{constructor(e){this.factories=e}static create(e,r){if(r){const s=r.factories.slice();e=e.concat(s)}return new t(e)}static extend(e){return{provide:t,useFactory:r=>t.create(e,r||bA()),deps:[[t,new nd,new td]]}}find(e){const r=this.factories.find(s=>s.supports(e));if(r)return r;throw new ce(901,!1)}}return t.\u0275prov=We({token:t,providedIn:"root",factory:bA}),t})();const t6=nA(null,"core",[]);let n6=(()=>{class t{constructor(e){}}return t.\u0275fac=function(e){return new(e||t)(Ge(Ed))},t.\u0275mod=qs({type:t}),t.\u0275inj=Is({}),t})(),Iw=null;function Fi(){return Iw}class o6{}const ss=new Le("DocumentToken");let Dw=(()=>{class t{historyGo(e){throw new Error("Not implemented")}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=We({token:t,factory:function(){return function i6(){return Ge(vA)}()},providedIn:"platform"}),t})();const a6=new Le("Location Initialized");let vA=(()=>{class t extends Dw{constructor(e){super(),this._doc=e,this._location=window.location,this._history=window.history}getBaseHrefFromDOM(){return Fi().getBaseHref(this._doc)}onPopState(e){const r=Fi().getGlobalEventTarget(this._doc,"window");return r.addEventListener("popstate",e,!1),()=>r.removeEventListener("popstate",e)}onHashChange(e){const r=Fi().getGlobalEventTarget(this._doc,"window");return r.addEventListener("hashchange",e,!1),()=>r.removeEventListener("hashchange",e)}get href(){return this._location.href}get protocol(){return this._location.protocol}get hostname(){return this._location.hostname}get port(){return this._location.port}get pathname(){return this._location.pathname}get search(){return this._location.search}get hash(){return this._location.hash}set pathname(e){this._location.pathname=e}pushState(e,r,s){xA()?this._history.pushState(e,r,s):this._location.hash=s}replaceState(e,r,s){xA()?this._history.replaceState(e,r,s):this._location.hash=s}forward(){this._history.forward()}back(){this._history.back()}historyGo(e=0){this._history.go(e)}getState(){return this._history.state}}return t.\u0275fac=function(e){return new(e||t)(Ge(ss))},t.\u0275prov=We({token:t,factory:function(){return function l6(){return new vA(Ge(ss))}()},providedIn:"platform"}),t})();function xA(){return!!window.history.pushState}function Tw(t,n){if(0==t.length)return n;if(0==n.length)return t;let e=0;return t.endsWith("/")&&e++,n.startsWith("/")&&e++,2==e?t+n.substring(1):1==e?t+n:t+"/"+n}function wA(t){const n=t.match(/#|\?|$/),e=n&&n.index||t.length;return t.slice(0,e-("/"===t[e-1]?1:0))+t.slice(e)}function Mi(t){return t&&"?"!==t[0]?"?"+t:t}let ul=(()=>{class t{historyGo(e){throw new Error("Not implemented")}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=We({token:t,factory:function(){return kt(_A)},providedIn:"root"}),t})();const CA=new Le("appBaseHref");let _A=(()=>{class t extends ul{constructor(e,r){super(),this._platformLocation=e,this._removeListenerFns=[],this._baseHref=r??this._platformLocation.getBaseHrefFromDOM()??kt(ss).location?.origin??""}ngOnDestroy(){for(;this._removeListenerFns.length;)this._removeListenerFns.pop()()}onPopState(e){this._removeListenerFns.push(this._platformLocation.onPopState(e),this._platformLocation.onHashChange(e))}getBaseHref(){return this._baseHref}prepareExternalUrl(e){return Tw(this._baseHref,e)}path(e=!1){const r=this._platformLocation.pathname+Mi(this._platformLocation.search),s=this._platformLocation.hash;return s&&e?`${r}${s}`:r}pushState(e,r,s,o){const i=this.prepareExternalUrl(s+Mi(o));this._platformLocation.pushState(e,r,i)}replaceState(e,r,s,o){const i=this.prepareExternalUrl(s+Mi(o));this._platformLocation.replaceState(e,r,i)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}getState(){return this._platformLocation.getState()}historyGo(e=0){this._platformLocation.historyGo?.(e)}}return t.\u0275fac=function(e){return new(e||t)(Ge(Dw),Ge(CA,8))},t.\u0275prov=We({token:t,factory:t.\u0275fac,providedIn:"root"}),t})(),u6=(()=>{class t extends ul{constructor(e,r){super(),this._platformLocation=e,this._baseHref="",this._removeListenerFns=[],null!=r&&(this._baseHref=r)}ngOnDestroy(){for(;this._removeListenerFns.length;)this._removeListenerFns.pop()()}onPopState(e){this._removeListenerFns.push(this._platformLocation.onPopState(e),this._platformLocation.onHashChange(e))}getBaseHref(){return this._baseHref}path(e=!1){let r=this._platformLocation.hash;return null==r&&(r="#"),r.length>0?r.substring(1):r}prepareExternalUrl(e){const r=Tw(this._baseHref,e);return r.length>0?"#"+r:r}pushState(e,r,s,o){let i=this.prepareExternalUrl(s+Mi(o));0==i.length&&(i=this._platformLocation.pathname),this._platformLocation.pushState(e,r,i)}replaceState(e,r,s,o){let i=this.prepareExternalUrl(s+Mi(o));0==i.length&&(i=this._platformLocation.pathname),this._platformLocation.replaceState(e,r,i)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}getState(){return this._platformLocation.getState()}historyGo(e=0){this._platformLocation.historyGo?.(e)}}return t.\u0275fac=function(e){return new(e||t)(Ge(Dw),Ge(CA,8))},t.\u0275prov=We({token:t,factory:t.\u0275fac}),t})(),Ew=(()=>{class t{constructor(e){this._subject=new _t,this._urlChangeListeners=[],this._urlChangeSubscription=null,this._locationStrategy=e;const r=this._locationStrategy.getBaseHref();this._basePath=function h6(t){if(new RegExp("^(https?:)?//").test(t)){const[,e]=t.split(/\/\/[^\/]+/);return e}return t}(wA(SA(r))),this._locationStrategy.onPopState(s=>{this._subject.emit({url:this.path(!0),pop:!0,state:s.state,type:s.type})})}ngOnDestroy(){this._urlChangeSubscription?.unsubscribe(),this._urlChangeListeners=[]}path(e=!1){return this.normalize(this._locationStrategy.path(e))}getState(){return this._locationStrategy.getState()}isCurrentPathEqualTo(e,r=""){return this.path()==this.normalize(e+Mi(r))}normalize(e){return t.stripTrailingSlash(function d6(t,n){if(!t||!n.startsWith(t))return n;const e=n.substring(t.length);return""===e||["/",";","?","#"].includes(e[0])?e:n}(this._basePath,SA(e)))}prepareExternalUrl(e){return e&&"/"!==e[0]&&(e="/"+e),this._locationStrategy.prepareExternalUrl(e)}go(e,r="",s=null){this._locationStrategy.pushState(s,"",e,r),this._notifyUrlChangeListeners(this.prepareExternalUrl(e+Mi(r)),s)}replaceState(e,r="",s=null){this._locationStrategy.replaceState(s,"",e,r),this._notifyUrlChangeListeners(this.prepareExternalUrl(e+Mi(r)),s)}forward(){this._locationStrategy.forward()}back(){this._locationStrategy.back()}historyGo(e=0){this._locationStrategy.historyGo?.(e)}onUrlChange(e){return this._urlChangeListeners.push(e),this._urlChangeSubscription||(this._urlChangeSubscription=this.subscribe(r=>{this._notifyUrlChangeListeners(r.url,r.state)})),()=>{const r=this._urlChangeListeners.indexOf(e);this._urlChangeListeners.splice(r,1),0===this._urlChangeListeners.length&&(this._urlChangeSubscription?.unsubscribe(),this._urlChangeSubscription=null)}}_notifyUrlChangeListeners(e="",r){this._urlChangeListeners.forEach(s=>s(e,r))}subscribe(e,r,s){return this._subject.subscribe({next:e,error:r,complete:s})}}return t.normalizeQueryParams=Mi,t.joinWithSlash=Tw,t.stripTrailingSlash=wA,t.\u0275fac=function(e){return new(e||t)(Ge(ul))},t.\u0275prov=We({token:t,factory:function(){return function c6(){return new Ew(Ge(ul))}()},providedIn:"root"}),t})();function SA(t){return t.replace(/\/index.html$/,"")}const Lw=/\s+/,FA=[];let MA=(()=>{class t{constructor(e,r,s,o){this._iterableDiffers=e,this._keyValueDiffers=r,this._ngEl=s,this._renderer=o,this.initialClasses=FA,this.stateMap=new Map}set klass(e){this.initialClasses=null!=e?e.trim().split(Lw):FA}set ngClass(e){this.rawClass="string"==typeof e?e.trim().split(Lw):e}ngDoCheck(){for(const r of this.initialClasses)this._updateState(r,!0);const e=this.rawClass;if(Array.isArray(e)||e instanceof Set)for(const r of e)this._updateState(r,!0);else if(null!=e)for(const r of Object.keys(e))this._updateState(r,Boolean(e[r]));this._applyStateDiff()}_updateState(e,r){const s=this.stateMap.get(e);void 0!==s?(s.enabled!==r&&(s.changed=!0,s.enabled=r),s.touched=!0):this.stateMap.set(e,{enabled:r,changed:!0,touched:!0})}_applyStateDiff(){for(const e of this.stateMap){const r=e[0],s=e[1];s.changed?(this._toggleClass(r,s.enabled),s.changed=!1):s.touched||(s.enabled&&this._toggleClass(r,!1),this.stateMap.delete(r)),s.touched=!1}}_toggleClass(e,r){(e=e.trim()).length>0&&e.split(Lw).forEach(s=>{r?this._renderer.addClass(this._ngEl.nativeElement,s):this._renderer.removeClass(this._ngEl.nativeElement,s)})}}return t.\u0275fac=function(e){return new(e||t)(Y(dm),Y(kd),Y(Lr),Y(Ti))},t.\u0275dir=Ze({type:t,selectors:[["","ngClass",""]],inputs:{klass:["class","klass"],ngClass:"ngClass"},standalone:!0}),t})();class Z6{constructor(n,e,r,s){this.$implicit=n,this.ngForOf=e,this.index=r,this.count=s}get first(){return 0===this.index}get last(){return this.index===this.count-1}get even(){return this.index%2==0}get odd(){return!this.even}}let Vw=(()=>{class t{set ngForOf(e){this._ngForOf=e,this._ngForOfDirty=!0}set ngForTrackBy(e){this._trackByFn=e}get ngForTrackBy(){return this._trackByFn}constructor(e,r,s){this._viewContainer=e,this._template=r,this._differs=s,this._ngForOf=null,this._ngForOfDirty=!0,this._differ=null}set ngForTemplate(e){e&&(this._template=e)}ngDoCheck(){if(this._ngForOfDirty){this._ngForOfDirty=!1;const e=this._ngForOf;!this._differ&&e&&(this._differ=this._differs.find(e).create(this.ngForTrackBy))}if(this._differ){const e=this._differ.diff(this._ngForOf);e&&this._applyChanges(e)}}_applyChanges(e){const r=this._viewContainer;e.forEachOperation((s,o,i)=>{if(null==s.previousIndex)r.createEmbeddedView(this._template,new Z6(s.item,this._ngForOf,-1,-1),null===i?void 0:i);else if(null==i)r.remove(null===o?void 0:o);else if(null!==o){const a=r.get(o);r.move(a,i),$A(a,s)}});for(let s=0,o=r.length;s<o;s++){const a=r.get(s).context;a.index=s,a.count=o,a.ngForOf=this._ngForOf}e.forEachIdentityChange(s=>{$A(r.get(s.currentIndex),s)})}static ngTemplateContextGuard(e,r){return!0}}return t.\u0275fac=function(e){return new(e||t)(Y(Qs),Y(ki),Y(dm))},t.\u0275dir=Ze({type:t,selectors:[["","ngFor","","ngForOf",""]],inputs:{ngForOf:"ngForOf",ngForTrackBy:"ngForTrackBy",ngForTemplate:"ngForTemplate"},standalone:!0}),t})();function $A(t,n){t.context.$implicit=n.item}let Bw=(()=>{class t{constructor(e,r){this._viewContainer=e,this._context=new J6,this._thenTemplateRef=null,this._elseTemplateRef=null,this._thenViewRef=null,this._elseViewRef=null,this._thenTemplateRef=r}set ngIf(e){this._context.$implicit=this._context.ngIf=e,this._updateView()}set ngIfThen(e){LA("ngIfThen",e),this._thenTemplateRef=e,this._thenViewRef=null,this._updateView()}set ngIfElse(e){LA("ngIfElse",e),this._elseTemplateRef=e,this._elseViewRef=null,this._updateView()}_updateView(){this._context.$implicit?this._thenViewRef||(this._viewContainer.clear(),this._elseViewRef=null,this._thenTemplateRef&&(this._thenViewRef=this._viewContainer.createEmbeddedView(this._thenTemplateRef,this._context))):this._elseViewRef||(this._viewContainer.clear(),this._thenViewRef=null,this._elseTemplateRef&&(this._elseViewRef=this._viewContainer.createEmbeddedView(this._elseTemplateRef,this._context)))}static ngTemplateContextGuard(e,r){return!0}}return t.\u0275fac=function(e){return new(e||t)(Y(Qs),Y(ki))},t.\u0275dir=Ze({type:t,selectors:[["","ngIf",""]],inputs:{ngIf:"ngIf",ngIfThen:"ngIfThen",ngIfElse:"ngIfElse"},standalone:!0}),t})();class J6{constructor(){this.$implicit=null,this.ngIf=null}}function LA(t,n){if(n&&!n.createEmbeddedView)throw new Error(`${t} must be a TemplateRef, but received '${un(n)}'.`)}let BA=(()=>{class t{constructor(e,r,s){this._ngEl=e,this._differs=r,this._renderer=s,this._ngStyle=null,this._differ=null}set ngStyle(e){this._ngStyle=e,!this._differ&&e&&(this._differ=this._differs.find(e).create())}ngDoCheck(){if(this._differ){const e=this._differ.diff(this._ngStyle);e&&this._applyChanges(e)}}_setStyle(e,r){const[s,o]=e.split("."),i=-1===s.indexOf("-")?void 0:ps.DashCase;null!=r?this._renderer.setStyle(this._ngEl.nativeElement,s,o?`${r}${o}`:r,i):this._renderer.removeStyle(this._ngEl.nativeElement,s,i)}_applyChanges(e){e.forEachRemovedItem(r=>this._setStyle(r.key,null)),e.forEachAddedItem(r=>this._setStyle(r.key,r.currentValue)),e.forEachChangedItem(r=>this._setStyle(r.key,r.currentValue))}}return t.\u0275fac=function(e){return new(e||t)(Y(Lr),Y(kd),Y(Ti))},t.\u0275dir=Ze({type:t,selectors:[["","ngStyle",""]],inputs:{ngStyle:"ngStyle"},standalone:!0}),t})(),zA=(()=>{class t{constructor(e){this._viewContainerRef=e,this._viewRef=null,this.ngTemplateOutletContext=null,this.ngTemplateOutlet=null,this.ngTemplateOutletInjector=null}ngOnChanges(e){if(e.ngTemplateOutlet||e.ngTemplateOutletInjector){const r=this._viewContainerRef;if(this._viewRef&&r.remove(r.indexOf(this._viewRef)),this.ngTemplateOutlet){const{ngTemplateOutlet:s,ngTemplateOutletContext:o,ngTemplateOutletInjector:i}=this;this._viewRef=r.createEmbeddedView(s,o,i?{injector:i}:void 0)}else this._viewRef=null}else this._viewRef&&e.ngTemplateOutletContext&&this.ngTemplateOutletContext&&(this._viewRef.context=this.ngTemplateOutletContext)}}return t.\u0275fac=function(e){return new(e||t)(Y(Qs))},t.\u0275dir=Ze({type:t,selectors:[["","ngTemplateOutlet",""]],inputs:{ngTemplateOutletContext:"ngTemplateOutletContext",ngTemplateOutlet:"ngTemplateOutlet",ngTemplateOutletInjector:"ngTemplateOutletInjector"},standalone:!0,features:[Es]}),t})(),WA=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=qs({type:t}),t.\u0275inj=Is({}),t})();const GA="browser";let N5=(()=>{class t{}return t.\u0275prov=We({token:t,providedIn:"root",factory:()=>new k5(Ge(ss),window)}),t})();class k5{constructor(n,e){this.document=n,this.window=e,this.offset=()=>[0,0]}setOffset(n){this.offset=Array.isArray(n)?()=>n:n}getScrollPosition(){return this.supportsScrolling()?[this.window.pageXOffset,this.window.pageYOffset]:[0,0]}scrollToPosition(n){this.supportsScrolling()&&this.window.scrollTo(n[0],n[1])}scrollToAnchor(n){if(!this.supportsScrolling())return;const e=function A5(t,n){const e=t.getElementById(n)||t.getElementsByName(n)[0];if(e)return e;if("function"==typeof t.createTreeWalker&&t.body&&(t.body.createShadowRoot||t.body.attachShadow)){const r=t.createTreeWalker(t.body,NodeFilter.SHOW_ELEMENT);let s=r.currentNode;for(;s;){const o=s.shadowRoot;if(o){const i=o.getElementById(n)||o.querySelector(`[name="${n}"]`);if(i)return i}s=r.nextNode()}}return null}(this.document,n);e&&(this.scrollToElement(e),e.focus())}setHistoryScrollRestoration(n){if(this.supportScrollRestoration()){const e=this.window.history;e&&e.scrollRestoration&&(e.scrollRestoration=n)}}scrollToElement(n){const e=n.getBoundingClientRect(),r=e.left+this.window.pageXOffset,s=e.top+this.window.pageYOffset,o=this.offset();this.window.scrollTo(r-o[0],s-o[1])}supportScrollRestoration(){try{if(!this.supportsScrolling())return!1;const n=HA(this.window.history)||HA(Object.getPrototypeOf(this.window.history));return!(!n||!n.writable&&!n.set)}catch{return!1}}supportsScrolling(){try{return!!this.window&&!!this.window.scrollTo&&"pageXOffset"in this.window}catch{return!1}}}function HA(t){return Object.getOwnPropertyDescriptor(t,"scrollRestoration")}class o8 extends o6{constructor(){super(...arguments),this.supportsDOMEvents=!0}}class qw extends o8{static makeCurrent(){!function s6(t){Iw||(Iw=t)}(new qw)}onAndCancel(n,e,r){return n.addEventListener(e,r,!1),()=>{n.removeEventListener(e,r,!1)}}dispatchEvent(n,e){n.dispatchEvent(e)}remove(n){n.parentNode&&n.parentNode.removeChild(n)}createElement(n,e){return(e=e||this.getDefaultDocument()).createElement(n)}createHtmlDocument(){return document.implementation.createHTMLDocument("fakeTitle")}getDefaultDocument(){return document}isElementNode(n){return n.nodeType===Node.ELEMENT_NODE}isShadowRoot(n){return n instanceof DocumentFragment}getGlobalEventTarget(n,e){return"window"===e?window:"document"===e?n:"body"===e?n.body:null}getBaseHref(n){const e=function i8(){return Md=Md||document.querySelector("base"),Md?Md.getAttribute("href"):null}();return null==e?null:function a8(t){_m=_m||document.createElement("a"),_m.setAttribute("href",t);const n=_m.pathname;return"/"===n.charAt(0)?n:`/${n}`}(e)}resetBaseElement(){Md=null}getUserAgent(){return window.navigator.userAgent}getCookie(n){return function X6(t,n){n=encodeURIComponent(n);for(const e of t.split(";")){const r=e.indexOf("="),[s,o]=-1==r?[e,""]:[e.slice(0,r),e.slice(r+1)];if(s.trim()===n)return decodeURIComponent(o)}return null}(document.cookie,n)}}let _m,Md=null;const YA=new Le("TRANSITION_ID"),u8=[{provide:om,useFactory:function l8(t,n,e){return()=>{e.get(im).donePromise.then(()=>{const r=Fi(),s=n.querySelectorAll(`style[ng-transition="${t}"]`);for(let o=0;o<s.length;o++)r.remove(s[o])})}},deps:[YA,ss,ts],multi:!0}];let d8=(()=>{class t{build(){return new XMLHttpRequest}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=We({token:t,factory:t.\u0275fac}),t})();const Sm=new Le("EventManagerPlugins");let Im=(()=>{class t{constructor(e,r){this._zone=r,this._eventNameToPlugin=new Map,e.forEach(s=>{s.manager=this}),this._plugins=e.slice().reverse()}addEventListener(e,r,s){return this._findPluginFor(r).addEventListener(e,r,s)}addGlobalEventListener(e,r,s){return this._findPluginFor(r).addGlobalEventListener(e,r,s)}getZone(){return this._zone}_findPluginFor(e){const r=this._eventNameToPlugin.get(e);if(r)return r;const s=this._plugins;for(let o=0;o<s.length;o++){const i=s[o];if(i.supports(e))return this._eventNameToPlugin.set(e,i),i}throw new Error(`No event manager plugin found for event ${e}`)}}return t.\u0275fac=function(e){return new(e||t)(Ge(Sm),Ge(Fn))},t.\u0275prov=We({token:t,factory:t.\u0275fac}),t})();class ZA{constructor(n){this._doc=n}addGlobalEventListener(n,e,r){const s=Fi().getGlobalEventTarget(this._doc,n);if(!s)throw new Error(`Unsupported event target ${s} for event ${e}`);return this.addEventListener(s,e,r)}}let QA=(()=>{class t{constructor(){this.usageCount=new Map}addStyles(e){for(const r of e)1===this.changeUsageCount(r,1)&&this.onStyleAdded(r)}removeStyles(e){for(const r of e)0===this.changeUsageCount(r,-1)&&this.onStyleRemoved(r)}onStyleRemoved(e){}onStyleAdded(e){}getAllStyles(){return this.usageCount.keys()}changeUsageCount(e,r){const s=this.usageCount;let o=s.get(e)??0;return o+=r,o>0?s.set(e,o):s.delete(e),o}ngOnDestroy(){for(const e of this.getAllStyles())this.onStyleRemoved(e);this.usageCount.clear()}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=We({token:t,factory:t.\u0275fac}),t})(),Pd=(()=>{class t extends QA{constructor(e){super(),this.doc=e,this.styleRef=new Map,this.hostNodes=new Set,this.resetHostNodes()}onStyleAdded(e){for(const r of this.hostNodes)this.addStyleToHost(r,e)}onStyleRemoved(e){const r=this.styleRef;r.get(e)?.forEach(o=>o.remove()),r.delete(e)}ngOnDestroy(){super.ngOnDestroy(),this.styleRef.clear(),this.resetHostNodes()}addHost(e){this.hostNodes.add(e);for(const r of this.getAllStyles())this.addStyleToHost(e,r)}removeHost(e){this.hostNodes.delete(e)}addStyleToHost(e,r){const s=this.doc.createElement("style");s.textContent=r,e.appendChild(s);const o=this.styleRef.get(r);o?o.push(s):this.styleRef.set(r,[s])}resetHostNodes(){const e=this.hostNodes;e.clear(),e.add(this.doc.head)}}return t.\u0275fac=function(e){return new(e||t)(Ge(ss))},t.\u0275prov=We({token:t,factory:t.\u0275fac}),t})();const Kw={svg:"http://www.w3.org/2000/svg",xhtml:"http://www.w3.org/1999/xhtml",xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/",math:"http://www.w3.org/1998/MathML/"},Xw=/%COMP%/g,tR=new Le("RemoveStylesOnCompDestory",{providedIn:"root",factory:()=>!1});function nR(t,n){return n.flat(100).map(e=>e.replace(Xw,t))}function rR(t){return n=>{if("__ngUnwrap__"===n)return t;!1===t(n)&&(n.preventDefault(),n.returnValue=!1)}}let Yw=(()=>{class t{constructor(e,r,s,o){this.eventManager=e,this.sharedStylesHost=r,this.appId=s,this.removeStylesOnCompDestory=o,this.rendererByCompId=new Map,this.defaultRenderer=new Zw(e)}createRenderer(e,r){if(!e||!r)return this.defaultRenderer;const s=this.getOrCreateRenderer(e,r);return s instanceof iR?s.applyToHost(e):s instanceof Qw&&s.applyStyles(),s}getOrCreateRenderer(e,r){const s=this.rendererByCompId;let o=s.get(r.id);if(!o){const i=this.eventManager,a=this.sharedStylesHost,l=this.removeStylesOnCompDestory;switch(r.encapsulation){case Uo.Emulated:o=new iR(i,a,r,this.appId,l);break;case Uo.ShadowDom:return new b8(i,a,e,r);default:o=new Qw(i,a,r,l)}o.onDestroy=()=>s.delete(r.id),s.set(r.id,o)}return o}ngOnDestroy(){this.rendererByCompId.clear()}begin(){}end(){}}return t.\u0275fac=function(e){return new(e||t)(Ge(Im),Ge(Pd),Ge(Td),Ge(tR))},t.\u0275prov=We({token:t,factory:t.\u0275fac}),t})();class Zw{constructor(n){this.eventManager=n,this.data=Object.create(null),this.destroyNode=null}destroy(){}createElement(n,e){return e?document.createElementNS(Kw[e]||e,n):document.createElement(n)}createComment(n){return document.createComment(n)}createText(n){return document.createTextNode(n)}appendChild(n,e){(oR(n)?n.content:n).appendChild(e)}insertBefore(n,e,r){n&&(oR(n)?n.content:n).insertBefore(e,r)}removeChild(n,e){n&&n.removeChild(e)}selectRootElement(n,e){let r="string"==typeof n?document.querySelector(n):n;if(!r)throw new Error(`The selector "${n}" did not match any elements`);return e||(r.textContent=""),r}parentNode(n){return n.parentNode}nextSibling(n){return n.nextSibling}setAttribute(n,e,r,s){if(s){e=s+":"+e;const o=Kw[s];o?n.setAttributeNS(o,e,r):n.setAttribute(e,r)}else n.setAttribute(e,r)}removeAttribute(n,e,r){if(r){const s=Kw[r];s?n.removeAttributeNS(s,e):n.removeAttribute(`${r}:${e}`)}else n.removeAttribute(e)}addClass(n,e){n.classList.add(e)}removeClass(n,e){n.classList.remove(e)}setStyle(n,e,r,s){s&(ps.DashCase|ps.Important)?n.style.setProperty(e,r,s&ps.Important?"important":""):n.style[e]=r}removeStyle(n,e,r){r&ps.DashCase?n.style.removeProperty(e):n.style[e]=""}setProperty(n,e,r){n[e]=r}setValue(n,e){n.nodeValue=e}listen(n,e,r){return"string"==typeof n?this.eventManager.addGlobalEventListener(n,e,rR(r)):this.eventManager.addEventListener(n,e,rR(r))}}function oR(t){return"TEMPLATE"===t.tagName&&void 0!==t.content}class b8 extends Zw{constructor(n,e,r,s){super(n),this.sharedStylesHost=e,this.hostEl=r,this.shadowRoot=r.attachShadow({mode:"open"}),this.sharedStylesHost.addHost(this.shadowRoot);const o=nR(s.id,s.styles);for(const i of o){const a=document.createElement("style");a.textContent=i,this.shadowRoot.appendChild(a)}}nodeOrShadowRoot(n){return n===this.hostEl?this.shadowRoot:n}appendChild(n,e){return super.appendChild(this.nodeOrShadowRoot(n),e)}insertBefore(n,e,r){return super.insertBefore(this.nodeOrShadowRoot(n),e,r)}removeChild(n,e){return super.removeChild(this.nodeOrShadowRoot(n),e)}parentNode(n){return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(n)))}destroy(){this.sharedStylesHost.removeHost(this.shadowRoot)}}class Qw extends Zw{constructor(n,e,r,s,o=r.id){super(n),this.sharedStylesHost=e,this.removeStylesOnCompDestory=s,this.rendererUsageCount=0,this.styles=nR(o,r.styles)}applyStyles(){this.sharedStylesHost.addStyles(this.styles),this.rendererUsageCount++}destroy(){this.removeStylesOnCompDestory&&(this.sharedStylesHost.removeStyles(this.styles),this.rendererUsageCount--,0===this.rendererUsageCount&&this.onDestroy?.())}}class iR extends Qw{constructor(n,e,r,s,o){const i=s+"-"+r.id;super(n,e,r,o,i),this.contentAttr=function m8(t){return"_ngcontent-%COMP%".replace(Xw,t)}(i),this.hostAttr=function g8(t){return"_nghost-%COMP%".replace(Xw,t)}(i)}applyToHost(n){this.applyStyles(),this.setAttribute(n,this.hostAttr,"")}createElement(n,e){const r=super.createElement(n,e);return super.setAttribute(r,this.contentAttr,""),r}}let v8=(()=>{class t extends ZA{constructor(e){super(e)}supports(e){return!0}addEventListener(e,r,s){return e.addEventListener(r,s,!1),()=>this.removeEventListener(e,r,s)}removeEventListener(e,r,s){return e.removeEventListener(r,s)}}return t.\u0275fac=function(e){return new(e||t)(Ge(ss))},t.\u0275prov=We({token:t,factory:t.\u0275fac}),t})();const aR=["alt","control","meta","shift"],x8={"\b":"Backspace","\t":"Tab","\x7f":"Delete","\x1b":"Escape",Del:"Delete",Esc:"Escape",Left:"ArrowLeft",Right:"ArrowRight",Up:"ArrowUp",Down:"ArrowDown",Menu:"ContextMenu",Scroll:"ScrollLock",Win:"OS"},w8={alt:t=>t.altKey,control:t=>t.ctrlKey,meta:t=>t.metaKey,shift:t=>t.shiftKey};let C8=(()=>{class t extends ZA{constructor(e){super(e)}supports(e){return null!=t.parseEventName(e)}addEventListener(e,r,s){const o=t.parseEventName(r),i=t.eventCallback(o.fullKey,s,this.manager.getZone());return this.manager.getZone().runOutsideAngular(()=>Fi().onAndCancel(e,o.domEventName,i))}static parseEventName(e){const r=e.toLowerCase().split("."),s=r.shift();if(0===r.length||"keydown"!==s&&"keyup"!==s)return null;const o=t._normalizeKey(r.pop());let i="",a=r.indexOf("code");if(a>-1&&(r.splice(a,1),i="code."),aR.forEach(u=>{const c=r.indexOf(u);c>-1&&(r.splice(c,1),i+=u+".")}),i+=o,0!=r.length||0===o.length)return null;const l={};return l.domEventName=s,l.fullKey=i,l}static matchEventFullKeyCode(e,r){let s=x8[e.key]||e.key,o="";return r.indexOf("code.")>-1&&(s=e.code,o="code."),!(null==s||!s)&&(s=s.toLowerCase()," "===s?s="space":"."===s&&(s="dot"),aR.forEach(i=>{i!==s&&(0,w8[i])(e)&&(o+=i+".")}),o+=s,o===r)}static eventCallback(e,r,s){return o=>{t.matchEventFullKeyCode(o,e)&&s.runGuarded(()=>r(o))}}static _normalizeKey(e){return"esc"===e?"escape":e}}return t.\u0275fac=function(e){return new(e||t)(Ge(ss))},t.\u0275prov=We({token:t,factory:t.\u0275fac}),t})();const D8=nA(t6,"browser",[{provide:hw,useValue:GA},{provide:Hk,useValue:function _8(){qw.makeCurrent()},multi:!0},{provide:ss,useFactory:function I8(){return function l4(t){Zv=t}(document),document},deps:[]}]),cR=new Le(""),dR=[{provide:am,useClass:class c8{addToWindow(n){pn.getAngularTestability=(r,s=!0)=>{const o=n.findTestabilityInTree(r,s);if(null==o)throw new Error("Could not find testability for element.");return o},pn.getAllAngularTestabilities=()=>n.getAllTestabilities(),pn.getAllAngularRootElements=()=>n.getAllRootElements(),pn.frameworkStabilizers||(pn.frameworkStabilizers=[]),pn.frameworkStabilizers.push(r=>{const s=pn.getAllAngularTestabilities();let o=s.length,i=!1;const a=function(l){i=i||l,o--,0==o&&r(i)};s.forEach(function(l){l.whenStable(a)})})}findTestabilityInTree(n,e,r){return null==e?null:n.getTestability(e)??(r?Fi().isShadowRoot(e)?this.findTestabilityInTree(n,e.host,!0):this.findTestabilityInTree(n,e.parentElement,!0):null)}},deps:[]},{provide:Zk,useClass:gw,deps:[Fn,yw,am]},{provide:gw,useClass:gw,deps:[Fn,yw,am]}],hR=[{provide:ix,useValue:"root"},{provide:vu,useFactory:function S8(){return new vu},deps:[]},{provide:Sm,useClass:v8,multi:!0,deps:[ss,Fn,hw]},{provide:Sm,useClass:C8,multi:!0,deps:[ss]},{provide:Yw,useClass:Yw,deps:[Im,Pd,Td,tR]},{provide:zT,useExisting:Yw},{provide:QA,useExisting:Pd},{provide:Pd,useClass:Pd,deps:[ss]},{provide:Im,useClass:Im,deps:[Sm,Fn]},{provide:class R5{},useClass:d8,deps:[]},[]];let T8=(()=>{class t{constructor(e){}static withServerTransition(e){return{ngModule:t,providers:[{provide:Td,useValue:e.appId},{provide:YA,useExisting:Td},u8]}}}return t.\u0275fac=function(e){return new(e||t)(Ge(cR,12))},t.\u0275mod=qs({type:t}),t.\u0275inj=Is({providers:[...hR,...dR],imports:[WA,n6]}),t})(),pR=(()=>{class t{constructor(e){this._doc=e}getTitle(){return this._doc.title}setTitle(e){this._doc.title=e||""}}return t.\u0275fac=function(e){return new(e||t)(Ge(ss))},t.\u0275prov=We({token:t,factory:function(e){let r=null;return r=e?new e:function N8(){return new pR(Ge(ss))}(),r},providedIn:"root"}),t})();function je(...t){return Kn(t,Bc(t))}typeof window<"u"&&window;class Io extends yi{constructor(n){super(),this._value=n}get value(){return this.getValue()}_subscribe(n){const e=super._subscribe(n);return!e.closed&&n.next(this._value),e}getValue(){const{hasError:n,thrownError:e,_value:r}=this;if(n)throw e;return this._throwIfClosed(),r}next(n){super.next(this._value=n)}}const Dm=Ve(t=>function(){t(this),this.name="EmptyError",this.message="no elements in sequence"}),{isArray:P8}=Array,{getPrototypeOf:O8,prototype:$8,keys:L8}=Object;function gR(t){if(1===t.length){const n=t[0];if(P8(n))return{args:n,keys:null};if(function V8(t){return t&&"object"==typeof t&&O8(t)===$8}(n)){const e=L8(n);return{args:e.map(r=>n[r]),keys:e}}}return{args:t,keys:null}}const{isArray:B8}=Array;function yR(t){return Nt(n=>function z8(t,n){return B8(n)?t(...n):t(n)}(t,n))}function bR(t,n){return t.reduce((e,r,s)=>(e[r]=n[s],e),{})}function vR(...t){const n=Bc(t),e=A1(t),{args:r,keys:s}=gR(t);if(0===r.length)return Kn([],n);const o=new xt(function U8(t,n,e=vn){return r=>{xR(n,()=>{const{length:s}=t,o=new Array(s);let i=s,a=s;for(let l=0;l<s;l++)xR(n,()=>{const u=Kn(t[l],n);let c=!1;u.subscribe(sr(r,d=>{o[l]=d,c||(c=!0,a--),a||r.next(e(o.slice()))},()=>{--i||r.complete()}))},r)},r)}}(r,n,s?i=>bR(s,i):vn));return e?o.pipe(yR(e)):o}function xR(t,n,e){t?bi(e,t,n):n()}function tC(...t){return function W8(){return Zl(1)}()(Kn(t,Bc(t)))}function wR(t){return new xt(n=>{Gs(t()).subscribe(n)})}function Od(t,n){const e=Fe(t)?t:()=>t,r=s=>s.error(e());return new xt(n?s=>n.schedule(r,0,s):r)}function nC(){return yr((t,n)=>{let e=null;t._refCount++;const r=sr(n,void 0,void 0,void 0,()=>{if(!t||t._refCount<=0||0<--t._refCount)return void(e=null);const s=t._connection,o=e;e=null,s&&(!o||s===o)&&s.unsubscribe(),n.unsubscribe()});t.subscribe(r),r.closed||(e=t.connect())})}class CR extends xt{constructor(n,e){super(),this.source=n,this.subjectFactory=e,this._subject=null,this._refCount=0,this._connection=null,y1(n)&&(this.lift=n.lift)}_subscribe(n){return this.getSubject().subscribe(n)}getSubject(){const n=this._subject;return(!n||n.isStopped)&&(this._subject=this.subjectFactory()),this._subject}_teardown(){this._refCount=0;const{_connection:n}=this;this._subject=this._connection=null,n?.unsubscribe()}connect(){let n=this._connection;if(!n){n=this._connection=new O;const e=this.getSubject();n.add(this.source.subscribe(sr(e,void 0,()=>{this._teardown(),e.complete()},r=>{this._teardown(),e.error(r)},()=>this._teardown()))),n.closed&&(this._connection=null,n=O.EMPTY)}return n}refCount(){return nC()(this)}}function Zo(t,n){return yr((e,r)=>{let s=null,o=0,i=!1;const a=()=>i&&!s&&r.complete();e.subscribe(sr(r,l=>{s?.unsubscribe();let u=0;const c=o++;Gs(t(l,c)).subscribe(s=sr(r,d=>r.next(n?n(l,d,c,u++):d),()=>{s=null,a()}))},()=>{i=!0,a()}))})}function $d(t){return t<=0?()=>Bo:yr((n,e)=>{let r=0;n.subscribe(sr(e,s=>{++r<=t&&(e.next(s),t<=r&&e.complete())}))})}function ra(t,n){return yr((e,r)=>{let s=0;e.subscribe(sr(r,o=>t.call(n,o,s++)&&r.next(o)))})}function Tm(t){return yr((n,e)=>{let r=!1;n.subscribe(sr(e,s=>{r=!0,e.next(s)},()=>{r||e.next(t),e.complete()}))})}function _R(t=H8){return yr((n,e)=>{let r=!1;n.subscribe(sr(e,s=>{r=!0,e.next(s)},()=>r?e.complete():e.error(t())))})}function H8(){return new Dm}function sa(t,n){const e=arguments.length>=2;return r=>r.pipe(t?ra((s,o)=>t(s,o,r)):vn,$d(1),e?Tm(n):_R(()=>new Dm))}function cl(t,n){return Fe(n)?_r(t,n,1):_r(t,1)}function Br(t,n,e){const r=Fe(t)||n||e?{next:t,error:n,complete:e}:t;return r?yr((s,o)=>{var i;null===(i=r.subscribe)||void 0===i||i.call(r);let a=!0;s.subscribe(sr(o,l=>{var u;null===(u=r.next)||void 0===u||u.call(r,l),o.next(l)},()=>{var l;a=!1,null===(l=r.complete)||void 0===l||l.call(r),o.complete()},l=>{var u;a=!1,null===(u=r.error)||void 0===u||u.call(r,l),o.error(l)},()=>{var l,u;a&&(null===(l=r.unsubscribe)||void 0===l||l.call(r)),null===(u=r.finalize)||void 0===u||u.call(r)}))}):vn}function oa(t){return yr((n,e)=>{let o,r=null,s=!1;r=n.subscribe(sr(e,void 0,void 0,i=>{o=Gs(t(i,oa(t)(n))),r?(r.unsubscribe(),r=null,o.subscribe(e)):s=!0})),s&&(r.unsubscribe(),r=null,o.subscribe(e))})}function SR(t,n){return yr(function j8(t,n,e,r,s){return(o,i)=>{let a=e,l=n,u=0;o.subscribe(sr(i,c=>{const d=u++;l=a?t(l,c,d):(a=!0,c),r&&i.next(l)},s&&(()=>{a&&i.next(l),i.complete()})))}}(t,n,arguments.length>=2,!0))}function rC(t){return t<=0?()=>Bo:yr((n,e)=>{let r=[];n.subscribe(sr(e,s=>{r.push(s),t<r.length&&r.shift()},()=>{for(const s of r)e.next(s);e.complete()},void 0,()=>{r=null}))})}function IR(t,n){const e=arguments.length>=2;return r=>r.pipe(t?ra((s,o)=>t(s,o,r)):vn,rC(1),e?Tm(n):_R(()=>new Dm))}function sC(t){return yr((n,e)=>{try{n.subscribe(e)}finally{e.add(t)}})}const ut="primary",Ld=Symbol("RouteTitle");class X8{constructor(n){this.params=n||{}}has(n){return Object.prototype.hasOwnProperty.call(this.params,n)}get(n){if(this.has(n)){const e=this.params[n];return Array.isArray(e)?e[0]:e}return null}getAll(n){if(this.has(n)){const e=this.params[n];return Array.isArray(e)?e:[e]}return[]}get keys(){return Object.keys(this.params)}}function Bu(t){return new X8(t)}function Y8(t,n,e){const r=e.path.split("/");if(r.length>t.length||"full"===e.pathMatch&&(n.hasChildren()||r.length<t.length))return null;const s={};for(let o=0;o<r.length;o++){const i=r[o],a=t[o];if(i.startsWith(":"))s[i.substring(1)]=a;else if(i!==a.path)return null}return{consumed:t.slice(0,r.length),posParams:s}}function Qo(t,n){const e=t?Object.keys(t):void 0,r=n?Object.keys(n):void 0;if(!e||!r||e.length!=r.length)return!1;let s;for(let o=0;o<e.length;o++)if(s=e[o],!DR(t[s],n[s]))return!1;return!0}function DR(t,n){if(Array.isArray(t)&&Array.isArray(n)){if(t.length!==n.length)return!1;const e=[...t].sort(),r=[...n].sort();return e.every((s,o)=>r[o]===s)}return t===n}function TR(t){return Array.prototype.concat.apply([],t)}function ER(t){return t.length>0?t[t.length-1]:null}function Tr(t,n){for(const e in t)t.hasOwnProperty(e)&&n(t[e],e)}function ia(t){return Lx(t)?t:gd(t)?Kn(Promise.resolve(t)):je(t)}const Em=!1,Q8={exact:function AR(t,n,e){if(!dl(t.segments,n.segments)||!Nm(t.segments,n.segments,e)||t.numberOfChildren!==n.numberOfChildren)return!1;for(const r in n.children)if(!t.children[r]||!AR(t.children[r],n.children[r],e))return!1;return!0},subset:RR},NR={exact:function J8(t,n){return Qo(t,n)},subset:function eK(t,n){return Object.keys(n).length<=Object.keys(t).length&&Object.keys(n).every(e=>DR(t[e],n[e]))},ignored:()=>!0};function kR(t,n,e){return Q8[e.paths](t.root,n.root,e.matrixParams)&&NR[e.queryParams](t.queryParams,n.queryParams)&&!("exact"===e.fragment&&t.fragment!==n.fragment)}function RR(t,n,e){return FR(t,n,n.segments,e)}function FR(t,n,e,r){if(t.segments.length>e.length){const s=t.segments.slice(0,e.length);return!(!dl(s,e)||n.hasChildren()||!Nm(s,e,r))}if(t.segments.length===e.length){if(!dl(t.segments,e)||!Nm(t.segments,e,r))return!1;for(const s in n.children)if(!t.children[s]||!RR(t.children[s],n.children[s],r))return!1;return!0}{const s=e.slice(0,t.segments.length),o=e.slice(t.segments.length);return!!(dl(t.segments,s)&&Nm(t.segments,s,r)&&t.children[ut])&&FR(t.children[ut],n,o,r)}}function Nm(t,n,e){return n.every((r,s)=>NR[e](t[s].parameters,r.parameters))}class aa{constructor(n=new St([],{}),e={},r=null){this.root=n,this.queryParams=e,this.fragment=r}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=Bu(this.queryParams)),this._queryParamMap}toString(){return rK.serialize(this)}}class St{constructor(n,e){this.segments=n,this.children=e,this.parent=null,Tr(e,(r,s)=>r.parent=this)}hasChildren(){return this.numberOfChildren>0}get numberOfChildren(){return Object.keys(this.children).length}toString(){return km(this)}}class Vd{constructor(n,e){this.path=n,this.parameters=e}get parameterMap(){return this._parameterMap||(this._parameterMap=Bu(this.parameters)),this._parameterMap}toString(){return OR(this)}}function dl(t,n){return t.length===n.length&&t.every((e,r)=>e.path===n[r].path)}let Bd=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=We({token:t,factory:function(){return new oC},providedIn:"root"}),t})();class oC{parse(n){const e=new hK(n);return new aa(e.parseRootSegment(),e.parseQueryParams(),e.parseFragment())}serialize(n){const e=`/${zd(n.root,!0)}`,r=function iK(t){const n=Object.keys(t).map(e=>{const r=t[e];return Array.isArray(r)?r.map(s=>`${Am(e)}=${Am(s)}`).join("&"):`${Am(e)}=${Am(r)}`}).filter(e=>!!e);return n.length?`?${n.join("&")}`:""}(n.queryParams);return`${e}${r}${"string"==typeof n.fragment?`#${function sK(t){return encodeURI(t)}(n.fragment)}`:""}`}}const rK=new oC;function km(t){return t.segments.map(n=>OR(n)).join("/")}function zd(t,n){if(!t.hasChildren())return km(t);if(n){const e=t.children[ut]?zd(t.children[ut],!1):"",r=[];return Tr(t.children,(s,o)=>{o!==ut&&r.push(`${o}:${zd(s,!1)}`)}),r.length>0?`${e}(${r.join("//")})`:e}{const e=function nK(t,n){let e=[];return Tr(t.children,(r,s)=>{s===ut&&(e=e.concat(n(r,s)))}),Tr(t.children,(r,s)=>{s!==ut&&(e=e.concat(n(r,s)))}),e}(t,(r,s)=>s===ut?[zd(t.children[ut],!1)]:[`${s}:${zd(r,!1)}`]);return 1===Object.keys(t.children).length&&null!=t.children[ut]?`${km(t)}/${e[0]}`:`${km(t)}/(${e.join("//")})`}}function MR(t){return encodeURIComponent(t).replace(/%40/g,"@").replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",")}function Am(t){return MR(t).replace(/%3B/gi,";")}function iC(t){return MR(t).replace(/\(/g,"%28").replace(/\)/g,"%29").replace(/%26/gi,"&")}function Rm(t){return decodeURIComponent(t)}function PR(t){return Rm(t.replace(/\+/g,"%20"))}function OR(t){return`${iC(t.path)}${function oK(t){return Object.keys(t).map(n=>`;${iC(n)}=${iC(t[n])}`).join("")}(t.parameters)}`}const aK=/^[^\/()?;=#]+/;function Fm(t){const n=t.match(aK);return n?n[0]:""}const lK=/^[^=?&#]+/,cK=/^[^&#]+/;class hK{constructor(n){this.url=n,this.remaining=n}parseRootSegment(){return this.consumeOptional("/"),""===this.remaining||this.peekStartsWith("?")||this.peekStartsWith("#")?new St([],{}):new St([],this.parseChildren())}parseQueryParams(){const n={};if(this.consumeOptional("?"))do{this.parseQueryParam(n)}while(this.consumeOptional("&"));return n}parseFragment(){return this.consumeOptional("#")?decodeURIComponent(this.remaining):null}parseChildren(){if(""===this.remaining)return{};this.consumeOptional("/");const n=[];for(this.peekStartsWith("(")||n.push(this.parseSegment());this.peekStartsWith("/")&&!this.peekStartsWith("//")&&!this.peekStartsWith("/(");)this.capture("/"),n.push(this.parseSegment());let e={};this.peekStartsWith("/(")&&(this.capture("/"),e=this.parseParens(!0));let r={};return this.peekStartsWith("(")&&(r=this.parseParens(!1)),(n.length>0||Object.keys(e).length>0)&&(r[ut]=new St(n,e)),r}parseSegment(){const n=Fm(this.remaining);if(""===n&&this.peekStartsWith(";"))throw new ce(4009,Em);return this.capture(n),new Vd(Rm(n),this.parseMatrixParams())}parseMatrixParams(){const n={};for(;this.consumeOptional(";");)this.parseParam(n);return n}parseParam(n){const e=Fm(this.remaining);if(!e)return;this.capture(e);let r="";if(this.consumeOptional("=")){const s=Fm(this.remaining);s&&(r=s,this.capture(r))}n[Rm(e)]=Rm(r)}parseQueryParam(n){const e=function uK(t){const n=t.match(lK);return n?n[0]:""}(this.remaining);if(!e)return;this.capture(e);let r="";if(this.consumeOptional("=")){const i=function dK(t){const n=t.match(cK);return n?n[0]:""}(this.remaining);i&&(r=i,this.capture(r))}const s=PR(e),o=PR(r);if(n.hasOwnProperty(s)){let i=n[s];Array.isArray(i)||(i=[i],n[s]=i),i.push(o)}else n[s]=o}parseParens(n){const e={};for(this.capture("(");!this.consumeOptional(")")&&this.remaining.length>0;){const r=Fm(this.remaining),s=this.remaining[r.length];if("/"!==s&&")"!==s&&";"!==s)throw new ce(4010,Em);let o;r.indexOf(":")>-1?(o=r.slice(0,r.indexOf(":")),this.capture(o),this.capture(":")):n&&(o=ut);const i=this.parseChildren();e[o]=1===Object.keys(i).length?i[ut]:new St([],i),this.consumeOptional("//")}return e}peekStartsWith(n){return this.remaining.startsWith(n)}consumeOptional(n){return!!this.peekStartsWith(n)&&(this.remaining=this.remaining.substring(n.length),!0)}capture(n){if(!this.consumeOptional(n))throw new ce(4011,Em)}}function aC(t){return t.segments.length>0?new St([],{[ut]:t}):t}function Mm(t){const n={};for(const r of Object.keys(t.children)){const o=Mm(t.children[r]);(o.segments.length>0||o.hasChildren())&&(n[r]=o)}return function pK(t){if(1===t.numberOfChildren&&t.children[ut]){const n=t.children[ut];return new St(t.segments.concat(n.segments),n.children)}return t}(new St(t.segments,n))}function hl(t){return t instanceof aa}const lC=!1;function fK(t,n,e,r,s){if(0===e.length)return zu(n.root,n.root,n.root,r,s);const o=function zR(t){if("string"==typeof t[0]&&1===t.length&&"/"===t[0])return new BR(!0,0,t);let n=0,e=!1;const r=t.reduce((s,o,i)=>{if("object"==typeof o&&null!=o){if(o.outlets){const a={};return Tr(o.outlets,(l,u)=>{a[u]="string"==typeof l?l.split("/"):l}),[...s,{outlets:a}]}if(o.segmentPath)return[...s,o.segmentPath]}return"string"!=typeof o?[...s,o]:0===i?(o.split("/").forEach((a,l)=>{0==l&&"."===a||(0==l&&""===a?e=!0:".."===a?n++:""!=a&&s.push(a))}),s):[...s,o]},[]);return new BR(e,n,r)}(e);return o.toRoot()?zu(n.root,n.root,new St([],{}),r,s):function i(l){const u=function gK(t,n,e,r){if(t.isAbsolute)return new Uu(n.root,!0,0);if(-1===r)return new Uu(e,e===n.root,0);return function UR(t,n,e){let r=t,s=n,o=e;for(;o>s;){if(o-=s,r=r.parent,!r)throw new ce(4005,lC&&"Invalid number of '../'");s=r.segments.length}return new Uu(r,!1,s-o)}(e,r+(Ud(t.commands[0])?0:1),t.numberOfDoubleDots)}(o,n,t.snapshot?._urlSegment,l),c=u.processChildren?Wu(u.segmentGroup,u.index,o.commands):uC(u.segmentGroup,u.index,o.commands);return zu(n.root,u.segmentGroup,c,r,s)}(t.snapshot?._lastPathIndex)}function Ud(t){return"object"==typeof t&&null!=t&&!t.outlets&&!t.segmentPath}function Wd(t){return"object"==typeof t&&null!=t&&t.outlets}function zu(t,n,e,r,s){let i,o={};r&&Tr(r,(l,u)=>{o[u]=Array.isArray(l)?l.map(c=>`${c}`):`${l}`}),i=t===n?e:VR(t,n,e);const a=aC(Mm(i));return new aa(a,o,s)}function VR(t,n,e){const r={};return Tr(t.children,(s,o)=>{r[o]=s===n?e:VR(s,n,e)}),new St(t.segments,r)}class BR{constructor(n,e,r){if(this.isAbsolute=n,this.numberOfDoubleDots=e,this.commands=r,n&&r.length>0&&Ud(r[0]))throw new ce(4003,lC&&"Root segment cannot have matrix parameters");const s=r.find(Wd);if(s&&s!==ER(r))throw new ce(4004,lC&&"{outlets:{}} has to be the last command")}toRoot(){return this.isAbsolute&&1===this.commands.length&&"/"==this.commands[0]}}class Uu{constructor(n,e,r){this.segmentGroup=n,this.processChildren=e,this.index=r}}function uC(t,n,e){if(t||(t=new St([],{})),0===t.segments.length&&t.hasChildren())return Wu(t,n,e);const r=function bK(t,n,e){let r=0,s=n;const o={match:!1,pathIndex:0,commandIndex:0};for(;s<t.segments.length;){if(r>=e.length)return o;const i=t.segments[s],a=e[r];if(Wd(a))break;const l=`${a}`,u=r<e.length-1?e[r+1]:null;if(s>0&&void 0===l)break;if(l&&u&&"object"==typeof u&&void 0===u.outlets){if(!GR(l,u,i))return o;r+=2}else{if(!GR(l,{},i))return o;r++}s++}return{match:!0,pathIndex:s,commandIndex:r}}(t,n,e),s=e.slice(r.commandIndex);if(r.match&&r.pathIndex<t.segments.length){const o=new St(t.segments.slice(0,r.pathIndex),{});return o.children[ut]=new St(t.segments.slice(r.pathIndex),t.children),Wu(o,0,s)}return r.match&&0===s.length?new St(t.segments,{}):r.match&&!t.hasChildren()?cC(t,n,e):r.match?Wu(t,0,s):cC(t,n,e)}function Wu(t,n,e){if(0===e.length)return new St(t.segments,{});{const r=function yK(t){return Wd(t[0])?t[0].outlets:{[ut]:t}}(e),s={};return!r[ut]&&t.children[ut]&&1===t.numberOfChildren&&0===t.children[ut].segments.length?Wu(t.children[ut],n,e):(Tr(r,(o,i)=>{"string"==typeof o&&(o=[o]),null!==o&&(s[i]=uC(t.children[i],n,o))}),Tr(t.children,(o,i)=>{void 0===r[i]&&(s[i]=o)}),new St(t.segments,s))}}function cC(t,n,e){const r=t.segments.slice(0,n);let s=0;for(;s<e.length;){const o=e[s];if(Wd(o)){const l=vK(o.outlets);return new St(r,l)}if(0===s&&Ud(e[0])){r.push(new Vd(t.segments[n].path,WR(e[0]))),s++;continue}const i=Wd(o)?o.outlets[ut]:`${o}`,a=s<e.length-1?e[s+1]:null;i&&a&&Ud(a)?(r.push(new Vd(i,WR(a))),s+=2):(r.push(new Vd(i,{})),s++)}return new St(r,{})}function vK(t){const n={};return Tr(t,(e,r)=>{"string"==typeof e&&(e=[e]),null!==e&&(n[r]=cC(new St([],{}),0,e))}),n}function WR(t){const n={};return Tr(t,(e,r)=>n[r]=`${e}`),n}function GR(t,n,e){return t==e.path&&Qo(n,e.parameters)}const Gd="imperative";class Jo{constructor(n,e){this.id=n,this.url=e}}class dC extends Jo{constructor(n,e,r="imperative",s=null){super(n,e),this.type=0,this.navigationTrigger=r,this.restoredState=s}toString(){return`NavigationStart(id: ${this.id}, url: '${this.url}')`}}class pl extends Jo{constructor(n,e,r){super(n,e),this.urlAfterRedirects=r,this.type=1}toString(){return`NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`}}class Pm extends Jo{constructor(n,e,r,s){super(n,e),this.reason=r,this.code=s,this.type=2}toString(){return`NavigationCancel(id: ${this.id}, url: '${this.url}')`}}class Om extends Jo{constructor(n,e,r,s){super(n,e),this.reason=r,this.code=s,this.type=16}}class hC extends Jo{constructor(n,e,r,s){super(n,e),this.error=r,this.target=s,this.type=3}toString(){return`NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`}}class xK extends Jo{constructor(n,e,r,s){super(n,e),this.urlAfterRedirects=r,this.state=s,this.type=4}toString(){return`RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class wK extends Jo{constructor(n,e,r,s){super(n,e),this.urlAfterRedirects=r,this.state=s,this.type=7}toString(){return`GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class CK extends Jo{constructor(n,e,r,s,o){super(n,e),this.urlAfterRedirects=r,this.state=s,this.shouldActivate=o,this.type=8}toString(){return`GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`}}class _K extends Jo{constructor(n,e,r,s){super(n,e),this.urlAfterRedirects=r,this.state=s,this.type=5}toString(){return`ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class SK extends Jo{constructor(n,e,r,s){super(n,e),this.urlAfterRedirects=r,this.state=s,this.type=6}toString(){return`ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class IK{constructor(n){this.route=n,this.type=9}toString(){return`RouteConfigLoadStart(path: ${this.route.path})`}}class DK{constructor(n){this.route=n,this.type=10}toString(){return`RouteConfigLoadEnd(path: ${this.route.path})`}}class TK{constructor(n){this.snapshot=n,this.type=11}toString(){return`ChildActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class EK{constructor(n){this.snapshot=n,this.type=12}toString(){return`ChildActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class NK{constructor(n){this.snapshot=n,this.type=13}toString(){return`ActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class kK{constructor(n){this.snapshot=n,this.type=14}toString(){return`ActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class HR{constructor(n,e,r){this.routerEvent=n,this.position=e,this.anchor=r,this.type=15}toString(){return`Scroll(anchor: '${this.anchor}', position: '${this.position?`${this.position[0]}, ${this.position[1]}`:null}')`}}let FK=(()=>{class t{createUrlTree(e,r,s,o,i,a){return fK(e||r.root,s,o,i,a)}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=We({token:t,factory:t.\u0275fac}),t})(),PK=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=We({token:t,factory:function(n){return FK.\u0275fac(n)},providedIn:"root"}),t})();class jR{constructor(n){this._root=n}get root(){return this._root.value}parent(n){const e=this.pathFromRoot(n);return e.length>1?e[e.length-2]:null}children(n){const e=pC(n,this._root);return e?e.children.map(r=>r.value):[]}firstChild(n){const e=pC(n,this._root);return e&&e.children.length>0?e.children[0].value:null}siblings(n){const e=fC(n,this._root);return e.length<2?[]:e[e.length-2].children.map(s=>s.value).filter(s=>s!==n)}pathFromRoot(n){return fC(n,this._root).map(e=>e.value)}}function pC(t,n){if(t===n.value)return n;for(const e of n.children){const r=pC(t,e);if(r)return r}return null}function fC(t,n){if(t===n.value)return[n];for(const e of n.children){const r=fC(t,e);if(r.length)return r.unshift(n),r}return[]}class Oi{constructor(n,e){this.value=n,this.children=e}toString(){return`TreeNode(${this.value})`}}function Gu(t){const n={};return t&&t.children.forEach(e=>n[e.value.outlet]=e),n}class qR extends jR{constructor(n,e){super(n),this.snapshot=e,mC(this,n)}toString(){return this.snapshot.toString()}}function KR(t,n){const e=function OK(t,n){const i=new $m([],{},{},"",{},ut,n,null,t.root,-1,{});return new YR("",new Oi(i,[]))}(t,n),r=new Io([new Vd("",{})]),s=new Io({}),o=new Io({}),i=new Io({}),a=new Io(""),l=new Hu(r,s,i,a,o,ut,n,e.root);return l.snapshot=e.root,new qR(new Oi(l,[]),e)}class Hu{constructor(n,e,r,s,o,i,a,l){this.url=n,this.params=e,this.queryParams=r,this.fragment=s,this.data=o,this.outlet=i,this.component=a,this.title=this.data?.pipe(Nt(u=>u[Ld]))??je(void 0),this._futureSnapshot=l}get routeConfig(){return this._futureSnapshot.routeConfig}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap||(this._paramMap=this.params.pipe(Nt(n=>Bu(n)))),this._paramMap}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=this.queryParams.pipe(Nt(n=>Bu(n)))),this._queryParamMap}toString(){return this.snapshot?this.snapshot.toString():`Future(${this._futureSnapshot})`}}function XR(t,n="emptyOnly"){const e=t.pathFromRoot;let r=0;if("always"!==n)for(r=e.length-1;r>=1;){const s=e[r],o=e[r-1];if(s.routeConfig&&""===s.routeConfig.path)r--;else{if(o.component)break;r--}}return function $K(t){return t.reduce((n,e)=>({params:{...n.params,...e.params},data:{...n.data,...e.data},resolve:{...e.data,...n.resolve,...e.routeConfig?.data,...e._resolvedData}}),{params:{},data:{},resolve:{}})}(e.slice(r))}class $m{get title(){return this.data?.[Ld]}constructor(n,e,r,s,o,i,a,l,u,c,d){this.url=n,this.params=e,this.queryParams=r,this.fragment=s,this.data=o,this.outlet=i,this.component=a,this.routeConfig=l,this._urlSegment=u,this._lastPathIndex=c,this._resolve=d}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap||(this._paramMap=Bu(this.params)),this._paramMap}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=Bu(this.queryParams)),this._queryParamMap}toString(){return`Route(url:'${this.url.map(r=>r.toString()).join("/")}', path:'${this.routeConfig?this.routeConfig.path:""}')`}}class YR extends jR{constructor(n,e){super(e),this.url=n,mC(this,e)}toString(){return ZR(this._root)}}function mC(t,n){n.value._routerState=t,n.children.forEach(e=>mC(t,e))}function ZR(t){const n=t.children.length>0?` { ${t.children.map(ZR).join(", ")} } `:"";return`${t.value}${n}`}function gC(t){if(t.snapshot){const n=t.snapshot,e=t._futureSnapshot;t.snapshot=e,Qo(n.queryParams,e.queryParams)||t.queryParams.next(e.queryParams),n.fragment!==e.fragment&&t.fragment.next(e.fragment),Qo(n.params,e.params)||t.params.next(e.params),function Z8(t,n){if(t.length!==n.length)return!1;for(let e=0;e<t.length;++e)if(!Qo(t[e],n[e]))return!1;return!0}(n.url,e.url)||t.url.next(e.url),Qo(n.data,e.data)||t.data.next(e.data)}else t.snapshot=t._futureSnapshot,t.data.next(t._futureSnapshot.data)}function yC(t,n){const e=Qo(t.params,n.params)&&function tK(t,n){return dl(t,n)&&t.every((e,r)=>Qo(e.parameters,n[r].parameters))}(t.url,n.url);return e&&!(!t.parent!=!n.parent)&&(!t.parent||yC(t.parent,n.parent))}function Hd(t,n,e){if(e&&t.shouldReuseRoute(n.value,e.value.snapshot)){const r=e.value;r._futureSnapshot=n.value;const s=function VK(t,n,e){return n.children.map(r=>{for(const s of e.children)if(t.shouldReuseRoute(r.value,s.value.snapshot))return Hd(t,r,s);return Hd(t,r)})}(t,n,e);return new Oi(r,s)}{if(t.shouldAttach(n.value)){const o=t.retrieve(n.value);if(null!==o){const i=o.route;return i.value._futureSnapshot=n.value,i.children=n.children.map(a=>Hd(t,a)),i}}const r=function BK(t){return new Hu(new Io(t.url),new Io(t.params),new Io(t.queryParams),new Io(t.fragment),new Io(t.data),t.outlet,t.component,t)}(n.value),s=n.children.map(o=>Hd(t,o));return new Oi(r,s)}}const bC="ngNavigationCancelingError";function QR(t,n){const{redirectTo:e,navigationBehaviorOptions:r}=hl(n)?{redirectTo:n,navigationBehaviorOptions:void 0}:n,s=JR(!1,0,n);return s.url=e,s.navigationBehaviorOptions=r,s}function JR(t,n,e){const r=new Error("NavigationCancelingError: "+(t||""));return r[bC]=!0,r.cancellationCode=n,e&&(r.url=e),r}function e2(t){return t2(t)&&hl(t.url)}function t2(t){return t&&t[bC]}class zK{constructor(){this.outlet=null,this.route=null,this.resolver=null,this.injector=null,this.children=new jd,this.attachRef=null}}let jd=(()=>{class t{constructor(){this.contexts=new Map}onChildOutletCreated(e,r){const s=this.getOrCreateContext(e);s.outlet=r,this.contexts.set(e,s)}onChildOutletDestroyed(e){const r=this.getContext(e);r&&(r.outlet=null,r.attachRef=null)}onOutletDeactivated(){const e=this.contexts;return this.contexts=new Map,e}onOutletReAttached(e){this.contexts=e}getOrCreateContext(e){let r=this.getContext(e);return r||(r=new zK,this.contexts.set(e,r)),r}getContext(e){return this.contexts.get(e)||null}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=We({token:t,factory:t.\u0275fac,providedIn:"root"}),t})();const Lm=!1;let n2=(()=>{class t{constructor(){this.activated=null,this._activatedRoute=null,this.name=ut,this.activateEvents=new _t,this.deactivateEvents=new _t,this.attachEvents=new _t,this.detachEvents=new _t,this.parentContexts=kt(jd),this.location=kt(Qs),this.changeDetector=kt(Nd),this.environmentInjector=kt(Di)}ngOnChanges(e){if(e.name){const{firstChange:r,previousValue:s}=e.name;if(r)return;this.isTrackedInParentContexts(s)&&(this.deactivate(),this.parentContexts.onChildOutletDestroyed(s)),this.initializeOutletWithName()}}ngOnDestroy(){this.isTrackedInParentContexts(this.name)&&this.parentContexts.onChildOutletDestroyed(this.name)}isTrackedInParentContexts(e){return this.parentContexts.getContext(e)?.outlet===this}ngOnInit(){this.initializeOutletWithName()}initializeOutletWithName(){if(this.parentContexts.onChildOutletCreated(this.name,this),this.activated)return;const e=this.parentContexts.getContext(this.name);e?.route&&(e.attachRef?this.attach(e.attachRef,e.route):this.activateWith(e.route,e.injector))}get isActivated(){return!!this.activated}get component(){if(!this.activated)throw new ce(4012,Lm);return this.activated.instance}get activatedRoute(){if(!this.activated)throw new ce(4012,Lm);return this._activatedRoute}get activatedRouteData(){return this._activatedRoute?this._activatedRoute.snapshot.data:{}}detach(){if(!this.activated)throw new ce(4012,Lm);this.location.detach();const e=this.activated;return this.activated=null,this._activatedRoute=null,this.detachEvents.emit(e.instance),e}attach(e,r){this.activated=e,this._activatedRoute=r,this.location.insert(e.hostView),this.attachEvents.emit(e.instance)}deactivate(){if(this.activated){const e=this.component;this.activated.destroy(),this.activated=null,this._activatedRoute=null,this.deactivateEvents.emit(e)}}activateWith(e,r){if(this.isActivated)throw new ce(4013,Lm);this._activatedRoute=e;const s=this.location,i=e.snapshot.component,a=this.parentContexts.getOrCreateContext(this.name).children,l=new UK(e,a,s.injector);if(r&&function WK(t){return!!t.resolveComponentFactory}(r)){const u=r.resolveComponentFactory(i);this.activated=s.createComponent(u,s.length,l)}else this.activated=s.createComponent(i,{index:s.length,injector:l,environmentInjector:r??this.environmentInjector});this.changeDetector.markForCheck(),this.activateEvents.emit(this.activated.instance)}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275dir=Ze({type:t,selectors:[["router-outlet"]],inputs:{name:"name"},outputs:{activateEvents:"activate",deactivateEvents:"deactivate",attachEvents:"attach",detachEvents:"detach"},exportAs:["outlet"],standalone:!0,features:[Es]}),t})();class UK{constructor(n,e,r){this.route=n,this.childContexts=e,this.parent=r}get(n,e){return n===Hu?this.route:n===jd?this.childContexts:this.parent.get(n,e)}}let vC=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275cmp=ja({type:t,selectors:[["ng-component"]],standalone:!0,features:[ok],decls:1,vars:0,template:function(e,r){1&e&&Vt(0,"router-outlet")},dependencies:[n2],encapsulation:2}),t})();function r2(t,n){return t.providers&&!t._injector&&(t._injector=em(t.providers,n,`Route: ${t.path}`)),t._injector??n}function wC(t){const n=t.children&&t.children.map(wC),e=n?{...t,children:n}:{...t};return!e.component&&!e.loadComponent&&(n||e.loadChildren)&&e.outlet&&e.outlet!==ut&&(e.component=vC),e}function to(t){return t.outlet||ut}function s2(t,n){const e=t.filter(r=>to(r)===n);return e.push(...t.filter(r=>to(r)!==n)),e}function qd(t){if(!t)return null;if(t.routeConfig?._injector)return t.routeConfig._injector;for(let n=t.parent;n;n=n.parent){const e=n.routeConfig;if(e?._loadedInjector)return e._loadedInjector;if(e?._injector)return e._injector}return null}class KK{constructor(n,e,r,s){this.routeReuseStrategy=n,this.futureState=e,this.currState=r,this.forwardEvent=s}activate(n){const e=this.futureState._root,r=this.currState?this.currState._root:null;this.deactivateChildRoutes(e,r,n),gC(this.futureState.root),this.activateChildRoutes(e,r,n)}deactivateChildRoutes(n,e,r){const s=Gu(e);n.children.forEach(o=>{const i=o.value.outlet;this.deactivateRoutes(o,s[i],r),delete s[i]}),Tr(s,(o,i)=>{this.deactivateRouteAndItsChildren(o,r)})}deactivateRoutes(n,e,r){const s=n.value,o=e?e.value:null;if(s===o)if(s.component){const i=r.getContext(s.outlet);i&&this.deactivateChildRoutes(n,e,i.children)}else this.deactivateChildRoutes(n,e,r);else o&&this.deactivateRouteAndItsChildren(e,r)}deactivateRouteAndItsChildren(n,e){n.value.component&&this.routeReuseStrategy.shouldDetach(n.value.snapshot)?this.detachAndStoreRouteSubtree(n,e):this.deactivateRouteAndOutlet(n,e)}detachAndStoreRouteSubtree(n,e){const r=e.getContext(n.value.outlet),s=r&&n.value.component?r.children:e,o=Gu(n);for(const i of Object.keys(o))this.deactivateRouteAndItsChildren(o[i],s);if(r&&r.outlet){const i=r.outlet.detach(),a=r.children.onOutletDeactivated();this.routeReuseStrategy.store(n.value.snapshot,{componentRef:i,route:n,contexts:a})}}deactivateRouteAndOutlet(n,e){const r=e.getContext(n.value.outlet),s=r&&n.value.component?r.children:e,o=Gu(n);for(const i of Object.keys(o))this.deactivateRouteAndItsChildren(o[i],s);r&&r.outlet&&(r.outlet.deactivate(),r.children.onOutletDeactivated(),r.attachRef=null,r.resolver=null,r.route=null)}activateChildRoutes(n,e,r){const s=Gu(e);n.children.forEach(o=>{this.activateRoutes(o,s[o.value.outlet],r),this.forwardEvent(new kK(o.value.snapshot))}),n.children.length&&this.forwardEvent(new EK(n.value.snapshot))}activateRoutes(n,e,r){const s=n.value,o=e?e.value:null;if(gC(s),s===o)if(s.component){const i=r.getOrCreateContext(s.outlet);this.activateChildRoutes(n,e,i.children)}else this.activateChildRoutes(n,e,r);else if(s.component){const i=r.getOrCreateContext(s.outlet);if(this.routeReuseStrategy.shouldAttach(s.snapshot)){const a=this.routeReuseStrategy.retrieve(s.snapshot);this.routeReuseStrategy.store(s.snapshot,null),i.children.onOutletReAttached(a.contexts),i.attachRef=a.componentRef,i.route=a.route.value,i.outlet&&i.outlet.attach(a.componentRef,a.route.value),gC(a.route.value),this.activateChildRoutes(n,null,i.children)}else{const a=qd(s.snapshot),l=a?.get(yu)??null;i.attachRef=null,i.route=s,i.resolver=l,i.injector=a,i.outlet&&i.outlet.activateWith(s,i.injector),this.activateChildRoutes(n,null,i.children)}}else this.activateChildRoutes(n,null,r)}}class o2{constructor(n){this.path=n,this.route=this.path[this.path.length-1]}}class Vm{constructor(n,e){this.component=n,this.route=e}}function XK(t,n,e){const r=t._root;return Kd(r,n?n._root:null,e,[r.value])}function ju(t,n){const e=Symbol(),r=n.get(t,e);return r===e?"function"!=typeof t||function nz(t){return null!==ef(t)}(t)?n.get(t):t:r}function Kd(t,n,e,r,s={canDeactivateChecks:[],canActivateChecks:[]}){const o=Gu(n);return t.children.forEach(i=>{(function ZK(t,n,e,r,s={canDeactivateChecks:[],canActivateChecks:[]}){const o=t.value,i=n?n.value:null,a=e?e.getContext(t.value.outlet):null;if(i&&o.routeConfig===i.routeConfig){const l=function QK(t,n,e){if("function"==typeof e)return e(t,n);switch(e){case"pathParamsChange":return!dl(t.url,n.url);case"pathParamsOrQueryParamsChange":return!dl(t.url,n.url)||!Qo(t.queryParams,n.queryParams);case"always":return!0;case"paramsOrQueryParamsChange":return!yC(t,n)||!Qo(t.queryParams,n.queryParams);default:return!yC(t,n)}}(i,o,o.routeConfig.runGuardsAndResolvers);l?s.canActivateChecks.push(new o2(r)):(o.data=i.data,o._resolvedData=i._resolvedData),Kd(t,n,o.component?a?a.children:null:e,r,s),l&&a&&a.outlet&&a.outlet.isActivated&&s.canDeactivateChecks.push(new Vm(a.outlet.component,i))}else i&&Xd(n,a,s),s.canActivateChecks.push(new o2(r)),Kd(t,null,o.component?a?a.children:null:e,r,s)})(i,o[i.value.outlet],e,r.concat([i.value]),s),delete o[i.value.outlet]}),Tr(o,(i,a)=>Xd(i,e.getContext(a),s)),s}function Xd(t,n,e){const r=Gu(t),s=t.value;Tr(r,(o,i)=>{Xd(o,s.component?n?n.children.getContext(i):null:n,e)}),e.canDeactivateChecks.push(new Vm(s.component&&n&&n.outlet&&n.outlet.isActivated?n.outlet.component:null,s))}function Yd(t){return"function"==typeof t}function CC(t){return t instanceof Dm||"EmptyError"===t?.name}const Bm=Symbol("INITIAL_VALUE");function qu(){return Zo(t=>vR(t.map(n=>n.pipe($d(1),function G8(...t){const n=Bc(t);return yr((e,r)=>{(n?tC(t,e,n):tC(t,e)).subscribe(r)})}(Bm)))).pipe(Nt(n=>{for(const e of n)if(!0!==e){if(e===Bm)return Bm;if(!1===e||e instanceof aa)return e}return!0}),ra(n=>n!==Bm),$d(1)))}function i2(t){return function kn(...t){return Zr(t)}(Br(n=>{if(hl(n))throw QR(0,n)}),Nt(n=>!0===n))}const _C={matched:!1,consumedSegments:[],remainingSegments:[],parameters:{},positionalParamSegments:{}};function a2(t,n,e,r,s){const o=SC(t,n,e);return o.matched?function mX(t,n,e,r){const s=n.canMatch;return s&&0!==s.length?je(s.map(i=>{const a=ju(i,t);return ia(function sX(t){return t&&Yd(t.canMatch)}(a)?a.canMatch(n,e):t.runInContext(()=>a(n,e)))})).pipe(qu(),i2()):je(!0)}(r=r2(n,r),n,e).pipe(Nt(i=>!0===i?o:{..._C})):je(o)}function SC(t,n,e){if(""===n.path)return"full"===n.pathMatch&&(t.hasChildren()||e.length>0)?{..._C}:{matched:!0,consumedSegments:[],remainingSegments:e,parameters:{},positionalParamSegments:{}};const s=(n.matcher||Y8)(e,t,n);if(!s)return{..._C};const o={};Tr(s.posParams,(a,l)=>{o[l]=a.path});const i=s.consumed.length>0?{...o,...s.consumed[s.consumed.length-1].parameters}:o;return{matched:!0,consumedSegments:s.consumed,remainingSegments:e.slice(s.consumed.length),parameters:i,positionalParamSegments:s.posParams??{}}}function zm(t,n,e,r){if(e.length>0&&function bX(t,n,e){return e.some(r=>Um(t,n,r)&&to(r)!==ut)}(t,e,r)){const o=new St(n,function yX(t,n,e,r){const s={};s[ut]=r,r._sourceSegment=t,r._segmentIndexShift=n.length;for(const o of e)if(""===o.path&&to(o)!==ut){const i=new St([],{});i._sourceSegment=t,i._segmentIndexShift=n.length,s[to(o)]=i}return s}(t,n,r,new St(e,t.children)));return o._sourceSegment=t,o._segmentIndexShift=n.length,{segmentGroup:o,slicedSegments:[]}}if(0===e.length&&function vX(t,n,e){return e.some(r=>Um(t,n,r))}(t,e,r)){const o=new St(t.segments,function gX(t,n,e,r,s){const o={};for(const i of r)if(Um(t,e,i)&&!s[to(i)]){const a=new St([],{});a._sourceSegment=t,a._segmentIndexShift=n.length,o[to(i)]=a}return{...s,...o}}(t,n,e,r,t.children));return o._sourceSegment=t,o._segmentIndexShift=n.length,{segmentGroup:o,slicedSegments:e}}const s=new St(t.segments,t.children);return s._sourceSegment=t,s._segmentIndexShift=n.length,{segmentGroup:s,slicedSegments:e}}function Um(t,n,e){return(!(t.hasChildren()||n.length>0)||"full"!==e.pathMatch)&&""===e.path}function l2(t,n,e,r){return!!(to(t)===r||r!==ut&&Um(n,e,t))&&("**"===t.path||SC(n,t,e).matched)}function u2(t,n,e){return 0===n.length&&!t.children[e]}const Wm=!1;class Gm{constructor(n){this.segmentGroup=n||null}}class c2{constructor(n){this.urlTree=n}}function Zd(t){return Od(new Gm(t))}function d2(t){return Od(new c2(t))}class _X{constructor(n,e,r,s,o){this.injector=n,this.configLoader=e,this.urlSerializer=r,this.urlTree=s,this.config=o,this.allowRedirects=!0}apply(){const n=zm(this.urlTree.root,[],[],this.config).segmentGroup,e=new St(n.segments,n.children);return this.expandSegmentGroup(this.injector,this.config,e,ut).pipe(Nt(o=>this.createUrlTree(Mm(o),this.urlTree.queryParams,this.urlTree.fragment))).pipe(oa(o=>{if(o instanceof c2)return this.allowRedirects=!1,this.match(o.urlTree);throw o instanceof Gm?this.noMatchError(o):o}))}match(n){return this.expandSegmentGroup(this.injector,this.config,n.root,ut).pipe(Nt(s=>this.createUrlTree(Mm(s),n.queryParams,n.fragment))).pipe(oa(s=>{throw s instanceof Gm?this.noMatchError(s):s}))}noMatchError(n){return new ce(4002,Wm)}createUrlTree(n,e,r){const s=aC(n);return new aa(s,e,r)}expandSegmentGroup(n,e,r,s){return 0===r.segments.length&&r.hasChildren()?this.expandChildren(n,e,r).pipe(Nt(o=>new St([],o))):this.expandSegment(n,r,e,r.segments,s,!0)}expandChildren(n,e,r){const s=[];for(const o of Object.keys(r.children))"primary"===o?s.unshift(o):s.push(o);return Kn(s).pipe(cl(o=>{const i=r.children[o],a=s2(e,o);return this.expandSegmentGroup(n,a,i,o).pipe(Nt(l=>({segment:l,outlet:o})))}),SR((o,i)=>(o[i.outlet]=i.segment,o),{}),IR())}expandSegment(n,e,r,s,o,i){return Kn(r).pipe(cl(a=>this.expandSegmentAgainstRoute(n,e,r,a,s,o,i).pipe(oa(u=>{if(u instanceof Gm)return je(null);throw u}))),sa(a=>!!a),oa((a,l)=>{if(CC(a))return u2(e,s,o)?je(new St([],{})):Zd(e);throw a}))}expandSegmentAgainstRoute(n,e,r,s,o,i,a){return l2(s,e,o,i)?void 0===s.redirectTo?this.matchSegmentAgainstRoute(n,e,s,o,i):a&&this.allowRedirects?this.expandSegmentAgainstRouteUsingRedirect(n,e,r,s,o,i):Zd(e):Zd(e)}expandSegmentAgainstRouteUsingRedirect(n,e,r,s,o,i){return"**"===s.path?this.expandWildCardWithParamsAgainstRouteUsingRedirect(n,r,s,i):this.expandRegularSegmentAgainstRouteUsingRedirect(n,e,r,s,o,i)}expandWildCardWithParamsAgainstRouteUsingRedirect(n,e,r,s){const o=this.applyRedirectCommands([],r.redirectTo,{});return r.redirectTo.startsWith("/")?d2(o):this.lineralizeSegments(r,o).pipe(_r(i=>{const a=new St(i,{});return this.expandSegment(n,a,e,i,s,!1)}))}expandRegularSegmentAgainstRouteUsingRedirect(n,e,r,s,o,i){const{matched:a,consumedSegments:l,remainingSegments:u,positionalParamSegments:c}=SC(e,s,o);if(!a)return Zd(e);const d=this.applyRedirectCommands(l,s.redirectTo,c);return s.redirectTo.startsWith("/")?d2(d):this.lineralizeSegments(s,d).pipe(_r(h=>this.expandSegment(n,e,r,h.concat(u),i,!1)))}matchSegmentAgainstRoute(n,e,r,s,o){return"**"===r.path?(n=r2(r,n),r.loadChildren?(r._loadedRoutes?je({routes:r._loadedRoutes,injector:r._loadedInjector}):this.configLoader.loadChildren(n,r)).pipe(Nt(a=>(r._loadedRoutes=a.routes,r._loadedInjector=a.injector,new St(s,{})))):je(new St(s,{}))):a2(e,r,s,n).pipe(Zo(({matched:i,consumedSegments:a,remainingSegments:l})=>i?this.getChildConfig(n=r._injector??n,r,s).pipe(_r(c=>{const d=c.injector??n,h=c.routes,{segmentGroup:p,slicedSegments:f}=zm(e,a,l,h),g=new St(p.segments,p.children);if(0===f.length&&g.hasChildren())return this.expandChildren(d,h,g).pipe(Nt(v=>new St(a,v)));if(0===h.length&&0===f.length)return je(new St(a,{}));const m=to(r)===o;return this.expandSegment(d,g,h,f,m?ut:o,!0).pipe(Nt(b=>new St(a.concat(b.segments),b.children)))})):Zd(e)))}getChildConfig(n,e,r){return e.children?je({routes:e.children,injector:n}):e.loadChildren?void 0!==e._loadedRoutes?je({routes:e._loadedRoutes,injector:e._loadedInjector}):function fX(t,n,e,r){const s=n.canLoad;return void 0===s||0===s.length?je(!0):je(s.map(i=>{const a=ju(i,t);return ia(function eX(t){return t&&Yd(t.canLoad)}(a)?a.canLoad(n,e):t.runInContext(()=>a(n,e)))})).pipe(qu(),i2())}(n,e,r).pipe(_r(s=>s?this.configLoader.loadChildren(n,e).pipe(Br(o=>{e._loadedRoutes=o.routes,e._loadedInjector=o.injector})):function wX(t){return Od(JR(Wm,3))}())):je({routes:[],injector:n})}lineralizeSegments(n,e){let r=[],s=e.root;for(;;){if(r=r.concat(s.segments),0===s.numberOfChildren)return je(r);if(s.numberOfChildren>1||!s.children[ut])return n.redirectTo,Od(new ce(4e3,Wm));s=s.children[ut]}}applyRedirectCommands(n,e,r){return this.applyRedirectCreateUrlTree(e,this.urlSerializer.parse(e),n,r)}applyRedirectCreateUrlTree(n,e,r,s){const o=this.createSegmentGroup(n,e.root,r,s);return new aa(o,this.createQueryParams(e.queryParams,this.urlTree.queryParams),e.fragment)}createQueryParams(n,e){const r={};return Tr(n,(s,o)=>{if("string"==typeof s&&s.startsWith(":")){const a=s.substring(1);r[o]=e[a]}else r[o]=s}),r}createSegmentGroup(n,e,r,s){const o=this.createSegments(n,e.segments,r,s);let i={};return Tr(e.children,(a,l)=>{i[l]=this.createSegmentGroup(n,a,r,s)}),new St(o,i)}createSegments(n,e,r,s){return e.map(o=>o.path.startsWith(":")?this.findPosParam(n,o,s):this.findOrReturn(o,r))}findPosParam(n,e,r){const s=r[e.path.substring(1)];if(!s)throw new ce(4001,Wm);return s}findOrReturn(n,e){let r=0;for(const s of e){if(s.path===n.path)return e.splice(r),s;r++}return n}}class IX{}class EX{constructor(n,e,r,s,o,i,a){this.injector=n,this.rootComponentType=e,this.config=r,this.urlTree=s,this.url=o,this.paramsInheritanceStrategy=i,this.urlSerializer=a}recognize(){const n=zm(this.urlTree.root,[],[],this.config.filter(e=>void 0===e.redirectTo)).segmentGroup;return this.processSegmentGroup(this.injector,this.config,n,ut).pipe(Nt(e=>{if(null===e)return null;const r=new $m([],Object.freeze({}),Object.freeze({...this.urlTree.queryParams}),this.urlTree.fragment,{},ut,this.rootComponentType,null,this.urlTree.root,-1,{}),s=new Oi(r,e),o=new YR(this.url,s);return this.inheritParamsAndData(o._root),o}))}inheritParamsAndData(n){const e=n.value,r=XR(e,this.paramsInheritanceStrategy);e.params=Object.freeze(r.params),e.data=Object.freeze(r.data),n.children.forEach(s=>this.inheritParamsAndData(s))}processSegmentGroup(n,e,r,s){return 0===r.segments.length&&r.hasChildren()?this.processChildren(n,e,r):this.processSegment(n,e,r,r.segments,s)}processChildren(n,e,r){return Kn(Object.keys(r.children)).pipe(cl(s=>{const o=r.children[s],i=s2(e,s);return this.processSegmentGroup(n,i,o,s)}),SR((s,o)=>s&&o?(s.push(...o),s):null),function q8(t,n=!1){return yr((e,r)=>{let s=0;e.subscribe(sr(r,o=>{const i=t(o,s++);(i||n)&&r.next(o),!i&&r.complete()}))})}(s=>null!==s),Tm(null),IR(),Nt(s=>{if(null===s)return null;const o=p2(s);return function NX(t){t.sort((n,e)=>n.value.outlet===ut?-1:e.value.outlet===ut?1:n.value.outlet.localeCompare(e.value.outlet))}(o),o}))}processSegment(n,e,r,s,o){return Kn(e).pipe(cl(i=>this.processSegmentAgainstRoute(i._injector??n,i,r,s,o)),sa(i=>!!i),oa(i=>{if(CC(i))return u2(r,s,o)?je([]):je(null);throw i}))}processSegmentAgainstRoute(n,e,r,s,o){if(e.redirectTo||!l2(e,r,s,o))return je(null);let i;if("**"===e.path){const a=s.length>0?ER(s).parameters:{},l=m2(r)+s.length;i=je({snapshot:new $m(s,a,Object.freeze({...this.urlTree.queryParams}),this.urlTree.fragment,g2(e),to(e),e.component??e._loadedComponent??null,e,f2(r),l,y2(e)),consumedSegments:[],remainingSegments:[]})}else i=a2(r,e,s,n).pipe(Nt(({matched:a,consumedSegments:l,remainingSegments:u,parameters:c})=>{if(!a)return null;const d=m2(r)+l.length;return{snapshot:new $m(l,c,Object.freeze({...this.urlTree.queryParams}),this.urlTree.fragment,g2(e),to(e),e.component??e._loadedComponent??null,e,f2(r),d,y2(e)),consumedSegments:l,remainingSegments:u}}));return i.pipe(Zo(a=>{if(null===a)return je(null);const{snapshot:l,consumedSegments:u,remainingSegments:c}=a;n=e._injector??n;const d=e._loadedInjector??n,h=function kX(t){return t.children?t.children:t.loadChildren?t._loadedRoutes:[]}(e),{segmentGroup:p,slicedSegments:f}=zm(r,u,c,h.filter(m=>void 0===m.redirectTo));if(0===f.length&&p.hasChildren())return this.processChildren(d,h,p).pipe(Nt(m=>null===m?null:[new Oi(l,m)]));if(0===h.length&&0===f.length)return je([new Oi(l,[])]);const g=to(e)===o;return this.processSegment(d,h,p,f,g?ut:o).pipe(Nt(m=>null===m?null:[new Oi(l,m)]))}))}}function AX(t){const n=t.value.routeConfig;return n&&""===n.path&&void 0===n.redirectTo}function p2(t){const n=[],e=new Set;for(const r of t){if(!AX(r)){n.push(r);continue}const s=n.find(o=>r.value.routeConfig===o.value.routeConfig);void 0!==s?(s.children.push(...r.children),e.add(s)):n.push(r)}for(const r of e){const s=p2(r.children);n.push(new Oi(r.value,s))}return n.filter(r=>!e.has(r))}function f2(t){let n=t;for(;n._sourceSegment;)n=n._sourceSegment;return n}function m2(t){let n=t,e=n._segmentIndexShift??0;for(;n._sourceSegment;)n=n._sourceSegment,e+=n._segmentIndexShift??0;return e-1}function g2(t){return t.data||{}}function y2(t){return t.resolve||{}}function b2(t){return"string"==typeof t.title||null===t.title}function IC(t){return Zo(n=>{const e=t(n);return e?Kn(e).pipe(Nt(()=>n)):je(n)})}const Ku=new Le("ROUTES");let DC=(()=>{class t{constructor(e,r){this.injector=e,this.compiler=r,this.componentLoaders=new WeakMap,this.childrenLoaders=new WeakMap}loadComponent(e){if(this.componentLoaders.get(e))return this.componentLoaders.get(e);if(e._loadedComponent)return je(e._loadedComponent);this.onLoadStartListener&&this.onLoadStartListener(e);const r=ia(e.loadComponent()).pipe(Nt(x2),Br(o=>{this.onLoadEndListener&&this.onLoadEndListener(e),e._loadedComponent=o}),sC(()=>{this.componentLoaders.delete(e)})),s=new CR(r,()=>new yi).pipe(nC());return this.componentLoaders.set(e,s),s}loadChildren(e,r){if(this.childrenLoaders.get(r))return this.childrenLoaders.get(r);if(r._loadedRoutes)return je({routes:r._loadedRoutes,injector:r._loadedInjector});this.onLoadStartListener&&this.onLoadStartListener(r);const o=this.loadModuleFactoryOrRoutes(r.loadChildren).pipe(Nt(a=>{this.onLoadEndListener&&this.onLoadEndListener(r);let l,u,c=!1;Array.isArray(a)?u=a:(l=a.create(e).injector,u=TR(l.get(Ku,[],Ye.Self|Ye.Optional)));return{routes:u.map(wC),injector:l}}),sC(()=>{this.childrenLoaders.delete(r)})),i=new CR(o,()=>new yi).pipe(nC());return this.childrenLoaders.set(r,i),i}loadModuleFactoryOrRoutes(e){return ia(e()).pipe(Nt(x2),_r(s=>s instanceof rk||Array.isArray(s)?je(s):Kn(this.compiler.compileModuleAsync(s))))}}return t.\u0275fac=function(e){return new(e||t)(Ge(ts),Ge(jk))},t.\u0275prov=We({token:t,factory:t.\u0275fac,providedIn:"root"}),t})();function x2(t){return function BX(t){return t&&"object"==typeof t&&"default"in t}(t)?t.default:t}let jm=(()=>{class t{get hasRequestedNavigation(){return 0!==this.navigationId}constructor(){this.currentNavigation=null,this.lastSuccessfulNavigation=null,this.events=new yi,this.configLoader=kt(DC),this.environmentInjector=kt(Di),this.urlSerializer=kt(Bd),this.rootContexts=kt(jd),this.navigationId=0,this.afterPreactivation=()=>je(void 0),this.rootComponentType=null,this.configLoader.onLoadEndListener=s=>this.events.next(new DK(s)),this.configLoader.onLoadStartListener=s=>this.events.next(new IK(s))}complete(){this.transitions?.complete()}handleNavigationRequest(e){const r=++this.navigationId;this.transitions?.next({...this.transitions.value,...e,id:r})}setupNavigations(e){return this.transitions=new Io({id:0,targetPageId:0,currentUrlTree:e.currentUrlTree,currentRawUrl:e.currentUrlTree,extractedUrl:e.urlHandlingStrategy.extract(e.currentUrlTree),urlAfterRedirects:e.urlHandlingStrategy.extract(e.currentUrlTree),rawUrl:e.currentUrlTree,extras:{},resolve:null,reject:null,promise:Promise.resolve(!0),source:Gd,restoredState:null,currentSnapshot:e.routerState.snapshot,targetSnapshot:null,currentRouterState:e.routerState,targetRouterState:null,guards:{canActivateChecks:[],canDeactivateChecks:[]},guardsResult:null}),this.transitions.pipe(ra(r=>0!==r.id),Nt(r=>({...r,extractedUrl:e.urlHandlingStrategy.extract(r.rawUrl)})),Zo(r=>{let s=!1,o=!1;return je(r).pipe(Br(i=>{this.currentNavigation={id:i.id,initialUrl:i.rawUrl,extractedUrl:i.extractedUrl,trigger:i.source,extras:i.extras,previousNavigation:this.lastSuccessfulNavigation?{...this.lastSuccessfulNavigation,previousNavigation:null}:null}}),Zo(i=>{const a=e.browserUrlTree.toString(),l=!e.navigated||i.extractedUrl.toString()!==a||a!==e.currentUrlTree.toString();if(!l&&"reload"!==(i.extras.onSameUrlNavigation??e.onSameUrlNavigation)){const c="";return this.events.next(new Om(i.id,e.serializeUrl(r.rawUrl),c,0)),e.rawUrlTree=i.rawUrl,i.resolve(null),Bo}if(e.urlHandlingStrategy.shouldProcessUrl(i.rawUrl))return w2(i.source)&&(e.browserUrlTree=i.extractedUrl),je(i).pipe(Zo(c=>{const d=this.transitions?.getValue();return this.events.next(new dC(c.id,this.urlSerializer.serialize(c.extractedUrl),c.source,c.restoredState)),d!==this.transitions?.getValue()?Bo:Promise.resolve(c)}),function SX(t,n,e,r){return Zo(s=>function CX(t,n,e,r,s){return new _X(t,n,e,r,s).apply()}(t,n,e,s.extractedUrl,r).pipe(Nt(o=>({...s,urlAfterRedirects:o}))))}(this.environmentInjector,this.configLoader,this.urlSerializer,e.config),Br(c=>{this.currentNavigation={...this.currentNavigation,finalUrl:c.urlAfterRedirects},r.urlAfterRedirects=c.urlAfterRedirects}),function FX(t,n,e,r,s){return _r(o=>function TX(t,n,e,r,s,o,i="emptyOnly"){return new EX(t,n,e,r,s,i,o).recognize().pipe(Zo(a=>null===a?function DX(t){return new xt(n=>n.error(t))}(new IX):je(a)))}(t,n,e,o.urlAfterRedirects,r.serialize(o.urlAfterRedirects),r,s).pipe(Nt(i=>({...o,targetSnapshot:i}))))}(this.environmentInjector,this.rootComponentType,e.config,this.urlSerializer,e.paramsInheritanceStrategy),Br(c=>{if(r.targetSnapshot=c.targetSnapshot,"eager"===e.urlUpdateStrategy){if(!c.extras.skipLocationChange){const h=e.urlHandlingStrategy.merge(c.urlAfterRedirects,c.rawUrl);e.setBrowserUrl(h,c)}e.browserUrlTree=c.urlAfterRedirects}const d=new xK(c.id,this.urlSerializer.serialize(c.extractedUrl),this.urlSerializer.serialize(c.urlAfterRedirects),c.targetSnapshot);this.events.next(d)}));if(l&&e.urlHandlingStrategy.shouldProcessUrl(e.rawUrlTree)){const{id:c,extractedUrl:d,source:h,restoredState:p,extras:f}=i,g=new dC(c,this.urlSerializer.serialize(d),h,p);this.events.next(g);const m=KR(d,this.rootComponentType).snapshot;return je(r={...i,targetSnapshot:m,urlAfterRedirects:d,extras:{...f,skipLocationChange:!1,replaceUrl:!1}})}{const c="";return this.events.next(new Om(i.id,e.serializeUrl(r.extractedUrl),c,1)),e.rawUrlTree=i.rawUrl,i.resolve(null),Bo}}),Br(i=>{const a=new wK(i.id,this.urlSerializer.serialize(i.extractedUrl),this.urlSerializer.serialize(i.urlAfterRedirects),i.targetSnapshot);this.events.next(a)}),Nt(i=>r={...i,guards:XK(i.targetSnapshot,i.currentSnapshot,this.rootContexts)}),function iX(t,n){return _r(e=>{const{targetSnapshot:r,currentSnapshot:s,guards:{canActivateChecks:o,canDeactivateChecks:i}}=e;return 0===i.length&&0===o.length?je({...e,guardsResult:!0}):function aX(t,n,e,r){return Kn(t).pipe(_r(s=>function pX(t,n,e,r,s){const o=n&&n.routeConfig?n.routeConfig.canDeactivate:null;return o&&0!==o.length?je(o.map(a=>{const l=qd(n)??s,u=ju(a,l);return ia(function rX(t){return t&&Yd(t.canDeactivate)}(u)?u.canDeactivate(t,n,e,r):l.runInContext(()=>u(t,n,e,r))).pipe(sa())})).pipe(qu()):je(!0)}(s.component,s.route,e,n,r)),sa(s=>!0!==s,!0))}(i,r,s,t).pipe(_r(a=>a&&function JK(t){return"boolean"==typeof t}(a)?function lX(t,n,e,r){return Kn(n).pipe(cl(s=>tC(function cX(t,n){return null!==t&&n&&n(new TK(t)),je(!0)}(s.route.parent,r),function uX(t,n){return null!==t&&n&&n(new NK(t)),je(!0)}(s.route,r),function hX(t,n,e){const r=n[n.length-1],o=n.slice(0,n.length-1).reverse().map(i=>function YK(t){const n=t.routeConfig?t.routeConfig.canActivateChild:null;return n&&0!==n.length?{node:t,guards:n}:null}(i)).filter(i=>null!==i).map(i=>wR(()=>je(i.guards.map(l=>{const u=qd(i.node)??e,c=ju(l,u);return ia(function nX(t){return t&&Yd(t.canActivateChild)}(c)?c.canActivateChild(r,t):u.runInContext(()=>c(r,t))).pipe(sa())})).pipe(qu())));return je(o).pipe(qu())}(t,s.path,e),function dX(t,n,e){const r=n.routeConfig?n.routeConfig.canActivate:null;if(!r||0===r.length)return je(!0);const s=r.map(o=>wR(()=>{const i=qd(n)??e,a=ju(o,i);return ia(function tX(t){return t&&Yd(t.canActivate)}(a)?a.canActivate(n,t):i.runInContext(()=>a(n,t))).pipe(sa())}));return je(s).pipe(qu())}(t,s.route,e))),sa(s=>!0!==s,!0))}(r,o,t,n):je(a)),Nt(a=>({...e,guardsResult:a})))})}(this.environmentInjector,i=>this.events.next(i)),Br(i=>{if(r.guardsResult=i.guardsResult,hl(i.guardsResult))throw QR(0,i.guardsResult);const a=new CK(i.id,this.urlSerializer.serialize(i.extractedUrl),this.urlSerializer.serialize(i.urlAfterRedirects),i.targetSnapshot,!!i.guardsResult);this.events.next(a)}),ra(i=>!!i.guardsResult||(e.restoreHistory(i),this.cancelNavigationTransition(i,"",3),!1)),IC(i=>{if(i.guards.canActivateChecks.length)return je(i).pipe(Br(a=>{const l=new _K(a.id,this.urlSerializer.serialize(a.extractedUrl),this.urlSerializer.serialize(a.urlAfterRedirects),a.targetSnapshot);this.events.next(l)}),Zo(a=>{let l=!1;return je(a).pipe(function MX(t,n){return _r(e=>{const{targetSnapshot:r,guards:{canActivateChecks:s}}=e;if(!s.length)return je(e);let o=0;return Kn(s).pipe(cl(i=>function PX(t,n,e,r){const s=t.routeConfig,o=t._resolve;return void 0!==s?.title&&!b2(s)&&(o[Ld]=s.title),function OX(t,n,e,r){const s=function $X(t){return[...Object.keys(t),...Object.getOwnPropertySymbols(t)]}(t);if(0===s.length)return je({});const o={};return Kn(s).pipe(_r(i=>function LX(t,n,e,r){const s=qd(n)??r,o=ju(t,s);return ia(o.resolve?o.resolve(n,e):s.runInContext(()=>o(n,e)))}(t[i],n,e,r).pipe(sa(),Br(a=>{o[i]=a}))),rC(1),function K8(t){return Nt(()=>t)}(o),oa(i=>CC(i)?Bo:Od(i)))}(o,t,n,r).pipe(Nt(i=>(t._resolvedData=i,t.data=XR(t,e).resolve,s&&b2(s)&&(t.data[Ld]=s.title),null)))}(i.route,r,t,n)),Br(()=>o++),rC(1),_r(i=>o===s.length?je(e):Bo))})}(e.paramsInheritanceStrategy,this.environmentInjector),Br({next:()=>l=!0,complete:()=>{l||(e.restoreHistory(a),this.cancelNavigationTransition(a,"",2))}}))}),Br(a=>{const l=new SK(a.id,this.urlSerializer.serialize(a.extractedUrl),this.urlSerializer.serialize(a.urlAfterRedirects),a.targetSnapshot);this.events.next(l)}))}),IC(i=>{const a=l=>{const u=[];l.routeConfig?.loadComponent&&!l.routeConfig._loadedComponent&&u.push(this.configLoader.loadComponent(l.routeConfig).pipe(Br(c=>{l.component=c}),Nt(()=>{})));for(const c of l.children)u.push(...a(c));return u};return vR(a(i.targetSnapshot.root)).pipe(Tm(),$d(1))}),IC(()=>this.afterPreactivation()),Nt(i=>{const a=function LK(t,n,e){const r=Hd(t,n._root,e?e._root:void 0);return new qR(r,n)}(e.routeReuseStrategy,i.targetSnapshot,i.currentRouterState);return r={...i,targetRouterState:a}}),Br(i=>{e.currentUrlTree=i.urlAfterRedirects,e.rawUrlTree=e.urlHandlingStrategy.merge(i.urlAfterRedirects,i.rawUrl),e.routerState=i.targetRouterState,"deferred"===e.urlUpdateStrategy&&(i.extras.skipLocationChange||e.setBrowserUrl(e.rawUrlTree,i),e.browserUrlTree=i.urlAfterRedirects)}),((t,n,e)=>Nt(r=>(new KK(n,r.targetRouterState,r.currentRouterState,e).activate(t),r)))(this.rootContexts,e.routeReuseStrategy,i=>this.events.next(i)),Br({next:i=>{s=!0,this.lastSuccessfulNavigation=this.currentNavigation,e.navigated=!0,this.events.next(new pl(i.id,this.urlSerializer.serialize(i.extractedUrl),this.urlSerializer.serialize(e.currentUrlTree))),e.titleStrategy?.updateTitle(i.targetRouterState.snapshot),i.resolve(!0)},complete:()=>{s=!0}}),sC(()=>{s||o||this.cancelNavigationTransition(r,"",1),this.currentNavigation?.id===r.id&&(this.currentNavigation=null)}),oa(i=>{if(o=!0,t2(i)){e2(i)||(e.navigated=!0,e.restoreHistory(r,!0));const a=new Pm(r.id,this.urlSerializer.serialize(r.extractedUrl),i.message,i.cancellationCode);if(this.events.next(a),e2(i)){const l=e.urlHandlingStrategy.merge(i.url,e.rawUrlTree),u={skipLocationChange:r.extras.skipLocationChange,replaceUrl:"eager"===e.urlUpdateStrategy||w2(r.source)};e.scheduleNavigation(l,Gd,null,u,{resolve:r.resolve,reject:r.reject,promise:r.promise})}else r.resolve(!1)}else{e.restoreHistory(r,!0);const a=new hC(r.id,this.urlSerializer.serialize(r.extractedUrl),i,r.targetSnapshot??void 0);this.events.next(a);try{r.resolve(e.errorHandler(i))}catch(l){r.reject(l)}}return Bo}))}))}cancelNavigationTransition(e,r,s){const o=new Pm(e.id,this.urlSerializer.serialize(e.extractedUrl),r,s);this.events.next(o),e.resolve(!1)}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=We({token:t,factory:t.\u0275fac,providedIn:"root"}),t})();function w2(t){return t!==Gd}let C2=(()=>{class t{buildTitle(e){let r,s=e.root;for(;void 0!==s;)r=this.getResolvedTitleForRoute(s)??r,s=s.children.find(o=>o.outlet===ut);return r}getResolvedTitleForRoute(e){return e.data[Ld]}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=We({token:t,factory:function(){return kt(zX)},providedIn:"root"}),t})(),zX=(()=>{class t extends C2{constructor(e){super(),this.title=e}updateTitle(e){const r=this.buildTitle(e);void 0!==r&&this.title.setTitle(r)}}return t.\u0275fac=function(e){return new(e||t)(Ge(pR))},t.\u0275prov=We({token:t,factory:t.\u0275fac,providedIn:"root"}),t})(),UX=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=We({token:t,factory:function(){return kt(GX)},providedIn:"root"}),t})();class WX{shouldDetach(n){return!1}store(n,e){}shouldAttach(n){return!1}retrieve(n){return null}shouldReuseRoute(n,e){return n.routeConfig===e.routeConfig}}let GX=(()=>{class t extends WX{}return t.\u0275fac=function(){let n;return function(r){return(n||(n=Dr(t)))(r||t)}}(),t.\u0275prov=We({token:t,factory:t.\u0275fac,providedIn:"root"}),t})();const qm=new Le("",{providedIn:"root",factory:()=>({})});let jX=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=We({token:t,factory:function(){return kt(qX)},providedIn:"root"}),t})(),qX=(()=>{class t{shouldProcessUrl(e){return!0}extract(e){return e}merge(e,r){return e}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=We({token:t,factory:t.\u0275fac,providedIn:"root"}),t})();function KX(t){throw t}function XX(t,n,e){return n.parse("/")}const YX={paths:"exact",fragment:"ignored",matrixParams:"ignored",queryParams:"exact"},ZX={paths:"subset",fragment:"ignored",matrixParams:"ignored",queryParams:"subset"};let Fs=(()=>{class t{get navigationId(){return this.navigationTransitions.navigationId}get browserPageId(){return this.location.getState()?.\u0275routerPageId}get events(){return this.navigationTransitions.events}constructor(){this.disposed=!1,this.currentPageId=0,this.console=kt(Cq),this.isNgZoneEnabled=!1,this.options=kt(qm,{optional:!0})||{},this.errorHandler=this.options.errorHandler||KX,this.malformedUriErrorHandler=this.options.malformedUriErrorHandler||XX,this.navigated=!1,this.lastSuccessfulId=-1,this.urlHandlingStrategy=kt(jX),this.routeReuseStrategy=kt(UX),this.urlCreationStrategy=kt(PK),this.titleStrategy=kt(C2),this.onSameUrlNavigation=this.options.onSameUrlNavigation||"ignore",this.paramsInheritanceStrategy=this.options.paramsInheritanceStrategy||"emptyOnly",this.urlUpdateStrategy=this.options.urlUpdateStrategy||"deferred",this.canceledNavigationResolution=this.options.canceledNavigationResolution||"replace",this.config=TR(kt(Ku,{optional:!0})??[]),this.navigationTransitions=kt(jm),this.urlSerializer=kt(Bd),this.location=kt(Ew),this.isNgZoneEnabled=kt(Fn)instanceof Fn&&Fn.isInAngularZone(),this.resetConfig(this.config),this.currentUrlTree=new aa,this.rawUrlTree=this.currentUrlTree,this.browserUrlTree=this.currentUrlTree,this.routerState=KR(this.currentUrlTree,null),this.navigationTransitions.setupNavigations(this).subscribe(e=>{this.lastSuccessfulId=e.id,this.currentPageId=e.targetPageId},e=>{this.console.warn(`Unhandled Navigation Error: ${e}`)})}resetRootComponentType(e){this.routerState.root.component=e,this.navigationTransitions.rootComponentType=e}initialNavigation(){if(this.setUpLocationChangeListener(),!this.navigationTransitions.hasRequestedNavigation){const e=this.location.getState();this.navigateToSyncWithBrowser(this.location.path(!0),Gd,e)}}setUpLocationChangeListener(){this.locationSubscription||(this.locationSubscription=this.location.subscribe(e=>{const r="popstate"===e.type?"popstate":"hashchange";"popstate"===r&&setTimeout(()=>{this.navigateToSyncWithBrowser(e.url,r,e.state)},0)}))}navigateToSyncWithBrowser(e,r,s){const o={replaceUrl:!0},i=s?.navigationId?s:null;if(s){const l={...s};delete l.navigationId,delete l.\u0275routerPageId,0!==Object.keys(l).length&&(o.state=l)}const a=this.parseUrl(e);this.scheduleNavigation(a,r,i,o)}get url(){return this.serializeUrl(this.currentUrlTree)}getCurrentNavigation(){return this.navigationTransitions.currentNavigation}resetConfig(e){this.config=e.map(wC),this.navigated=!1,this.lastSuccessfulId=-1}ngOnDestroy(){this.dispose()}dispose(){this.navigationTransitions.complete(),this.locationSubscription&&(this.locationSubscription.unsubscribe(),this.locationSubscription=void 0),this.disposed=!0}createUrlTree(e,r={}){const{relativeTo:s,queryParams:o,fragment:i,queryParamsHandling:a,preserveFragment:l}=r,u=l?this.currentUrlTree.fragment:i;let c=null;switch(a){case"merge":c={...this.currentUrlTree.queryParams,...o};break;case"preserve":c=this.currentUrlTree.queryParams;break;default:c=o||null}return null!==c&&(c=this.removeEmptyProps(c)),this.urlCreationStrategy.createUrlTree(s,this.routerState,this.currentUrlTree,e,c,u??null)}navigateByUrl(e,r={skipLocationChange:!1}){const s=hl(e)?e:this.parseUrl(e),o=this.urlHandlingStrategy.merge(s,this.rawUrlTree);return this.scheduleNavigation(o,Gd,null,r)}navigate(e,r={skipLocationChange:!1}){return function QX(t){for(let n=0;n<t.length;n++){const e=t[n];if(null==e)throw new ce(4008,false)}}(e),this.navigateByUrl(this.createUrlTree(e,r),r)}serializeUrl(e){return this.urlSerializer.serialize(e)}parseUrl(e){let r;try{r=this.urlSerializer.parse(e)}catch(s){r=this.malformedUriErrorHandler(s,this.urlSerializer,e)}return r}isActive(e,r){let s;if(s=!0===r?{...YX}:!1===r?{...ZX}:r,hl(e))return kR(this.currentUrlTree,e,s);const o=this.parseUrl(e);return kR(this.currentUrlTree,o,s)}removeEmptyProps(e){return Object.keys(e).reduce((r,s)=>{const o=e[s];return null!=o&&(r[s]=o),r},{})}scheduleNavigation(e,r,s,o,i){if(this.disposed)return Promise.resolve(!1);let a,l,u,c;return i?(a=i.resolve,l=i.reject,u=i.promise):u=new Promise((d,h)=>{a=d,l=h}),c="computed"===this.canceledNavigationResolution?s&&s.\u0275routerPageId?s.\u0275routerPageId:o.replaceUrl||o.skipLocationChange?this.browserPageId??0:(this.browserPageId??0)+1:0,this.navigationTransitions.handleNavigationRequest({targetPageId:c,source:r,restoredState:s,currentUrlTree:this.currentUrlTree,currentRawUrl:this.currentUrlTree,rawUrl:e,extras:o,resolve:a,reject:l,promise:u,currentSnapshot:this.routerState.snapshot,currentRouterState:this.routerState}),u.catch(d=>Promise.reject(d))}setBrowserUrl(e,r){const s=this.urlSerializer.serialize(e),o={...r.extras.state,...this.generateNgRouterState(r.id,r.targetPageId)};this.location.isCurrentPathEqualTo(s)||r.extras.replaceUrl?this.location.replaceState(s,"",o):this.location.go(s,"",o)}restoreHistory(e,r=!1){if("computed"===this.canceledNavigationResolution){const s=this.currentPageId-e.targetPageId;"popstate"!==e.source&&"eager"!==this.urlUpdateStrategy&&this.currentUrlTree!==this.getCurrentNavigation()?.finalUrl||0===s?this.currentUrlTree===this.getCurrentNavigation()?.finalUrl&&0===s&&(this.resetState(e),this.browserUrlTree=e.currentUrlTree,this.resetUrlToCurrentUrlTree()):this.location.historyGo(s)}else"replace"===this.canceledNavigationResolution&&(r&&this.resetState(e),this.resetUrlToCurrentUrlTree())}resetState(e){this.routerState=e.currentRouterState,this.currentUrlTree=e.currentUrlTree,this.rawUrlTree=this.urlHandlingStrategy.merge(this.currentUrlTree,e.rawUrl)}resetUrlToCurrentUrlTree(){this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree),"",this.generateNgRouterState(this.lastSuccessfulId,this.currentPageId))}generateNgRouterState(e,r){return"computed"===this.canceledNavigationResolution?{navigationId:e,\u0275routerPageId:r}:{navigationId:e}}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=We({token:t,factory:t.\u0275fac,providedIn:"root"}),t})();class _2{}let t7=(()=>{class t{constructor(e,r,s,o,i){this.router=e,this.injector=s,this.preloadingStrategy=o,this.loader=i}setUpPreloading(){this.subscription=this.router.events.pipe(ra(e=>e instanceof pl),cl(()=>this.preload())).subscribe(()=>{})}preload(){return this.processRoutes(this.injector,this.router.config)}ngOnDestroy(){this.subscription&&this.subscription.unsubscribe()}processRoutes(e,r){const s=[];for(const o of r){o.providers&&!o._injector&&(o._injector=em(o.providers,e,`Route: ${o.path}`));const i=o._injector??e,a=o._loadedInjector??i;o.loadChildren&&!o._loadedRoutes&&void 0===o.canLoad||o.loadComponent&&!o._loadedComponent?s.push(this.preloadConfig(i,o)):(o.children||o._loadedRoutes)&&s.push(this.processRoutes(a,o.children??o._loadedRoutes))}return Kn(s).pipe(Zl())}preloadConfig(e,r){return this.preloadingStrategy.preload(r,()=>{let s;s=r.loadChildren&&void 0===r.canLoad?this.loader.loadChildren(e,r):je(null);const o=s.pipe(_r(i=>null===i?je(void 0):(r._loadedRoutes=i.routes,r._loadedInjector=i.injector,this.processRoutes(i.injector??e,i.routes))));return r.loadComponent&&!r._loadedComponent?Kn([o,this.loader.loadComponent(r)]).pipe(Zl()):o})}}return t.\u0275fac=function(e){return new(e||t)(Ge(Fs),Ge(jk),Ge(Di),Ge(_2),Ge(DC))},t.\u0275prov=We({token:t,factory:t.\u0275fac,providedIn:"root"}),t})();const NC=new Le("");let S2=(()=>{class t{constructor(e,r,s,o,i={}){this.urlSerializer=e,this.transitions=r,this.viewportScroller=s,this.zone=o,this.options=i,this.lastId=0,this.lastSource="imperative",this.restoredId=0,this.store={},i.scrollPositionRestoration=i.scrollPositionRestoration||"disabled",i.anchorScrolling=i.anchorScrolling||"disabled"}init(){"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.setHistoryScrollRestoration("manual"),this.routerEventsSubscription=this.createScrollEvents(),this.scrollEventsSubscription=this.consumeScrollEvents()}createScrollEvents(){return this.transitions.events.subscribe(e=>{e instanceof dC?(this.store[this.lastId]=this.viewportScroller.getScrollPosition(),this.lastSource=e.navigationTrigger,this.restoredId=e.restoredState?e.restoredState.navigationId:0):e instanceof pl&&(this.lastId=e.id,this.scheduleScrollEvent(e,this.urlSerializer.parse(e.urlAfterRedirects).fragment))})}consumeScrollEvents(){return this.transitions.events.subscribe(e=>{e instanceof HR&&(e.position?"top"===this.options.scrollPositionRestoration?this.viewportScroller.scrollToPosition([0,0]):"enabled"===this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition(e.position):e.anchor&&"enabled"===this.options.anchorScrolling?this.viewportScroller.scrollToAnchor(e.anchor):"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition([0,0]))})}scheduleScrollEvent(e,r){this.zone.runOutsideAngular(()=>{setTimeout(()=>{this.zone.run(()=>{this.transitions.events.next(new HR(e,"popstate"===this.lastSource?this.store[this.restoredId]:null,r))})},0)})}ngOnDestroy(){this.routerEventsSubscription?.unsubscribe(),this.scrollEventsSubscription?.unsubscribe()}}return t.\u0275fac=function(e){!function aE(){throw new Error("invalid")}()},t.\u0275prov=We({token:t,factory:t.\u0275fac}),t})();var Ms=(()=>((Ms=Ms||{})[Ms.COMPLETE=0]="COMPLETE",Ms[Ms.FAILED=1]="FAILED",Ms[Ms.REDIRECTING=2]="REDIRECTING",Ms))();const Xu=!1;function la(t,n){return{\u0275kind:t,\u0275providers:n}}const kC=new Le("",{providedIn:"root",factory:()=>!1});function D2(){const t=kt(ts);return n=>{const e=t.get(Ed);if(n!==e.components[0])return;const r=t.get(Fs),s=t.get(T2);1===t.get(AC)&&r.initialNavigation(),t.get(E2,null,Ye.Optional)?.setUpPreloading(),t.get(NC,null,Ye.Optional)?.init(),r.resetRootComponentType(e.componentTypes[0]),s.closed||(s.next(),s.unsubscribe())}}const T2=new Le(Xu?"bootstrap done indicator":"",{factory:()=>new yi}),AC=new Le(Xu?"initial navigation":"",{providedIn:"root",factory:()=>1});function i7(){let t=[];return t=Xu?[{provide:Pf,multi:!0,useFactory:()=>{const n=kt(Fs);return()=>n.events.subscribe(e=>{console.group?.(`Router Event: ${e.constructor.name}`),console.log(function AK(t){if(!("type"in t))return`Unknown Router Event: ${t.constructor.name}`;switch(t.type){case 14:return`ActivationEnd(path: '${t.snapshot.routeConfig?.path||""}')`;case 13:return`ActivationStart(path: '${t.snapshot.routeConfig?.path||""}')`;case 12:return`ChildActivationEnd(path: '${t.snapshot.routeConfig?.path||""}')`;case 11:return`ChildActivationStart(path: '${t.snapshot.routeConfig?.path||""}')`;case 8:return`GuardsCheckEnd(id: ${t.id}, url: '${t.url}', urlAfterRedirects: '${t.urlAfterRedirects}', state: ${t.state}, shouldActivate: ${t.shouldActivate})`;case 7:return`GuardsCheckStart(id: ${t.id}, url: '${t.url}', urlAfterRedirects: '${t.urlAfterRedirects}', state: ${t.state})`;case 2:return`NavigationCancel(id: ${t.id}, url: '${t.url}')`;case 16:return`NavigationSkipped(id: ${t.id}, url: '${t.url}')`;case 1:return`NavigationEnd(id: ${t.id}, url: '${t.url}', urlAfterRedirects: '${t.urlAfterRedirects}')`;case 3:return`NavigationError(id: ${t.id}, url: '${t.url}', error: ${t.error})`;case 0:return`NavigationStart(id: ${t.id}, url: '${t.url}')`;case 6:return`ResolveEnd(id: ${t.id}, url: '${t.url}', urlAfterRedirects: '${t.urlAfterRedirects}', state: ${t.state})`;case 5:return`ResolveStart(id: ${t.id}, url: '${t.url}', urlAfterRedirects: '${t.urlAfterRedirects}', state: ${t.state})`;case 10:return`RouteConfigLoadEnd(path: ${t.route.path})`;case 9:return`RouteConfigLoadStart(path: ${t.route.path})`;case 4:return`RoutesRecognized(id: ${t.id}, url: '${t.url}', urlAfterRedirects: '${t.urlAfterRedirects}', state: ${t.state})`;case 15:return`Scroll(anchor: '${t.anchor}', position: '${t.position?`${t.position[0]}, ${t.position[1]}`:null}')`}}(e)),console.log(e),console.groupEnd?.()})}}]:[],la(1,t)}const E2=new Le(Xu?"router preloader":"");function a7(t){return la(0,[{provide:E2,useExisting:t7},{provide:_2,useExisting:t}])}const Qd=!1,N2=new Le(Qd?"router duplicate forRoot guard":"ROUTER_FORROOT_GUARD"),l7=[Ew,{provide:Bd,useClass:oC},Fs,jd,{provide:Hu,useFactory:function I2(t){return t.routerState.root},deps:[Fs]},DC,Qd?{provide:kC,useValue:!0}:[]];function u7(){return new eA("Router",Fs)}let k2=(()=>{class t{constructor(e){}static forRoot(e,r){return{ngModule:t,providers:[l7,Qd&&r?.enableTracing?i7().\u0275providers:[],{provide:Ku,multi:!0,useValue:e},{provide:N2,useFactory:p7,deps:[[Fs,new td,new nd]]},{provide:qm,useValue:r||{}},r?.useHash?{provide:ul,useClass:u6}:{provide:ul,useClass:_A},{provide:NC,useFactory:()=>{const t=kt(N5),n=kt(Fn),e=kt(qm),r=kt(jm),s=kt(Bd);return e.scrollOffset&&t.setOffset(e.scrollOffset),new S2(s,r,t,n,e)}},r?.preloadingStrategy?a7(r.preloadingStrategy).\u0275providers:[],{provide:eA,multi:!0,useFactory:u7},r?.initialNavigation?f7(r):[],[{provide:A2,useFactory:D2},{provide:Jk,multi:!0,useExisting:A2}]]}}static forChild(e){return{ngModule:t,providers:[{provide:Ku,multi:!0,useValue:e}]}}}return t.\u0275fac=function(e){return new(e||t)(Ge(N2,8))},t.\u0275mod=qs({type:t}),t.\u0275inj=Is({imports:[vC]}),t})();function p7(t){if(Qd&&t)throw new ce(4007,"The Router was provided more than once. This can happen if 'forRoot' is used outside of the root injector. Lazy loaded modules should use RouterModule.forChild() instead.");return"guarded"}function f7(t){return["disabled"===t.initialNavigation?la(3,[{provide:om,multi:!0,useFactory:()=>{const n=kt(Fs);return()=>{n.setUpLocationChangeListener()}}},{provide:AC,useValue:2}]).\u0275providers:[],"enabledBlocking"===t.initialNavigation?la(2,[{provide:AC,useValue:0},{provide:om,multi:!0,deps:[ts],useFactory:n=>{const e=n.get(a6,Promise.resolve());return()=>e.then(()=>new Promise(r=>{const s=n.get(Fs),o=n.get(T2);(function n7(t,n){t.events.pipe(ra(e=>e instanceof pl||e instanceof Pm||e instanceof hC||e instanceof Om),Nt(e=>e instanceof pl||e instanceof Om?Ms.COMPLETE:e instanceof Pm&&(0===e.code||1===e.code)?Ms.REDIRECTING:Ms.FAILED),ra(e=>e!==Ms.REDIRECTING),$d(1)).subscribe(()=>{n()})})(s,()=>{r(!0)}),n.get(jm).afterPreactivation=()=>(r(!0),o.closed?je(void 0):o),s.initialNavigation()}))}}]).\u0275providers:[]]}const A2=new Le(Qd?"Router Initializer":"");let R2=(()=>{class t{constructor(e,r){this._renderer=e,this._elementRef=r,this.onChange=s=>{},this.onTouched=()=>{}}setProperty(e,r){this._renderer.setProperty(this._elementRef.nativeElement,e,r)}registerOnTouched(e){this.onTouched=e}registerOnChange(e){this.onChange=e}setDisabledState(e){this.setProperty("disabled",e)}}return t.\u0275fac=function(e){return new(e||t)(Y(Ti),Y(Lr))},t.\u0275dir=Ze({type:t}),t})(),fl=(()=>{class t extends R2{}return t.\u0275fac=function(){let n;return function(r){return(n||(n=Dr(t)))(r||t)}}(),t.\u0275dir=Ze({type:t,features:[Yt]}),t})();const ei=new Le("NgValueAccessor"),b7={provide:ei,useExisting:cn(()=>Km),multi:!0},x7=new Le("CompositionEventMode");let Km=(()=>{class t extends R2{constructor(e,r,s){super(e,r),this._compositionMode=s,this._composing=!1,null==this._compositionMode&&(this._compositionMode=!function v7(){const t=Fi()?Fi().getUserAgent():"";return/android (\d+)/.test(t.toLowerCase())}())}writeValue(e){this.setProperty("value",e??"")}_handleInput(e){(!this._compositionMode||this._compositionMode&&!this._composing)&&this.onChange(e)}_compositionStart(){this._composing=!0}_compositionEnd(e){this._composing=!1,this._compositionMode&&this.onChange(e)}}return t.\u0275fac=function(e){return new(e||t)(Y(Ti),Y(Lr),Y(x7,8))},t.\u0275dir=Ze({type:t,selectors:[["input","formControlName","",3,"type","checkbox"],["textarea","formControlName",""],["input","formControl","",3,"type","checkbox"],["textarea","formControl",""],["input","ngModel","",3,"type","checkbox"],["textarea","ngModel",""],["","ngDefaultControl",""]],hostBindings:function(e,r){1&e&&Ee("input",function(o){return r._handleInput(o.target.value)})("blur",function(){return r.onTouched()})("compositionstart",function(){return r._compositionStart()})("compositionend",function(o){return r._compositionEnd(o.target.value)})},features:[xn([b7]),Yt]}),t})();const w7=!1;function ua(t){return null==t||("string"==typeof t||Array.isArray(t))&&0===t.length}function M2(t){return null!=t&&"number"==typeof t.length}const zr=new Le("NgValidators"),ca=new Le("NgAsyncValidators"),C7=/^(?=.{1,254}$)(?=.{1,64}@)[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;class Jd{static min(n){return function P2(t){return n=>{if(ua(n.value)||ua(t))return null;const e=parseFloat(n.value);return!isNaN(e)&&e<t?{min:{min:t,actual:n.value}}:null}}(n)}static max(n){return function O2(t){return n=>{if(ua(n.value)||ua(t))return null;const e=parseFloat(n.value);return!isNaN(e)&&e>t?{max:{max:t,actual:n.value}}:null}}(n)}static required(n){return function $2(t){return ua(t.value)?{required:!0}:null}(n)}static requiredTrue(n){return function L2(t){return!0===t.value?null:{required:!0}}(n)}static email(n){return function V2(t){return ua(t.value)||C7.test(t.value)?null:{email:!0}}(n)}static minLength(n){return function B2(t){return n=>ua(n.value)||!M2(n.value)?null:n.value.length<t?{minlength:{requiredLength:t,actualLength:n.value.length}}:null}(n)}static maxLength(n){return function z2(t){return n=>M2(n.value)&&n.value.length>t?{maxlength:{requiredLength:t,actualLength:n.value.length}}:null}(n)}static pattern(n){return function U2(t){if(!t)return Xm;let n,e;return"string"==typeof t?(e="","^"!==t.charAt(0)&&(e+="^"),e+=t,"$"!==t.charAt(t.length-1)&&(e+="$"),n=new RegExp(e)):(e=t.toString(),n=t),r=>{if(ua(r.value))return null;const s=r.value;return n.test(s)?null:{pattern:{requiredPattern:e,actualValue:s}}}}(n)}static nullValidator(n){return null}static compose(n){return K2(n)}static composeAsync(n){return X2(n)}}function Xm(t){return null}function W2(t){return null!=t}function G2(t){const n=gd(t)?Kn(t):t;if(w7&&!Lx(n)){let e="Expected async validator to return Promise or Observable.";throw"object"==typeof t&&(e+=" Are you using a synchronous validator where an async validator is expected?"),new ce(-1101,e)}return n}function H2(t){let n={};return t.forEach(e=>{n=null!=e?{...n,...e}:n}),0===Object.keys(n).length?null:n}function j2(t,n){return n.map(e=>e(t))}function q2(t){return t.map(n=>function _7(t){return!t.validate}(n)?n:e=>n.validate(e))}function K2(t){if(!t)return null;const n=t.filter(W2);return 0==n.length?null:function(e){return H2(j2(e,n))}}function RC(t){return null!=t?K2(q2(t)):null}function X2(t){if(!t)return null;const n=t.filter(W2);return 0==n.length?null:function(e){return function g7(...t){const n=A1(t),{args:e,keys:r}=gR(t),s=new xt(o=>{const{length:i}=e;if(!i)return void o.complete();const a=new Array(i);let l=i,u=i;for(let c=0;c<i;c++){let d=!1;Gs(e[c]).subscribe(sr(o,h=>{d||(d=!0,u--),a[c]=h},()=>l--,void 0,()=>{(!l||!d)&&(u||o.next(r?bR(r,a):a),o.complete())}))}});return n?s.pipe(yR(n)):s}(j2(e,n).map(G2)).pipe(Nt(H2))}}function FC(t){return null!=t?X2(q2(t)):null}function Y2(t,n){return null===t?[n]:Array.isArray(t)?[...t,n]:[t,n]}function Z2(t){return t._rawValidators}function Q2(t){return t._rawAsyncValidators}function MC(t){return t?Array.isArray(t)?t:[t]:[]}function Ym(t,n){return Array.isArray(t)?t.includes(n):t===n}function J2(t,n){const e=MC(n);return MC(t).forEach(s=>{Ym(e,s)||e.push(s)}),e}function eF(t,n){return MC(n).filter(e=>!Ym(t,e))}class tF{constructor(){this._rawValidators=[],this._rawAsyncValidators=[],this._onDestroyCallbacks=[]}get value(){return this.control?this.control.value:null}get valid(){return this.control?this.control.valid:null}get invalid(){return this.control?this.control.invalid:null}get pending(){return this.control?this.control.pending:null}get disabled(){return this.control?this.control.disabled:null}get enabled(){return this.control?this.control.enabled:null}get errors(){return this.control?this.control.errors:null}get pristine(){return this.control?this.control.pristine:null}get dirty(){return this.control?this.control.dirty:null}get touched(){return this.control?this.control.touched:null}get status(){return this.control?this.control.status:null}get untouched(){return this.control?this.control.untouched:null}get statusChanges(){return this.control?this.control.statusChanges:null}get valueChanges(){return this.control?this.control.valueChanges:null}get path(){return null}_setValidators(n){this._rawValidators=n||[],this._composedValidatorFn=RC(this._rawValidators)}_setAsyncValidators(n){this._rawAsyncValidators=n||[],this._composedAsyncValidatorFn=FC(this._rawAsyncValidators)}get validator(){return this._composedValidatorFn||null}get asyncValidator(){return this._composedAsyncValidatorFn||null}_registerOnDestroy(n){this._onDestroyCallbacks.push(n)}_invokeOnDestroyCallbacks(){this._onDestroyCallbacks.forEach(n=>n()),this._onDestroyCallbacks=[]}reset(n){this.control&&this.control.reset(n)}hasError(n,e){return!!this.control&&this.control.hasError(n,e)}getError(n,e){return this.control?this.control.getError(n,e):null}}class os extends tF{get formDirective(){return null}get path(){return null}}class da extends tF{constructor(){super(...arguments),this._parent=null,this.name=null,this.valueAccessor=null}}class nF{constructor(n){this._cd=n}get isTouched(){return!!this._cd?.control?.touched}get isUntouched(){return!!this._cd?.control?.untouched}get isPristine(){return!!this._cd?.control?.pristine}get isDirty(){return!!this._cd?.control?.dirty}get isValid(){return!!this._cd?.control?.valid}get isInvalid(){return!!this._cd?.control?.invalid}get isPending(){return!!this._cd?.control?.pending}get isSubmitted(){return!!this._cd?.submitted}}let rF=(()=>{class t extends nF{constructor(e){super(e)}}return t.\u0275fac=function(e){return new(e||t)(Y(da,2))},t.\u0275dir=Ze({type:t,selectors:[["","formControlName",""],["","ngModel",""],["","formControl",""]],hostVars:14,hostBindings:function(e,r){2&e&&nl("ng-untouched",r.isUntouched)("ng-touched",r.isTouched)("ng-pristine",r.isPristine)("ng-dirty",r.isDirty)("ng-valid",r.isValid)("ng-invalid",r.isInvalid)("ng-pending",r.isPending)},features:[Yt]}),t})(),sF=(()=>{class t extends nF{constructor(e){super(e)}}return t.\u0275fac=function(e){return new(e||t)(Y(os,10))},t.\u0275dir=Ze({type:t,selectors:[["","formGroupName",""],["","formArrayName",""],["","ngModelGroup",""],["","formGroup",""],["form",3,"ngNoForm",""],["","ngForm",""]],hostVars:16,hostBindings:function(e,r){2&e&&nl("ng-untouched",r.isUntouched)("ng-touched",r.isTouched)("ng-pristine",r.isPristine)("ng-dirty",r.isDirty)("ng-valid",r.isValid)("ng-invalid",r.isInvalid)("ng-pending",r.isPending)("ng-submitted",r.isSubmitted)},features:[Yt]}),t})();function oF(t,n){return t?`with name: '${n}'`:`at index: ${n}`}const $C=!1,eh="VALID",Qm="INVALID",Yu="PENDING",th="DISABLED";function LC(t){return(Jm(t)?t.validators:t)||null}function VC(t,n){return(Jm(n)?n.asyncValidators:t)||null}function Jm(t){return null!=t&&!Array.isArray(t)&&"object"==typeof t}function iF(t,n,e){const r=t.controls;if(!(n?Object.keys(r):r).length)throw new ce(1e3,$C?function T7(t){return`\n    There are no form controls registered with this ${t?"group":"array"} yet. If you're using ngModel,\n    you may want to check next tick (e.g. use setTimeout).\n  `}(n):"");if(!r[e])throw new ce(1001,$C?function E7(t,n){return`Cannot find form control ${oF(t,n)}`}(n,e):"")}function aF(t,n,e){t._forEachChild((r,s)=>{if(void 0===e[s])throw new ce(1002,$C?function N7(t,n){return`Must supply a value for form control ${oF(t,n)}`}(n,s):"")})}class eg{constructor(n,e){this._pendingDirty=!1,this._hasOwnPendingAsyncValidator=!1,this._pendingTouched=!1,this._onCollectionChange=()=>{},this._parent=null,this.pristine=!0,this.touched=!1,this._onDisabledChange=[],this._assignValidators(n),this._assignAsyncValidators(e)}get validator(){return this._composedValidatorFn}set validator(n){this._rawValidators=this._composedValidatorFn=n}get asyncValidator(){return this._composedAsyncValidatorFn}set asyncValidator(n){this._rawAsyncValidators=this._composedAsyncValidatorFn=n}get parent(){return this._parent}get valid(){return this.status===eh}get invalid(){return this.status===Qm}get pending(){return this.status==Yu}get disabled(){return this.status===th}get enabled(){return this.status!==th}get dirty(){return!this.pristine}get untouched(){return!this.touched}get updateOn(){return this._updateOn?this._updateOn:this.parent?this.parent.updateOn:"change"}setValidators(n){this._assignValidators(n)}setAsyncValidators(n){this._assignAsyncValidators(n)}addValidators(n){this.setValidators(J2(n,this._rawValidators))}addAsyncValidators(n){this.setAsyncValidators(J2(n,this._rawAsyncValidators))}removeValidators(n){this.setValidators(eF(n,this._rawValidators))}removeAsyncValidators(n){this.setAsyncValidators(eF(n,this._rawAsyncValidators))}hasValidator(n){return Ym(this._rawValidators,n)}hasAsyncValidator(n){return Ym(this._rawAsyncValidators,n)}clearValidators(){this.validator=null}clearAsyncValidators(){this.asyncValidator=null}markAsTouched(n={}){this.touched=!0,this._parent&&!n.onlySelf&&this._parent.markAsTouched(n)}markAllAsTouched(){this.markAsTouched({onlySelf:!0}),this._forEachChild(n=>n.markAllAsTouched())}markAsUntouched(n={}){this.touched=!1,this._pendingTouched=!1,this._forEachChild(e=>{e.markAsUntouched({onlySelf:!0})}),this._parent&&!n.onlySelf&&this._parent._updateTouched(n)}markAsDirty(n={}){this.pristine=!1,this._parent&&!n.onlySelf&&this._parent.markAsDirty(n)}markAsPristine(n={}){this.pristine=!0,this._pendingDirty=!1,this._forEachChild(e=>{e.markAsPristine({onlySelf:!0})}),this._parent&&!n.onlySelf&&this._parent._updatePristine(n)}markAsPending(n={}){this.status=Yu,!1!==n.emitEvent&&this.statusChanges.emit(this.status),this._parent&&!n.onlySelf&&this._parent.markAsPending(n)}disable(n={}){const e=this._parentMarkedDirty(n.onlySelf);this.status=th,this.errors=null,this._forEachChild(r=>{r.disable({...n,onlySelf:!0})}),this._updateValue(),!1!==n.emitEvent&&(this.valueChanges.emit(this.value),this.statusChanges.emit(this.status)),this._updateAncestors({...n,skipPristineCheck:e}),this._onDisabledChange.forEach(r=>r(!0))}enable(n={}){const e=this._parentMarkedDirty(n.onlySelf);this.status=eh,this._forEachChild(r=>{r.enable({...n,onlySelf:!0})}),this.updateValueAndValidity({onlySelf:!0,emitEvent:n.emitEvent}),this._updateAncestors({...n,skipPristineCheck:e}),this._onDisabledChange.forEach(r=>r(!1))}_updateAncestors(n){this._parent&&!n.onlySelf&&(this._parent.updateValueAndValidity(n),n.skipPristineCheck||this._parent._updatePristine(),this._parent._updateTouched())}setParent(n){this._parent=n}getRawValue(){return this.value}updateValueAndValidity(n={}){this._setInitialStatus(),this._updateValue(),this.enabled&&(this._cancelExistingSubscription(),this.errors=this._runValidator(),this.status=this._calculateStatus(),(this.status===eh||this.status===Yu)&&this._runAsyncValidator(n.emitEvent)),!1!==n.emitEvent&&(this.valueChanges.emit(this.value),this.statusChanges.emit(this.status)),this._parent&&!n.onlySelf&&this._parent.updateValueAndValidity(n)}_updateTreeValidity(n={emitEvent:!0}){this._forEachChild(e=>e._updateTreeValidity(n)),this.updateValueAndValidity({onlySelf:!0,emitEvent:n.emitEvent})}_setInitialStatus(){this.status=this._allControlsDisabled()?th:eh}_runValidator(){return this.validator?this.validator(this):null}_runAsyncValidator(n){if(this.asyncValidator){this.status=Yu,this._hasOwnPendingAsyncValidator=!0;const e=G2(this.asyncValidator(this));this._asyncValidationSubscription=e.subscribe(r=>{this._hasOwnPendingAsyncValidator=!1,this.setErrors(r,{emitEvent:n})})}}_cancelExistingSubscription(){this._asyncValidationSubscription&&(this._asyncValidationSubscription.unsubscribe(),this._hasOwnPendingAsyncValidator=!1)}setErrors(n,e={}){this.errors=n,this._updateControlsErrors(!1!==e.emitEvent)}get(n){let e=n;return null==e||(Array.isArray(e)||(e=e.split(".")),0===e.length)?null:e.reduce((r,s)=>r&&r._find(s),this)}getError(n,e){const r=e?this.get(e):this;return r&&r.errors?r.errors[n]:null}hasError(n,e){return!!this.getError(n,e)}get root(){let n=this;for(;n._parent;)n=n._parent;return n}_updateControlsErrors(n){this.status=this._calculateStatus(),n&&this.statusChanges.emit(this.status),this._parent&&this._parent._updateControlsErrors(n)}_initObservables(){this.valueChanges=new _t,this.statusChanges=new _t}_calculateStatus(){return this._allControlsDisabled()?th:this.errors?Qm:this._hasOwnPendingAsyncValidator||this._anyControlsHaveStatus(Yu)?Yu:this._anyControlsHaveStatus(Qm)?Qm:eh}_anyControlsHaveStatus(n){return this._anyControls(e=>e.status===n)}_anyControlsDirty(){return this._anyControls(n=>n.dirty)}_anyControlsTouched(){return this._anyControls(n=>n.touched)}_updatePristine(n={}){this.pristine=!this._anyControlsDirty(),this._parent&&!n.onlySelf&&this._parent._updatePristine(n)}_updateTouched(n={}){this.touched=this._anyControlsTouched(),this._parent&&!n.onlySelf&&this._parent._updateTouched(n)}_registerOnCollectionChange(n){this._onCollectionChange=n}_setUpdateStrategy(n){Jm(n)&&null!=n.updateOn&&(this._updateOn=n.updateOn)}_parentMarkedDirty(n){return!n&&!(!this._parent||!this._parent.dirty)&&!this._parent._anyControlsDirty()}_find(n){return null}_assignValidators(n){this._rawValidators=Array.isArray(n)?n.slice():n,this._composedValidatorFn=function k7(t){return Array.isArray(t)?RC(t):t||null}(this._rawValidators)}_assignAsyncValidators(n){this._rawAsyncValidators=Array.isArray(n)?n.slice():n,this._composedAsyncValidatorFn=function A7(t){return Array.isArray(t)?FC(t):t||null}(this._rawAsyncValidators)}}class nh extends eg{constructor(n,e,r){super(LC(e),VC(r,e)),this.controls=n,this._initObservables(),this._setUpdateStrategy(e),this._setUpControls(),this.updateValueAndValidity({onlySelf:!0,emitEvent:!!this.asyncValidator})}registerControl(n,e){return this.controls[n]?this.controls[n]:(this.controls[n]=e,e.setParent(this),e._registerOnCollectionChange(this._onCollectionChange),e)}addControl(n,e,r={}){this.registerControl(n,e),this.updateValueAndValidity({emitEvent:r.emitEvent}),this._onCollectionChange()}removeControl(n,e={}){this.controls[n]&&this.controls[n]._registerOnCollectionChange(()=>{}),delete this.controls[n],this.updateValueAndValidity({emitEvent:e.emitEvent}),this._onCollectionChange()}setControl(n,e,r={}){this.controls[n]&&this.controls[n]._registerOnCollectionChange(()=>{}),delete this.controls[n],e&&this.registerControl(n,e),this.updateValueAndValidity({emitEvent:r.emitEvent}),this._onCollectionChange()}contains(n){return this.controls.hasOwnProperty(n)&&this.controls[n].enabled}setValue(n,e={}){aF(this,!0,n),Object.keys(n).forEach(r=>{iF(this,!0,r),this.controls[r].setValue(n[r],{onlySelf:!0,emitEvent:e.emitEvent})}),this.updateValueAndValidity(e)}patchValue(n,e={}){null!=n&&(Object.keys(n).forEach(r=>{const s=this.controls[r];s&&s.patchValue(n[r],{onlySelf:!0,emitEvent:e.emitEvent})}),this.updateValueAndValidity(e))}reset(n={},e={}){this._forEachChild((r,s)=>{r.reset(n[s],{onlySelf:!0,emitEvent:e.emitEvent})}),this._updatePristine(e),this._updateTouched(e),this.updateValueAndValidity(e)}getRawValue(){return this._reduceChildren({},(n,e,r)=>(n[r]=e.getRawValue(),n))}_syncPendingControls(){let n=this._reduceChildren(!1,(e,r)=>!!r._syncPendingControls()||e);return n&&this.updateValueAndValidity({onlySelf:!0}),n}_forEachChild(n){Object.keys(this.controls).forEach(e=>{const r=this.controls[e];r&&n(r,e)})}_setUpControls(){this._forEachChild(n=>{n.setParent(this),n._registerOnCollectionChange(this._onCollectionChange)})}_updateValue(){this.value=this._reduceValue()}_anyControls(n){for(const[e,r]of Object.entries(this.controls))if(this.contains(e)&&n(r))return!0;return!1}_reduceValue(){return this._reduceChildren({},(e,r,s)=>((r.enabled||this.disabled)&&(e[s]=r.value),e))}_reduceChildren(n,e){let r=n;return this._forEachChild((s,o)=>{r=e(r,s,o)}),r}_allControlsDisabled(){for(const n of Object.keys(this.controls))if(this.controls[n].enabled)return!1;return Object.keys(this.controls).length>0||this.disabled}_find(n){return this.controls.hasOwnProperty(n)?this.controls[n]:null}}class lF extends nh{}const ml=new Le("CallSetDisabledState",{providedIn:"root",factory:()=>rh}),rh="always";function sh(t,n,e=rh){BC(t,n),n.valueAccessor.writeValue(t.value),(t.disabled||"always"===e)&&n.valueAccessor.setDisabledState?.(t.disabled),function F7(t,n){n.valueAccessor.registerOnChange(e=>{t._pendingValue=e,t._pendingChange=!0,t._pendingDirty=!0,"change"===t.updateOn&&uF(t,n)})}(t,n),function P7(t,n){const e=(r,s)=>{n.valueAccessor.writeValue(r),s&&n.viewToModelUpdate(r)};t.registerOnChange(e),n._registerOnDestroy(()=>{t._unregisterOnChange(e)})}(t,n),function M7(t,n){n.valueAccessor.registerOnTouched(()=>{t._pendingTouched=!0,"blur"===t.updateOn&&t._pendingChange&&uF(t,n),"submit"!==t.updateOn&&t.markAsTouched()})}(t,n),function R7(t,n){if(n.valueAccessor.setDisabledState){const e=r=>{n.valueAccessor.setDisabledState(r)};t.registerOnDisabledChange(e),n._registerOnDestroy(()=>{t._unregisterOnDisabledChange(e)})}}(t,n)}function ng(t,n,e=!0){const r=()=>{};n.valueAccessor&&(n.valueAccessor.registerOnChange(r),n.valueAccessor.registerOnTouched(r)),sg(t,n),t&&(n._invokeOnDestroyCallbacks(),t._registerOnCollectionChange(()=>{}))}function rg(t,n){t.forEach(e=>{e.registerOnValidatorChange&&e.registerOnValidatorChange(n)})}function BC(t,n){const e=Z2(t);null!==n.validator?t.setValidators(Y2(e,n.validator)):"function"==typeof e&&t.setValidators([e]);const r=Q2(t);null!==n.asyncValidator?t.setAsyncValidators(Y2(r,n.asyncValidator)):"function"==typeof r&&t.setAsyncValidators([r]);const s=()=>t.updateValueAndValidity();rg(n._rawValidators,s),rg(n._rawAsyncValidators,s)}function sg(t,n){let e=!1;if(null!==t){if(null!==n.validator){const s=Z2(t);if(Array.isArray(s)&&s.length>0){const o=s.filter(i=>i!==n.validator);o.length!==s.length&&(e=!0,t.setValidators(o))}}if(null!==n.asyncValidator){const s=Q2(t);if(Array.isArray(s)&&s.length>0){const o=s.filter(i=>i!==n.asyncValidator);o.length!==s.length&&(e=!0,t.setAsyncValidators(o))}}}const r=()=>{};return rg(n._rawValidators,r),rg(n._rawAsyncValidators,r),e}function uF(t,n){t._pendingDirty&&t.markAsDirty(),t.setValue(t._pendingValue,{emitModelToViewChange:!1}),n.viewToModelUpdate(t._pendingValue),t._pendingChange=!1}function hF(t,n){const e=t.indexOf(n);e>-1&&t.splice(e,1)}function pF(t){return"object"==typeof t&&null!==t&&2===Object.keys(t).length&&"value"in t&&"disabled"in t}const ih=class extends eg{constructor(n=null,e,r){super(LC(e),VC(r,e)),this.defaultValue=null,this._onChange=[],this._pendingChange=!1,this._applyFormState(n),this._setUpdateStrategy(e),this._initObservables(),this.updateValueAndValidity({onlySelf:!0,emitEvent:!!this.asyncValidator}),Jm(e)&&(e.nonNullable||e.initialValueIsDefault)&&(this.defaultValue=pF(n)?n.value:n)}setValue(n,e={}){this.value=this._pendingValue=n,this._onChange.length&&!1!==e.emitModelToViewChange&&this._onChange.forEach(r=>r(this.value,!1!==e.emitViewToModelChange)),this.updateValueAndValidity(e)}patchValue(n,e={}){this.setValue(n,e)}reset(n=this.defaultValue,e={}){this._applyFormState(n),this.markAsPristine(e),this.markAsUntouched(e),this.setValue(this.value,e),this._pendingChange=!1}_updateValue(){}_anyControls(n){return!1}_allControlsDisabled(){return this.disabled}registerOnChange(n){this._onChange.push(n)}_unregisterOnChange(n){hF(this._onChange,n)}registerOnDisabledChange(n){this._onDisabledChange.push(n)}_unregisterOnDisabledChange(n){hF(this._onDisabledChange,n)}_forEachChild(n){}_syncPendingControls(){return!("submit"!==this.updateOn||(this._pendingDirty&&this.markAsDirty(),this._pendingTouched&&this.markAsTouched(),!this._pendingChange)||(this.setValue(this._pendingValue,{onlySelf:!0,emitModelToViewChange:!1}),0))}_applyFormState(n){pF(n)?(this.value=this._pendingValue=n.value,n.disabled?this.disable({onlySelf:!0,emitEvent:!1}):this.enable({onlySelf:!0,emitEvent:!1})):this.value=this._pendingValue=n}};let bF=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275dir=Ze({type:t,selectors:[["form",3,"ngNoForm","",3,"ngNativeValidate",""]],hostAttrs:["novalidate",""]}),t})(),xF=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=qs({type:t}),t.\u0275inj=Is({}),t})();const HC=new Le("NgModelWithFormControlWarning"),X7={provide:os,useExisting:cn(()=>og)};let og=(()=>{class t extends os{constructor(e,r,s){super(),this.callSetDisabledState=s,this.submitted=!1,this._onCollectionChange=()=>this._updateDomValue(),this.directives=[],this.form=null,this.ngSubmit=new _t,this._setValidators(e),this._setAsyncValidators(r)}ngOnChanges(e){this._checkFormPresent(),e.hasOwnProperty("form")&&(this._updateValidators(),this._updateDomValue(),this._updateRegistrations(),this._oldForm=this.form)}ngOnDestroy(){this.form&&(sg(this.form,this),this.form._onCollectionChange===this._onCollectionChange&&this.form._registerOnCollectionChange(()=>{}))}get formDirective(){return this}get control(){return this.form}get path(){return[]}addControl(e){const r=this.form.get(e.path);return sh(r,e,this.callSetDisabledState),r.updateValueAndValidity({emitEvent:!1}),this.directives.push(e),r}getControl(e){return this.form.get(e.path)}removeControl(e){ng(e.control||null,e,!1),function V7(t,n){const e=t.indexOf(n);e>-1&&t.splice(e,1)}(this.directives,e)}addFormGroup(e){this._setUpFormContainer(e)}removeFormGroup(e){this._cleanUpFormContainer(e)}getFormGroup(e){return this.form.get(e.path)}addFormArray(e){this._setUpFormContainer(e)}removeFormArray(e){this._cleanUpFormContainer(e)}getFormArray(e){return this.form.get(e.path)}updateModel(e,r){this.form.get(e.path).setValue(r)}onSubmit(e){return this.submitted=!0,function dF(t,n){t._syncPendingControls(),n.forEach(e=>{const r=e.control;"submit"===r.updateOn&&r._pendingChange&&(e.viewToModelUpdate(r._pendingValue),r._pendingChange=!1)})}(this.form,this.directives),this.ngSubmit.emit(e),"dialog"===e?.target?.method}onReset(){this.resetForm()}resetForm(e){this.form.reset(e),this.submitted=!1}_updateDomValue(){this.directives.forEach(e=>{const r=e.control,s=this.form.get(e.path);r!==s&&(ng(r||null,e),(t=>t instanceof ih)(s)&&(sh(s,e,this.callSetDisabledState),e.control=s))}),this.form._updateTreeValidity({emitEvent:!1})}_setUpFormContainer(e){const r=this.form.get(e.path);(function cF(t,n){BC(t,n)})(r,e),r.updateValueAndValidity({emitEvent:!1})}_cleanUpFormContainer(e){if(this.form){const r=this.form.get(e.path);r&&function O7(t,n){return sg(t,n)}(r,e)&&r.updateValueAndValidity({emitEvent:!1})}}_updateRegistrations(){this.form._registerOnCollectionChange(this._onCollectionChange),this._oldForm&&this._oldForm._registerOnCollectionChange(()=>{})}_updateValidators(){BC(this.form,this),this._oldForm&&sg(this._oldForm,this)}_checkFormPresent(){}}return t.\u0275fac=function(e){return new(e||t)(Y(zr,10),Y(ca,10),Y(ml,8))},t.\u0275dir=Ze({type:t,selectors:[["","formGroup",""]],hostBindings:function(e,r){1&e&&Ee("submit",function(o){return r.onSubmit(o)})("reset",function(){return r.onReset()})},inputs:{form:["formGroup","form"]},outputs:{ngSubmit:"ngSubmit"},exportAs:["ngForm"],features:[xn([X7]),Yt,Es]}),t})();const Q7={provide:da,useExisting:cn(()=>KC)};let KC=(()=>{class t extends da{set isDisabled(e){}constructor(e,r,s,o,i){super(),this._ngModelWarningConfig=i,this._added=!1,this.update=new _t,this._ngModelWarningSent=!1,this._parent=e,this._setValidators(r),this._setAsyncValidators(s),this.valueAccessor=function WC(t,n){if(!n)return null;let e,r,s;return Array.isArray(n),n.forEach(o=>{o.constructor===Km?e=o:function L7(t){return Object.getPrototypeOf(t.constructor)===fl}(o)?r=o:s=o}),s||r||e||null}(0,o)}ngOnChanges(e){this._added||this._setUpControl(),function UC(t,n){if(!t.hasOwnProperty("model"))return!1;const e=t.model;return!!e.isFirstChange()||!Object.is(n,e.currentValue)}(e,this.viewModel)&&(this.viewModel=this.model,this.formDirective.updateModel(this,this.model))}ngOnDestroy(){this.formDirective&&this.formDirective.removeControl(this)}viewToModelUpdate(e){this.viewModel=e,this.update.emit(e)}get path(){return function tg(t,n){return[...n.path,t]}(null==this.name?this.name:this.name.toString(),this._parent)}get formDirective(){return this._parent?this._parent.formDirective:null}_checkParentType(){}_setUpControl(){this._checkParentType(),this.control=this.formDirective.addControl(this),this._added=!0}}return t._ngModelWarningSentOnce=!1,t.\u0275fac=function(e){return new(e||t)(Y(os,13),Y(zr,10),Y(ca,10),Y(ei,10),Y(HC,8))},t.\u0275dir=Ze({type:t,selectors:[["","formControlName",""]],inputs:{name:["formControlName","name"],isDisabled:["disabled","isDisabled"],model:["ngModel","model"]},outputs:{update:"ngModelChange"},features:[xn([Q7]),Yt,Es]}),t})(),OF=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=qs({type:t}),t.\u0275inj=Is({imports:[xF]}),t})();class $F extends eg{constructor(n,e,r){super(LC(e),VC(r,e)),this.controls=n,this._initObservables(),this._setUpdateStrategy(e),this._setUpControls(),this.updateValueAndValidity({onlySelf:!0,emitEvent:!!this.asyncValidator})}at(n){return this.controls[this._adjustIndex(n)]}push(n,e={}){this.controls.push(n),this._registerControl(n),this.updateValueAndValidity({emitEvent:e.emitEvent}),this._onCollectionChange()}insert(n,e,r={}){this.controls.splice(n,0,e),this._registerControl(e),this.updateValueAndValidity({emitEvent:r.emitEvent})}removeAt(n,e={}){let r=this._adjustIndex(n);r<0&&(r=0),this.controls[r]&&this.controls[r]._registerOnCollectionChange(()=>{}),this.controls.splice(r,1),this.updateValueAndValidity({emitEvent:e.emitEvent})}setControl(n,e,r={}){let s=this._adjustIndex(n);s<0&&(s=0),this.controls[s]&&this.controls[s]._registerOnCollectionChange(()=>{}),this.controls.splice(s,1),e&&(this.controls.splice(s,0,e),this._registerControl(e)),this.updateValueAndValidity({emitEvent:r.emitEvent}),this._onCollectionChange()}get length(){return this.controls.length}setValue(n,e={}){aF(this,!1,n),n.forEach((r,s)=>{iF(this,!1,s),this.at(s).setValue(r,{onlySelf:!0,emitEvent:e.emitEvent})}),this.updateValueAndValidity(e)}patchValue(n,e={}){null!=n&&(n.forEach((r,s)=>{this.at(s)&&this.at(s).patchValue(r,{onlySelf:!0,emitEvent:e.emitEvent})}),this.updateValueAndValidity(e))}reset(n=[],e={}){this._forEachChild((r,s)=>{r.reset(n[s],{onlySelf:!0,emitEvent:e.emitEvent})}),this._updatePristine(e),this._updateTouched(e),this.updateValueAndValidity(e)}getRawValue(){return this.controls.map(n=>n.getRawValue())}clear(n={}){this.controls.length<1||(this._forEachChild(e=>e._registerOnCollectionChange(()=>{})),this.controls.splice(0),this.updateValueAndValidity({emitEvent:n.emitEvent}))}_adjustIndex(n){return n<0?n+this.length:n}_syncPendingControls(){let n=this.controls.reduce((e,r)=>!!r._syncPendingControls()||e,!1);return n&&this.updateValueAndValidity({onlySelf:!0}),n}_forEachChild(n){this.controls.forEach((e,r)=>{n(e,r)})}_updateValue(){this.value=this.controls.filter(n=>n.enabled||this.disabled).map(n=>n.value)}_anyControls(n){return this.controls.some(e=>e.enabled&&n(e))}_setUpControls(){this._forEachChild(n=>this._registerControl(n))}_allControlsDisabled(){for(const n of this.controls)if(n.enabled)return!1;return this.controls.length>0||this.disabled}_registerControl(n){n.setParent(this),n._registerOnCollectionChange(this._onCollectionChange)}_find(n){return this.at(n)??null}}function LF(t){return!!t&&(void 0!==t.asyncValidators||void 0!==t.validators||void 0!==t.updateOn)}let p9=(()=>{class t{constructor(){this.useNonNullable=!1}get nonNullable(){const e=new t;return e.useNonNullable=!0,e}group(e,r=null){const s=this._reduceControls(e);let o={};return LF(r)?o=r:null!==r&&(o.validators=r.validator,o.asyncValidators=r.asyncValidator),new nh(s,o)}record(e,r=null){const s=this._reduceControls(e);return new lF(s,r)}control(e,r,s){let o={};return this.useNonNullable?(LF(r)?o=r:(o.validators=r,o.asyncValidators=s),new ih(e,{...o,nonNullable:!0})):new ih(e,r,s)}array(e,r,s){const o=e.map(i=>this._createControl(i));return new $F(o,r,s)}_reduceControls(e){const r={};return Object.keys(e).forEach(s=>{r[s]=this._createControl(e[s])}),r}_createControl(e){return e instanceof ih||e instanceof eg?e:Array.isArray(e)?this.control(e[0],e.length>1?e[1]:null,e.length>2?e[2]:null):this.control(e)}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=We({token:t,factory:t.\u0275fac,providedIn:"root"}),t})(),f9=(()=>{class t{static withConfig(e){return{ngModule:t,providers:[{provide:ml,useValue:e.callSetDisabledState??rh}]}}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=qs({type:t}),t.\u0275inj=Is({imports:[OF]}),t})(),m9=(()=>{class t{static withConfig(e){return{ngModule:t,providers:[{provide:HC,useValue:e.warnOnNgModelWithFormControl??"always"},{provide:ml,useValue:e.callSetDisabledState??rh}]}}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=qs({type:t}),t.\u0275inj=Is({imports:[OF]}),t})();class g9{constructor(n,e,r,s,o,i){this.titleColor=n,this.contentColor=e,this.backgroundColor=r,this.fontFamily=s,this.textAlign=o,this.camAlign=i}}var ha=(()=>{return(t=ha||(ha={}))[t.center=0]="center",t[t.right=1]="right",t[t.left=2]="left",t[t.justify=3]="justify",ha;var t})();class y9{constructor(n,e,r,s,o,i,a){this.title=n,this.description=e,this.modelURL=r,this.width=s,this.height=o,this.style=i,this.categories=a}}class VF{constructor(n,e,r){this.name=n,this.minValue=e,this.maxValue=r}}let QC=(()=>{class t{constructor(){const e=new g9("#000000","#000000","#FFFFFF","Calibri",ha.center,ha.center),r=new Array;r.push(new VF("Gato",0,.5)),r.push(new VF("Perro",.5,Number.MAX_SAFE_INTEGER)),this.configs=[new y9("Perros y gatos","","./assets/perros-gatos/model.json",100,100,e,r)]}addConfig(e){let r=!1;return this.configs.some(s=>s.title==e.title)||(this.configs.push(e),r=!0),r}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=We({token:t,factory:t.\u0275fac,providedIn:"root"}),t})();const b9=["dialogPopup"],v9=["hueSlider"],x9=["alphaSlider"];function w9(t,n){if(1&t&&Vt(0,"div"),2&t){const e=we();(function yN(t,n,e){wo(As,Yo,Su(ee(),t,n,e),!0)})("arrow arrow-",e.cpUsePosition,""),Un("left",e.cpArrowPosition)("top",e.arrowTop,"px")}}function C9(t,n){if(1&t){const e=zn();te(0,"div",28),Ee("newValue",function(s){return Qe(e),Je(we().onColorChange(s))})("dragStart",function(){return Qe(e),Je(we().onDragStart("saturation-lightness"))})("dragEnd",function(){return Qe(e),Je(we().onDragEnd("saturation-lightness"))}),Vt(1,"div",14),Q()}if(2&t){const e=we();Un("background-color",e.hueSliderColor),_e("rgX",1)("rgY",1),me(1),Un("top",null==e.slider?null:e.slider.v,"px")("left",null==e.slider?null:e.slider.s,"px")}}function _9(t,n){1&t&&(function gD(){it.lFrame.currentNamespace=eD}(),te(0,"svg",29),Vt(1,"path",30)(2,"path",31),Q())}function S9(t,n){if(1&t){const e=zn();te(0,"button",32),Ee("click",function(s){Qe(e);const o=we();return Je(o.onAddPresetColor(s,o.selectedColor))}),Be(1),Q()}if(2&t){const e=we();rl(e.cpAddColorButtonClass),_e("disabled",e.cpPresetColors&&e.cpPresetColors.length>=e.cpMaxPresetColorsLength),me(1),Zs(" ",e.cpAddColorButtonText," ")}}function I9(t,n){1&t&&Vt(0,"div",33)}function D9(t,n){if(1&t){const e=zn();te(0,"input",39),Ee("keyup.enter",function(s){return Qe(e),Je(we(2).onAcceptColor(s))})("newValue",function(s){return Qe(e),Je(we(2).onAlphaInput(s))}),Q()}if(2&t){const e=we(2);_e("rg",1)("value",null==e.cmykText?null:e.cmykText.a)}}function T9(t,n){1&t&&(te(0,"div"),Be(1,"A"),Q())}function E9(t,n){if(1&t){const e=zn();te(0,"div",34)(1,"div",35)(2,"input",36),Ee("keyup.enter",function(s){return Qe(e),Je(we().onAcceptColor(s))})("newValue",function(s){return Qe(e),Je(we().onCyanInput(s))}),Q(),te(3,"input",36),Ee("keyup.enter",function(s){return Qe(e),Je(we().onAcceptColor(s))})("newValue",function(s){return Qe(e),Je(we().onMagentaInput(s))}),Q(),te(4,"input",36),Ee("keyup.enter",function(s){return Qe(e),Je(we().onAcceptColor(s))})("newValue",function(s){return Qe(e),Je(we().onYellowInput(s))}),Q(),te(5,"input",36),Ee("keyup.enter",function(s){return Qe(e),Je(we().onAcceptColor(s))})("newValue",function(s){return Qe(e),Je(we().onBlackInput(s))}),Q(),Ot(6,D9,1,2,"input",37),Q(),te(7,"div",35)(8,"div"),Be(9,"C"),Q(),te(10,"div"),Be(11,"M"),Q(),te(12,"div"),Be(13,"Y"),Q(),te(14,"div"),Be(15,"K"),Q(),Ot(16,T9,2,0,"div",38),Q()()}if(2&t){const e=we();Un("display",3!==e.format?"none":"block"),me(2),_e("rg",100)("value",null==e.cmykText?null:e.cmykText.c),me(1),_e("rg",100)("value",null==e.cmykText?null:e.cmykText.m),me(1),_e("rg",100)("value",null==e.cmykText?null:e.cmykText.y),me(1),_e("rg",100)("value",null==e.cmykText?null:e.cmykText.k),me(1),_e("ngIf","disabled"!==e.cpAlphaChannel),me(10),_e("ngIf","disabled"!==e.cpAlphaChannel)}}function N9(t,n){if(1&t){const e=zn();te(0,"input",39),Ee("keyup.enter",function(s){return Qe(e),Je(we(2).onAcceptColor(s))})("newValue",function(s){return Qe(e),Je(we(2).onAlphaInput(s))}),Q()}if(2&t){const e=we(2);_e("rg",1)("value",null==e.hslaText?null:e.hslaText.a)}}function k9(t,n){1&t&&(te(0,"div"),Be(1,"A"),Q())}function A9(t,n){if(1&t){const e=zn();te(0,"div",40)(1,"div",35)(2,"input",41),Ee("keyup.enter",function(s){return Qe(e),Je(we().onAcceptColor(s))})("newValue",function(s){return Qe(e),Je(we().onHueInput(s))}),Q(),te(3,"input",36),Ee("keyup.enter",function(s){return Qe(e),Je(we().onAcceptColor(s))})("newValue",function(s){return Qe(e),Je(we().onSaturationInput(s))}),Q(),te(4,"input",36),Ee("keyup.enter",function(s){return Qe(e),Je(we().onAcceptColor(s))})("newValue",function(s){return Qe(e),Je(we().onLightnessInput(s))}),Q(),Ot(5,N9,1,2,"input",37),Q(),te(6,"div",35)(7,"div"),Be(8,"H"),Q(),te(9,"div"),Be(10,"S"),Q(),te(11,"div"),Be(12,"L"),Q(),Ot(13,k9,2,0,"div",38),Q()()}if(2&t){const e=we();Un("display",2!==e.format?"none":"block"),me(2),_e("rg",360)("value",null==e.hslaText?null:e.hslaText.h),me(1),_e("rg",100)("value",null==e.hslaText?null:e.hslaText.s),me(1),_e("rg",100)("value",null==e.hslaText?null:e.hslaText.l),me(1),_e("ngIf","disabled"!==e.cpAlphaChannel),me(8),_e("ngIf","disabled"!==e.cpAlphaChannel)}}function R9(t,n){if(1&t){const e=zn();te(0,"input",39),Ee("keyup.enter",function(s){return Qe(e),Je(we(2).onAcceptColor(s))})("newValue",function(s){return Qe(e),Je(we(2).onAlphaInput(s))}),Q()}if(2&t){const e=we(2);_e("rg",1)("value",null==e.rgbaText?null:e.rgbaText.a)}}function F9(t,n){1&t&&(te(0,"div"),Be(1,"A"),Q())}function M9(t,n){if(1&t){const e=zn();te(0,"div",42)(1,"div",35)(2,"input",43),Ee("keyup.enter",function(s){return Qe(e),Je(we().onAcceptColor(s))})("newValue",function(s){return Qe(e),Je(we().onRedInput(s))}),Q(),te(3,"input",43),Ee("keyup.enter",function(s){return Qe(e),Je(we().onAcceptColor(s))})("newValue",function(s){return Qe(e),Je(we().onGreenInput(s))}),Q(),te(4,"input",43),Ee("keyup.enter",function(s){return Qe(e),Je(we().onAcceptColor(s))})("newValue",function(s){return Qe(e),Je(we().onBlueInput(s))}),Q(),Ot(5,R9,1,2,"input",37),Q(),te(6,"div",35)(7,"div"),Be(8,"R"),Q(),te(9,"div"),Be(10,"G"),Q(),te(11,"div"),Be(12,"B"),Q(),Ot(13,F9,2,0,"div",38),Q()()}if(2&t){const e=we();Un("display",1!==e.format?"none":"block"),me(2),_e("rg",255)("value",null==e.rgbaText?null:e.rgbaText.r),me(1),_e("rg",255)("value",null==e.rgbaText?null:e.rgbaText.g),me(1),_e("rg",255)("value",null==e.rgbaText?null:e.rgbaText.b),me(1),_e("ngIf","disabled"!==e.cpAlphaChannel),me(8),_e("ngIf","disabled"!==e.cpAlphaChannel)}}function P9(t,n){if(1&t){const e=zn();te(0,"input",39),Ee("keyup.enter",function(s){return Qe(e),Je(we(2).onAcceptColor(s))})("newValue",function(s){return Qe(e),Je(we(2).onAlphaInput(s))}),Q()}if(2&t){const e=we(2);_e("rg",1)("value",e.hexAlpha)}}function O9(t,n){1&t&&(te(0,"div"),Be(1,"A"),Q())}function $9(t,n){if(1&t){const e=zn();te(0,"div",44)(1,"div",35)(2,"input",45),Ee("blur",function(){return Qe(e),Je(we().onHexInput(null))})("keyup.enter",function(s){return Qe(e),Je(we().onAcceptColor(s))})("newValue",function(s){return Qe(e),Je(we().onHexInput(s))}),Q(),Ot(3,P9,1,2,"input",37),Q(),te(4,"div",35)(5,"div"),Be(6,"Hex"),Q(),Ot(7,O9,2,0,"div",38),Q()()}if(2&t){const e=we();Un("display",0!==e.format?"none":"block"),nl("hex-alpha","forced"===e.cpAlphaChannel),me(2),_e("value",e.hexText),me(1),_e("ngIf","forced"===e.cpAlphaChannel),me(4),_e("ngIf","forced"===e.cpAlphaChannel)}}function L9(t,n){if(1&t){const e=zn();te(0,"input",39),Ee("keyup.enter",function(s){return Qe(e),Je(we(2).onAcceptColor(s))})("newValue",function(s){return Qe(e),Je(we(2).onAlphaInput(s))}),Q()}if(2&t){const e=we(2);_e("rg",1)("value",null==e.hslaText?null:e.hslaText.a)}}function V9(t,n){if(1&t){const e=zn();te(0,"div",46)(1,"div",35)(2,"input",36),Ee("keyup.enter",function(s){return Qe(e),Je(we().onAcceptColor(s))})("newValue",function(s){return Qe(e),Je(we().onValueInput(s))}),Q(),Ot(3,L9,1,2,"input",37),Q(),te(4,"div",35)(5,"div"),Be(6,"V"),Q(),te(7,"div"),Be(8,"A"),Q()()()}if(2&t){const e=we();me(2),_e("rg",100)("value",null==e.hslaText?null:e.hslaText.l),me(1),_e("ngIf","disabled"!==e.cpAlphaChannel)}}function B9(t,n){if(1&t){const e=zn();te(0,"div",47)(1,"span",48),Ee("click",function(){return Qe(e),Je(we().onFormatToggle(-1))}),Q(),te(2,"span",48),Ee("click",function(){return Qe(e),Je(we().onFormatToggle(1))}),Q()()}}function z9(t,n){if(1&t){const e=zn();te(0,"span",55),Ee("click",function(s){Qe(e);const o=we().$implicit;return Je(we(3).onRemovePresetColor(s,o))}),Q()}2&t&&rl(we(4).cpRemoveColorButtonClass)}function U9(t,n){if(1&t){const e=zn();te(0,"div",53),Ee("click",function(){const o=Qe(e).$implicit;return Je(we(3).setColorFromString(o))}),Ot(1,z9,1,3,"span",54),Q()}if(2&t){const e=n.$implicit,r=we(3);Un("background-color",e),me(1),_e("ngIf",r.cpAddColorButton)}}function W9(t,n){if(1&t&&(te(0,"div"),Ot(1,U9,2,3,"div",52),Q()),2&t){const e=we(2);rl(e.cpPresetColorsClass),me(1),_e("ngForOf",e.cpPresetColors)}}function G9(t,n){if(1&t&&(te(0,"div"),Be(1),Q()),2&t){const e=we(2);rl(e.cpPresetEmptyMessageClass),me(1),sl(e.cpPresetEmptyMessage)}}function H9(t,n){if(1&t&&(te(0,"div",49),Vt(1,"hr"),te(2,"div",50),Be(3),Q(),Ot(4,W9,2,4,"div",51),Ot(5,G9,2,4,"div",51),Q()),2&t){const e=we();me(3),sl(e.cpPresetLabel),me(1),_e("ngIf",null==e.cpPresetColors?null:e.cpPresetColors.length),me(1),_e("ngIf",!(null!=e.cpPresetColors&&e.cpPresetColors.length)&&e.cpAddColorButton)}}function j9(t,n){if(1&t){const e=zn();te(0,"button",58),Ee("click",function(s){return Qe(e),Je(we(2).onCancelColor(s))}),Be(1),Q()}if(2&t){const e=we(2);rl(e.cpCancelButtonClass),me(1),sl(e.cpCancelButtonText)}}function q9(t,n){if(1&t){const e=zn();te(0,"button",58),Ee("click",function(s){return Qe(e),Je(we(2).onAcceptColor(s))}),Be(1),Q()}if(2&t){const e=we(2);rl(e.cpOKButtonClass),me(1),sl(e.cpOKButtonText)}}function K9(t,n){if(1&t&&(te(0,"div",56),Ot(1,j9,2,4,"button",57),Ot(2,q9,2,4,"button",57),Q()),2&t){const e=we();me(1),_e("ngIf",e.cpCancelButton),me(1),_e("ngIf",e.cpOKButton)}}function X9(t,n){1&t&&$x(0)}function Y9(t,n){if(1&t&&(te(0,"div",59),Ot(1,X9,1,0,"ng-container",60),Q()),2&t){const e=we();me(1),_e("ngTemplateOutlet",e.cpExtraTemplate)}}var Er=(()=>{return(t=Er||(Er={}))[t.HEX=0]="HEX",t[t.RGBA=1]="RGBA",t[t.HSLA=2]="HSLA",t[t.CMYK=3]="CMYK",Er;var t})();class $i{constructor(n,e,r,s){this.r=n,this.g=e,this.b=r,this.a=s}}class ig{constructor(n,e,r,s){this.h=n,this.s=e,this.v=r,this.a=s}}class yl{constructor(n,e,r,s){this.h=n,this.s=e,this.l=r,this.a=s}}class ah{constructor(n,e,r,s,o=1){this.c=n,this.m=e,this.y=r,this.k=s,this.a=o}}let J9=(()=>{class t{constructor(){this.newValue=new _t}inputChange(e){const r=e.target.value;if(void 0===this.rg)this.newValue.emit(r);else{const s=parseFloat(r);this.newValue.emit({v:s,rg:this.rg})}}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275dir=Ze({type:t,selectors:[["","text",""]],hostBindings:function(e,r){1&e&&Ee("input",function(o){return r.inputChange(o)})},inputs:{rg:"rg",text:"text"},outputs:{newValue:"newValue"}}),t})(),eY=(()=>{class t{constructor(e){this.elRef=e,this.dragEnd=new _t,this.dragStart=new _t,this.newValue=new _t,this.listenerMove=r=>this.move(r),this.listenerStop=()=>this.stop()}mouseDown(e){this.start(e)}touchStart(e){this.start(e)}move(e){e.preventDefault(),this.setCursor(e)}start(e){this.setCursor(e),e.stopPropagation(),document.addEventListener("mouseup",this.listenerStop),document.addEventListener("touchend",this.listenerStop),document.addEventListener("mousemove",this.listenerMove),document.addEventListener("touchmove",this.listenerMove),this.dragStart.emit()}stop(){document.removeEventListener("mouseup",this.listenerStop),document.removeEventListener("touchend",this.listenerStop),document.removeEventListener("mousemove",this.listenerMove),document.removeEventListener("touchmove",this.listenerMove),this.dragEnd.emit()}getX(e){const r=this.elRef.nativeElement.getBoundingClientRect();return(void 0!==e.pageX?e.pageX:e.touches[0].pageX)-r.left-window.pageXOffset}getY(e){const r=this.elRef.nativeElement.getBoundingClientRect();return(void 0!==e.pageY?e.pageY:e.touches[0].pageY)-r.top-window.pageYOffset}setCursor(e){const r=this.elRef.nativeElement.offsetWidth,s=this.elRef.nativeElement.offsetHeight,o=Math.max(0,Math.min(this.getX(e),r)),i=Math.max(0,Math.min(this.getY(e),s));void 0!==this.rgX&&void 0!==this.rgY?this.newValue.emit({s:o/r,v:1-i/s,rgX:this.rgX,rgY:this.rgY}):void 0===this.rgX&&void 0!==this.rgY?this.newValue.emit({v:i/s,rgY:this.rgY}):void 0!==this.rgX&&void 0===this.rgY&&this.newValue.emit({v:o/r,rgX:this.rgX})}}return t.\u0275fac=function(e){return new(e||t)(Y(Lr))},t.\u0275dir=Ze({type:t,selectors:[["","slider",""]],hostBindings:function(e,r){1&e&&Ee("mousedown",function(o){return r.mouseDown(o)})("touchstart",function(o){return r.touchStart(o)})},inputs:{rgX:"rgX",rgY:"rgY",slider:"slider"},outputs:{dragEnd:"dragEnd",dragStart:"dragStart",newValue:"newValue"}}),t})();class BF{constructor(n,e,r,s){this.h=n,this.s=e,this.v=r,this.a=s}}class zF{constructor(n,e,r,s){this.h=n,this.s=e,this.v=r,this.a=s}}let JC=(()=>{class t{constructor(){this.active=null}setActive(e){this.active&&this.active!==e&&"inline"!==this.active.cpDialogDisplay&&this.active.closeDialog(),this.active=e}hsva2hsla(e){const r=e.h,s=e.s,o=e.v,i=e.a;if(0===o)return new yl(r,0,0,i);if(0===s&&1===o)return new yl(r,1,1,i);{const a=o*(2-s)/2;return new yl(r,o*s/(1-Math.abs(2*a-1)),a,i)}}hsla2hsva(e){const r=Math.min(e.h,1),s=Math.min(e.s,1),o=Math.min(e.l,1),i=Math.min(e.a,1);if(0===o)return new ig(r,0,0,i);{const a=o+s*(1-Math.abs(2*o-1))/2;return new ig(r,2*(a-o)/a,a,i)}}hsvaToRgba(e){let r,s,o;const i=e.h,a=e.s,l=e.v,u=e.a,c=Math.floor(6*i),d=6*i-c,h=l*(1-a),p=l*(1-d*a),f=l*(1-(1-d)*a);switch(c%6){case 0:r=l,s=f,o=h;break;case 1:r=p,s=l,o=h;break;case 2:r=h,s=l,o=f;break;case 3:r=h,s=p,o=l;break;case 4:r=f,s=h,o=l;break;case 5:r=l,s=h,o=p;break;default:r=0,s=0,o=0}return new $i(r,s,o,u)}cmykToRgb(e){return new $i((1-e.c)*(1-e.k),(1-e.m)*(1-e.k),(1-e.y)*(1-e.k),e.a)}rgbaToCmyk(e){const r=1-Math.max(e.r,e.g,e.b);return 1===r?new ah(0,0,0,1,e.a):new ah((1-e.r-r)/(1-r),(1-e.g-r)/(1-r),(1-e.b-r)/(1-r),r,e.a)}rgbaToHsva(e){let r,s;const o=Math.min(e.r,1),i=Math.min(e.g,1),a=Math.min(e.b,1),l=Math.min(e.a,1),u=Math.max(o,i,a),c=Math.min(o,i,a),d=u,h=u-c;if(s=0===u?0:h/u,u===c)r=0;else{switch(u){case o:r=(i-a)/h+(i<a?6:0);break;case i:r=(a-o)/h+2;break;case a:r=(o-i)/h+4;break;default:r=0}r/=6}return new ig(r,s,d,l)}rgbaToHex(e,r){let s="#"+(16777216|e.r<<16|e.g<<8|e.b).toString(16).substr(1);return r&&(s+=(256|Math.round(255*e.a)).toString(16).substr(1)),s}normalizeCMYK(e){return new ah(e.c/100,e.m/100,e.y/100,e.k/100,e.a)}denormalizeCMYK(e){return new ah(Math.floor(100*e.c),Math.floor(100*e.m),Math.floor(100*e.y),Math.floor(100*e.k),e.a)}denormalizeRGBA(e){return new $i(Math.round(255*e.r),Math.round(255*e.g),Math.round(255*e.b),e.a)}stringToHsva(e="",r=!1){let s=null;e=(e||"").toLowerCase();const o=[{re:/(rgb)a?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*%?,\s*(\d{1,3})\s*%?(?:,\s*(\d+(?:\.\d+)?)\s*)?\)/,parse:function(i){return new $i(parseInt(i[2],10)/255,parseInt(i[3],10)/255,parseInt(i[4],10)/255,isNaN(parseFloat(i[5]))?1:parseFloat(i[5]))}},{re:/(hsl)a?\(\s*(\d{1,3})\s*,\s*(\d{1,3})%\s*,\s*(\d{1,3})%\s*(?:,\s*(\d+(?:\.\d+)?)\s*)?\)/,parse:function(i){return new yl(parseInt(i[2],10)/360,parseInt(i[3],10)/100,parseInt(i[4],10)/100,isNaN(parseFloat(i[5]))?1:parseFloat(i[5]))}}];o.push(r?{re:/#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})?$/,parse:function(i){return new $i(parseInt(i[1],16)/255,parseInt(i[2],16)/255,parseInt(i[3],16)/255,parseInt(i[4]||"FF",16)/255)}}:{re:/#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})$/,parse:function(i){return new $i(parseInt(i[1],16)/255,parseInt(i[2],16)/255,parseInt(i[3],16)/255,1)}}),o.push({re:/#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])$/,parse:function(i){return new $i(parseInt(i[1]+i[1],16)/255,parseInt(i[2]+i[2],16)/255,parseInt(i[3]+i[3],16)/255,1)}});for(const i in o)if(o.hasOwnProperty(i)){const a=o[i],l=a.re.exec(e),u=l&&a.parse(l);if(u)return u instanceof $i?s=this.rgbaToHsva(u):u instanceof yl&&(s=this.hsla2hsva(u)),s}return s}outputFormat(e,r,s){switch("auto"===r&&(r=e.a<1?"rgba":"hex"),r){case"hsla":const o=this.hsva2hsla(e),i=new yl(Math.round(360*o.h),Math.round(100*o.s),Math.round(100*o.l),Math.round(100*o.a)/100);return e.a<1||"always"===s?"hsla("+i.h+","+i.s+"%,"+i.l+"%,"+i.a+")":"hsl("+i.h+","+i.s+"%,"+i.l+"%)";case"rgba":const a=this.denormalizeRGBA(this.hsvaToRgba(e));return e.a<1||"always"===s?"rgba("+a.r+","+a.g+","+a.b+","+Math.round(100*a.a)/100+")":"rgb("+a.r+","+a.g+","+a.b+")";default:const l="always"===s||"forced"===s;return this.rgbaToHex(this.denormalizeRGBA(this.hsvaToRgba(e)),l)}}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=We({token:t,factory:t.\u0275fac}),t})();const UF=typeof window<"u"&&"ontouchstart"in window;let tY=(()=>{class t{constructor(e,r,s,o,i,a){this.ngZone=e,this.elRef=r,this.cdRef=s,this.document=o,this.platformId=i,this.service=a,this.isIE10=!1,this.dialogArrowSize=10,this.dialogArrowOffset=15,this.dialogInputFields=[Er.HEX,Er.RGBA,Er.HSLA,Er.CMYK],this.useRootViewContainer=!1,this.eyeDropperSupported=function E5(t){return t===GA}(this.platformId)&&"EyeDropper"in this.document.defaultView}handleEsc(e){this.show&&"popup"===this.cpDialogDisplay&&this.onCancelColor(e)}handleEnter(e){this.show&&"popup"===this.cpDialogDisplay&&this.onAcceptColor(e)}ngOnInit(){this.slider=new BF(0,0,0,0),this.sliderDimMax=new zF(this.hueSlider.nativeElement.offsetWidth||140,this.cpWidth,130,this.alphaSlider.nativeElement.offsetWidth||140),this.format=this.cpCmykEnabled?Er.CMYK:"rgba"===this.cpOutputFormat?Er.RGBA:"hsla"===this.cpOutputFormat?Er.HSLA:Er.HEX,this.listenerMouseDown=s=>{this.onMouseDown(s)},this.listenerResize=()=>{this.onResize()},this.openDialog(this.initialColor,!1)}ngOnDestroy(){this.closeDialog()}ngAfterViewInit(){230===this.cpWidth&&"inline"!==this.cpDialogDisplay||(this.sliderDimMax=new zF(this.hueSlider.nativeElement.offsetWidth||140,this.cpWidth,130,this.alphaSlider.nativeElement.offsetWidth||140),this.updateColorPicker(!1),this.cdRef.detectChanges())}openDialog(e,r=!0){this.service.setActive(this),this.width||(this.cpWidth=this.directiveElementRef.nativeElement.offsetWidth),this.height||(this.height=320),this.setInitialColor(e),this.setColorFromString(e,r),this.openColorPicker()}closeDialog(){this.closeColorPicker()}setupDialog(e,r,s,o,i,a,l,u,c,d,h,p,f,g,m,y,b,v,x,w,C,I,D,E,N,P,V,B,z,U,j,q,W,K,ne,ae,he,le){this.setInitialColor(s),this.setColorMode(u),this.isIE10=10===function Q9(){let t="";typeof navigator<"u"&&(t=navigator.userAgent.toLowerCase());const n=t.indexOf("msie ");return n>0&&parseInt(t.substring(n+5,t.indexOf(".",n)),10)}(),this.directiveInstance=e,this.directiveElementRef=r,this.cpDisableInput=p,this.cpCmykEnabled=c,this.cpAlphaChannel=d,this.cpOutputFormat=h,this.cpDialogDisplay=a,this.cpIgnoredElements=f,this.cpSaveClickOutside=g,this.cpCloseClickOutside=m,this.useRootViewContainer=y,this.width=this.cpWidth=parseInt(o,10),this.height=this.cpHeight=parseInt(i,10),this.cpPosition=b,this.cpPositionOffset=parseInt(v,10),this.cpOKButton=P,this.cpOKButtonText=B,this.cpOKButtonClass=V,this.cpCancelButton=z,this.cpCancelButtonText=j,this.cpCancelButtonClass=U,this.cpEyeDropper=ae,this.fallbackColor=l||"#fff",this.setPresetConfig(w,C),this.cpPresetColorsClass=I,this.cpMaxPresetColorsLength=D,this.cpPresetEmptyMessage=E,this.cpPresetEmptyMessageClass=N,this.cpAddColorButton=q,this.cpAddColorButtonText=K,this.cpAddColorButtonClass=W,this.cpRemoveColorButtonClass=ne,this.cpTriggerElement=he,this.cpExtraTemplate=le,x||(this.dialogArrowOffset=0),"inline"===a&&(this.dialogArrowSize=0,this.dialogArrowOffset=0),"hex"===h&&"always"!==d&&"forced"!==d&&(this.cpAlphaChannel="disabled")}setColorMode(e){switch(e.toString().toUpperCase()){case"1":case"C":case"COLOR":default:this.cpColorMode=1;break;case"2":case"G":case"GRAYSCALE":this.cpColorMode=2;break;case"3":case"P":case"PRESETS":this.cpColorMode=3}}setInitialColor(e){this.initialColor=e}setPresetConfig(e,r){this.cpPresetLabel=e,this.cpPresetColors=r}setColorFromString(e,r=!0,s=!0){let o;"always"===this.cpAlphaChannel||"forced"===this.cpAlphaChannel?(o=this.service.stringToHsva(e,!0),!o&&!this.hsva&&(o=this.service.stringToHsva(e,!1))):o=this.service.stringToHsva(e,!1),!o&&!this.hsva&&(o=this.service.stringToHsva(this.fallbackColor,!1)),o&&(this.hsva=o,this.sliderH=this.hsva.h,"hex"===this.cpOutputFormat&&"disabled"===this.cpAlphaChannel&&(this.hsva.a=1),this.updateColorPicker(r,s))}onResize(){"fixed"===this.position?this.setDialogPosition():"inline"!==this.cpDialogDisplay&&this.closeColorPicker()}onDragEnd(e){this.directiveInstance.sliderDragEnd({slider:e,color:this.outputColor})}onDragStart(e){this.directiveInstance.sliderDragStart({slider:e,color:this.outputColor})}onMouseDown(e){this.show&&!this.isIE10&&"popup"===this.cpDialogDisplay&&e.target!==this.directiveElementRef.nativeElement&&!this.isDescendant(this.elRef.nativeElement,e.target)&&!this.isDescendant(this.directiveElementRef.nativeElement,e.target)&&0===this.cpIgnoredElements.filter(r=>r===e.target).length&&this.ngZone.run(()=>{this.cpSaveClickOutside?this.directiveInstance.colorSelected(this.outputColor):(this.hsva=null,this.setColorFromString(this.initialColor,!1),this.cpCmykEnabled&&this.directiveInstance.cmykChanged(this.cmykColor),this.directiveInstance.colorChanged(this.initialColor),this.directiveInstance.colorCanceled()),this.cpCloseClickOutside&&this.closeColorPicker()})}onAcceptColor(e){e.stopPropagation(),this.outputColor&&this.directiveInstance.colorSelected(this.outputColor),"popup"===this.cpDialogDisplay&&this.closeColorPicker()}onCancelColor(e){this.hsva=null,e.stopPropagation(),this.directiveInstance.colorCanceled(),this.setColorFromString(this.initialColor,!0),"popup"===this.cpDialogDisplay&&(this.cpCmykEnabled&&this.directiveInstance.cmykChanged(this.cmykColor),this.directiveInstance.colorChanged(this.initialColor,!0),this.closeColorPicker())}onEyeDropper(){this.eyeDropperSupported&&(new window.EyeDropper).open().then(r=>{this.setColorFromString(r.sRGBHex,!0)})}onFormatToggle(e){const r=this.dialogInputFields.length-(this.cpCmykEnabled?0:1),s=((this.dialogInputFields.indexOf(this.format)+e)%r+r)%r;this.format=this.dialogInputFields[s]}onColorChange(e){this.hsva.s=e.s/e.rgX,this.hsva.v=e.v/e.rgY,this.updateColorPicker(),this.directiveInstance.sliderChanged({slider:"lightness",value:this.hsva.v,color:this.outputColor}),this.directiveInstance.sliderChanged({slider:"saturation",value:this.hsva.s,color:this.outputColor})}onHueChange(e){this.hsva.h=e.v/e.rgX,this.sliderH=this.hsva.h,this.updateColorPicker(),this.directiveInstance.sliderChanged({slider:"hue",value:this.hsva.h,color:this.outputColor})}onValueChange(e){this.hsva.v=e.v/e.rgX,this.updateColorPicker(),this.directiveInstance.sliderChanged({slider:"value",value:this.hsva.v,color:this.outputColor})}onAlphaChange(e){this.hsva.a=e.v/e.rgX,this.updateColorPicker(),this.directiveInstance.sliderChanged({slider:"alpha",value:this.hsva.a,color:this.outputColor})}onHexInput(e){if(null===e)this.updateColorPicker();else{e&&"#"!==e[0]&&(e="#"+e);let r=/^#([a-f0-9]{3}|[a-f0-9]{6})$/gi;"always"===this.cpAlphaChannel&&(r=/^#([a-f0-9]{3}|[a-f0-9]{6}|[a-f0-9]{8})$/gi);const s=r.test(e);s&&(e.length<5&&(e="#"+e.substring(1).split("").map(o=>o+o).join("")),"forced"===this.cpAlphaChannel&&(e+=Math.round(255*this.hsva.a).toString(16)),this.setColorFromString(e,!0,!1)),this.directiveInstance.inputChanged({input:"hex",valid:s,value:e,color:this.outputColor})}}onRedInput(e){const r=this.service.hsvaToRgba(this.hsva),s=!isNaN(e.v)&&e.v>=0&&e.v<=e.rg;s&&(r.r=e.v/e.rg,this.hsva=this.service.rgbaToHsva(r),this.sliderH=this.hsva.h,this.updateColorPicker()),this.directiveInstance.inputChanged({input:"red",valid:s,value:r.r,color:this.outputColor})}onBlueInput(e){const r=this.service.hsvaToRgba(this.hsva),s=!isNaN(e.v)&&e.v>=0&&e.v<=e.rg;s&&(r.b=e.v/e.rg,this.hsva=this.service.rgbaToHsva(r),this.sliderH=this.hsva.h,this.updateColorPicker()),this.directiveInstance.inputChanged({input:"blue",valid:s,value:r.b,color:this.outputColor})}onGreenInput(e){const r=this.service.hsvaToRgba(this.hsva),s=!isNaN(e.v)&&e.v>=0&&e.v<=e.rg;s&&(r.g=e.v/e.rg,this.hsva=this.service.rgbaToHsva(r),this.sliderH=this.hsva.h,this.updateColorPicker()),this.directiveInstance.inputChanged({input:"green",valid:s,value:r.g,color:this.outputColor})}onHueInput(e){const r=!isNaN(e.v)&&e.v>=0&&e.v<=e.rg;r&&(this.hsva.h=e.v/e.rg,this.sliderH=this.hsva.h,this.updateColorPicker()),this.directiveInstance.inputChanged({input:"hue",valid:r,value:this.hsva.h,color:this.outputColor})}onValueInput(e){const r=!isNaN(e.v)&&e.v>=0&&e.v<=e.rg;r&&(this.hsva.v=e.v/e.rg,this.updateColorPicker()),this.directiveInstance.inputChanged({input:"value",valid:r,value:this.hsva.v,color:this.outputColor})}onAlphaInput(e){const r=!isNaN(e.v)&&e.v>=0&&e.v<=e.rg;r&&(this.hsva.a=e.v/e.rg,this.updateColorPicker()),this.directiveInstance.inputChanged({input:"alpha",valid:r,value:this.hsva.a,color:this.outputColor})}onLightnessInput(e){const r=this.service.hsva2hsla(this.hsva),s=!isNaN(e.v)&&e.v>=0&&e.v<=e.rg;s&&(r.l=e.v/e.rg,this.hsva=this.service.hsla2hsva(r),this.sliderH=this.hsva.h,this.updateColorPicker()),this.directiveInstance.inputChanged({input:"lightness",valid:s,value:r.l,color:this.outputColor})}onSaturationInput(e){const r=this.service.hsva2hsla(this.hsva),s=!isNaN(e.v)&&e.v>=0&&e.v<=e.rg;s&&(r.s=e.v/e.rg,this.hsva=this.service.hsla2hsva(r),this.sliderH=this.hsva.h,this.updateColorPicker()),this.directiveInstance.inputChanged({input:"saturation",valid:s,value:r.s,color:this.outputColor})}onCyanInput(e){!isNaN(e.v)&&e.v>=0&&e.v<=e.rg&&(this.cmyk.c=e.v,this.updateColorPicker(!1,!0,!0)),this.directiveInstance.inputChanged({input:"cyan",valid:!0,value:this.cmyk.c,color:this.outputColor})}onMagentaInput(e){!isNaN(e.v)&&e.v>=0&&e.v<=e.rg&&(this.cmyk.m=e.v,this.updateColorPicker(!1,!0,!0)),this.directiveInstance.inputChanged({input:"magenta",valid:!0,value:this.cmyk.m,color:this.outputColor})}onYellowInput(e){!isNaN(e.v)&&e.v>=0&&e.v<=e.rg&&(this.cmyk.y=e.v,this.updateColorPicker(!1,!0,!0)),this.directiveInstance.inputChanged({input:"yellow",valid:!0,value:this.cmyk.y,color:this.outputColor})}onBlackInput(e){!isNaN(e.v)&&e.v>=0&&e.v<=e.rg&&(this.cmyk.k=e.v,this.updateColorPicker(!1,!0,!0)),this.directiveInstance.inputChanged({input:"black",valid:!0,value:this.cmyk.k,color:this.outputColor})}onAddPresetColor(e,r){e.stopPropagation(),this.cpPresetColors.filter(s=>s===r).length||(this.cpPresetColors=this.cpPresetColors.concat(r),this.directiveInstance.presetColorsChanged(this.cpPresetColors))}onRemovePresetColor(e,r){e.stopPropagation(),this.cpPresetColors=this.cpPresetColors.filter(s=>s!==r),this.directiveInstance.presetColorsChanged(this.cpPresetColors)}openColorPicker(){this.show||(this.show=!0,this.hidden=!0,setTimeout(()=>{this.hidden=!1,this.setDialogPosition(),this.cdRef.detectChanges()},0),this.directiveInstance.stateChanged(!0),this.isIE10||this.ngZone.runOutsideAngular(()=>{UF?document.addEventListener("touchstart",this.listenerMouseDown):document.addEventListener("mousedown",this.listenerMouseDown)}),window.addEventListener("resize",this.listenerResize))}closeColorPicker(){this.show&&(this.show=!1,this.directiveInstance.stateChanged(!1),this.isIE10||(UF?document.removeEventListener("touchstart",this.listenerMouseDown):document.removeEventListener("mousedown",this.listenerMouseDown)),window.removeEventListener("resize",this.listenerResize),this.cdRef.destroyed||this.cdRef.detectChanges())}updateColorPicker(e=!0,r=!0,s=!1){if(this.sliderDimMax){let o,i,a;2===this.cpColorMode&&(this.hsva.s=0);const l=this.outputColor;if(i=this.service.hsva2hsla(this.hsva),this.cpCmykEnabled?(s?(a=this.service.cmykToRgb(this.service.normalizeCMYK(this.cmyk)),this.hsva=this.service.rgbaToHsva(a)):(a=this.service.hsvaToRgba(this.hsva),this.cmyk=this.service.denormalizeCMYK(this.service.rgbaToCmyk(a))),a=this.service.denormalizeRGBA(a),this.sliderH=this.hsva.h):a=this.service.denormalizeRGBA(this.service.hsvaToRgba(this.hsva)),o=this.service.denormalizeRGBA(this.service.hsvaToRgba(new ig(this.sliderH||this.hsva.h,1,1,1))),r&&(this.hslaText=new yl(Math.round(360*i.h),Math.round(100*i.s),Math.round(100*i.l),Math.round(100*i.a)/100),this.rgbaText=new $i(a.r,a.g,a.b,Math.round(100*a.a)/100),this.cpCmykEnabled&&(this.cmykText=new ah(this.cmyk.c,this.cmyk.m,this.cmyk.y,this.cmyk.k,Math.round(100*this.cmyk.a)/100)),this.hexText=this.service.rgbaToHex(a,"always"===this.cpAlphaChannel),this.hexAlpha=this.rgbaText.a),"auto"===this.cpOutputFormat&&this.format!==Er.RGBA&&this.format!==Er.CMYK&&this.format!==Er.HSLA&&this.hsva.a<1&&(this.format=this.hsva.a<1?Er.RGBA:Er.HEX),this.hueSliderColor="rgb("+o.r+","+o.g+","+o.b+")",this.alphaSliderColor="rgb("+a.r+","+a.g+","+a.b+")",this.outputColor=this.service.outputFormat(this.hsva,this.cpOutputFormat,this.cpAlphaChannel),this.selectedColor=this.service.outputFormat(this.hsva,"rgba",null),this.format!==Er.CMYK)this.cmykColor="";else if("always"===this.cpAlphaChannel||"enabled"===this.cpAlphaChannel||"forced"===this.cpAlphaChannel){const u=Math.round(100*this.cmyk.a)/100;this.cmykColor=`cmyka(${this.cmyk.c},${this.cmyk.m},${this.cmyk.y},${this.cmyk.k},${u})`}else this.cmykColor=`cmyk(${this.cmyk.c},${this.cmyk.m},${this.cmyk.y},${this.cmyk.k})`;this.slider=new BF((this.sliderH||this.hsva.h)*this.sliderDimMax.h-8,this.hsva.s*this.sliderDimMax.s-8,(1-this.hsva.v)*this.sliderDimMax.v-8,this.hsva.a*this.sliderDimMax.a-8),e&&l!==this.outputColor&&(this.cpCmykEnabled&&this.directiveInstance.cmykChanged(this.cmykColor),this.directiveInstance.colorChanged(this.outputColor))}}setDialogPosition(){if("inline"===this.cpDialogDisplay)this.position="relative";else{let s,e="static",r="",o=null,i=null,a=this.directiveElementRef.nativeElement.parentNode;const l=this.dialogElement.nativeElement.offsetHeight;for(;null!==a&&"HTML"!==a.tagName;){if(s=window.getComputedStyle(a),e=s.getPropertyValue("position"),r=s.getPropertyValue("transform"),"static"!==e&&null===o&&(o=a),r&&"none"!==r&&null===i&&(i=a),"fixed"===e){o=i;break}a=a.parentNode}const u=this.createDialogBox(this.directiveElementRef.nativeElement,"fixed"!==e);if(this.useRootViewContainer||"fixed"===e&&(!o||o instanceof HTMLUnknownElement))this.top=u.top,this.left=u.left;else{null===o&&(o=a);const d=this.createDialogBox(o,"fixed"!==e);this.top=u.top-d.top,this.left=u.left-d.left}"fixed"===e&&(this.position="fixed");let c=this.cpPosition;if("auto"===this.cpPosition){const d=this.dialogElement.nativeElement.getBoundingClientRect(),h=window.innerHeight,p=window.innerWidth,f=this.elRef.nativeElement.getBoundingClientRect();this.top+d.height>h&&(this.top=h-d.height,this.cpArrowPosition=f.x/2-20),this.left+d.width>p&&(this.left=p-d.width,this.cpArrowPosition=f.x/2-20),c=function Z9(t,n){let e="right",r="bottom";const{height:s,width:o}=t,{top:i,left:a}=n,l=i+n.height,u=a+n.width,c=i-s<0,d=l+s>(window.innerHeight||document.documentElement.clientHeight),h=a-o<0,p=u+o>(window.innerWidth||document.documentElement.clientWidth);return d&&(r="top"),c&&(r="bottom"),h&&(e="right"),p&&(e="left"),c&&d&&h&&p?["left","right","top","bottom"].reduce((m,y)=>t[m]>t[y]?m:y):h&&p?c?"bottom":d||i>l?"top":"bottom":c&&d?h?"right":p||a>u?"left":"right":`${r}-${e}`}(d,this.cpTriggerElement.nativeElement.getBoundingClientRect())}"top"===c?(this.arrowTop=l-1,this.top-=l+this.dialogArrowSize,this.left+=this.cpPositionOffset/100*u.width-this.dialogArrowOffset):"bottom"===c?(this.top+=u.height+this.dialogArrowSize,this.left+=this.cpPositionOffset/100*u.width-this.dialogArrowOffset):"top-left"===c||"left-top"===c?(this.top-=l-u.height+u.height*this.cpPositionOffset/100,this.left-=this.cpWidth+this.dialogArrowSize-2-this.dialogArrowOffset):"top-right"===c||"right-top"===c?(this.top-=l-u.height+u.height*this.cpPositionOffset/100,this.left+=u.width+this.dialogArrowSize-2-this.dialogArrowOffset):"left"===c||"bottom-left"===c||"left-bottom"===c?(this.top+=u.height*this.cpPositionOffset/100-this.dialogArrowOffset,this.left-=this.cpWidth+this.dialogArrowSize-2):(this.top+=u.height*this.cpPositionOffset/100-this.dialogArrowOffset,this.left+=u.width+this.dialogArrowSize-2),this.cpUsePosition=c}}isDescendant(e,r){let s=r.parentNode;for(;null!==s;){if(s===e)return!0;s=s.parentNode}return!1}createDialogBox(e,r){const{top:s,left:o}=e.getBoundingClientRect();return{top:s+(r?window.pageYOffset:0),left:o+(r?window.pageXOffset:0),width:e.offsetWidth,height:e.offsetHeight}}}return t.\u0275fac=function(e){return new(e||t)(Y(Fn),Y(Lr),Y(Nd),Y(ss),Y(hw),Y(JC))},t.\u0275cmp=ja({type:t,selectors:[["color-picker"]],viewQuery:function(e,r){if(1&e&&(Ou(b9,7),Ou(v9,7),Ou(x9,7)),2&e){let s;il(s=al())&&(r.dialogElement=s.first),il(s=al())&&(r.hueSlider=s.first),il(s=al())&&(r.alphaSlider=s.first)}},hostBindings:function(e,r){1&e&&Ee("keyup.esc",function(o){return r.handleEsc(o)},0,px)("keyup.enter",function(o){return r.handleEnter(o)},!1,px)},decls:30,vars:51,consts:[[1,"color-picker",3,"click"],["dialogPopup",""],[3,"left","class","top",4,"ngIf"],["class","saturation-lightness",3,"slider","rgX","rgY","background-color","newValue","dragStart","dragEnd",4,"ngIf"],[1,"hue-alpha","box"],[1,"left"],[1,"selected-color-background"],[1,"selected-color",3,"click"],["class","eyedropper-icon","xmlns","http://www.w3.org/2000/svg","height","24px","viewBox","0 0 24 24","width","24px","fill","#000000",4,"ngIf"],["type","button",3,"class","disabled","click",4,"ngIf"],[1,"right"],["style","height: 16px;",4,"ngIf"],[1,"hue",3,"slider","rgX","newValue","dragStart","dragEnd"],["hueSlider",""],[1,"cursor"],[1,"value",3,"slider","rgX","newValue","dragStart","dragEnd"],["valueSlider",""],[1,"alpha",3,"slider","rgX","newValue","dragStart","dragEnd"],["alphaSlider",""],["class","cmyk-text",3,"display",4,"ngIf"],["class","hsla-text",3,"display",4,"ngIf"],["class","rgba-text",3,"display",4,"ngIf"],["class","hex-text",3,"hex-alpha","display",4,"ngIf"],["class","value-text",4,"ngIf"],["class","type-policy",4,"ngIf"],["class","preset-area",4,"ngIf"],["class","button-area",4,"ngIf"],["class","extra-template",4,"ngIf"],[1,"saturation-lightness",3,"slider","rgX","rgY","newValue","dragStart","dragEnd"],["xmlns","http://www.w3.org/2000/svg","height","24px","viewBox","0 0 24 24","width","24px","fill","#000000",1,"eyedropper-icon"],["d","M0 0h24v24H0V0z","fill","none"],["d","M17.66 5.41l.92.92-2.69 2.69-.92-.92 2.69-2.69M17.67 3c-.26 0-.51.1-.71.29l-3.12 3.12-1.93-1.91-1.41 1.41 1.42 1.42L3 16.25V21h4.75l8.92-8.92 1.42 1.42 1.41-1.41-1.92-1.92 3.12-3.12c.4-.4.4-1.03.01-1.42l-2.34-2.34c-.2-.19-.45-.29-.7-.29zM6.92 19L5 17.08l8.06-8.06 1.92 1.92L6.92 19z"],["type","button",3,"disabled","click"],[2,"height","16px"],[1,"cmyk-text"],[1,"box"],["type","number","pattern","[0-9]*","min","0","max","100",3,"text","rg","value","keyup.enter","newValue"],["type","number","pattern","[0-9]+([\\.,][0-9]{1,2})?","min","0","max","1","step","0.1",3,"text","rg","value","keyup.enter","newValue",4,"ngIf"],[4,"ngIf"],["type","number","pattern","[0-9]+([\\.,][0-9]{1,2})?","min","0","max","1","step","0.1",3,"text","rg","value","keyup.enter","newValue"],[1,"hsla-text"],["type","number","pattern","[0-9]*","min","0","max","360",3,"text","rg","value","keyup.enter","newValue"],[1,"rgba-text"],["type","number","pattern","[0-9]*","min","0","max","255",3,"text","rg","value","keyup.enter","newValue"],[1,"hex-text"],[3,"text","value","blur","keyup.enter","newValue"],[1,"value-text"],[1,"type-policy"],[1,"type-policy-arrow",3,"click"],[1,"preset-area"],[1,"preset-label"],[3,"class",4,"ngIf"],["class","preset-color",3,"backgroundColor","click",4,"ngFor","ngForOf"],[1,"preset-color",3,"click"],[3,"class","click",4,"ngIf"],[3,"click"],[1,"button-area"],["type","button",3,"class","click",4,"ngIf"],["type","button",3,"click"],[1,"extra-template"],[4,"ngTemplateOutlet"]],template:function(e,r){1&e&&(te(0,"div",0,1),Ee("click",function(o){return o.stopPropagation()}),Ot(2,w9,1,7,"div",2),Ot(3,C9,2,8,"div",3),te(4,"div",4)(5,"div",5),Vt(6,"div",6),te(7,"div",7),Ee("click",function(){return r.eyeDropperSupported&&r.cpEyeDropper&&r.onEyeDropper()}),Ot(8,_9,3,0,"svg",8),Q(),Ot(9,S9,2,5,"button",9),Q(),te(10,"div",10),Ot(11,I9,1,0,"div",11),te(12,"div",12,13),Ee("newValue",function(o){return r.onHueChange(o)})("dragStart",function(){return r.onDragStart("hue")})("dragEnd",function(){return r.onDragEnd("hue")}),Vt(14,"div",14),Q(),te(15,"div",15,16),Ee("newValue",function(o){return r.onValueChange(o)})("dragStart",function(){return r.onDragStart("value")})("dragEnd",function(){return r.onDragEnd("value")}),Vt(17,"div",14),Q(),te(18,"div",17,18),Ee("newValue",function(o){return r.onAlphaChange(o)})("dragStart",function(){return r.onDragStart("alpha")})("dragEnd",function(){return r.onDragEnd("alpha")}),Vt(20,"div",14),Q()()(),Ot(21,E9,17,12,"div",19),Ot(22,A9,14,10,"div",20),Ot(23,M9,14,10,"div",21),Ot(24,$9,8,7,"div",22),Ot(25,V9,9,3,"div",23),Ot(26,B9,3,0,"div",24),Ot(27,H9,6,3,"div",25),Ot(28,K9,3,2,"div",26),Ot(29,Y9,2,1,"div",27),Q()),2&e&&(Un("display",r.show?"block":"none")("visibility",r.hidden?"hidden":"visible")("top",r.top,"px")("left",r.left,"px")("position",r.position)("height",r.cpHeight,"px")("width",r.cpWidth,"px"),nl("open",r.show),me(2),_e("ngIf","popup"===r.cpDialogDisplay),me(1),_e("ngIf",1===(r.cpColorMode||1)),me(4),Un("background-color",r.selectedColor)("cursor",r.eyeDropperSupported&&r.cpEyeDropper?"pointer":null),me(1),_e("ngIf",r.eyeDropperSupported&&r.cpEyeDropper),me(1),_e("ngIf",r.cpAddColorButton),me(2),_e("ngIf","disabled"===r.cpAlphaChannel),me(1),Un("display",1===(r.cpColorMode||1)?"block":"none"),_e("rgX",1),me(2),Un("left",null==r.slider?null:r.slider.h,"px"),me(1),Un("display",2===(r.cpColorMode||1)?"block":"none"),_e("rgX",1),me(2),Un("right",null==r.slider?null:r.slider.v,"px"),me(1),Un("display","disabled"===r.cpAlphaChannel?"none":"block")("background-color",r.alphaSliderColor),_e("rgX",1),me(2),Un("left",null==r.slider?null:r.slider.a,"px"),me(1),_e("ngIf",!r.cpDisableInput&&1===(r.cpColorMode||1)),me(1),_e("ngIf",!r.cpDisableInput&&1===(r.cpColorMode||1)),me(1),_e("ngIf",!r.cpDisableInput&&1===(r.cpColorMode||1)),me(1),_e("ngIf",!r.cpDisableInput&&1===(r.cpColorMode||1)),me(1),_e("ngIf",!r.cpDisableInput&&2===(r.cpColorMode||1)),me(1),_e("ngIf",!r.cpDisableInput&&1===(r.cpColorMode||1)),me(1),_e("ngIf",(null==r.cpPresetColors?null:r.cpPresetColors.length)||r.cpAddColorButton),me(1),_e("ngIf",r.cpOKButton||r.cpCancelButton),me(1),_e("ngIf",r.cpExtraTemplate))},dependencies:[Vw,Bw,zA,J9,eY],styles:['.color-picker{position:absolute;z-index:1000;width:230px;height:auto;border:#777 solid 1px;cursor:default;-webkit-user-select:none;user-select:none;background-color:#fff}.color-picker *{box-sizing:border-box;margin:0;font-size:11px}.color-picker input{width:0;height:26px;min-width:0;font-size:13px;text-align:center;color:#000}.color-picker input:invalid,.color-picker input:-moz-ui-invalid,.color-picker input:-moz-submit-invalid{box-shadow:none}.color-picker input::-webkit-inner-spin-button,.color-picker input::-webkit-outer-spin-button{margin:0;-webkit-appearance:none}.color-picker .arrow{position:absolute;z-index:999999;width:0;height:0;border-style:solid}.color-picker .arrow.arrow-top{left:8px;border-width:10px 5px;border-color:#777 rgba(0,0,0,0) rgba(0,0,0,0) rgba(0,0,0,0)}.color-picker .arrow.arrow-bottom{top:-20px;left:8px;border-width:10px 5px;border-color:rgba(0,0,0,0) rgba(0,0,0,0) #777 rgba(0,0,0,0)}.color-picker .arrow.arrow-top-left,.color-picker .arrow.arrow-left-top{right:-21px;bottom:8px;border-width:5px 10px;border-color:rgba(0,0,0,0) rgba(0,0,0,0) rgba(0,0,0,0) #777}.color-picker .arrow.arrow-top-right,.color-picker .arrow.arrow-right-top{bottom:8px;left:-20px;border-width:5px 10px;border-color:rgba(0,0,0,0) #777 rgba(0,0,0,0) rgba(0,0,0,0)}.color-picker .arrow.arrow-left,.color-picker .arrow.arrow-left-bottom,.color-picker .arrow.arrow-bottom-left{top:8px;right:-21px;border-width:5px 10px;border-color:rgba(0,0,0,0) rgba(0,0,0,0) rgba(0,0,0,0) #777}.color-picker .arrow.arrow-right,.color-picker .arrow.arrow-right-bottom,.color-picker .arrow.arrow-bottom-right{top:8px;left:-20px;border-width:5px 10px;border-color:rgba(0,0,0,0) #777 rgba(0,0,0,0) rgba(0,0,0,0)}.color-picker .cursor{position:relative;width:16px;height:16px;border:#222 solid 2px;border-radius:50%;cursor:default}.color-picker .box{display:flex;padding:4px 8px}.color-picker .left{position:relative;padding:16px 8px}.color-picker .right{flex:1 1 auto;padding:12px 8px}.color-picker .button-area{padding:0 16px 16px;text-align:right}.color-picker .button-area button{margin-left:8px}.color-picker .preset-area{padding:4px 15px}.color-picker .preset-area .preset-label{overflow:hidden;width:100%;padding:4px;font-size:11px;white-space:nowrap;text-align:left;text-overflow:ellipsis;color:#555}.color-picker .preset-area .preset-color{position:relative;display:inline-block;width:18px;height:18px;margin:4px 6px 8px;border:#a9a9a9 solid 1px;border-radius:25%;cursor:pointer}.color-picker .preset-area .preset-empty-message{min-height:18px;margin-top:4px;margin-bottom:8px;font-style:italic;text-align:center}.color-picker .hex-text{width:100%;padding:4px 8px;font-size:11px}.color-picker .hex-text .box{padding:0 24px 8px 8px}.color-picker .hex-text .box div{float:left;flex:1 1 auto;text-align:center;color:#555;clear:left}.color-picker .hex-text .box input{flex:1 1 auto;padding:1px;border:#a9a9a9 solid 1px}.color-picker .hex-alpha .box div:first-child,.color-picker .hex-alpha .box input:first-child{flex-grow:3;margin-right:8px}.color-picker .cmyk-text,.color-picker .hsla-text,.color-picker .rgba-text,.color-picker .value-text{width:100%;padding:4px 8px;font-size:11px}.color-picker .cmyk-text .box,.color-picker .hsla-text .box,.color-picker .rgba-text .box{padding:0 24px 8px 8px}.color-picker .value-text .box{padding:0 8px 8px}.color-picker .cmyk-text .box div,.color-picker .hsla-text .box div,.color-picker .rgba-text .box div,.color-picker .value-text .box div{flex:1 1 auto;margin-right:8px;text-align:center;color:#555}.color-picker .cmyk-text .box div:last-child,.color-picker .hsla-text .box div:last-child,.color-picker .rgba-text .box div:last-child,.color-picker .value-text .box div:last-child{margin-right:0}.color-picker .cmyk-text .box input,.color-picker .hsla-text .box input,.color-picker .rgba-text .box input,.color-picker .value-text .box input{float:left;flex:1;padding:1px;margin:0 8px 0 0;border:#a9a9a9 solid 1px}.color-picker .cmyk-text .box input:last-child,.color-picker .hsla-text .box input:last-child,.color-picker .rgba-text .box input:last-child,.color-picker .value-text .box input:last-child{margin-right:0}.color-picker .hue-alpha{align-items:center;margin-bottom:3px}.color-picker .hue{direction:ltr;width:100%;height:16px;margin-bottom:16px;border:none;cursor:pointer;background-size:100% 100%;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJYAAAAQCAYAAAD06IYnAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4AIWDwkUFWbCCAAAAFxJREFUaN7t0kEKg0AQAME2x83/n2qu5qCgD1iDhCoYdpnbQC9bbY1qVO/jvc6k3ad91s7/7F1/csgPrujuQ17BDYSFsBAWwgJhISyEBcJCWAgLhIWwEBYIi2f7Ar/1TCgFH2X9AAAAAElFTkSuQmCC)}.color-picker .value{direction:rtl;width:100%;height:16px;margin-bottom:16px;border:none;cursor:pointer;background-size:100% 100%;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJYAAAAQCAYAAAD06IYnAAACTklEQVR42u3SYUcrABhA4U2SkmRJMmWSJklKJiWZZpKUJJskKUmaTFImKZOUzMySpGRmliRNJilJSpKSJEtmSpIpmWmSdO736/6D+x7OP3gUCoWCv1cqlSQlJZGcnExKSgqpqamkpaWRnp5ORkYGmZmZqFQqsrKyyM7OJicnh9zcXNRqNXl5eeTn56PRaCgoKKCwsJCioiK0Wi3FxcWUlJRQWlpKWVkZ5eXlVFRUUFlZiU6no6qqiurqampqaqitraWurg69Xk99fT0GgwGj0UhDQwONjY00NTXR3NxMS0sLra2ttLW10d7ejslkwmw209HRQWdnJ11dXXR3d9PT00Nvby99fX309/czMDDA4OAgFouFoaEhrFYrw8PDjIyMMDo6ytjYGDabjfHxcSYmJpicnGRqagq73c709DQzMzPMzs4yNzfH/Pw8DocDp9OJy+XC7XazsLDA4uIiS0tLLC8vs7KywurqKmtra3g8HrxeLz6fD7/fz/r6OhsbG2xubrK1tcX29jaBQICdnR2CwSC7u7vs7e2xv7/PwcEBh4eHHB0dcXx8zMnJCaenp5ydnXF+fs7FxQWXl5dcXV1xfX3Nzc0Nt7e33N3dEQqFuL+/5+HhgXA4TCQS4fHxkaenJ56fn3l5eeH19ZVoNMrb2xvv7+98fHwQi8WIx+N8fn6SSCT4+vri+/ubn58ffn9/+VcKgSWwBJbAElgCS2AJLIElsASWwBJYAktgCSyBJbAElsASWAJLYAksgSWwBJbAElgCS2AJLIElsP4/WH8AmJ5Z6jHS4h8AAAAASUVORK5CYII=)}.color-picker .alpha{direction:ltr;width:100%;height:16px;border:none;cursor:pointer;background-size:100% 100%;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJYAAAAQCAYAAAD06IYnAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4AIWDwYQlZMa3gAAAWVJREFUaN7tmEGO6jAQRCsOArHgBpyAJYGjcGocxAm4A2IHpmoWE0eBH+ezmFlNvU06shJ3W6VEelWMUQAIIF9f6qZpimsA1LYtS2uF51/u27YVAFZVRUkEoGHdPV/sIcbIEIIkUdI/9Xa7neyv61+SWFUVAVCSct00TWn2fv6u3+Ecfd3tXzy/0+nEUu+SPjo/kqzrmiQpScN6v98XewfA8/lMkiLJ2WxGSUopcT6fM6U0NX9/frfbjev1WtfrlZfLhYfDQQHG/AIOlnGwjINlHCxjHCzjYJm/TJWdCwquJXseFFzGwDNNeiKMOJTO8xQdDQaeB29+K9efeLaBo9J7vdvtJj1RjFFjfiv7qv95tjx/7leSQgh93e1ffMeIp6O+YQjho/N791t1XVOSSI7N//K+4/GoxWLBx+PB5/Op5XLJ+/3OlJJWqxU3m83ovv5iGf8KjYNlHCxjHCzjYBkHy5gf5gusvQU7U37jTAAAAABJRU5ErkJggg==)}.color-picker .type-policy{position:absolute;top:218px;right:12px;width:16px;height:24px;background-size:8px 16px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAAgCAYAAAAffCjxAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAACewAAAnsB01CO3AAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAIASURBVEiJ7ZY9axRRFIafsxMStrLQJpAgpBFhi+C9w1YSo00I6RZ/g9vZpBf/QOr4GyRgkSKNSrAadsZqQGwCkuAWyRZJsySwvhZ7N/vhzrgbLH3Ld8597jlzz50zJokyxXH8DqDVar0qi6v8BbItqSGpEcfxdlmsFWXkvX8AfAVWg3UKPEnT9GKujMzsAFgZsVaCN1VTQd77XUnrgE1kv+6935268WRpzrnHZvYRWC7YvC3pRZZl3wozqtVqiyH9IgjAspkd1Gq1xUJQtVrdB9ZKIAOthdg/Qc65LUk7wNIMoCVJO865rYFhkqjX6/d7vV4GPJwBMqofURS5JEk6FYBer/eeYb/Mo9WwFnPOvQbeAvfuAAK4BN4sAJtAG/gJIElmNuiJyba3EGNmZiPeZuEVmVell/Y/6N+CzDn3AXhEOOo7Hv/3BeAz8IzQkMPnJbuPx1wC+yYJ7/0nYIP5S/0FHKdp+rwCEEXRS/rf5Hl1Gtb2M0iSpCOpCZzPATmX1EySpHMLAsiy7MjMDoHrGSDXZnaYZdnRwBh7J91utwmczAA6CbG3GgPleX4jqUH/a1CktqRGnuc3hSCAMB32gKspkCtgb3KCQMmkjeP4WNJThrNNZval1WptTIsv7JtQ4tmIdRa8qSoEpWl6YWZNoAN0zKxZNPehpLSBZv2t+Q0CJ9lLnARQLAAAAABJRU5ErkJggg==);background-repeat:no-repeat;background-position:center}.color-picker .type-policy .type-policy-arrow{display:block;width:100%;height:50%}.color-picker .selected-color{position:absolute;top:16px;left:8px;width:40px;height:40px;border:1px solid #a9a9a9;border-radius:50%}.color-picker .selected-color-background{width:40px;height:40px;border-radius:50%;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAoCAYAAACM/rhtAAAAh0lEQVRYR+2W0QlAMQgD60zdfwOdqa8TmI/wQMr5K0I5bZLIzLOa2nt37VVVbd+dDx5obgCC3KBLwJ2ff4PnVidkf+ucIhw80HQaCLo3DMH3CRK3iFsmAWVl6hPNDwt8EvNE5q+YuEXcMgkonVM6SdyCoEvAnZ8v1Hjx817MilmxSUB5rdLJDycZgUAZUch/AAAAAElFTkSuQmCC)}.color-picker .saturation-lightness{direction:ltr;width:100%;height:130px;border:none;cursor:pointer;touch-action:manipulation;background-size:100% 100%;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAOYAAACCCAYAAABSD7T3AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4AIWDwksPWR6lgAAIABJREFUeNrtnVuT47gRrAHN+P//Or/61Y5wONZ7mZ1u3XAeLMjJZGZVgdKsfc5xR3S0RIIUW+CHzCpc2McYo7XGv3ex7UiZd57rjyzzv+v+33X/R/+3r/f7vR386Y+TvKNcf/wdhTLPcv9qU2wZd74uth0t1821jkIZLPcsI/6nWa4XvutquU0Z85mnx80S/ZzgpnLnOtHNt7/ofx1TKXcSNzN/7qbMQ3ju7rNQmMYYd/4s2j9aa+P+gGaMcZrb1M/tdrvf7/d2v99P9/t93O/3cbvdxu12G9frdVwul3E+n8c///nP+2+//Xb66aefxl//+tfx5z//2YK5Al2rgvf4UsbpdGrB52bAvArXpuzjmiqAVSGz5eDmGYXzhbAZmCrnmzddpUU+8Y1dAOYeXCtDUwVwV7YCGH6uAmyMcZ9l5vkUaBPGMUZ7/J5w/792/fvv9Xq93263dr/fTxPECeME8nK5jM/Pz/HTTz/dv337dvrll1/GP/7xj/G3v/1t/OUvfwkVswongjdOp9PzH3U3D3zmWGnZVXn4jCqs7wC2BKP4/8tAzkZsoWx6XrqeHZymvp4ABCBJhTQwKfDT8gzrZCIqi5AhiACjBfEB2rP8/X63MM7f6/V6v9/v7Xa7bYC83W7jcrlsVHIq5ffv30+//fbb+OWXX8ZPP/00/v73v4+ff/75JSvbeu+bL2WMMaFbAlpBNM85QX+ct6qoSqkPAwuQlBVKqGNFSUOAA3Bmu7gC5hNOd15nSwvAOUW7C4giUCV8Sgn5L9hNFIqTsp0GxI0ysioyjAjkY/tGJVEpz+fz+OWXX+7fv38//f777+Pbt2/j119/HT///PP49ddfx8fHRwrmTjV779EXu2px2xhjwtdJZQcAWQIPLPISsMJaSwiD8gzIKrwSyATE5j5nAbR5c1dBUwBlsEWW0h6LqiYsqFPAQxCyRZ3wOSARxmlXMX5k64pQfvv27f75+dk+Pj5OHx8f4/v37+Pbt2/jt99+G9++fRsfHx/jcrmUFLO31gYDWblxRIs/TqfT7ousxJsAxXA2Gc7TA9XdgfdoHbFsj76X2+1WArgI1ageGwA3qupqoHsmcbI6Fu93quggFa9d7LeDtgKfAFHBJ+NEByIkcJ5KervdTmhhGcgJJSZ5vn//fj+fz+18Pp8+Pz/H5+fnmGD+/vvv4/v37+Pj42N8fn6O2+1Ws7JjjP6wraMI5E4RZ8x2vV5TSwkquotV7/d7Tz6HFWsD/qNcdw0CQ3q/321c686TwDVIdbuy73zNldhSHb8I2klZznm+InBS4U6n0302aBFsLhHDAKJVJVglfI9jhvu53W53sLANYNxAiDA6MCeUHx8f9+v12i6XS7tcLqcZW57P5yeY8/fz83Ocz+fnsSmYUyknWEG85WBst9stzSLyMdfr9Qi08iY15UZ0LlDGLhR3o5zK2j7OPUTD0E+nU3tk7Xb/16NFbhloAMuY1zjLUOO3BKeIDe+Z8s3/J4gFo4TM5jPmuRg28foUKKVSwo16TgA5npywcWLHgYl/Pz8/73/605/ab7/91m63W7tcLie0sZj4mao5gTyfz88E0f1+j8EcYzwTPEG2cqjyfHNF0M8fuqEiaOVnRzZZQNh5fwQyHg/HDGfJo89Q1zb/quu5XC6773I2XKfTqd/v9+d3wuqWva/YTdUdEV3fhIv/Viyps6YE3x3r43K5bJQS66zaxVGFsvd+//j4aF+/fm3fv39vt9utff36tf3+++/tdrudvn37ZuNLBaaCMgUzC+rZRiFowxUuJI8YMqcCp9Opq5vagaYU6lGJA1XQqejchw6Cj0Gw5nYBrGw01A2O206n04BGouNNyTfp/FwElhUey6nXrIKw7QQWddxuN2ldL5fL839gSPF8ahu/JvBO48CPSuqMf8Vp9/P53L58+dLu93s7n8/tfr8/39/v9/b5+TkhPJ3P56mQ436/j+/fv+/iSgbzer0+AZx/5+88bv6OMda6S5z6kd21fYC9dxv7cIJJ2d9AOS30fPMzyHiTM8B4DF6XUlYHp4KQW3W+1t77MNB1vGHxWq7Xa7vf78+y5/N5A+H1et29xuP5dbYtyaRu4AksbPq6936fjRzXRxBbPr/b+b18+fKljTHaBBBfn8/n0/1+H1++fBnn8zm0sB8fH5u4cr5GuBhMVk0EEn9RsctgVhM+ixlJtMA23R8B6yysAstBOgFXIKKCMIgToMqNEu2fYMH7ztc732dQKkCj1ytAZtY0Kx8pIr8GGJ+AT3V+2Hirhl++fBmXy2Wz73w+b17P8p+fn8/tUwGVleVkTyUb68DkfayWY4zxNRihU4EpLJPZVrK+u7J4/mgfKqeLW9X2REWlItL1diynbDDb3+jXgYjQqn0rrxWc+NkILP7F7xIbMvx7vV53x40xnlbWJF12ZSag/N0pW6t+ZzmOMzHjajKwDfond78zYTdfq18up97zr2q8v3IioBprRtBl0EZ9og5WBRGOdOHjIjXF7UotFbgOWnXzIJyzYvjG5IYgsmMOxHkz8OsMSrVNWeq5T8DaOcbEv1Od5rbs9aO7YvMet63EkF++fMExq+MRl4/L5bLZN/+ez+fnZ6KazuMqXSQVO5spJXflHAIzes/xJseckRJiDMog9d6VfRrqXMr6KpVV27jRwJacGovOAM1zMdQMnwK1AubK63kdCChvI1C7g0z9nf/D+Xze2Vj8H7Gx4P9duQlsYCrqyN8XqG3Hm/10Oj3jw/n+crlstuM+jPmmxT2dTuPz83Pzt2pn1XsEHX/bnPaVqVmh0xwOt0o6XLLAHePUU203wHfcrspCwmV3TryB5s0Mseeg97x/BwzCjBlbB+pRAPla0BVQuT6V6QHdBlj3d0KG147b+DqxQeUymDO43W4dQar+TIjwmAd0z8/h65vf0/yLv3Pb5XLpru/ydDo9s7ET0I+Pj6dKK9VUEIeKWQWPAOrJ8LKd4vE+t91Y3e7UFlWatg2VwJnb+HPmtvm/sfK59/OaWF3x/eP1UPHvA5DDYDpYXfb0drv1V2DkBkxtw/tEWVVlXWdC9pFYs5/jfh9dS/16vW7s6lTG+TfqsxSJHxkXXq/Xdr1eu4LsfD6P3vsT3N77DkL+zPm5jSdKL4zR3AxQd6rHkLkYlSowsrq7znzu6wSwdsMJOXmA5fBcjxtgMGBYHlr5zokhtsMCTgXLQOW4XC6dEyEMprL8mAQzXRgduix2yZzorxkYsDn3hB1VeMLGsXsVtgl2pW8S3svk0vw7R4hNaHvv4cACl5HFzwIH0Kc6zu4XjDPR/jpAVxWzO1Xk2DDb3vTcxeGU1iWZHkmIDWziWKvirCJ4Dravs6IJ/GG6cTqWdXDy+fArQDVVkLqkVjAoZIITdmmIqXwqa95N3+MGYoZQdRVNO53Y1xRkhO16vY7eu507Ca9lJnbGpxOemQhSw/AQsmmp5zU9BiU8G6wvX76M6/U6Pj4+do0Bz4CpgiknTUeDqwlKBmg3u4OVjrZ1A+rAcgaejWq6eJCvCYFDONSwOgHX4EQRw8lxbzDOdEK6gZ3Hk1b+8g2o1JFtKXyv/fEdTXuWjWXdAZiBp6ADeDrCFiim7B6ZFneeI7Gvm/PMkUDX67W7xI8b0D7/v8dA9qfN5oaCf74WZjH0mf1cmfY1Y0JUFmVrTWu8uzkNcLtEj7u5FXBTkfC6GOA5q8YMxO8KVvF6sAVGdcrUbsKODcQKkLMOMdmlxum642YrPm26AlhZW1YB1R+rrGswE8TaYAWeUMxdf+WjwSvZ2Ef3ytOyfn5+PpVPAaqOn43MtNBqvmjjxbjM4lZjZY4gqNMI5ktaW/sYKNwS+9lFQzGihmMCKPa7+Z0V6Eb0GRmobtpX8JljWu5FMLN5ja6hG9kwQgZqf5+1NH5UxzkFReCdWhJ8XdlGUkxO7HRlYRm4mVO43W7ter12TPJEw/rmEN3L5SKHIWZg9mz+pUoKOYq5bJTJdX2gme1UcxMZQFaEQIlHct32M+Y1BzGkGuzfiyAN9z+ugplZ1symCrDCYYkGxDTpI9RzBy0rHyeDUC1nWaeUaD9n4xkNyYMBDZtzZ3B++fJlY21XFDOcARJlabOyiS3uCpLI9jrZjCDkaVvcCCjwognKShWdzXZWlZMvVTgD8LpqlCLrqgbcB+qYwrgKYpT0ccCqbKyCValkEabn/FynogCrPKfqf51xJ7sGB2ZXcZmxoSOztjx300DZi7a0/2AIR0UlBag9SuDw6KcAzlaB7vHZvWpjK90dyrq6bKyDUZQbR0B05biLQkHIcSUmgIK+SwuqgHCnoio2RQU1yj+BnBy9pphVKLGyC7ZzFK1pxWK+E8IhVCWLN/uLtnUU4ayoYLoaANz8FdtaSvY4pV0BEW2ls61czqllBKpTyKgMAhrZ1cdc1RROtPmvWNkdcKZ7ZKxaWjiPLJMpp7OZKxA+rqG/oJLjxf0pnJlqLoDZo3gyU0mKGys2taKecj/d1C+rJSplBqlTyAqgR+D8KjKlmRL2gtUcAdCtsL+ijCNT1oqqqkH2OHEbG5sDFnUg5Aa+yLou2VU1ptj1S2ZQqv1ORZN9IWzRfgaRBxKoBE8UWyqlJFtrIc0AxNjSjed99CTY/XDfSzCz5M0IZoVEsWnPFNTsl8ooVC1TzbGgqFZNDSgVwKK+1sGDMKqxZCWGVMDysiEr1jVSQJUYwj5iHOlThdHt44SQg9CN+nl8D90NMIgAdgr46JqRiR9I8vRdFvbr17m/yxUMKjNLMiVUADwu2CWGhhi+F55TWM9M9cogzms1dnM4uOF/LAEYWdcqnM7yFmyq3IfwmOROd7Y1iFWtOjoY8To41mTV5IysgFFuRzsbWFGbNIIJCDv1dOo4lZG7jWBwRFtVTKuWyeCByJKOan8oZ3ep9XddNl0tDuaywLz9cXPYeDAA0SpkBO9sbVcTOVWldPv4uyzEkzxHtjvonHoSkFEWNoo1d8DhcQputd2ppNon4BzoAiJ1hBFQg0dVtdbGHHDQWushmNEQukLM2QO1G2Y8bgTXqFhcBJj7EjPgcPts8US8qPpPB/dXznOh5Z438tzH5ec6QgrOKrRRfKmysBmUDB+PhYabMlVPER+GCSITTzr7am2tArH3bgcEzPJm+cr5jJ4NnHNFDVrFXcI5Le9k5Jnw+bedbV+FfRzZIHaOOaOsLY0/7UGs58DjrGwKMIMFIGzOEW1/jGsdAtCN6hEAI4hBe9YXeRROBSVPAVPAqvIM5bx5hVKWAMP6zBRy3iescridVdFBinBxXDnG2GRY2XbCvp1lhvGtO9Bxu5h908XQu42lnSArMFdizMim8uwRCxPGnnOS8lwpnbOiDqTAjsrRN/PcoAScCbaACqVM40ylnjjTBs+bwWlAG23/UKbdkiwKWIQPGzWaczpoSlxPEj822cNWkpS7FyzsDrqpfgpG3jahw2vgbaSQAxuLWZYt7JzyNe8JoZpNAcvDFOdw0wqYT9AK1rZz/DdbSlLPp0ryIxgQJlK9AZlEq7IOXpohg9PIhrCng88JsOxiV4ZWAYfg4sikx/8ky2Z9l862uqwrfscIH8+ugTmVGyiddeVYUgEMn4GZzg14EwIsh9sx2cKKiWXReuOE5gzGOQgdlRKVVdlevqb279Xq0Qnsts2VDaBO0coezsruWtHApu6sKG4IBhN0aGU2kLrMKGRTN3HmbCDwKV14zvkMEDG4QfZVspVlaNU2mhc5TEZ3N1h/zqTheuLpW05ZWTGVjb3dbnNmxKZBnN8JqidaVLKAOyARNLS+MB54Z2+VaqoMLKroVBlngefnTPAcoHNWCSvlfA8CI0HEmBNBnBlXyMrzU7A7WVm94PPqQ2gmqKx+WDGsnvilmcSOBJqOK1nYyAIzuAyesq3UdSK3KfWcYKD95HmfYOU3qser2CtYEUA+FpfqdNvgPBZUBhDrGONRVlQsh8rLcaUCykHG0OOUwTlLBrsh5soEMGezi1E4HRVt1icp5wZEFXdibCkG8Y8vX75sbO4E0iom9z+hjSiOfy3DhpXItpVhE+UGQdvoWjtChmrGHf4YAzKgBNnGtuJxFCeGdhUAfQLLK8kBYAP6gvFJZajMG3Xkycy8KuC0q4Eyymwtwdxdv2M0mIBtK0LKnf640j00Auq4gUkdWGlhs22qJc6dZCsL19oxnlTJG4SYVRIGpD8TPFBuM6OElbS1pldid4mGAyN6ZIupbC5bXJN9fdpbThSxLUaI8IG1XIYBxW3Tjs6KQosKcxfxcQmdnwRGM10GnFcCy2XYunLMyAkdgk4mePiczsLygthcBut6goOqS7YVFXADLjaosB6s6ofcZWAZSIRYqSUkizYwttYab3vUOQ9w2HRxIIg8WwRVeE68xi4UtL3zRphxplzwuZrcqYCq1I3jPI5dnJIygEohMbPqVJSzrwzxBJTs5zN+ReUSgxikPQVF3JVBeNQxbHENrEMNvEdFZVV9lH9+ORGEsNZQpyTNc4C3AG7XF4ngzq+DrO2zbuaaOXgdaFcdkEotoSFBVX2qJ0C8OWZeG4KGlpghA0XfTOPCqV2qqwQ26QWfF2PMLhI2w1lVAa2aPsYd0za25MQRwgcZN6uQDCi+ZxiD4XEM2kZxOT41FnZnaRlcpZouzlRqqdbQVWopQoSB58RV50lBNrHi/AwXS5LrwDVlpY3Fc3ByiYGc52Trist6kOXdwInAQtJpp5QchyaquYOV7Su+fxVMaV3dc0RE2S6mUY0gLt2pMcYqrKIQ9w2l1gpQUMtQYcmmbt5DTNxdhnUCjQqtbK9SUSzvrC0mmhhE1e2FS2+oxypy/ZASutkmtjx3vcBC24PX65nbqkBCRhfjS9kIYPnee8cMagVOhI/3T1fAmdtAWZsCswTJCkQVNa0qWKSKPOpHAUhD9DrbVcyoYkwqhvh17vYAayXLQyKGYdxlUDFp494rBXRjYgO17DDYetNIUj/ezp6S0lnlpEwsWmJMkOwsKXeZKEAjIHn0EQJISaRBcO6UMINz7p/bEjjnw4ft+xmDvksxX4G2rIris7qaeKwAFMP2Oi7n4criuZwtpSUwpfLxSnORSrIqusc5ZFaXysqRWjiZ2DyAWEIL35tVSoQElFACjOeGGSE7AHEQgdo/LSvCOgGBvkxsmDbvlS3Fp5vhaB2TAGqRKrKKMrhLVpaGzEVjZ0OQxDhaCTA+QyRR1d15aQzrJntL3RibsipjG6jlgL4yqbS0sNYg1e84vhbBVrElK64CUcWYXDfKxhpIuxiVJZUxsbMy/uRBKTNRQ4kQ3LdRYLS0rJjRPlTPqY6gdJsEDc+aQXAn+HgsNUCbRuF0Oj0zwnA7bWDkbhO5Ens00qeQhS1laBMl5M/cAaxsLF8rKyql+Tf7ELLEGu/ixiimdCvo0TjfpjKwaggen4eh5v7LokLKbLuyvHhcZG8dhGrEDx7Hg93ZppJF7qBqO3iVveXEDQNInzeoe8Yq6ePaZBZ2JviM3W2UAGotekRCAGq4EkF1X3DOnR11yRsBL1tRa0PVcZiNFXZ2c34FskvomInQQ6lzpJoZbJxk43NwKJFBquJSsrByHydxKOnTxQASBmS3j+JMnsHSla3Ec6K9VWoJVn9zfjwOM7hqYAAqJQwE2a3nA48J2QGegRkpZNivSY+ys3EkKd4oJIwsvIHl3cWgLt5k4NH6OmtLWdpurOkwEMupYc7eMtDRhOcI2ui5JhVIzXzLyto/GAPuZoyo8wkoduVgJglCt7OhGbgID4Mq4si+63zUS1FuFFXFlqyaj2emHlLMcBqYu0FMuR28BbB7lOxRMSiCQXFhCKuwkhZ+pYDiGSgbsKKV8MiSRsuHSIWM9rklRiIlZZuqXjsQK8ooYJMgq3JKWVkhHbhsVxFUzthOWPkYijcbx54IKsSdT+uLr3crGKyoYgFiGR9iBk4kfloUX+JIlQRQqabmpgnhqtpQpb6RVQ1WH5DnrS4hEoGZqaerQ2dhFbz8XePxShmDbo70eISjoorO2vK8SJXI4SUmEU4zWKDzUDtWTYw7xXlbSTEj4FRg7zKnKoGRALv0Gs9Tgc1BpCywGZRQAtqVz2xrBcAMzEpfZwFSa2G5W0QBFjSMapWAEFa3HcGN7CxDzECyIkJ97qwrqWNTWVo876PPsjPkj2wvgroM5lLZKMETKVql/CvnWVFiFa/SzJUQwkoZsr67Y6vlSRV3/2tmNTOY3vnaxYwMuoPKqdzR1w7IqHymlPxaAThfU7Ko2ZXYj4AYJHL+kNdKwRQYESTRa5fsUZ/rVC1TMTyWVyYoqNtuzaHsMyv2tvoarxdfqwYgU1axFo/cnql1FGsqK+uAROV8BX4GU8WcZTATi2q7Qcyi0O0V+GhWBMNRUkn8H1SsWVE5By3Gi0ECqUeJoBfAtDa4amkdXG37AGP5Ggeb84p7UazpoKRzdFzeQ8HkoHGxprKy/Hpm5t12p47J6xTYDEz7uINEXSuxYXvFskYAc+ySxH9sf5ftKzU6IbwVBcUGg5e5FMCEXSErZR0wGayV19woM9guPjTqJdVTqR4uE4nJnLldWVkECCZLd2VLF+xtamex7IpiriSDUpvrpn9lrwGMCHyppMH+ps6LILsuFGUj1XEOXiqbqSHPUKnClpWV68kqtURVNDY4TNaocykoYeTU5ngGEQa/S1DnnE4AeXMcKjHPAmFVjCBENaeyLVNHfr3px8xUstJ94hIpfH4HKE/eDaArK6lSyVVFbdt1gxTIVk3pppVlFXi4pEhVBTObquohU85MLXn1iahvUkHJjSCMc01tLFveVVBx0DodM6jftCu7DOtIzYxrc0qp1JGP2ayYFz2Gb6HvMrO8cnGtV6Gjm3uImSfD2GpWK6uowbZGMxFKQCo1pOMtcMXFpRst+hXGoAomF3sSTBGgTglbBKWwsQ3tZqaYSp0Z1CimRDWFcCJUPYJ00BI5FkKYNoifuQxmN88SWVXWLMaUqqqgC0BmQJR6sk3u9NCf6jYLXxAfqsYEgVLAhRY2AtgtflZNFmFyhxdrLkAdWlk4D88M2ixHyepIdhMHrG/iR1ZGtq0MGpbDbRPYOXeSY1M6Ny4ZstvGSktK+XbFPATj2D371saPEsAMXhXrsZ0km/XStkhhMyBfsa6uXFZe2VCe+YMr1+GKgwrQyNYq1VRrB+EizAow6NsdNKcyVEkYeM73ys6q4kAHp6BiFklTkIrVC5oYV7uzwOGCz4UJ0Stq2lWMJy4wtb+RetL6tZFicnJmBw5UjCvXXMZVJX2MQkbf+XN5EWd78Vz8/JEsMZTBiKNzsm1inLRUQ74H4NidaqI68j5sAFgxcRveC7ieLJXfQYxjZZ2CsiWFewZXJmBIlZ1tdtrX4hSuateKso/RZOtOKW2nmq1oTzeK6dRWAWu2NRVb4hq0SXm1GvtugHrbr5IXqmSktg5CuDE2MSlPwsY5kNE2Wp3AqiZbWVLAxiBF+2iBZbuNj6MB6rsMLC7FyasaYDyo7KkoPyEtw3pEMXfPvxAJi2jAQQgjrz0rLIZSWZlIoNhwd5xK4AR9mYNjWAaLrnuImJeBVN9zBORObVvbr+mTTfFSEJLSRnHo7hEJoIi8MFqjxmvgmF5URZz4zLFgZZ8Ctu2X7ggVccKm9gVxIsOHqxXgNMKnFWZYnf1dBnOhayXq17QwFlWW09eNKyVJFmXqaONGA5aCegMbJ3UUkGY1ic3nKWgjq8qfVYGQG1gRt6rs62a6HiqqUOqdesK5NmX4nGofJoiE1d0dF9lVVkvT1/kEEaaCoYOwFpcVcoLM+7669PxC9rWqktH0sWUYld0VCpuBZ/stVRcGgy9WX2+U1Qthi9SzAqSxzZsy+OiFzBYnySGV6Gku44rD8BCOZBV3BvD5+AKRHNwMEsB6EzHnJpkTAeiUlEGkcECeB6GDZTp5YEJTlvdrknxYjTllMkfNtXwDjM7uVjK5JXUUn43rrqpK2jytaxHW0M5G8DC8rtHMYs7KSgduVQMGTYFqFvVS6rkD3sDJ46afdYFwoq11AOKCBLhvwoUgc8IGANycR6knZrdJPdsuxnyjfd3FovTlRMdEdtOl5CMV5EHsXQBis7TOwvIDZaGj2Vnpbh7cpK63VwYEMLwqbjzyl699sawFFkF1yqjUU31HfC6sW1ZFVFuXVXVgz9keEaw0ys1lWfm+azQAQSWA+hKYVfsZjPncAcUB9oIayy/UZXRNckDGji77GsWbvBo6tPrWPqOyVkBUq+INeqpzNdYs/u0ifh5qmpqIW+33JVSUcwY70KL4U9lYdU6ljtSls7lmfi9g3YzeQfVkaGFaV3ODCnaD2N8wsEDFklE3RzM3ZghdYkWHsszq70FIecnKkVkt8ezMzRq9bkGuKojRLBVSod3Y1yPqKgYW7JRQTPVyy5xIYLjOgxgT52RKJUY1dOrIiRd4futQx/A5AcSmEjz0vFWrkLzvbWAu9HOWbGgxFk1VNTpnBKk6TgwisI/HcxYXP1uAWO72ULFlBTq+aSu2VTUs6hrxM2CF+hEor1VIA9ZmFUaab1lSSgZsVs4sxzHlVLoJHr9H4DhONTkI1XC0/wiY2NoWAG5RlnHFnq6oLccpQddMuJ/O17JVA5OHLi0BqCztq7Y1++ucCd98qLI8MIHBV/cKjxQTme3hFBS3MyCqnDsuym2o80HjvFFTtrURmNaGJsmVahImjTsUXKtQZTAVs7Mvv8/+fzUrZAXcLJ6M4koe6XP0b6SmWWNDzyUpQ8bl+LtWx4tuqZ36cRYV3yuVxPNwvIiqiQCSmu7srgTzR6nkyhpCarXwFy1vGd5iP2cY06lFr5Njhhg1Y6+NB28ftbK83s8rf7kLJbKwDFPbLg25a0AdZJEiqr5phixKMDlRUtcssq1hriLqGoH+zeNgVm9OemjsETV8JdF0NHnkIFxWY1OB4Yrp7rtWJ7NgAAAPXklEQVQ3oNs5nplyVf8u2FoLu1JrHveaZWQjqAkshtFa2gzsSG3Zpkbvg3HafF9slPPlldjFlK80Gysm8Mr4MPhneNWENPGjAIpmilTPATdTRTXlCBYHYAQuPwA36xIpWtGN4q3Y2MhiGsUpuSSnlEJRD8PorC7CFYVw+F51qThgabxsTxWzCGY0ZSsb3lfqAy0OPNjNy8xiQQKsHYFQ2HBZVvVbBuq3m1oWKajqaonsM6uZUr6CjXWNZ0l5E3h3jURma6kP3MJIiy1Lm+kahQq41N2iZja5sjtlLYNZHZrH6qUGm4vMbDp6Rw2CFmvuyFkrBcCyMtFqBaECmsHoK9BZ2LA/lJcRqSaDqnaWbrZdGaz3DLgIvBln4woGztbyJGqslwxkhhHrTjTYFXCtOoKS8uLdofVdAbOylGU6nlYpXWZts4nXBq6WxJitMNokHUJnbnJplQm+aGpY2a5GMV2QD1hRubBPFKdumf5OHkLHz0F9luE5kjBjRa0nFE5CUGqHw32MmjZ6xkgINVnSnZ1VZStK2qKlRaLlQgK7uTq7JFXJwM+3SOEKyhZNI+tJ0I5qMYy9k2qJD7dVWdqKXa0CKNR0Ccjg+B2IYu2fcBZJZkMFgM11r0X92wilghFGgzVnexlqB7xL9mS29SiYUVY2nXOZjNBRsyDsQPRWW5hrZ4XcdC4HVWRbjgJr4sFofK5SzjQ7rhI1UebdPdEbj6sqIvTZQZ5va08rABsAW0UxeWytAk7A2KJ9ZpxzCioB24XFtYAeXYxr6anSqhLgppEqWbGwLunTgrV+IjWlL29ljaAl4EQMGsErp4apeZiquwRXLXAqOCeru32mmydc6oWTSWpFAGdzeTB8RTHVMEtlM90CbbQCYhPjq3egYr1FGdYIQjiuDGZ5zZ/AzobKGOyLxti6c4Rwtv2anyWlLICnlLhxJRXt6A5ebDBWFNONbxWZ2d02mnu4S9YECpeppV1zSWRBWxHYzVIv1CXSouwqqX3jBBBDZdYQbpTQW4ZQlS8r5kH4suSRmg2++3JN10x1PaAmEkmtYlEdeGpJEM6kOuCqCR22oSujj5IV2HdT0zj5prLKTjXFAPjdQlyq7xIBxAQP5yMczG4VxAKw0n6ilZ2QBce2pLulkuxxqnoIzFfgqyqjil9S1VNwBrFmeyeops8yOjZUybZdfS8CuaTIJumzs5tODaNtLpFDQ/PcJGweLhmeL1nB0KqiUDScsiUVD89Di3HtrKtSULw3RLiygZD+7sF8JTObgYsrGvDNUFRGl1iy0Ll1YkUc2aJYMog920I8qW6YDCg1Mqk0JHJFKXkbgbRreI+qpYNOZHrVcDUba7pjsphSJNtK6upgRNAVoOS0mugBeN4bIZgHhuPZ/s1ENaX6KsVr+YNrh1Nb7ipR0PE5zbNRegCbrHRUw6Yf07dLBJl1f8KB9as2V1nNqAsl62LBBhehwalerkHmB1JFIEZKSEusdl5JQj1nJlHXSCF342gJ9CYGrXelknJIXqVP8sD+qtplCR3XH2qfKq0ygMp+KnVkKxNlZ8m2YkIlVMiCnXUwl7qznBKSvQz3m3Pt6oQbXO5b5FixCh/fHxUQW/AEcK6zCNqKQnL9sywqmKuwvqSYzT/aPVNNpVyhvRW21aqciCsjdWvBwILUvh5VyCzbWoC1pJjJ680CWsl+udKB6T5RwG1mlohnlpbg47iz5U9ha0FGtmRLFYBtO99y97Ap0z+ZDTAog6kSLZsMHg/IFkkgp6CpvU2U0cYVSdnmkjwBdOmXbxTWNWzuIbipMioVxEckZEoahSOiy2M3K0jcC1LhVDwaqG0ZvkcWqCnrG4GIxykrqlbWdw6LQyBaZR8HmLRIhQWsHswD42ZXVLNkf9l+FlW0HVQ2lwFsC/Z1FdzlQR0KaPfo+Fdfu+/dwVRICu1CGR7AEIiAhc+AZUF0kOBaPxmUqg4i64vQnU4nFDYJ9Nz+1fVXveH9qmr+kPILx8oKcRV/BFbxbE0JMT0kSD4w6L/lNY8ocsqagVdU3A3MjxhxcGuqzsPH4irpaow1q6OyrVjvp9Npc59E91LldboYVzJWdimWfAW2SNEKcDaX2FmBLLA/uKxlmhh613Is1URQApbKfttwxL02q6Onx5pQxSbPojAg+v5hAnN6LHVRDXIsvKtRjiS0qJUyZTAXVbAK82ElFJWaQdVoqUC1Unt7BVaTQudM6SuqexjQJN4+0icaxv/utbKv83ETbT8H8gjcOKxOJmbUa6OOVXht3dFY6rHv9XoNzFLceEA1o8+pKm0LAHPHZ2rYKjFq0hfZFixsqHJgD3eD5n+U0kb1mFjXkn2lvMSSOsNE/CdIAKF0Sytq6urOHUN5gwg4GZosgbmggM5ucra2qrS2Ig1cbiBBcxYzgzUDNLCvL8GbZXNp6ORy3LmS+Kk83zRIAK6A1ioKa2I9NapIuiUFdfC9766PFZUtqUr6KbWk+zZU1a/ZrIXEztrjTOfz7hwKziCeXIaraHtbZIMz+2pGgazCmw4qWAFvEdhodYp0Xq0pV7G1YWYWbO4qhGq42+Z8BYtrLWvluNPpZAeaFFS1vubPgbgxsqcpnAaszBovKaFoDQ8BGtjfUOl4NAG2nmQV04feJgumvX2fsrQEWZghL0JnVdYkn3DOZIeRN86RqPWCmsvGVqEMRnwxQAxwS8EMYo3IzmY2+BCcLp4MKiuyuhImamlbZFcNoNl7tp+RHd18ZjQIRKyXdFRhN98/hyKqwXWNo7O1wiaXoHN108REZZWEq6grnIfjzeg8jdRf1XEL4kkXa5bBjKxoKaljBjeHlVxQ4GaycpW4lDOAKtnTxHAtOfzOtZwHAM7sqVXkV6yu6kap1nHkXKqWF/4XHqjenNKqBjpR3l1ch3Ejg1+EsgdQhsdG0B4FM9sWAVWpuAyiwTPleZxt9VyZVS2qXfReWqTAilpr9ApoWTjxymit7NwV4JTriZyOA9B0k7HFfULourmKYHVnRQvqGL5HMHdqFcR2qWpmcK6eTwx2dipWrviDilr+fKWq3OWRWdHKwA4eu8wjchbeRzFilqjjZN3ufCpfkJ0/scVpnYk6L0PI77lxdWCZ87WiWm7B/AGquQSnujGKsB8CJmiJq8q1pKIVWyqOiTK66r18BN8r74/AE71fdC3yPS2MxdOpnE1tlVxD9JmVOoggN+r4PjAXVFPa3Eg5jVJGFVUGNolH20GVrUB7BOySWq6WqYQdWR92pcFMYMwckbSgCKCqD67DiiWu1g8MQC9ByfcFqW1L+jL714qNCuznoSxt0da2gtWN1G8F0BK0NN0nuimelUF9dIdAfjO44UT3CjQLoUeLHJFTO3gmpRuIIOvwBQCbqNeo3qtZ9iF6xVK13GRlo4zqimq+CGdTiR1uRY8oqgE02hZBa79kZXPMquxRHKla2saZWN4mRqZUj0vLCKhkjKnqOQHNuSZVJoKvAqS1wpEquvWDC1B2ypwrCPsRMEPVTODMLJMDv6qeKXwi2JYV5Sq4qKyvgGsHCLiuj2jR59V8gMqSJ2FJZRXEHVRHj3sFPrct6OpqlW1GpatQdt0GvwfM6n63InsGVFhJGaBqgqqIV6IsXllZgySPq4R3bnt3wi5cv+cN2yqQLW1T95KYVsWWtKk4cB9W53WQQflQYR6Wl4HaJZjvVE0D5yvq+RKgZCs5qdBEP5sD94cAvQLlSgNaSMAtHx88BuNQ41zdFsX30zKbcs0MLD/ihkpQzl0wiTqKLTfbKmCmyYICnK0IbaieC4CG9iSyLQ7cIMGQwau6TKoq60Apl3WN40LZpca1CKKK9VQyyIEn8w0F8F6CL2h8o3ixGwC7s7EWzCOqmcApYxYD4jsAzVS0sl2t98pA7vrKophCVSonbYpgH6mvSn24pTBV4sdtV3BtMq5k82y+IADvUJ0uAlkCVTxIaPm+UNu/qkV4F1TzHXCGrXIAqItBKypqK99VtAOVs64O4ObX7pHLVCpYHcRmwvLR7TvYAKBBN58LGVzDuFz+hQbWgncQyCZAk+VbsPSouf93261iZgmfCpwRbAvqmSqriU2PwhjaoOyYqtIegVXViTsmyta6bGySpY3gyRrpIyAeaWDDxtpsXwKyalMDKNP7YBXMqEskUsi2uC8FNAPxAKTVfT1o6VzM0E0jF+1rWcUuHvdyg7vgoFplX8HpvHpMCOMRUPHzZkInsqlFKNX/EIO52E0SxSzOwob2VmRLW5D1XIU0rbgM1AzWgyC7fe8G7xUAK/taEBat7luqtyP7EmsaJQOj5F+mrnZfCuYCfBUAWwShyd6pMY/vAHG1UqOYpbI/gy5T0CMKm+UO3gFuC85dgfDVeguPDfITrIBLsLrcgdh3CFgFZjaKJ4Iv3F8ANEqvuxR1tVKOgLoCa1jxboBAkj6v7j/icFbA7f4rfRnQDLRViG13i0vqBQrYVqBbADZT0ZpiHoSzvQpopKIFS3sE1HfBWlHXd0H7LnArqvougMtljHBgZnh3Eoz/BKjLML4Z2Aq0+hEJr9jaVUBbvNzCIUiroC7AWmmFw4o5AK3MtB5VypZMSFgs05JyGVwlwBqsEGAAa2ZU1CjUexXGsE4rKriilBvFzOKKo3AuAroE6QFQU3u8YpNXwS5k+1TZt5UrwouN4KiUEw+k3ZWDp1RXHNRqXb21Ts39945yZSg3VnZFNQ9CF3XeZyr5DgBXKiwCMa2MxeTDYXgP1Fsf9QNKZc0k81RJk3r6EQ3rCmBVyLL75EjZ1pIVDHoFtiOAHoB0BdTVylqBsKKKS+AeBXJVLY+CXASuGvO/Auq7GuEjDfGKg1oKa1z/dmmi9I9SUGNhl0AtfulHAawoYrnSkmNXAVuGEhrEVXvUF+A5Ct2PqNOjDetyna4CmeUolmeXLN4Aq7C5Sj10Q7yjgl+t6CNxSRHmI5X+CpwreYB3Qfdqna4q21KdBuc4GoZsn49ZOOiVinwHqK9WzjvgeweEh2AU5+vtxZ9Cd9Wqkh49V18E5oj6vVyn0RStAyGIO5edXRKd5B0VGVXq2yr3xYp+5Ut+C4QJ4P1N339pQMjRejj4vb/Dcr6rQc3O/0rjmtZpeYCBiCHfCemRbNhbK/pNUPc3wfKy5f2D7OlL3/uPhve/oU4T0F8f+VNM2vyoiv0jK+KHQfdHq+0bncz4oz73/+Y6LbKw1o/5B7eOf1Rl/0du9B9tn/9bvrf/j+v0h6ttn2tp/r/4819y4/zv5391uvzzfwDifz6phT1MPgAAAABJRU5ErkJggg==)}.color-picker .cp-add-color-button-class{position:absolute;display:inline;padding:0;margin:3px -3px;border:0;cursor:pointer;background:transparent}.color-picker .cp-add-color-button-class:hover{text-decoration:underline}.color-picker .cp-add-color-button-class:disabled{cursor:not-allowed;color:#999}.color-picker .cp-add-color-button-class:disabled:hover{text-decoration:none}.color-picker .cp-remove-color-button-class{position:absolute;top:-5px;right:-5px;display:block;width:10px;height:10px;border-radius:50%;cursor:pointer;text-align:center;background:#fff;box-shadow:1px 1px 5px #333}.color-picker .cp-remove-color-button-class:before{content:"x";position:relative;bottom:3.5px;display:inline-block;font-size:10px}.color-picker .eyedropper-icon{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);fill:#fff;mix-blend-mode:exclusion}\n'],encapsulation:2}),t})(),rY=(()=>{class t{constructor(e,r,s,o,i,a){this.injector=e,this.cfr=r,this.appRef=s,this.vcRef=o,this.elRef=i,this._service=a,this.dialogCreated=!1,this.ignoreChanges=!1,this.viewAttachedToAppRef=!1,this.cpWidth="230px",this.cpHeight="auto",this.cpToggle=!1,this.cpDisabled=!1,this.cpIgnoredElements=[],this.cpFallbackColor="",this.cpColorMode="color",this.cpCmykEnabled=!1,this.cpOutputFormat="auto",this.cpAlphaChannel="enabled",this.cpDisableInput=!1,this.cpDialogDisplay="popup",this.cpSaveClickOutside=!0,this.cpCloseClickOutside=!0,this.cpUseRootViewContainer=!1,this.cpPosition="auto",this.cpPositionOffset="0%",this.cpPositionRelativeToArrow=!1,this.cpOKButton=!1,this.cpOKButtonText="OK",this.cpOKButtonClass="cp-ok-button-class",this.cpCancelButton=!1,this.cpCancelButtonText="Cancel",this.cpCancelButtonClass="cp-cancel-button-class",this.cpEyeDropper=!1,this.cpPresetLabel="Preset colors",this.cpPresetColorsClass="cp-preset-colors-class",this.cpMaxPresetColorsLength=6,this.cpPresetEmptyMessage="No colors added",this.cpPresetEmptyMessageClass="preset-empty-message",this.cpAddColorButton=!1,this.cpAddColorButtonText="Add color",this.cpAddColorButtonClass="cp-add-color-button-class",this.cpRemoveColorButtonClass="cp-remove-color-button-class",this.cpArrowPosition=0,this.cpInputChange=new _t(!0),this.cpToggleChange=new _t(!0),this.cpSliderChange=new _t(!0),this.cpSliderDragEnd=new _t(!0),this.cpSliderDragStart=new _t(!0),this.colorPickerOpen=new _t(!0),this.colorPickerClose=new _t(!0),this.colorPickerCancel=new _t(!0),this.colorPickerSelect=new _t(!0),this.colorPickerChange=new _t(!1),this.cpCmykColorChange=new _t(!0),this.cpPresetColorsChange=new _t(!0)}handleClick(){this.inputFocus()}handleFocus(){this.inputFocus()}handleInput(e){this.inputChange(e)}ngOnDestroy(){null!=this.cmpRef&&(this.viewAttachedToAppRef&&this.appRef.detachView(this.cmpRef.hostView),this.cmpRef.destroy(),this.cmpRef=null,this.dialog=null)}ngOnChanges(e){e.cpToggle&&!this.cpDisabled&&(e.cpToggle.currentValue?this.openDialog():e.cpToggle.currentValue||this.closeDialog()),e.colorPicker&&(this.dialog&&!this.ignoreChanges&&("inline"===this.cpDialogDisplay&&this.dialog.setInitialColor(e.colorPicker.currentValue),this.dialog.setColorFromString(e.colorPicker.currentValue,!1),this.cpUseRootViewContainer&&"inline"!==this.cpDialogDisplay&&this.cmpRef.changeDetectorRef.detectChanges()),this.ignoreChanges=!1),(e.cpPresetLabel||e.cpPresetColors)&&this.dialog&&this.dialog.setPresetConfig(this.cpPresetLabel,this.cpPresetColors)}openDialog(){if(this.dialogCreated)this.dialog&&this.dialog.openDialog(this.colorPicker);else{let e=this.vcRef;if(this.dialogCreated=!0,this.viewAttachedToAppRef=!1,this.cpUseRootViewContainer&&"inline"!==this.cpDialogDisplay){const o=this.injector.get(this.appRef.componentTypes[0],ts.NULL);o!==ts.NULL?e=o.vcRef||o.viewContainerRef||this.vcRef:this.viewAttachedToAppRef=!0}const r=this.cfr.resolveComponentFactory(tY);if(this.viewAttachedToAppRef)this.cmpRef=r.create(this.injector),this.appRef.attachView(this.cmpRef.hostView),document.body.appendChild(this.cmpRef.hostView.rootNodes[0]);else{const s=ts.create({providers:[],parent:e.injector});this.cmpRef=e.createComponent(r,0,s,[])}this.cmpRef.instance.setupDialog(this,this.elRef,this.colorPicker,this.cpWidth,this.cpHeight,this.cpDialogDisplay,this.cpFallbackColor,this.cpColorMode,this.cpCmykEnabled,this.cpAlphaChannel,this.cpOutputFormat,this.cpDisableInput,this.cpIgnoredElements,this.cpSaveClickOutside,this.cpCloseClickOutside,this.cpUseRootViewContainer,this.cpPosition,this.cpPositionOffset,this.cpPositionRelativeToArrow,this.cpPresetLabel,this.cpPresetColors,this.cpPresetColorsClass,this.cpMaxPresetColorsLength,this.cpPresetEmptyMessage,this.cpPresetEmptyMessageClass,this.cpOKButton,this.cpOKButtonClass,this.cpOKButtonText,this.cpCancelButton,this.cpCancelButtonClass,this.cpCancelButtonText,this.cpAddColorButton,this.cpAddColorButtonClass,this.cpAddColorButtonText,this.cpRemoveColorButtonClass,this.cpEyeDropper,this.elRef,this.cpExtraTemplate),this.dialog=this.cmpRef.instance,this.vcRef!==e&&this.cmpRef.changeDetectorRef.detectChanges()}}closeDialog(){this.dialog&&"popup"===this.cpDialogDisplay&&this.dialog.closeDialog()}cmykChanged(e){this.cpCmykColorChange.emit(e)}stateChanged(e){this.cpToggleChange.emit(e),e?this.colorPickerOpen.emit(this.colorPicker):this.colorPickerClose.emit(this.colorPicker)}colorChanged(e,r=!0){this.ignoreChanges=r,this.colorPickerChange.emit(e)}colorSelected(e){this.colorPickerSelect.emit(e)}colorCanceled(){this.colorPickerCancel.emit()}inputFocus(){const e=this.elRef.nativeElement,r=this.cpIgnoredElements.filter(s=>s===e);!this.cpDisabled&&!r.length&&(typeof document<"u"&&e===document.activeElement?this.openDialog():this.dialog&&this.dialog.show?this.closeDialog():this.openDialog())}inputChange(e){this.dialog?this.dialog.setColorFromString(e.target.value,!0):(this.colorPicker=e.target.value,this.colorPickerChange.emit(this.colorPicker))}inputChanged(e){this.cpInputChange.emit(e)}sliderChanged(e){this.cpSliderChange.emit(e)}sliderDragEnd(e){this.cpSliderDragEnd.emit(e)}sliderDragStart(e){this.cpSliderDragStart.emit(e)}presetColorsChanged(e){this.cpPresetColorsChange.emit(e)}}return t.\u0275fac=function(e){return new(e||t)(Y(ts),Y(yu),Y(Ed),Y(Qs),Y(Lr),Y(JC))},t.\u0275dir=Ze({type:t,selectors:[["","colorPicker",""]],hostBindings:function(e,r){1&e&&Ee("click",function(){return r.handleClick()})("focus",function(){return r.handleFocus()})("input",function(o){return r.handleInput(o)})},inputs:{colorPicker:"colorPicker",cpWidth:"cpWidth",cpHeight:"cpHeight",cpToggle:"cpToggle",cpDisabled:"cpDisabled",cpIgnoredElements:"cpIgnoredElements",cpFallbackColor:"cpFallbackColor",cpColorMode:"cpColorMode",cpCmykEnabled:"cpCmykEnabled",cpOutputFormat:"cpOutputFormat",cpAlphaChannel:"cpAlphaChannel",cpDisableInput:"cpDisableInput",cpDialogDisplay:"cpDialogDisplay",cpSaveClickOutside:"cpSaveClickOutside",cpCloseClickOutside:"cpCloseClickOutside",cpUseRootViewContainer:"cpUseRootViewContainer",cpPosition:"cpPosition",cpPositionOffset:"cpPositionOffset",cpPositionRelativeToArrow:"cpPositionRelativeToArrow",cpOKButton:"cpOKButton",cpOKButtonText:"cpOKButtonText",cpOKButtonClass:"cpOKButtonClass",cpCancelButton:"cpCancelButton",cpCancelButtonText:"cpCancelButtonText",cpCancelButtonClass:"cpCancelButtonClass",cpEyeDropper:"cpEyeDropper",cpPresetLabel:"cpPresetLabel",cpPresetColors:"cpPresetColors",cpPresetColorsClass:"cpPresetColorsClass",cpMaxPresetColorsLength:"cpMaxPresetColorsLength",cpPresetEmptyMessage:"cpPresetEmptyMessage",cpPresetEmptyMessageClass:"cpPresetEmptyMessageClass",cpAddColorButton:"cpAddColorButton",cpAddColorButtonText:"cpAddColorButtonText",cpAddColorButtonClass:"cpAddColorButtonClass",cpRemoveColorButtonClass:"cpRemoveColorButtonClass",cpArrowPosition:"cpArrowPosition",cpExtraTemplate:"cpExtraTemplate"},outputs:{cpInputChange:"cpInputChange",cpToggleChange:"cpToggleChange",cpSliderChange:"cpSliderChange",cpSliderDragEnd:"cpSliderDragEnd",cpSliderDragStart:"cpSliderDragStart",colorPickerOpen:"colorPickerOpen",colorPickerClose:"colorPickerClose",colorPickerCancel:"colorPickerCancel",colorPickerSelect:"colorPickerSelect",colorPickerChange:"colorPickerChange",cpCmykColorChange:"cpCmykColorChange",cpPresetColorsChange:"cpPresetColorsChange"},exportAs:["ngxColorPicker"],features:[Es]}),t})(),sY=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=qs({type:t}),t.\u0275inj=Is({providers:[JC],imports:[WA]}),t})();function WF(t,n,e,r,s,o,i){try{var a=t[o](i),l=a.value}catch(u){return void e(u)}a.done?n(l):Promise.resolve(l).then(r,s)}function J(t){return function(){var n=this,e=arguments;return new Promise(function(r,s){var o=t.apply(n,e);function i(l){WF(o,r,s,i,a,"next",l)}function a(l){WF(o,r,s,i,a,"throw",l)}i(void 0)})}}class GF{constructor(n,e){this.backend=n,this.dataMover=e,this.data=new WeakMap,this.dataIdsCount=0}get(n){return this.data.has(n)||this.dataMover.moveData(this.backend,n),this.data.get(n)}set(n,e){this.dataIdsCount++,this.data.set(n,e)}has(n){return this.data.has(n)}delete(n){return this.dataIdsCount--,this.data.delete(n)}numDataIds(){return this.dataIdsCount}}class e0{refCount(n){return gs("refCount")}incRef(n){return gs("incRef")}timerAvailable(){return!0}time(n){return gs("time")}read(n){return gs("read")}readSync(n){return gs("readSync")}readToGPU(n,e){return gs("readToGPU")}numDataIds(){return gs("numDataIds")}disposeData(n,e){return gs("disposeData")}write(n,e,r){return gs("write")}move(n,e,r,s,o){return gs("move")}createTensorFromGPUData(n,e,r){return gs("createTensorFromGPUData")}memory(){return gs("memory")}floatPrecision(){return gs("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return gs("dispose")}}function gs(t){throw new Error(`'${t}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function HF(t){let n=t.length,e=0;for(;n>0;)e=Math.random()*n|0,n--,pa(t,n,e)}function bl(t,n,e){return Math.max(t,Math.min(n,e))}function t0(t){return t%2==0?t:t+1}function pa(t,n,e){const r=t[n];t[n]=t[e],t[e]=r}function _(t,n){if(!t)throw new Error("string"==typeof n?n:n())}function no(t,n,e=""){_(Bt(t,n),()=>e+` Shapes ${t} and ${n} must match`)}function n0(t){_(null!=t,()=>"The input to the tensor constructor must be a non-null value.")}function G(t){if(0===t.length)return 1;let n=t[0];for(let e=1;e<t.length;e++)n*=t[e];return n}function Bt(t,n){if(t===n)return!0;if(null==t||null==n||t.length!==n.length)return!1;for(let e=0;e<t.length;e++)if(t[e]!==n[e])return!1;return!0}function Zu(t){return t%1==0}function r0(t){const n=Math.ceil(Math.sqrt(t));return[n,Math.ceil(t/n)]}function Qu(t,n){return n<=t.length?t:t+" ".repeat(n-t.length)}function jF(t,n=(s=>0),e,r){return new Promise((s,o)=>{let i=0;const a=()=>{if(t())return void s();i++;const l=n(i);null!=e&&i>=e?o():null!=r?r(a,l):setTimeout(a,l)};a()})}function qF(t,n){let e=1,r=-1;for(let o=0;o<t.length;++o)if(t[o]>=0)e*=t[o];else if(-1===t[o]){if(-1!==r)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${o}`);r=o}else if(t[o]<0)throw Error(`Shapes can not be < 0. Found ${t[o]} at dim ${o}`);if(-1===r){if(n>0&&n!==e)throw Error(`Size(${n}) must match the product of shape ${t}`);return t}if(0===e)throw Error(`Cannot infer the missing size in [${t}] when there are 0 elements`);if(n%e!=0)throw Error(`The implicit shape can't be a fractional number. Got ${n} / ${e}`);const s=t.slice();return s[r]=n/e,s}function bt(t,n){const e=n.length;return _((t=null==t?n.map((r,s)=>s):[].concat(t)).every(r=>r>=-e&&r<e),()=>`All values in axis param must be in range [-${e}, ${e}) but got axis ${t}`),_(t.every(r=>Zu(r)),()=>`All values in axis param must be integers but got axis ${t}`),t.map(r=>r<0?e+r:r)}function fa(t,n){const e=[],r=[],s=null!=n&&Array.isArray(n)&&0===n.length,o=null==n||s?null:bt(n,t).sort();let i=0;for(let a=0;a<t.length;++a){if(null!=o){if(o[i]===a&&1!==t[a])throw new Error(`Can't squeeze axis ${a} since its dim '${t[a]}' is not 1`);(null==o[i]||o[i]>a)&&1===t[a]&&(e.push(t[a]),r.push(a)),o[i]<=a&&i++}1!==t[a]&&(e.push(t[a]),r.push(a))}return{newShape:e,keptDims:r}}function Nr(t,n){return Mn(t,n)}function Mn(t,n){let e=null;if(null==t||"float32"===t)e=new Float32Array(n);else if("int32"===t)e=new Int32Array(n);else if("bool"===t)e=new Uint8Array(n);else{if("string"!==t)throw new Error(`Unknown data type ${t}`);e=new Array(n)}return e}function KF(t,n){return!("complex64"===n||"float32"===n&&"complex64"!==t||"int32"===n&&"float32"!==t&&"complex64"!==t||"bool"===n&&"bool"===t)}function ag(t){if("float32"===t||"int32"===t)return 4;if("complex64"===t)return 8;if("bool"===t)return 1;throw new Error(`Unknown dtype ${t}`)}function lh(t){return"string"==typeof t||t instanceof String}function s0(t){return"number"==typeof t}function Ju(t){return Array.isArray(t)?Ju(t[0]):t instanceof Float32Array?"float32":t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray?"int32":s0(t)?"float32":lh(t)?"string":function dY(t){return"boolean"==typeof t}(t)?"bool":"float32"}function o0(t){return!!(t&&t.constructor&&t.call&&t.apply)}function a0(t,n){for(let e=n;e<t;++e)if(t%e==0)return e;return t}function Pe(t){const n=t.length;if(n<2)return[];const e=new Array(n-1);e[n-2]=t[n-1];for(let r=n-3;r>=0;--r)e[r]=e[r+1]*t[r+1];return e}function XF(t,n,e,r=!1){const s=new Array;if(1===n.length){const o=n[0]*(r?2:1);for(let i=0;i<o;i++)s[i]=e[t+i]}else{const o=n[0],i=n.slice(1),a=i.reduce((l,u)=>l*u)*(r?2:1);for(let l=0;l<o;l++)s[l]=XF(t+l*a,i,e,r)}return s}function Do(t,n,e=!1){if(0===t.length)return n[0];const r=t.reduce((s,o)=>s*o)*(e?2:1);if(0===r)return[];if(r!==n.length)throw new Error(`[${t}] does not match the input size ${n.length}${e?" for a complex tensor":""}.`);return XF(0,t,n,e)}function l0(t,n){const e=kr(t,n);for(let r=0;r<e.length;r++)e[r]=1;return e}function kr(t,n){if(null==n||"float32"===n||"complex64"===n)return new Float32Array(t);if("int32"===n)return new Int32Array(t);if("bool"===n)return new Uint8Array(t);throw new Error(`Unknown data type ${n}`)}function YF(t,n){const e=t.reduce((r,s)=>r*s,1);if(null==n||"float32"===n)return Do(t,new Float32Array(e));if("int32"===n)return Do(t,new Int32Array(e));if("bool"===n)return Do(t,new Uint8Array(e));throw new Error(`Unknown data type ${n}`)}function Li(t){t.forEach(n=>{_(Number.isInteger(n)&&n>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${t}].`)})}function ti(t,n,e){if(0===n)return 0;if(1===n)return t[0];let r=t[t.length-1];for(let s=0;s<t.length-1;++s)r+=e[s]*t[s];return r}function ec(t,n,e){if(0===n)return[];if(1===n)return[t];const r=new Array(n);for(let s=0;s<r.length-1;++s)r[s]=Math.floor(t/e[s]),t-=r[s]*e[s];return r[r.length-1]=t,r}function u0(t){return t&&t.then&&"function"==typeof t.then}const ZF="tfjsflags";class pY{constructor(n){this.global=n,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=fY,this.populateURLFlags()}setPlatform(n,e){null!=this.platform&&(L().getBool("IS_TEST")||L().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${n}.`)),this.platformName=n,this.platform=e}registerFlag(n,e,r){if(this.flagRegistry[n]={evaluationFn:e,setHook:r},null!=this.urlFlags[n]){const s=this.urlFlags[n];L().getBool("IS_TEST")||L().getBool("PROD")||console.warn(`Setting feature override from URL ${n}: ${s}.`),this.set(n,s)}}getAsync(n){var e=this;return J(function*(){return n in e.flags||(e.flags[n]=yield e.evaluateFlag(n)),e.flags[n]})()}get(n){if(n in this.flags)return this.flags[n];const e=this.evaluateFlag(n);if(u0(e))throw new Error(`Flag ${n} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[n]=e,this.flags[n]}getNumber(n){return this.get(n)}getBool(n){return this.get(n)}getFlags(){return this.flags}get features(){return this.flags}set(n,e){if(null==this.flagRegistry[n])throw new Error(`Cannot set flag ${n} as it has not been registered.`);this.flags[n]=e,null!=this.flagRegistry[n].setHook&&this.flagRegistry[n].setHook(e)}evaluateFlag(n){if(null==this.flagRegistry[n])throw new Error(`Cannot evaluate flag '${n}': no evaluation function found.`);return this.flagRegistry[n].evaluationFn()}setFlags(n){this.flags=Object.assign({},n)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const n=this.getQueryParams(this.global.location.search);ZF in n&&n[ZF].split(",").forEach(r=>{const[s,o]=r.split(":");this.urlFlags[s]=function gY(t,n){if("true"===(n=n.toLowerCase())||"false"===n)return"true"===n;if(""+ +n===n)return+n;throw new Error(`Could not parse value flag value ${n} for flag ${t}.`)}(s,o)})}}function fY(t){const n={};return t.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(e,...r)=>(function mY(t,n,e){t[decodeURIComponent(n)]=decodeURIComponent(e||"")}(n,r[0],r[1]),r.join("="))),n}function L(){return QF}let c0,QF=null;function JF(){if(null==c0){let t;if(typeof window<"u")t=window;else if(typeof global<"u")t=global;else if(typeof process<"u")t=process;else{if(!(typeof self<"u"))throw new Error("Could not find a global object");t=self}c0=t}return c0}function d0(t,n){const e=function bY(){const t=JF();return null==t._tfGlobals&&(t._tfGlobals=new Map),t._tfGlobals}();if(e.has(t))return e.get(t);{const r=n();return e.set(t,r),e.get(t)}}const lg="Abs",uh="Acos",ch="Acosh",tc="Add",h0="AddN",ug="ArgMax",cg="ArgMin",dh="Asin",hh="Asinh",ph="Atan",fh="Atanh",mh="Atan2",dg="AvgPool",m0="AvgPoolGrad",hg="AvgPool3D",g0="AvgPool3DGrad",pg="BatchMatMul",fg="BatchToSpaceND",y0="Bincount",eM="BroadcastArgs",gh="Cast",yh="Ceil",bh="ClipByValue",b0="Complex",mg="ComplexAbs",gg="Concat",yg="Conv2D",v0="Conv2DBackpropFilter",bg="Conv2DBackpropInput",vg="Conv3D",x0="Conv3DBackpropFilterV2",w0="Conv3DBackpropInputV2",vh="Cos",xh="Cosh",C0="Cumprod",xg="Cumsum",_0="CropAndResize",S0="DenseBincount",I0="DepthToSpace",wg="DepthwiseConv2dNative",D0="DepthwiseConv2dNativeBackpropFilter",T0="DepthwiseConv2dNativeBackpropInput",Cg="Dilation2D",E0="Dilation2DBackpropInput",N0="Dilation2DBackpropFilter",wh="RealDiv",Ch="Elu",k0="EluGrad",_h="Erf",_g="Equal",Sh="Exp",Sg="ExpandDims",Ih="Expm1",R0="Fill",F0="FlipLeftRight",Dh="Floor",Th="FloorDiv",Ig="FusedBatchNorm",Dg="GatherV2",rM="GatherNd",Tg="Greater",Eh="GreaterEqual",Nh="Identity",M0="IFFT",P0="Imag",kh="IsFinite",Ah="IsInf",Rh="IsNan",Eg="LeakyRelu",Ng="Less",kg="LessEqual",sM="LinSpace",Fh="Log",Mh="Log1p",Ag="LogicalAnd",Rg="LogicalNot",Fg="LogicalOr",Mg="LRN",O0="LRNGrad",Pg="Max",Ph="Maximum",Og="MaxPool",$0="MaxPoolGrad",$g="MaxPool3D",L0="MaxPool3DGrad",oM="MaxPoolWithArgmax",Lg="Mean",Vg="Min",Oh="Minimum",Bg="MirrorPad",$h="Mod",iM="Multinomial",Lh="Multiply",zg="Neg",Ug="NotEqual",V0="NonMaxSuppressionV3",B0="NonMaxSuppressionV4",z0="NonMaxSuppressionV5",Wg="OnesLike",Gg="OneHot",Hg="Pack",jg="PadV2",Vh="Pow",qg="Prelu",Kg="Prod",aM="RaggedGather",lM="RaggedRange",uM="RaggedTensorToTensor",U0="Range",W0="Real",Bh="Reciprocal",zh="Relu",Xg="Reshape",Yg="ResizeNearestNeighbor",G0="ResizeNearestNeighborGrad",Zg="ResizeBilinear",H0="ResizeBilinearGrad",Uh="Relu6",Qg="Reverse",Wh="Round",Gh="Rsqrt",cM="ScatterNd",dM="TensorScatterUpdate",hM="SearchSorted",Jg="Select",Hh="Selu",ey="Slice",jh="Sin",qh="Sinh",Kh="Sign",Xh="Sigmoid",Yh="Softplus",Zh="Sqrt",ty="Sum",ny="SpaceToBatchND",ry="SplitV",sy="Softmax",j0="SparseFillEmptyRows",q0="SparseReshape",K0="SparseSegmentMean",X0="SparseSegmentSum",pM="SparseToDense",Qh="SquaredDifference",Y0="Square",oy="StaticRegexReplace",Z0="StridedSlice",Q0="StringNGrams",J0="StringSplit",e_="StringToHashBucketFast",Jh="Sub",ep="Tan",tp="Tanh",np="Tile",t_="TopK",n_="Transform",nc="Transpose",r_="Unique",iy="Unpack",ay="UnsortedSegmentSum",ly="ZerosLike",rp="Step",s_="RotateWithOffset",uy="_FusedMatMul",cy="FusedConv2D",dy="FusedDepthwiseConv2D";function Ps(...t){L().getBool("IS_TEST")||L().getBool("PROD")||console.warn(...t)}function CY(...t){L().getBool("IS_TEST")||L().getBool("PROD")||console.log(...t)}const rc=d0("kernelRegistry",()=>new Map),sp=d0("gradRegistry",()=>new Map);function fM(t,n){const e=a_(t,n);return rc.get(e)}function mM(t){return sp.get(t)}function o_(t){const n=rc.entries(),e=[];for(;;){const{done:r,value:s}=n.next();if(r)break;const[o,i]=s,[a]=o.split("_");a===t&&e.push(i)}return e}function i_(t){const{kernelName:n,backendName:e}=t,r=a_(n,e);rc.has(r)&&Ps(`The kernel '${n}' for backend '${e}' is already registered`),rc.set(r,t)}function _Y(t){const{kernelName:n}=t;sp.has(n)&&L().getBool("DEBUG")&&Ps(`Overriding the gradient for '${n}'`),sp.set(n,t)}function a_(t,n){return`${n}_${t}`}var gM=de(658);const vl=de.n(gM)()||gM;function hy(t){return vl.fromString(t,!0,16)}const yM=hy("c3a5c85c97cb3127"),xl=hy("b492b66fbe98f273"),Ur=hy("9ae16a3b2f90404f");function l_(t){return t.xor(t.shru(47))}function bM(t,n,e){const r=t.slice(n,n+e);return vl.fromBytes(Array.from(r),!0,!0)}function nn(t,n){return bM(t,n,8)}function vM(t,n){return bM(t,n,4)}function lr(t,n){return 0===n?t:t.shru(n).or(t.shl(64-n))}function ma(t,n,e=hy("9ddfea08eb382d69")){let r=t.xor(n).mul(e);r=r.xor(r.shru(47));let s=n.xor(r).mul(e);return s=s.xor(s.shru(47)),s=s.mul(e),s}function py(t,n,e,r){return function IY(t,n,e,r,s,o){s=s.add(t),o=lr(o.add(s).add(r),21);const i=s;return s=(s=s.add(n)).add(e),o=o.add(lr(s,44)),[s.add(r),o.add(i)]}(nn(t,n),nn(t,n+8),nn(t,n+16),nn(t,n+24),e,r)}function NY(t,n=t.length){const e=vl.fromNumber(81,!0);if(n<=32)return n<=16?function DY(t,n=t.length){if(n>=8){const e=Ur.add(2*n),r=nn(t,0).add(Ur),s=nn(t,n-8);return ma(lr(s,37).mul(e).add(r),lr(r,25).add(s).mul(e),e)}if(n>=4){const e=Ur.add(2*n);return ma(vM(t,0).shl(3).add(n),vM(t,n-4),e)}if(n>0){const i=n+(t[n-1]<<2);return l_(Ur.mul(t[0]+(t[n>>1]<<8)).xor(yM.mul(i))).mul(Ur)}return Ur}(t,n):function TY(t,n=t.length){const e=Ur.add(2*n),r=nn(t,0).mul(xl),s=nn(t,8),o=nn(t,n-8).mul(e),i=nn(t,n-16).mul(Ur);return ma(lr(r.add(s),43).add(lr(o,30)).add(i),r.add(lr(s.add(Ur),18)).add(o),e)}(t,n);if(n<=64)return function EY(t,n=t.length){const e=Ur.add(2*n),r=nn(t,0).mul(Ur),s=nn(t,8),o=nn(t,n-8).mul(e),i=nn(t,n-16).mul(Ur),a=lr(r.add(s),43).add(lr(o,30)).add(i),l=ma(a,r.add(lr(s.add(Ur),18)).add(o),e),u=nn(t,16).mul(e),c=nn(t,24),d=a.add(nn(t,n-32)).mul(e),h=l.add(nn(t,n-24)).mul(e);return ma(lr(u.add(c),43).add(lr(d,30)).add(h),u.add(lr(c.add(r),18)).add(d),e)}(t,n);let r=e,s=e.mul(xl).add(113),o=l_(s.mul(Ur).add(113)).mul(Ur),i=[vl.UZERO,vl.UZERO],a=[vl.UZERO,vl.UZERO];r=r.mul(Ur).add(nn(t,0));let l=0;const u=64*(n-1>>6),c=u+(n-1&63)-63;do{r=lr(r.add(s).add(i[0]).add(nn(t,l+8)),37).mul(xl),s=lr(s.add(i[1]).add(nn(t,l+48)),42).mul(xl),r=r.xor(a[1]),s=s.add(i[0]).add(nn(t,l+40)),o=lr(o.add(a[0]),33).mul(xl),i=py(t,l,i[1].mul(xl),r.add(a[0])),a=py(t,l+32,o.add(a[1]),s.add(nn(t,l+16))),[o,r]=[r,o],l+=64}while(l!==u);const d=xl.add(o.and(255).shl(1));return l=c,a[0]=a[0].add(n-1&63),i[0]=i[0].add(a[0]),a[0]=a[0].add(i[0]),r=lr(r.add(s).add(i[0]).add(nn(t,l+8)),37).mul(d),s=lr(s.add(i[1]).add(nn(t,l+48)),42).mul(d),r=r.xor(a[1].mul(9)),s=s.add(i[0].mul(9).add(nn(t,l+40))),o=lr(o.add(a[0]),33).mul(d),i=py(t,l,i[1].mul(d),r.add(a[0])),a=py(t,l+32,o.add(a[1]),s.add(nn(t,l+16))),[o,r]=[r,o],ma(ma(i[0],a[0],d).add(l_(s).mul(yM)).add(o),ma(i[1],a[1],d).add(r),d)}function ga(t,n){return"string"===n?ya(t):wl([t],n)}function wl(t,n){if("string"===n)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(t)&&(t=Cl(t)),L().getBool("DEBUG")&&function lY(t,n){for(let e=0;e<t.length;e++){const r=t[e];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${n} being uploaded contains ${r}.`)}}(t,n),function kY(t,n){return t instanceof Float32Array&&"float32"===n||t instanceof Int32Array&&"int32"===n||t instanceof Uint8Array&&"bool"===n}(t,n))return t;if(null==n||"float32"===n||"complex64"===n)return new Float32Array(t);if("int32"===n)return new Int32Array(t);if("bool"===n){const e=new Uint8Array(t.length);for(let r=0;r<e.length;++r)0!==Math.round(t[r])&&(e[r]=1);return e}throw new Error(`Unknown data type ${n}`)}function is(){return L().platform.now()}function ya(t,n="utf-8"){return n=n||"utf-8",L().platform.encode(t,n)}function ba(t,n="utf-8"){return n=n||"utf-8",L().platform.decode(t,n)}function To(t){return L().platform.isTypedArray(t)}function Cl(t,n=[],e=!1){if(null==n&&(n=[]),"boolean"==typeof t||"number"==typeof t||"string"==typeof t||u0(t)||null==t||To(t)&&e)n.push(t);else if(Array.isArray(t)||To(t))for(let r=0;r<t.length;++r)Cl(t[r],n,e);else{let r=-1;for(const s of Object.keys(t))/^([1-9]+[0-9]*|0)$/.test(s)&&(r=Math.max(r,Number(s)));for(let s=0;s<=r;s++)Cl(t[s],n,e)}return n}class AY{constructor(n,e){this.backendTimer=n,this.logger=e,null==e&&(this.logger=new FY)}profileKernel(n,e,r){let s;const o=()=>{s=r()};let i;const a=is();if(this.backendTimer.timerAvailable())i=this.backendTimer.time(o);else{o();for(const u of s)u.dataSync();i=Promise.resolve({kernelMs:is()-a})}if(L().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let u=0;u<s.length;u++){const c=s[u];c.data().then(d=>{RY(d,c.dtype,n)})}return{kernelName:n,outputs:s,inputs:e,timeMs:i.then(u=>u.kernelMs),extraInfo:i.then(u=>null!=u.getExtraProfileInfo?u.getExtraProfileInfo():"")}}logKernelProfile(n){const{kernelName:e,outputs:r,timeMs:s,inputs:o,extraInfo:i}=n;r.forEach(a=>{Promise.all([a.data(),s,i]).then(l=>{this.logger.logKernelProfile(e,a,l[0],l[1],o,l[2])})})}}function RY(t,n,e){if("float32"!==n)return!1;for(let r=0;r<t.length;r++){const s=t[r];if(isNaN(s)||!isFinite(s))return console.warn(`Found ${s} in the result of '${e}'`),!0}return!1}class FY{logKernelProfile(n,e,r,s,o,i){const a="number"==typeof s?Qu(`${s}ms`,9):s.error,l=Qu(n,25),u=e.rank,c=e.size,d=Qu(e.shape.toString(),14);let h="";for(const p in o){const f=o[p];if(null!=f){const g=f.shape||e.shape,m=g.length;h+=`${p}: ${m}D ${m>0?g:""} `}}console.log(`%c${l}\t%c${a}\t%c${u}D ${d}\t%c${c}\t%c${h}\t%c${i}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}const xM=20,op=3,u_=7;function OY(t,n,e,r){const s=Pe(n),o=function $Y(t,n,e,r){const s=G(n),o=r[r.length-1],i=new Array(o).fill(0),a=n.length,l="complex64"===e?ap(t):t;if(a>1)for(let u=0;u<s/o;u++){const c=u*o;for(let d=0;d<o;d++)i[d]=Math.max(i[d],ip(l[c+d],0,e).length)}return i}(t,n,e,s),i=n.length,a=fy(t,n,e,s,o),l=["Tensor"];return r&&(l.push(`  dtype: ${e}`),l.push(`  rank: ${i}`),l.push(`  shape: [${n}]`),l.push("  values:")),l.push(a.map(u=>"    "+u).join("\n")),l.join("\n")}function ip(t,n,e){let r;return r=Array.isArray(t)?`${parseFloat(t[0].toFixed(u_))} + ${parseFloat(t[1].toFixed(u_))}j`:lh(t)?`'${t}'`:"bool"===e?wM(t):parseFloat(t.toFixed(u_)).toString(),Qu(r,n)}function wM(t){return 0===t?"false":"true"}function fy(t,n,e,r,s,o=!0){const i="complex64"===e?2:1,a=n[0],l=n.length;if(0===l)return"complex64"===e?[ip(ap(t)[0],0,e)]:"bool"===e?[wM(t[0])]:[t[0].toString()];if(1===l){if(a>xM){let y=Array.from(t.slice(0,op*i)),b=Array.from(t.slice((a-op)*i,a*i));return"complex64"===e&&(y=ap(y),b=ap(b)),["["+y.map((v,x)=>ip(v,s[x],e)).join(", ")+", ..., "+b.map((v,x)=>ip(v,s[a-op+x],e)).join(", ")+"]"]}return["["+("complex64"===e?ap(t):Array.from(t)).map((m,y)=>ip(m,s[y],e)).join(", ")+"]"]}const u=n.slice(1),c=r.slice(1),d=r[0]*i,h=[];if(a>xM){for(let g=0;g<op;g++){const m=g*d;h.push(...fy(t.slice(m,m+d),u,e,c,s,!1))}h.push("...");for(let g=a-op;g<a;g++){const m=g*d;h.push(...fy(t.slice(m,m+d),u,e,c,s,g===a-1))}}else for(let g=0;g<a;g++){const m=g*d;h.push(...fy(t.slice(m,m+d),u,e,c,s,g===a-1))}const p=2===l?",":"";h[0]="["+(a>0?h[0]+p:"");for(let g=1;g<h.length-1;g++)h[g]=" "+h[g]+p;let f=",\n";for(let g=2;g<l;g++)f+="\n";return h[h.length-1]=" "+h[h.length-1]+"]"+(o?"":f),h}function ap(t){const n=[];for(let e=0;e<t.length;e+=2)n.push([t[e],t[e+1]]);return n}class br{constructor(n,e,r){if(this.dtype=e,this.shape=n.slice(),this.size=G(n),null!=r){const s=r.length;_(s===this.size,()=>`Length of values '${s}' does not match the size inferred by the shape '${this.size}'.`)}if("complex64"===e)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=r||Mn(e,this.size),this.strides=Pe(n)}set(n,...e){0===e.length&&(e=[0]),_(e.length===this.rank,()=>`The number of provided coordinates (${e.length}) must match the rank (${this.rank})`);const r=this.locToIndex(e);this.values[r]=n}get(...n){0===n.length&&(n=[0]);let e=0;for(const s of n){if(s<0||s>=this.shape[e])throw new Error(`Requested out of range element at ${n}.   Buffer shape=${this.shape}`);e++}let r=n[n.length-1];for(let s=0;s<n.length-1;++s)r+=this.strides[s]*n[s];return this.values[r]}locToIndex(n){if(0===this.rank)return 0;if(1===this.rank)return n[0];let e=n[n.length-1];for(let r=0;r<n.length-1;++r)e+=this.strides[r]*n[r];return e}indexToLoc(n){if(0===this.rank)return[];if(1===this.rank)return[n];const e=new Array(this.shape.length);for(let r=0;r<e.length-1;++r)e[r]=Math.floor(n/this.strides[r]),n-=e[r]*this.strides[r];return e[e.length-1]=n,e}get rank(){return this.shape.length}toTensor(){return Eo().makeTensor(this.values,this.shape,this.dtype)}}let Eo=null,sc=null,CM=null;class Hn{constructor(n,e,r,s){this.kept=!1,this.isDisposedInternal=!1,this.shape=n.slice(),this.dtype=e||"float32",this.size=G(n),this.strides=Pe(n),this.dataId=r,this.id=s,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}buffer(){var n=this;return J(function*(){const e=yield n.data();return sc.buffer(n.shape,n.dtype,e)})()}bufferSync(){return sc.buffer(this.shape,this.dtype,this.dataSync())}array(){var n=this;return J(function*(){const e=yield n.data();return Do(n.shape,e,"complex64"===n.dtype)})()}arraySync(){return Do(this.shape,this.dataSync(),"complex64"===this.dtype)}data(){var n=this;return J(function*(){n.throwIfDisposed();const e=Eo().read(n.dataId);if("string"===n.dtype){const r=yield e;try{return r.map(s=>ba(s))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e})()}dataToGPU(n){return this.throwIfDisposed(),Eo().readToGPU(this.dataId,n)}dataSync(){this.throwIfDisposed();const n=Eo().readSync(this.dataId);if("string"===this.dtype)try{return n.map(e=>ba(e))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return n}bytes(){var n=this;return J(function*(){n.throwIfDisposed();const e=yield Eo().read(n.dataId);return"string"===n.dtype?e:new Uint8Array(e.buffer)})()}dispose(){this.isDisposed||(Eo().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(n=!1){return sc.print(this,n)}clone(){return this.throwIfDisposed(),sc.clone(this)}toString(n=!1){return OY(this.dataSync(),this.shape,this.dtype,n)}cast(n){return this.throwIfDisposed(),sc.cast(this,n)}variable(n=!0,e,r){return this.throwIfDisposed(),Eo().makeVariable(this,n,e,r)}}function H(){return d0("Tensor",()=>Hn)}Object.defineProperty(Hn,Symbol.hasInstance,{value:t=>!!t&&null!=t.data&&null!=t.dataSync&&null!=t.throwIfDisposed}),H();class my extends Hn{constructor(n,e,r,s){super(n.shape,n.dtype,n.dataId,s),this.trainable=e,this.name=r}assign(n){if(n.dtype!==this.dtype)throw new Error(`dtype of the new value (${n.dtype}) and previous value (${this.dtype}) must match`);if(!Bt(n.shape,this.shape))throw new Error(`shape of the new value (${n.shape}) and previous value (${this.shape}) must match`);Eo().disposeTensor(this),this.dataId=n.dataId,Eo().incRef(this,null)}dispose(){Eo().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(my,Symbol.hasInstance,{value:t=>t instanceof Hn&&null!=t.assign&&t.assign instanceof Function});var gy=(()=>{return(t=gy||(gy={})).float32="float32",t.int32="int32",t.bool="int32",t.complex64="complex64",gy;var t})(),yy=(()=>{return(t=yy||(yy={})).float32="float32",t.int32="int32",t.bool="bool",t.complex64="complex64",yy;var t})(),by=(()=>{return(t=by||(by={})).float32="float32",t.int32="float32",t.bool="float32",t.complex64="complex64",by;var t})(),vy=(()=>{return(t=vy||(vy={})).float32="complex64",t.int32="complex64",t.bool="complex64",t.complex64="complex64",vy;var t})();const zY={float32:by,int32:gy,bool:yy,complex64:vy};function ys(t,n){if("string"===t||"string"===n){if("string"===t&&"string"===n)return"string";throw new Error(`Can not upcast ${t} with ${n}`)}return zY[t][n]}function c_(t){return ys(t,"int32")}function _M(t){return null!=t&&"object"==typeof t&&"texture"in t&&t.texture instanceof WebGLTexture}function SM(t){return typeof GPUBuffer<"u"&&null!=t&&"object"==typeof t&&"buffer"in t&&t.buffer instanceof GPUBuffer}function Tn(t,n){if(t.dtype===n.dtype)return[t,n];const e=ys(t.dtype,n.dtype);return[t.cast(e),n.cast(e)]}function IM(t){const n=[];return DM(t,n,new Set),n}function DM(t,n,e){if(null==t)return;if(t instanceof Hn)return void n.push(t);if(!function UY(t){return Array.isArray(t)||"object"==typeof t}(t))return;const r=t;for(const s in r){const o=r[s];e.has(o)||(e.add(o),DM(o,n,e))}}function d_(t){return null!=t.kernelName}class TM{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(n=>n.name)))}}}dispose(){for(const n in this.registeredVariables)this.registeredVariables[n].dispose()}}let WY=(()=>{class t{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new TM}ready(){var e=this;return J(function*(){if(null!=e.pendingBackendInit)return e.pendingBackendInit.then(()=>{});if(null!=e.backendInstance)return;const r=e.getSortedBackends();for(let s=0;s<r.length;s++){const o=r[s];if(yield e.initializeBackend(o).success)return void(yield e.setBackend(o))}throw new Error("Could not initialize any backends, all backend initializations failed.")})()}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:e,asyncInit:r}=this.initializeBackendsAndReturnBest();if(r)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{const{asyncInit:r}=this.initializeBackend(e);if(r)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,r,s=1){return e in this.registryFactory?(Ps(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:r,priority:s},!0)}setBackend(e){var r=this;return J(function*(){if(null==r.registryFactory[e])throw new Error(`Backend name '${e}' not found in registry`);if(r.backendName=e,null==r.registry[e]){r.backendInstance=null;const{success:s,asyncInit:o}=r.initializeBackend(e);if(!(o?yield s:s))return!1}return r.backendInstance=r.registry[e],r.setupRegisteredKernels(),r.profiler=new AY(r.backendInstance),!0})()}setupRegisteredKernels(){o_(this.backendName).forEach(r=>{null!=r.setupFunc&&r.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){o_(e).forEach(s=>{null!=s.disposeFunc&&s.disposeFunc(this.registry[e])})}initializeBackend(e){const r=this.registryFactory[e];if(null==r)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const s=r.factory();if(!s||s instanceof e0||"function"!=typeof s.then)return this.registry[e]=s,{success:!0,asyncInit:!1};{const o=++this.pendingBackendInitId,i=s.then(a=>!(o<this.pendingBackendInitId||(this.registry[e]=a,this.pendingBackendInit=null,0))).catch(a=>(o<this.pendingBackendInitId||(this.pendingBackendInit=null,Ps(`Initialization of backend ${e} failed`),Ps(a.stack||a.message)),!1));return this.pendingBackendInit=i,{success:i,asyncInit:!0}}}catch(s){return Ps(`Initialization of backend ${e} failed`),Ps(s.stack||s.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,r)=>this.registryFactory[r].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let r=0;r<e.length;r++){const s=e[r],{success:o,asyncInit:i}=this.initializeBackend(s);if(i||o)return{name:s,asyncInit:i}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,r){const s=this.state.tensorInfo.get(r),o=s.backend,i=this.readSync(r),a=o.refCount(r);o.disposeData(r,!0),s.backend=e,e.move(r,i,s.shape,s.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,r){let o,s=null;if(null==r){if("function"!=typeof e)throw new Error("Please provide a function to tidy()");r=e}else{if("string"!=typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof r)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");s=e}return this.scopedRun(()=>this.startScope(s),()=>this.endScope(o),()=>(o=r(),o instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),o))}scopedRun(e,r,s){e();try{const o=s();return r(),o}catch(o){throw r(),o}}nextTensorId(){return t.nextTensorId++}nextVariableId(){return t.nextVariableId++}clone(e){const r=R.runKernel(Nh,{x:e});return this.addTapeNode(this.state.activeScope.name,{x:e},[r],a=>({x:()=>R.runKernel(gh,{x:a},{dtype:"float32"})}),[],{}),r}runKernel(e,r,s){if(null==fM(e,this.backendName))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:r,attrs:s})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,r,s){const o=this.backend.numDataIds();let i=0;s.forEach(u=>{i+="complex64"===u.dtype?3:1});const l=o-r-i-this.state.numDataMovesStack[this.state.numDataMovesStack.length-1];if(l>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${l} data ids) after running '${e}'`)}runKernelFunc(e){let r,s=[];const o=this.isTapeOn(),i=this.state.numBytes,a=this.state.numTensors;let l,u;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);const c=d_(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(d_(e)){const{kernelName:g,inputs:m,attrs:y}=e,b=fM(g,this.backendName);_(null!=b,()=>`Cannot find registered kernel '${g}' for backend '${this.backendName}'`),l=()=>{const v=this.backend.numDataIds();u=b.kernelFunc({inputs:m,attrs:y,backend:this.backend});const x=Array.isArray(u)?u:[u];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(g,v,x);const w=x.map(C=>null!=C.rank?C:this.makeTensorFromTensorInfo(C));if(o){const C=this.getTensorsForGradient(g,m,w);s=this.saveTensorsForBackwardMode(C)}return w}}else{const{forwardFunc:g}=e,m=y=>{o&&(s=y.map(b=>this.keep(this.clone(b))))};l=()=>{const y=this.backend.numDataIds();u=this.tidy(()=>g(this.backend,m));const b=Array.isArray(u)?u:[u];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,y,b),b}}const{inputs:d,attrs:h}=e,p=d_(e)?null:e.backwardsFunc;let f;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(f=this.profiler.profileKernel(c,d,()=>l()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(f),r=f.outputs):r=l()}),o&&this.addTapeNode(c,d,r,p,s,h),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-i,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(d).map(g=>null!=d[g]?d[g].shape:null),outputShapes:r.map(g=>g.shape),kernelTimeMs:f.timeMs,extraInfo:f.extraInfo}),Array.isArray(u)?r:r[0]}saveTensorsForBackwardMode(e){return e.map(s=>this.keep(this.clone(s)))}getTensorsForGradient(e,r,s){const o=mM(e);if(null!=o){const i=o.inputsToSave||[],a=o.outputsToSave||[];let l;o.saveAllInputs?(_(Array.isArray(r),()=>"saveAllInputs is true, expected inputs to be an array."),l=Object.keys(r).map(c=>r[c])):l=i.map(c=>r[c]);const u=s.filter((c,d)=>a[d]);return l.concat(u)}return[]}makeTensor(e,r,s,o){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");o=o||this.backend;let i=e;"string"===(s=s||"float32")&&lh(e[0])&&(i=e.map(u=>ya(u)));const a=o.write(i,r,s),l=new Hn(r,s,a,this.nextTensorId());if(this.trackTensor(l,o),"string"===s){const u=this.state.tensorInfo.get(a),c=function cY(t){if(null==t)return 0;let n=0;return t.forEach(e=>n+=e.length),n}(i);this.state.numBytes+=c-u.bytes,u.bytes=c}return l}makeTensorFromDataId(e,r,s,o){return this.makeTensorFromTensorInfo({dataId:e,shape:r,dtype:s=s||"float32"},o)}makeTensorFromTensorInfo(e,r){const{dataId:s,shape:o,dtype:i}=e,a=new Hn(o,i,s,this.nextTensorId());return this.trackTensor(a,r),a}makeVariable(e,r=!0,s,o){s=s||this.nextVariableId().toString(),null!=o&&o!==e.dtype&&(e=e.cast(o));const i=new my(e,r,s,this.nextTensorId());if(null!=this.state.registeredVariables[i.name])throw new Error(`Variable with name ${i.name} was already registered`);return this.state.registeredVariables[i.name]=i,this.incRef(i,this.backend),i}trackTensor(e,r){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let s=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(s=e.size*ag(e.dtype)),this.state.numBytes+=s,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:r||this.backend,dtype:e.dtype,shape:e.shape,bytes:s})),e instanceof my||this.track(e)}incRef(e,r){this.trackTensor(e,r),this.backend.incRef(e.dataId)}removeDataId(e,r){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===r&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const r=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=r.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){const s=e.size*ag(e.dtype);this.state.numBytes-=s}r.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,r.backend)}disposeVariables(){for(const e in this.state.registeredVariables)this.disposeVariable(this.state.registeredVariables[e])}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}profile(e){var r=this;return J(function*(){r.state.profiling=!0;const s=r.state.numBytes,o=r.state.numTensors;r.state.activeProfile.kernels=[],r.state.activeProfile.result=yield e(),r.state.profiling=!1,r.state.activeProfile.peakBytes=Math.max(...r.state.activeProfile.kernels.map(i=>i.totalBytesSnapshot)),r.state.activeProfile.newBytes=r.state.numBytes-s,r.state.activeProfile.newTensors=r.state.numTensors-o;for(const i of r.state.activeProfile.kernels)i.kernelTimeMs=yield i.kernelTimeMs,i.extraInfo=yield i.extraInfo;return r.state.activeProfile})()}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,r,s,o,i,a){const l={id:this.state.nextTapeNodeId++,kernelName:e,inputs:r,outputs:s,saved:i},u=mM(e);null!=u&&(o=u.gradFunc),null!=o&&(l.gradient=c=>(c=c.map((d,h)=>{if(null==d){const p=s[h],f=kr(p.size,p.dtype);return this.makeTensor(f,p.shape,p.dtype)}return d}),o(c.length>1?c:c[0],i,a))),this.state.activeTape.push(l)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const r={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(r.name=e),this.state.scopeStack.push(r),this.state.activeScope=r}endScope(e){const r=IM(e),s=new Set(r.map(i=>i.id));for(let i=0;i<this.state.activeScope.track.length;i++){const a=this.state.activeScope.track[i];!a.kept&&!s.has(a.id)&&a.dispose()}const o=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],r.forEach(i=>{!i.kept&&i.scopeId===o.id&&this.track(i)})}gradients(e,r,s,o=!1){if(_(r.length>0,()=>"gradients() received an empty list of xs."),null!=s&&"float32"!==s.dtype)throw new Error(`dy must have 'float32' dtype, but has '${s.dtype}'`);const i=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));_(i instanceof Hn,()=>"The result y returned by f() must be a tensor.");const a=function MY(t,n,e){const r={},s={};for(let l=0;l<n.length;l++)r[n[l].id]=!0;for(let l=0;l<t.length;l++){const u=t[l],c=u.inputs;for(const d in c){const h=c[d];let p=!1;for(let f=0;f<n.length;f++)if(r[h.id]){u.outputs.forEach(g=>r[g.id]=!0),p=!0,s[u.id]=!0;break}if(p)break}}const o={};o[e.id]=!0;const i={};for(let l=t.length-1;l>=0;l--){const u=t[l],c=u.inputs;for(let d=0;d<u.outputs.length;d++)if(o[u.outputs[d].id]){for(const h in c)o[c[h].id]=!0,i[u.id]=!0;break}}const a=[];for(let l=0;l<t.length;l++){const u=t[l];if(s[u.id]&&i[u.id]){const c={};for(const h in u.inputs){const p=u.inputs[h];r[p.id]&&(c[h]=p)}const d=Object.assign({},u);d.inputs=c,d.outputs=u.outputs,a.push(d)}}return a}(this.state.activeTape,r,i);if(!o&&0===a.length&&r.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const l={};l[i.id]=s??function GY(t){const n=l0(G(t),"float32");return R.makeTensor(n,t,"float32")}(i.shape),function PY(t,n,e,r){for(let s=n.length-1;s>=0;s--){const o=n[s],i=[];if(o.outputs.forEach(l=>{const u=t[l.id];i.push(null!=u?u:null)}),null==o.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${o.kernelName}.`);const a=o.gradient(i);for(const l in o.inputs){if(!(l in a))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(a)}.`);const u=e(()=>a[l]());if("float32"!==u.dtype)throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${u.dtype}'`);const c=o.inputs[l];if(!Bt(u.shape,c.shape))throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input '${l}' has shape '${u.shape}', which does not match the shape of the input '${c.shape}'`);if(null==t[c.id])t[c.id]=u;else{const d=t[c.id];t[c.id]=r(d,u),d.dispose()}}}}(l,a,c=>this.tidy(c),HY);const u=r.map(c=>l[c.id]);return 0===this.state.gradientDepth&&(this.state.activeTape.forEach(c=>{for(const d of c.saved)d.dispose()}),this.state.activeTape=null),{value:i,grads:u}})}customGrad(e){return _(o0(e),()=>"The f passed in customGrad(f) must be a function."),(...r)=>{let s;_(r.every(l=>l instanceof Hn),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");const o={};return r.forEach((l,u)=>{o[u]=l}),this.runKernelFunc({forwardFunc:(l,u)=>(s=e(...r,u),_(s.value instanceof Hn,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),_(o0(s.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),s.value),backwardsFunc:(l,u)=>{const c=s.gradFunc(l,u),d=Array.isArray(c)?c:[c];_(d.length===r.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),_(d.every(p=>p instanceof Hn),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const h={};return d.forEach((p,f)=>{h[f]=()=>p}),h},inputs:o})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,r){return this.state.tensorInfo.get(e).backend.readToGPU(e,r)}time(e){var r=this;return J(function*(){const s=is(),o=yield r.backend.time(e);return o.wallMs=is()-s,o})()}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new TM;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}return t.nextTensorId=0,t.nextVariableId=0,t})();function EM(){const t=JF();if(null==t._tfengine){const n=new pY(t);t._tfengine=new WY(n)}return function yY(t){QF=t}(t._tfengine.ENV),function LY(t){Eo=t}(()=>t._tfengine),t._tfengine}const R=EM();function HY(t,n){return R.runKernel(tc,{a:t,b:n})}let h_;function NM(t){if(void 0!==h_)return h_;if(t||function jY(){return typeof navigator<"u"&&null!=navigator}()){if(t||(t=navigator),"ReactNative"===t.product)return!0;const n=t.userAgent||t.vendor||(typeof window<"u"?window.opera:"");return n?/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(n)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(n.substr(0,4)):t.userAgentData&&t.userAgentData.mobile}return!1}function kM(){return typeof window<"u"&&null!=window.document||typeof WorkerGlobalScope<"u"}const as=L();function lp(t,n){let e=t;if(To(t))return"string"===n?[]:[t.length];if(_M(t))return[t.height,t.width*(t.channels||"RGBA").length];if(SM(t))return[t.buffer.size/(null==n?4:ag(n))];if(!Array.isArray(t))return[];const r=[];for(;Array.isArray(e)||To(e)&&"string"!==n;)r.push(e.length),e=e[0];return Array.isArray(t)&&L().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&AM(t,r,[]),r}function AM(t,n,e){if(e=e||[],!Array.isArray(t)&&!To(t))return void _(0===n.length,()=>`Element arr[${e.join("][")}] is a primitive, but should be an array/TypedArray of ${n[0]} elements`);_(n.length>0,()=>`Element arr[${e.join("][")}] should be a primitive, but is an array of ${t.length} elements`),_(t.length===n[0],()=>`Element arr[${e.join("][")}] should have ${n[0]} elements, but has ${t.length} elements`);const r=n.slice(1);for(let s=0;s<t.length;++s)AM(t[s],r,e.concat(s))}function RM(t,n,e,r){if("string_or_numeric"!==t){if(null==t)throw new Error("Expected dtype cannot be null.");if("numeric"!==t&&t!==n||"numeric"===t&&"string"===n)throw new Error(`Argument '${e}' passed to '${r}' must be ${t} tensor, but got ${n} tensor`)}}function S(t,n,e,r="numeric"){if(t instanceof Hn)return RM(r,t.dtype,n,e),t;let s=Ju(t);if("string"!==s&&["bool","int32","float32"].indexOf(r)>=0&&(s=r),RM(r,s,n,e),null==t||!To(t)&&!Array.isArray(t)&&"number"!=typeof t&&"boolean"!=typeof t&&"string"!=typeof t)throw new Error(`Argument '${n}' passed to '${e}' must be a Tensor or TensorLike, but got '${null==t?"null":t.constructor.name}'`);const o=lp(t,s);!To(t)&&!Array.isArray(t)&&(t=[t]);const a="string"!==s?wl(t,s):Cl(t,[],!0);return R.makeTensor(a,o,s)}function FM(t,n,e,r="numeric"){if(!Array.isArray(t))throw new Error(`Argument ${n} passed to ${e} must be a \`Tensor[]\` or \`TensorLike[]\``);return t.map((o,i)=>S(o,`${n}[${i}]`,e,r))}as.registerFlag("DEBUG",()=>!1,t=>{t&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),as.registerFlag("IS_BROWSER",()=>kM()),as.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u"),as.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),as.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&null!=navigator&&null!=navigator.userAgent&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor)),as.registerFlag("PROD",()=>!1),as.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>as.getBool("DEBUG")),as.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),as.registerFlag("IS_TEST",()=>!1),as.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>as.getBool("DEBUG")),as.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1),as.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1),as.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);const qY="__op";function F(t){const n=Object.keys(t);if(1!==n.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${n.length} keys.`);let e=n[0];const r=t[e];e.endsWith("_")&&(e=e.substring(0,e.length-1)),e+=qY;const s=(...o)=>{R.startScope(e);try{const i=r(...o);return u0(i)&&console.error("Cannot return a Promise inside of tidy."),R.endScope(i),i}catch(i){throw R.endScope(null),i}};return Object.defineProperty(s,"name",{value:e,configurable:!0}),s}const _l=F({complex_:function KY(t,n){const e=S(t,"real","complex"),r=S(n,"imag","complex");return no(e.shape,r.shape,`real and imag shapes, ${e.shape} and ${r.shape}, must match in call to tf.complex().`),R.runKernel(b0,{real:e,imag:r})}});function up(t,n,e,r){if(null==r)r=Ju(t);else if("complex64"===r)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(SM(t)||_M(t)){if("float32"!==r&&"int32"!==r)throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return R.backend.createTensorFromGPUData(t,n||e,r)}if(!To(t)&&!Array.isArray(t)&&"number"!=typeof t&&"boolean"!=typeof t&&"string"!=typeof t)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=n){Li(n);const s=G(n),o=G(e);_(s===o,()=>`Based on the provided shape, [${n}], the tensor should have ${s} values but has ${o}`);for(let i=0;i<e.length;++i){const l=i!==e.length-1||e[i]!==G(n.slice(i));_(e[i]===n[i]||!l,()=>`Error creating a new Tensor. Inferred shape (${e}) does not match the provided shape (${n}). `)}}return!To(t)&&!Array.isArray(t)&&(t=[t]),n=n||e,t="string"!==r?wl(t,r):Cl(t,[],!0),R.makeTensor(t,n,r)}function cp(t,n,e){return up(t,n,lp(t,e),e)}const p_={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8},xy=4;function MM(t,n){return f_.apply(this,arguments)}function f_(){return f_=J(function*(t,n){const e=[],r=[],s=Array.isArray(t)?t.map(i=>i.name):Object.keys(t);for(let i=0;i<s.length;++i){const a=s[i],l=Array.isArray(t)?t[i].tensor:t[a];if("float32"!==l.dtype&&"int32"!==l.dtype&&"bool"!==l.dtype&&"string"!==l.dtype&&"complex64"!==l.dtype)throw new Error(`Unsupported dtype in weight '${a}': ${l.dtype}`);const u={name:a,shape:l.shape,dtype:l.dtype};if("string"===l.dtype){const c=new Promise(function(){var d=J(function*(h){const p=yield l.bytes(),f=p.reduce((y,b)=>y+b.length,0)+xy*p.length,g=new Uint8Array(f);let m=0;for(let y=0;y<p.length;y++){const b=p[y],v=new Uint8Array(new Uint32Array([b.length]).buffer);g.set(v,m),m+=xy,g.set(b,m),m+=b.length}h(g)});return function(h){return d.apply(this,arguments)}}());r.push(c)}else r.push(l.data());null!=n&&(u.group=n),e.push(u)}return{data:XY(yield Promise.all(r)),specs:e}}),f_.apply(this,arguments)}function XY(t){if(null===t)throw new Error(`Invalid input value: ${JSON.stringify(t)}`);let n=0;const e=[];t.forEach(o=>{if(n+=o.byteLength,e.push(o.byteLength===o.buffer.byteLength?o:new o.constructor(o)),!(o instanceof Float32Array||o instanceof Int32Array||o instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${o.constructor.name}`)});const r=new Uint8Array(n);let s=0;return e.forEach(o=>{r.set(new Uint8Array(o.buffer),s),s+=o.byteLength}),r.buffer}const m_=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function OM(t){return m_?Buffer.byteLength(t):new Blob([t]).size}function g_(t){if(1===t.length)return t[0];let n=0;t.forEach(s=>{n+=s.byteLength});const e=new Uint8Array(n);let r=0;return t.forEach(s=>{e.set(new Uint8Array(s),r),r+=s.byteLength}),e.buffer}function LM(t,n){const e={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,weightsManifest:n};return null!=t.signature&&(e.signature=t.signature),null!=t.userDefinedMetadata&&(e.userDefinedMetadata=t.userDefinedMetadata),null!=t.modelInitializer&&(e.modelInitializer=t.modelInitializer),null!=t.initializerSignature&&(e.initializerSignature=t.initializerSignature),null!=t.trainingConfig&&(e.trainingConfig=t.trainingConfig),e}function VM(t,n){return y_.apply(this,arguments)}function y_(){return(y_=J(function*(t,n){let e,r;return null!=t.weightsManifest&&([e,r]=yield n(t.weightsManifest)),function QY(t,n,e){const r={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy};if(null!=t.trainingConfig&&(r.trainingConfig=t.trainingConfig),null!=t.weightsManifest){if(!n)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!e)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=n,r.weightData=e}return null!=t.signature&&(r.signature=t.signature),null!=t.userDefinedMetadata&&(r.userDefinedMetadata=t.userDefinedMetadata),null!=t.modelInitializer&&(r.modelInitializer=t.modelInitializer),null!=t.initializerSignature&&(r.initializerSignature=t.initializerSignature),r}(t,e,r)})).apply(this,arguments)}function wy(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==t.modelTopology?0:OM(JSON.stringify(t.modelTopology)),weightSpecsBytes:null==t.weightSpecs?0:OM(JSON.stringify(t.weightSpecs)),weightDataBytes:null==t.weightData?0:t.weightData.byteLength}}function rZ(){const t=function eZ(){const t=e=>{let r=e<<13,s=0;for(;!(8388608&r);)s-=8388608,r<<=1;return r&=-8388609,s+=947912704,r|s},n=new Uint32Array(2048);n[0]=0;for(let e=1;e<1024;e++)n[e]=t(e);for(let e=1024;e<2048;e++)n[e]=939524096+(e-1024<<13);return n}(),n=function tZ(){const t=new Uint32Array(64);t[0]=0,t[31]=1199570944,t[32]=2147483648,t[63]=3347054592;for(let n=1;n<31;n++)t[n]=n<<23;for(let n=33;n<63;n++)t[n]=2147483648+(n-32<<23);return t}(),e=function nZ(){const t=new Uint32Array(64);for(let n=0;n<64;n++)t[n]=1024;return t[0]=t[32]=0,t}();return r=>{const s=new ArrayBuffer(4*r.length),o=new Uint32Array(s);for(let i=0;i<r.length;i++){const a=r[i];o[i]=t[e[a>>10]+(1023&a)]+n[a>>10]}return new Float32Array(s)}}class wn{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==wn.instance&&(wn.instance=new wn),wn.instance}static registerSaveRouter(n){wn.getInstance().saveRouters.push(n)}static registerLoadRouter(n){wn.getInstance().loadRouters.push(n)}static getSaveHandlers(n){return wn.getHandlers(n,"save")}static getLoadHandlers(n,e){return wn.getHandlers(n,"load",e)}static getHandlers(n,e,r){const s=[];return("load"===e?wn.getInstance().loadRouters:wn.getInstance().saveRouters).forEach(i=>{const a=i(n,r);null!==a&&s.push(a)}),s}}const oZ=(t,n)=>wn.getLoadHandlers(t,n),Cy="tensorflowjs",Sl="models_store",va="model_info_store";function x_(){if(!L().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const t=typeof window>"u"?self:window,n=t.indexedDB||t.mozIndexedDB||t.webkitIndexedDB||t.msIndexedDB||t.shimIndexedDB;if(null==n)throw new Error("The current browser does not appear to support IndexedDB.");return n}function w_(t){const n=t.result;n.createObjectStore(Sl,{keyPath:"modelPath"}),n.createObjectStore(va,{keyPath:"modelPath"})}let oc=(()=>{class t{constructor(e){if(this.indexedDB=x_(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}save(e){var r=this;return J(function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return r.databaseAction(r.modelPath,e)})()}load(){var e=this;return J(function*(){return e.databaseAction(e.modelPath)})()}databaseAction(e,r){return new Promise((s,o)=>{const i=this.indexedDB.open(Cy,1);i.onupgradeneeded=()=>w_(i),i.onsuccess=()=>{const a=i.result;if(null==r){const l=a.transaction(Sl,"readonly"),c=l.objectStore(Sl).get(this.modelPath);c.onsuccess=()=>{if(null==c.result)return a.close(),o(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));s(c.result.modelArtifacts)},c.onerror=d=>(a.close(),o(c.error)),l.oncomplete=()=>a.close()}else{const l=wy(r),u=a.transaction(va,"readwrite");let d,h,c=u.objectStore(va);try{d=c.put({modelPath:this.modelPath,modelArtifactsInfo:l})}catch(p){return o(p)}d.onsuccess=()=>{h=a.transaction(Sl,"readwrite");const p=h.objectStore(Sl);let f;try{f=p.put({modelPath:this.modelPath,modelArtifacts:r,modelArtifactsInfo:l})}catch(g){return o(g)}f.onsuccess=()=>s({modelArtifactsInfo:l}),f.onerror=g=>{c=u.objectStore(va);const m=c.delete(this.modelPath);m.onsuccess=()=>(a.close(),o(f.error)),m.onerror=y=>(a.close(),o(f.error))}},d.onerror=p=>(a.close(),o(d.error)),u.oncomplete=()=>{null==h?a.close():h.oncomplete=()=>a.close()}}},i.onerror=a=>o(i.error)})}}return t.URL_SCHEME="indexeddb://",t})();const BM=t=>L().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(oc.URL_SCHEME)?function iZ(t){return new oc(t)}(t.slice(oc.URL_SCHEME.length)):null;wn.registerSaveRouter(BM),wn.registerLoadRouter(BM);class lZ{constructor(){this.indexedDB=x_()}listModels(){var n=this;return J(function*(){return new Promise((e,r)=>{const s=n.indexedDB.open(Cy,1);s.onupgradeneeded=()=>w_(s),s.onsuccess=()=>{const o=s.result,i=o.transaction(va,"readonly"),l=i.objectStore(va).getAll();l.onsuccess=()=>{const u={};for(const c of l.result)u[c.modelPath]=c.modelArtifactsInfo;e(u)},l.onerror=u=>(o.close(),r(l.error)),i.oncomplete=()=>o.close()},s.onerror=o=>r(s.error)})})()}removeModel(n){var e=this;return J(function*(){return n=function aZ(t){return t.startsWith(oc.URL_SCHEME)?t.slice(oc.URL_SCHEME.length):t}(n),new Promise((r,s)=>{const o=e.indexedDB.open(Cy,1);o.onupgradeneeded=()=>w_(o),o.onsuccess=()=>{const i=o.result,a=i.transaction(va,"readwrite"),l=a.objectStore(va),u=l.get(n);let c;u.onsuccess=()=>{if(null==u.result)return i.close(),s(new Error(`Cannot find model with path '${n}' in IndexedDB.`));{const d=l.delete(n),h=()=>{c=i.transaction(Sl,"readwrite");const f=c.objectStore(Sl).delete(n);f.onsuccess=()=>r(u.result.modelArtifactsInfo),f.onerror=g=>s(u.error)};d.onsuccess=h,d.onerror=p=>(h(),i.close(),s(u.error))}},u.onerror=d=>(i.close(),s(u.error)),a.oncomplete=()=>{null==c?i.close():c.oncomplete=()=>i.close()}},o.onerror=i=>s(o.error)})})()}}const ni="/",Il="tensorflowjs_models",zM="info",uZ="model_topology",cZ="weight_specs",dZ="weight_data",hZ="model_metadata";function UM(t){return{info:[Il,t,zM].join(ni),topology:[Il,t,uZ].join(ni),weightSpecs:[Il,t,cZ].join(ni),weightData:[Il,t,dZ].join(ni),modelMetadata:[Il,t,hZ].join(ni)}}function WM(t){for(const n of Object.values(t))window.localStorage.removeItem(n)}function GM(t){const n=t.split(ni);if(n.length<3)throw new Error(`Invalid key format: ${t}`);return n.slice(1,n.length-1).join(ni)}let ic=(()=>{class t{constructor(e){if(!L().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=UM(this.modelPath)}save(e){var r=this;return J(function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const s=JSON.stringify(e.modelTopology),o=JSON.stringify(e.weightSpecs),i=wy(e);try{return r.LS.setItem(r.keys.info,JSON.stringify(i)),r.LS.setItem(r.keys.topology,s),r.LS.setItem(r.keys.weightSpecs,o),r.LS.setItem(r.keys.weightData,function YY(t){if(m_)return Buffer.from(t).toString("base64");const n=new Uint8Array(t);let e="";for(let r=0,s=n.length;r<s;r++)e+=String.fromCharCode(n[r]);return btoa(e)}(e.weightData)),r.LS.setItem(r.keys.modelMetadata,JSON.stringify({format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:null!=e.signature?e.signature:void 0,userDefinedMetadata:null!=e.userDefinedMetadata?e.userDefinedMetadata:void 0,modelInitializer:null!=e.modelInitializer?e.modelInitializer:void 0,initializerSignature:null!=e.initializerSignature?e.initializerSignature:void 0,trainingConfig:null!=e.trainingConfig?e.trainingConfig:void 0})),{modelArtifactsInfo:i}}catch{throw WM(r.keys),new Error(`Failed to save model '${r.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${i.modelTopologyBytes}, weightSpecsBytes=${i.weightSpecsBytes}, weightDataBytes=${i.weightDataBytes}.`)}}})()}load(){var e=this;return J(function*(){const r=JSON.parse(e.LS.getItem(e.keys.info));if(null==r)throw new Error(`In local storage, there is no model with name '${e.modelPath}'`);if("JSON"!==r.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const s={},o=JSON.parse(e.LS.getItem(e.keys.topology));if(null==o)throw new Error(`In local storage, the topology of model '${e.modelPath}' is missing.`);s.modelTopology=o;const i=JSON.parse(e.LS.getItem(e.keys.weightSpecs));if(null==i)throw new Error(`In local storage, the weight specs of model '${e.modelPath}' are missing.`);s.weightSpecs=i;const a=e.LS.getItem(e.keys.modelMetadata);if(null!=a){const u=JSON.parse(a);s.format=u.format,s.generatedBy=u.generatedBy,s.convertedBy=u.convertedBy,null!=u.signature&&(s.signature=u.signature),null!=u.userDefinedMetadata&&(s.userDefinedMetadata=u.userDefinedMetadata),null!=u.modelInitializer&&(s.modelInitializer=u.modelInitializer),null!=u.initializerSignature&&(s.initializerSignature=u.initializerSignature),null!=u.trainingConfig&&(s.trainingConfig=u.trainingConfig)}const l=e.LS.getItem(e.keys.weightData);if(null==l)throw new Error(`In local storage, the binary weight values of model '${e.modelPath}' are missing.`);return s.weightData=function ZY(t){if(m_){const r=Buffer.from(t,"base64");return r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)}const n=atob(t),e=new Uint8Array(n.length);for(let r=0;r<n.length;++r)e.set([n.charCodeAt(r)],r);return e.buffer}(l),s})()}}return t.URL_SCHEME="localstorage://",t})();const HM=t=>L().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(ic.URL_SCHEME)?function fZ(t){return new ic(t)}(t.slice(ic.URL_SCHEME.length)):null;wn.registerSaveRouter(HM),wn.registerLoadRouter(HM);class mZ{constructor(){_(L().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),_(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}listModels(){var n=this;return J(function*(){const e={},r=Il+ni,s=ni+zM;for(let o=0;o<n.LS.length;++o){const i=n.LS.key(o);i.startsWith(r)&&i.endsWith(s)&&(e[GM(i)]=JSON.parse(n.LS.getItem(i)))}return e})()}removeModel(n){var e=this;return J(function*(){const r=UM(n=function pZ(t){return t.startsWith(ic.URL_SCHEME)?t.slice(ic.URL_SCHEME.length):t}(n));if(null==e.LS.getItem(r.info))throw new Error(`Cannot find model at path '${n}'`);const s=JSON.parse(e.LS.getItem(r.info));return WM(r),s})()}}class Wr{constructor(){this.managers={}}static getInstance(){return null==Wr.instance&&(Wr.instance=new Wr),Wr.instance}static registerManager(n,e){_(null!=n,()=>"scheme must not be undefined or null."),n.endsWith("://")&&(n=n.slice(0,n.indexOf("://"))),_(n.length>0,()=>"scheme must not be an empty string.");const r=Wr.getInstance();_(null==r.managers[n],()=>`A model store manager is already registered for scheme '${n}'.`),r.managers[n]=e}static getManager(n){const e=Wr.getInstance().managers[n];if(null==e)throw new Error(`Cannot find model manager for scheme '${n}'`);return e}static getSchemes(){return Object.keys(Wr.getInstance().managers)}}class gZ{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(n,e){return fetch(n,e)}now(){return performance.now()}encode(n,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Browser's encoder only supports utf-8, but got ${e}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(n)}decode(n,e){return new TextDecoder(e).decode(n)}setTimeoutCustom(n,e){typeof window>"u"||!L().getBool("USE_SETTIMEOUTCUSTOM")?setTimeout(n,e):(this.functionRefs.push(n),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},e),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",r=>{r.source===window&&r.data.name===this.messageName&&(r.stopPropagation(),(0,this.functionRefs[r.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0))},!0)))}isTypedArray(n){return n instanceof Float32Array||n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray}}if(L().get("IS_BROWSER")){L().setPlatform("browser",new gZ);try{Wr.registerManager(ic.URL_SCHEME,new mZ)}catch{}try{Wr.registerManager(oc.URL_SCHEME,new lZ)}catch{}}let lc;function vt(t,n="float32",e){return n=n||"float32",Li(t),new br(t,n,e)}L().get("IS_NODE")&&!L().get("IS_BROWSER")&&L().setPlatform("node",new class bZ{constructor(){this.util=de(628),this.textEncoder=new this.util.TextEncoder}fetch(n,e){return null!=L().global.fetch?L().global.fetch(n,e):(null==lc&&(lc=de(410)),lc(n,e))}now(){const n=process.hrtime();return 1e3*n[0]+n[1]/1e6}encode(n,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Node built-in encoder only supports utf-8, but got ${e}`);return this.textEncoder.encode(n)}decode(n,e){return 0===n.length?"":new this.util.TextDecoder(e).decode(n)}isTypedArray(n){return this.util.types.isFloat32Array(n)||this.util.types.isInt32Array(n)||this.util.types.isUint8Array(n)||this.util.types.isUint8ClampedArray(n)}});const xe=F({cast_:function vZ(t,n){const e=S(t,"x","cast");if(!function uY(t){return"bool"===t||"complex64"===t||"float32"===t||"int32"===t||"string"===t}(n))throw new Error(`Failed to cast to unknown dtype ${n}`);if("string"===n&&"string"!==e.dtype||"string"!==n&&"string"===e.dtype)throw new Error("Only strings can be casted to strings");return R.runKernel(gh,{x:e},{dtype:n})}}),Dl=F({clone_:function xZ(t){const e={x:S(t,"x","clone","string_or_numeric")};return R.runKernel(Nh,e)}});function ri(){return R}function T_(){return R.memory()}function $(t,n){return R.tidy(t,n)}function ft(t){IM(t).forEach(e=>e.dispose())}function si(t){return R.keep(t)}function qM(t,n,e=1){return R.registerBackend(t,n,e)}EM(),function VY(t){sc=t}({buffer:vt,cast:xe,clone:Dl,print:function wZ(t,n=!1){console.log(t.toString(n))}}),function BY(t){CM=t}(function CZ(t){L().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(t+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")});const ie=F({add_:function SZ(t,n){let e=S(t,"a","add"),r=S(n,"b","add");return[e,r]=Tn(e,r),R.runKernel(tc,{a:e,b:r})}}),KM=F({floorDiv_:function IZ(t,n){let e=S(t,"a","floorDiv"),r=S(n,"b","floorDiv");return[e,r]=Tn(e,r),R.runKernel(Th,{a:e,b:r})}}),Oe=F({div_:function DZ(t,n){let e=S(t,"a","div"),r=S(n,"b","div");return[e,r]=Tn(e,r),"int32"===e.dtype&&"int32"===r.dtype?KM(e,r):R.runKernel(wh,{a:e,b:r},{})}}),k=F({mul_:function TZ(t,n){let e=S(t,"a","mul"),r=S(n,"b","mul");return[e,r]=Tn(e,r),R.runKernel(Lh,{a:e,b:r})}}),Gr=F({sqrt_:function EZ(t){const e={x:S(t,"x","sqrt","float32")};return R.runKernel(Zh,e)}}),rn=F({square_:function NZ(t){const n=S(t,"x","square");return R.runKernel("Square",{x:n},{})}}),At=F({zerosLike_:function kZ(t){const e={x:S(t,"x","zerosLike")};return R.runKernel(ly,e)}});function Vi(t){return R.customGrad(t)}function rt(t,n){if((To(t)&&"string"!==n||Array.isArray(t))&&"complex64"!==n)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===n&&To(t)&&!(t instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return up(t,[],[],n)}class uc{getClassName(){return this.constructor.className}static fromConfig(n,e){return new n(e)}}class ro{constructor(){this.classNameMap={}}static getMap(){return null==ro.instance&&(ro.instance=new ro),ro.instance}static register(n){ro.getMap().classNameMap[n.className]=[n,n.fromConfig]}}function se(t){_(null!=t.className,()=>"Class being registered does not have the static className property defined."),_("string"==typeof t.className,()=>"className is required to be a string, but got type "+typeof t.className),_(t.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),ro.register(t)}class xa extends uc{minimize(n,e=!1,r){const{value:s,grads:o}=this.computeGradients(n,r);if(null!=r){const i=r.map(a=>({name:a.name,tensor:o[a.name]}));this.applyGradients(i)}else this.applyGradients(o);return ft(o),e?s:(s.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(n,e){return function AZ(t,n){_(o0(t),()=>"The f passed in variableGrads(f) must be a function"),_(null==n||Array.isArray(n)&&n.every(u=>u instanceof my),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const e=null!=n;if(!e){n=[];for(const u in R.registeredVariables)n.push(R.registeredVariables[u])}const r=e?n.filter(u=>!u.trainable):null,s=n.length;_((n=n.filter(u=>u.trainable)).length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${s} variables is trainable.`);const{value:i,grads:a}=R.gradients(t,n,null,!0);_(a.some(u=>null!=u),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),_(0===i.rank,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`);const l={};return n.forEach((u,c)=>{null!=a[c]&&(l[u.name]=a[c])}),r?.forEach(u=>l[u.name]=null),{value:i,grads:l}}(n,e)}dispose(){null!=this.iterations_&&ft(this.iterations_)}saveIterations(){var n=this;return J(function*(){return null==n.iterations_&&(n.iterations_=0),{name:"iter",tensor:rt(n.iterations_,"int32")}})()}getWeights(){return J(function*(){throw new Error("getWeights() is not implemented for this optimizer yet.")})()}setWeights(n){var e=this;return J(function*(){throw new Error(`setWeights() is not implemented for this optimizer class ${e.getClassName()}`)})()}extractIterations(n){var e=this;return J(function*(){return e.iterations_=(yield n[0].tensor.data())[0],n.slice(1)})()}}Object.defineProperty(xa,Symbol.hasInstance,{value:t=>null!=t.minimize&&null!=t.computeGradients&&null!=t.applyGradients});class XM extends xa{static get className(){return"Adadelta"}constructor(n,e,r=null){super(),this.learningRate=n,this.rho=e,this.epsilon=r,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==r&&(this.epsilon=R.backend.epsilon())}applyGradients(n){(Array.isArray(n)?n.map(r=>r.name):Object.keys(n)).forEach((r,s)=>{const o=R.registeredVariables[r];null==this.accumulatedGrads[s]&&(this.accumulatedGrads[s]={originalName:`${r}/accum_grad`,variable:$(()=>At(o).variable(!1))}),null==this.accumulatedUpdates[s]&&(this.accumulatedUpdates[s]={originalName:`${r}/accum_var`,variable:$(()=>At(o).variable(!1))});const a=Array.isArray(n)?n[s].tensor:n[r];if(null==a)return;const l=this.accumulatedGrads[s].variable,u=this.accumulatedUpdates[s].variable;$(()=>{const c=ie(k(l,this.rho),k(rn(a),1-this.rho)),d=k(Oe(Gr(ie(u,this.epsilon)),Gr(ie(l,this.epsilon))),a),h=ie(k(u,this.rho),k(rn(d),1-this.rho));l.assign(c),u.assign(h);const p=ie(k(d,-this.learningRate),o);o.assign(p)})}),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(ft(this.accumulatedGrads.map(n=>n.variable)),ft(this.accumulatedUpdates.map(n=>n.variable)))}getWeights(){var n=this;return J(function*(){const e=[...n.accumulatedGrads,...n.accumulatedUpdates];return[yield n.saveIterations()].concat(e.map(r=>({name:r.originalName,tensor:r.variable})))})()}setWeights(n){var e=this;return J(function*(){const r=(n=yield e.extractIterations(n)).length/2;e.accumulatedGrads=n.slice(0,r).map(o=>({originalName:o.name,variable:o.tensor.variable(!1)})),e.accumulatedUpdates=n.slice(r,2*r).map(o=>({originalName:o.name,variable:o.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(n,e){return new n(e.learningRate,e.rho,e.epsilon)}}function dp(t,n,e){return Li(t),e=e||Ju(n),R.runKernel(R0,{},{shape:t,value:n,dtype:e})}class YM extends xa{static get className(){return"Adagrad"}constructor(n,e=.1){super(),this.learningRate=n,this.initialAccumulatorValue=e,this.accumulatedGrads=[]}applyGradients(n){(Array.isArray(n)?n.map(r=>r.name):Object.keys(n)).forEach((r,s)=>{const o=R.registeredVariables[r];null==this.accumulatedGrads[s]&&(this.accumulatedGrads[s]={originalName:`${r}/accumulator`,variable:$(()=>dp(o.shape,this.initialAccumulatorValue).variable(!1))});const i=Array.isArray(n)?n[s].tensor:n[r];if(null==i)return;const a=this.accumulatedGrads[s].variable;$(()=>{const l=ie(a,rn(i));a.assign(l);const u=ie(k(Oe(i,Gr(ie(l,R.backend.epsilon()))),-this.learningRate),o);o.assign(u)})}),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&ft(this.accumulatedGrads.map(n=>n.variable))}getWeights(){var n=this;return J(function*(){return[yield n.saveIterations()].concat(n.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))})()}setWeights(n){var e=this;return J(function*(){n=yield e.extractIterations(n),e.accumulatedGrads=n.map(s=>({originalName:s.name,variable:s.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(n,e){return new n(e.learningRate,e.initialAccumulatorValue)}}const cc=F({pow_:function RZ(t,n){let e=S(t,"base","pow"),r=S(n,"exp","pow");return[e,r]=Tn(e,r),R.runKernel(Vh,{a:e,b:r})}}),ke=F({sub_:function FZ(t,n){let e=S(t,"a","sub"),r=S(n,"b","sub");return[e,r]=Tn(e,r),R.runKernel(Jh,{a:e,b:r})}});class ZM extends xa{static get className(){return"Adam"}constructor(n,e,r,s=null){super(),this.learningRate=n,this.beta1=e,this.beta2=r,this.epsilon=s,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],$(()=>{this.accBeta1=rt(e).variable(),this.accBeta2=rt(r).variable()}),null==s&&(this.epsilon=R.backend.epsilon())}applyGradients(n){const e=Array.isArray(n)?n.map(r=>r.name):Object.keys(n);$(()=>{const r=ke(1,this.accBeta1),s=ke(1,this.accBeta2);e.forEach((o,i)=>{const a=R.registeredVariables[o];null==this.accumulatedFirstMoment[i]&&(this.accumulatedFirstMoment[i]={originalName:`${o}/m`,variable:$(()=>At(a).variable(!1))}),null==this.accumulatedSecondMoment[i]&&(this.accumulatedSecondMoment[i]={originalName:`${o}/v`,variable:$(()=>At(a).variable(!1))});const u=Array.isArray(n)?n[i].tensor:n[o];if(null==u)return;const c=this.accumulatedFirstMoment[i].variable,d=this.accumulatedSecondMoment[i].variable,h=ie(k(c,this.beta1),k(u,1-this.beta1)),p=ie(k(d,this.beta2),k(rn(u),1-this.beta2)),f=Oe(h,r),g=Oe(p,s);c.assign(h),d.assign(p);const m=ie(k(Oe(f,ie(Gr(g),this.epsilon)),-this.learningRate),a);a.assign(m)}),this.accBeta1.assign(k(this.accBeta1,this.beta1)),this.accBeta2.assign(k(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&ft(this.accumulatedFirstMoment.map(n=>n.variable)),null!=this.accumulatedSecondMoment&&ft(this.accumulatedSecondMoment.map(n=>n.variable))}getWeights(){var n=this;return J(function*(){const e=[...n.accumulatedFirstMoment,...n.accumulatedSecondMoment];return[yield n.saveIterations()].concat(e.map(r=>({name:r.originalName,tensor:r.variable})))})()}setWeights(n){var e=this;return J(function*(){n=yield e.extractIterations(n),$(()=>{e.accBeta1.assign(cc(e.beta1,e.iterations_+1)),e.accBeta2.assign(cc(e.beta2,e.iterations_+1))});const r=n.length/2;e.accumulatedFirstMoment=n.slice(0,r).map(o=>({originalName:o.name,variable:o.tensor.variable(!1)})),e.accumulatedSecondMoment=n.slice(r,2*r).map(o=>({originalName:o.name,variable:o.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(n,e){return new n(e.learningRate,e.beta1,e.beta2,e.epsilon)}}const ur=F({abs_:function MZ(t){const n=S(t,"x","abs");return R.runKernel("complex64"===n.dtype?mg:lg,{x:n})}});function dc(t,n){const e=t.length,r=[];for(let s=0;s<e;s++){const o=e-1-s;(n[n.length-1-s]||1)>1&&1===(t[o]||1)&&r.unshift(o)}return r}function Qn(t,n){const e=[];for(let r=0;r<n.length;r++){const s=t[t.length-r-1],o=n.length-r-1;(null==s||1===s&&n[o]>1)&&e.unshift(o)}return e}function st(t,n){const e=Math.max(t.length,n.length),r=new Array(e);for(let s=0;s<e;s++){let o=t[t.length-s-1];null==o&&(o=1);let i=n[n.length-s-1];if(null==i&&(i=1),1===o)r[e-s-1]=i;else if(1===i)r[e-s-1]=o;else{if(o!==i)throw Error(`Operands could not be broadcast together with shapes ${t} and ${n}.`);r[e-s-1]=o}}return r}const wa=F({maximum_:function PZ(t,n){let e=S(t,"a","maximum"),r=S(n,"b","maximum");return[e,r]=Tn(e,r),"bool"===e.dtype&&(e=xe(e,"int32"),r=xe(r,"int32")),st(e.shape,r.shape),R.runKernel(Ph,{a:e,b:r})}});class QM extends xa{static get className(){return"Adamax"}constructor(n,e,r,s=null,o=0){super(),this.learningRate=n,this.beta1=e,this.beta2=r,this.epsilon=s,this.decay=o,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],$(()=>{this.iteration=rt(0).variable(),this.accBeta1=rt(e).variable()}),null==s&&(this.epsilon=R.backend.epsilon())}applyGradients(n){const e=Array.isArray(n)?n.map(r=>r.name):Object.keys(n);$(()=>{const r=ke(1,this.accBeta1),s=Oe(-this.learningRate,ie(k(this.iteration,this.decay),1));e.forEach((o,i)=>{const a=R.registeredVariables[o];null==this.accumulatedFirstMoment[i]&&(this.accumulatedFirstMoment[i]={originalName:`${o}/m`,variable:At(a).variable(!1)}),null==this.accumulatedWeightedInfNorm[i]&&(this.accumulatedWeightedInfNorm[i]={originalName:`${o}/v`,variable:At(a).variable(!1)});const u=Array.isArray(n)?n[i].tensor:n[o];if(null==u)return;const c=this.accumulatedFirstMoment[i].variable,d=this.accumulatedWeightedInfNorm[i].variable,h=ie(k(c,this.beta1),k(u,1-this.beta1)),p=k(d,this.beta2),f=ur(u),g=wa(p,f);c.assign(h),d.assign(g);const m=ie(k(Oe(s,r),Oe(h,ie(g,this.epsilon))),a);a.assign(m)}),this.iteration.assign(ie(this.iteration,1)),this.accBeta1.assign(k(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&ft(this.accumulatedFirstMoment.map(n=>n.variable)),null!=this.accumulatedWeightedInfNorm&&ft(this.accumulatedWeightedInfNorm.map(n=>n.variable))}getWeights(){return J(function*(){throw new Error("getWeights() is not implemented for Adamax yet.")})()}setWeights(n){return J(function*(){throw new Error("setWeights() is not implemented for Adamax yet.")})()}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(n,e){return new n(e.learningRate,e.beta1,e.beta2,e.epsilon,e.decay)}}class E_ extends xa{static get className(){return"SGD"}constructor(n){super(),this.learningRate=n,this.setLearningRate(n)}applyGradients(n){(Array.isArray(n)?n.map(r=>r.name):Object.keys(n)).forEach((r,s)=>{const o=Array.isArray(n)?n[s].tensor:n[r];if(null==o)return;const i=R.registeredVariables[r];$(()=>{const a=ie(k(this.c,o),i);i.assign(a)})}),this.incrementIterations()}setLearningRate(n){this.learningRate=n,null!=this.c&&this.c.dispose(),this.c=si(rt(-n))}dispose(){this.c.dispose()}getWeights(){var n=this;return J(function*(){return[yield n.saveIterations()]})()}setWeights(n){var e=this;return J(function*(){if(0!==(n=yield e.extractIterations(n)).length)throw new Error("SGD optimizer does not have settable weights.")})()}getConfig(){return{learningRate:this.learningRate}}static fromConfig(n,e){return new n(e.learningRate)}}class JM extends E_{static get className(){return"Momentum"}constructor(n,e,r=!1){super(n),this.learningRate=n,this.momentum=e,this.useNesterov=r,this.accumulations=[],this.m=rt(this.momentum)}applyGradients(n){(Array.isArray(n)?n.map(r=>r.name):Object.keys(n)).forEach((r,s)=>{const o=R.registeredVariables[r];null==this.accumulations[s]&&(this.accumulations[s]={originalName:`${r}/momentum`,variable:$(()=>At(o).variable(!1))});const i=this.accumulations[s].variable,a=Array.isArray(n)?n[s].tensor:n[r];null!=a&&$(()=>{let l;const u=ie(k(this.m,i),a);l=ie(k(this.c,this.useNesterov?ie(a,k(u,this.m)):u),o),i.assign(u),o.assign(l)})}),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&ft(this.accumulations.map(n=>n.variable))}setMomentum(n){this.momentum=n}getWeights(){var n=this;return J(function*(){return[yield n.saveIterations()].concat(n.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))})()}setWeights(n){var e=this;return J(function*(){n=yield e.extractIterations(n),e.accumulations=n.map(s=>({originalName:s.name,variable:s.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(n,e){return new n(e.learningRate,e.momentum,e.useNesterov)}}class eP extends xa{static get className(){return"RMSProp"}constructor(n,e=.9,r=0,s=null,o=!1){if(super(),this.learningRate=n,this.decay=e,this.momentum=r,this.epsilon=s,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=o,null==s&&(this.epsilon=R.backend.epsilon()),null==n)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(n){(Array.isArray(n)?n.map(r=>r.name):Object.keys(n)).forEach((r,s)=>{const o=R.registeredVariables[r],i=!1;null==this.accumulatedMeanSquares[s]&&(this.accumulatedMeanSquares[s]={originalName:`${r}/rms`,variable:$(()=>At(o).variable(i))}),null==this.accumulatedMoments[s]&&(this.accumulatedMoments[s]={originalName:`${r}/momentum`,variable:$(()=>At(o).variable(i))}),null==this.accumulatedMeanGrads[s]&&this.centered&&(this.accumulatedMeanGrads[s]={originalName:`${r}/mg`,variable:$(()=>At(o).variable(i))});const a=Array.isArray(n)?n[s].tensor:n[r];if(null==a)return;const l=this.accumulatedMeanSquares[s].variable,u=this.accumulatedMoments[s].variable;$(()=>{const c=ie(k(l,this.decay),k(rn(a),1-this.decay));if(this.centered){const d=this.accumulatedMeanGrads[s].variable,h=ie(k(d,this.decay),k(a,1-this.decay)),p=Oe(k(a,this.learningRate),Gr(ke(c,ie(rn(h),this.epsilon)))),f=ie(k(u,this.momentum),p);l.assign(c),d.assign(h),u.assign(f);const g=ke(o,f);o.assign(g)}else{const d=ie(k(l,this.decay),k(rn(a),1-this.decay)),h=ie(k(u,this.momentum),Oe(k(a,this.learningRate),Gr(ie(d,this.epsilon))));l.assign(d),u.assign(h);const p=ke(o,h);o.assign(p)}})}),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&ft(this.accumulatedMeanSquares.map(n=>n.variable)),null!=this.accumulatedMeanGrads&&this.centered&&ft(this.accumulatedMeanGrads.map(n=>n.variable)),null!=this.accumulatedMoments&&ft(this.accumulatedMoments.map(n=>n.variable))}getWeights(){var n=this;return J(function*(){const e=[...n.accumulatedMeanSquares,...n.accumulatedMoments];return n.centered&&e.push(...n.accumulatedMeanGrads),[yield n.saveIterations()].concat(e.map(r=>({name:r.originalName,tensor:r.variable})))})()}setWeights(n){var e=this;return J(function*(){n=yield e.extractIterations(n);const r=e.centered?n.length/3:n.length/2,s=!1;e.accumulatedMeanSquares=n.slice(0,r).map(o=>({originalName:o.name,variable:o.tensor.variable(s)})),e.accumulatedMoments=n.slice(r,2*r).map(o=>({originalName:o.name,variable:o.tensor.variable(s)})),e.centered&&(e.accumulatedMeanGrads=n.slice(2*r,3*r).map(o=>({originalName:o.name,variable:o.tensor.variable(s)})))})()}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(n,e){return new n(e.learningRate,e.decay,e.momentum,e.epsilon,e.centered)}}const OZ=[XM,YM,ZM,QM,JM,eP,E_];function tP(t){return new Promise(n=>setTimeout(n)).then(t)}let N_=(()=>{class t{constructor(e){if(!L().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(t.URL_SCHEME)&&(e=e.slice(t.URL_SCHEME.length)),(null==e||0===e.length)&&(e="model"),this.modelJsonFileName=e+".json",this.weightDataFileName=e+".weights.bin"}save(e){var r=this;return J(function*(){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const s=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const i=LM(e,[{paths:["./"+r.weightDataFileName],weights:e.weightSpecs}]),a=window.URL.createObjectURL(new Blob([JSON.stringify(i)],{type:"application/json"})),l=null==r.modelJsonAnchor?document.createElement("a"):r.modelJsonAnchor;if(l.download=r.modelJsonFileName,l.href=a,yield tP(()=>l.dispatchEvent(new MouseEvent("click"))),null!=e.weightData){const u=null==r.weightDataAnchor?document.createElement("a"):r.weightDataAnchor;u.download=r.weightDataFileName,u.href=s,yield tP(()=>u.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:wy(e)}}})()}}return t.URL_SCHEME="downloads://",t})();function nP(t,n,e,r){(function i(l){_(null!=l&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")})(t),function a(l,u){_(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),_(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${u}`),_(u>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${u}`)}(e=e??0,r=r??1);let s=0;return Promise.all(t.map(l=>(l.then(u=>{const c=e+ ++s/t.length*(r-e);return n(c),u}),l)))}function rP(t,n){return k_.apply(this,arguments)}function k_(){return(k_=J(function*(t,n){null==n&&(n={});const e=null==n.fetchFunc?L().platform.fetch:n.fetchFunc,r=t.map(d=>e(d,n.requestInit,{isBinary:!0})),a=(null==n.onProgress?yield Promise.all(r):yield nP(r,n.onProgress,0,.5)).map(d=>d.arrayBuffer());return null==n.onProgress?yield Promise.all(a):yield nP(a,n.onProgress,.5,1)})).apply(this,arguments)}wn.registerSaveRouter(t=>L().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(N_.URL_SCHEME)?function WZ(t="model"){return new N_(t)}(t.slice(N_.URL_SCHEME.length)):null);let sP=(()=>{class t{constructor(e,r){if(this.DEFAULT_METHOD="POST",null==r&&(r={}),this.weightPathPrefix=r.weightPathPrefix,this.onProgress=r.onProgress,this.weightUrlConverter=r.weightUrlConverter,null!=r.fetchFunc?(_("function"==typeof r.fetchFunc,()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=r.fetchFunc):this.fetch=L().platform.fetch,_(null!=e&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&_(2===e.length,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,null!=r.requestInit&&null!=r.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=r.requestInit||{}}save(e){var r=this;return J(function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const s=Object.assign({method:r.DEFAULT_METHOD},r.requestInit);s.body=new FormData;const i=LM(e,[{paths:["./model.weights.bin"],weights:e.weightSpecs}]);s.body.append("model.json",new Blob([JSON.stringify(i)],{type:"application/json"}),"model.json"),null!=e.weightData&&s.body.append("model.weights.bin",new Blob([e.weightData],{type:"application/octet-stream"}),"model.weights.bin");const a=yield r.fetch(r.path,s);if(a.ok)return{modelArtifactsInfo:wy(e),responses:[a]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${a.status}.`)})()}load(){var e=this;return J(function*(){const r=yield e.fetch(e.path,e.requestInit);if(!r.ok)throw new Error(`Request to ${e.path} failed with status code ${r.status}. Please verify this URL points to the model JSON of the model to load.`);let s;try{s=yield r.json()}catch{let l=`Failed to parse model JSON of response from ${e.path}.`;throw e.path.endsWith(".pb")?l+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":l+=" Please make sure the server is serving valid JSON for this request.",new Error(l)}if(null==s.modelTopology&&null==s.weightsManifest)throw new Error(`The JSON from HTTP path ${e.path} contains neither model topology or manifest for weights.`);return VM(s,a=>e.loadWeights(a))})()}loadWeights(e){var r=this;return J(function*(){const s=Array.isArray(r.path)?r.path[1]:r.path,[o,i]=function qZ(t){const n=t.lastIndexOf("/"),e=t.lastIndexOf("?");return[t.substring(0,n)+"/",e>n?t.substring(e):""]}(s),a=r.weightPathPrefix||o,l=function JY(t){const n=[];for(const e of t)n.push(...e.weights);return n}(e),u=[],c=[];for(const h of e)for(const p of h.paths)null!=r.weightUrlConverter?c.push(r.weightUrlConverter(p)):u.push(a+p+i);return r.weightUrlConverter&&u.push(...yield Promise.all(c)),[l,g_(yield rP(u,{requestInit:r.requestInit,fetchFunc:r.fetch,onProgress:r.onProgress}))]})()}}return t.URL_SCHEME_REGEX=/^https?:\/\//,t})();function oP(t){return null!=t.match(sP.URL_SCHEME_REGEX)}const iP=(t,n)=>{if(typeof fetch>"u"&&(null==n||null==n.fetchFunc))return null;{let e=!0;if(e=Array.isArray(t)?t.every(r=>oP(r)):oP(t),e)return aP(t,n)}return null};function aP(t,n){return new sP(t,n)}wn.registerSaveRouter(iP),wn.registerLoadRouter(iP);const F_=-2,ZZ=-1;function M_(t,n,e){const r=t.shape.length;_(r===n.length,()=>`Error in slice${r}D: Length of begin ${n} must match the rank of the array (${r}).`),_(r===e.length,()=>`Error in slice${r}D: Length of size ${e} must match the rank of the array (${r}).`);for(let s=0;s<r;++s)_(n[s]+e[s]<=t.shape[s],()=>`Error in slice${r}D: begin[${s}] + size[${s}] (${n[s]+e[s]}) would overflow input.shape[${s}] (${t.shape[s]})`)}function QZ(t){const n=[];let e=0;for(;t>0;)1&t&&n.push(e),t/=2,e++;return n}function P_(t,n,e){const r=[];for(let s=0;s<t.length;s++)r[s]=Math.ceil((n[s]-t[s])/e[s]);return r}function uP(t,n,e,r){const s=[...t];for(let o=s.length;o<r.length;o++)s.push(1);for(let o=0;o<e;o++)0===o?s[n]=1:(s.splice(n,0,1),s.pop());return s}function cP(t,n,e){return e<=t?e:e-(n-1)}function dP(t,n){const e=[];for(let r=0;r<t;r++)e.push(n+r);return e}function JZ(t,n,e,r,s,o,i,a,l){const u=t.length;let c=new Array(u),d=new Array(u),h=new Array(u);if(n.length&&e>0){const p=n[0],f=e+1;c=hP(i,p,f,r,t),d=pP(a,p,f,s,t),h=uP(o,p,f,t)}else for(let p=0;p<u;p++)c[p]=mP(i,r,o,t,p,l),d[p]=gP(a,s,o,t,p,l),h[p]=fP(o,p,l);return{begin:c,end:d,strides:h}}function hP(t,n,e,r,s){const o=[...s],i=dP(e,n);for(let a=0;a<o.length;a++)if(i.indexOf(a)>-1)o[a]=0;else{const l=cP(n,e,a);let u=r[l];t&1<<l&&(u=0),o[a]=u}return o}function pP(t,n,e,r,s){const o=[...s],i=dP(e,n);for(let a=0;a<o.length;a++)if(i.indexOf(a)>-1)o[a]=Number.MAX_SAFE_INTEGER;else{const l=cP(n,e,a);let u=r[l];t&1<<l&&(u=Number.MAX_SAFE_INTEGER),o[a]=u}for(let a=0;a<o.length;a++)o[a]<0&&(o[a]+=s[a]),o[a]=bl(0,o[a],s[a]);return o}function fP(t,n,e){let r=t[n];return(e&1<<n||null==r)&&(r=1),r}function mP(t,n,e,r,s,o){let i=n[s];(t&1<<s||o&1<<s||null==i)&&(i=(e[s]||1)>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const l=r[s];return i<0&&(i+=l),i=bl(0,i,l-1),i}function gP(t,n,e,r,s,o){let i=n[s];const a=e[s]||1;(t&1<<s||o&1<<s||null==i)&&(i=a>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const l=r[s];return i<0&&(i+=l),i=a>0?bl(0,i,l):bl(-1,i,l-1),i}function O_(t,n,e){let r=e.length;for(let s=0;s<e.length;s++)if(e[s]>1){r=s;break}for(let s=r+1;s<e.length;s++)if(n[s]>0||e[s]!==t[s])return!1;return!0}function $_(t,n){let e=t.length>0?t[t.length-1]:1;for(let r=0;r<t.length-1;r++)e+=t[r]*n[r];return e}function Iy(t,n,e){let r;const s=t.shape.length;let o;return r="number"==typeof n?[n,...new Array(s-1).fill(0)]:n.length<s?n.concat(new Array(s-n.length).fill(0)):n.slice(),r.forEach(i=>{_(-1!==i,()=>"slice() does not support negative begin indexing.")}),o=null==e?new Array(s).fill(-1):"number"==typeof e?[e,...new Array(s-1).fill(-1)]:e.length<s?e.concat(new Array(s-e.length).fill(-1)):e,o=o.map((i,a)=>i>=0?i:(_(-1===i,()=>`Negative size values should be exactly -1 but got ${i} for the slice() size at index ${a}.`),t.shape[a]-r[a])),[r,o]}function L_(t,n,e,r,s,o,i,a,l){let u;if(null==r?(u=new Array(n.length),u.fill(1)):u=r,null!=i&&i&i-1)throw new Error("Multiple ellipses in slice is not allowed.");let c=!1;const d={dims:u.length,numAddAxisAfterEllipsis:0,begin:n.slice(),end:e.slice(),strides:u.slice(),beginMask:s,endMask:o,ellipsisMask:i,newAxisMask:a,shrinkAxisMask:l};for(let v=0;v<d.dims;v++)c&&1<<v&a&&d.numAddAxisAfterEllipsis++,1<<v&i&&(c=!0);c||(d.ellipsisMask|=1<<d.dims,d.dims++);const h={dims:t.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function eQ(t,n){n.beginMask=0,n.endMask=0,n.shrinkAxisMask=0;let e=0;n.beginValid=null!=t.begin,n.endValid=null!=t.end,n.begin=new Array(n.dims),n.end=new Array(n.dims),n.strides=new Array(n.dims),n.finalShapeGatherIndices=[],n.finalShapeGatherIndicesSparse=[],n.inputShapeGatherIndicesSparse=new Array(n.dims);for(let r=0;r<t.dims;r++)if(1<<r&t.ellipsisMask){const s=Math.min(n.dims-(t.dims-r)+1+t.numAddAxisAfterEllipsis,n.dims);for(;e<s;e++)n.begin[e]=0,n.end[e]=0,n.strides[e]=1,n.beginMask|=1<<e,n.endMask|=1<<e,n.finalShapeGatherIndices.push(e),n.finalShapeGatherIndicesSparse.push(-1),n.inputShapeGatherIndicesSparse[e]=r}else if(1<<r&t.newAxisMask)n.finalShapeGatherIndices.push(F_),n.finalShapeGatherIndicesSparse.push(-1);else{if(e===n.begin.length)throw Error(`Index out of range using input dim ${e}; input has only ${n.dims} dims, ${n.begin.length}.`);null!=t.begin&&(n.begin[e]=t.begin[r]),null!=t.end&&(n.end[e]=t.end[r]),n.strides[e]=t.strides[r],t.beginMask&1<<r&&(n.beginMask|=1<<e),t.endMask&1<<r&&(n.endMask|=1<<e),t.shrinkAxisMask&1<<r?(n.finalShapeGatherIndices.push(ZZ),n.finalShapeGatherIndicesSparse.push(-1),n.shrinkAxisMask|=1<<e):(n.finalShapeGatherIndices.push(e),n.finalShapeGatherIndicesSparse.push(r)),n.inputShapeGatherIndicesSparse[e]=r,e++}}(d,h);let p=!0,f=!0,g=!0;const m=[],y=[];for(let v=0;v<t.length;++v){if(0===h.strides[v])throw Error(`strides[${v}] must be non-zero`);const x=!!(h.shrinkAxisMask&1<<v),w=t[v];if(-1===w){m.push(x?1:-1);continue}const C=[h.beginMask&1<<v,h.endMask&1<<v],I=[h.strides[v]>0?0:-1,h.strides[v]>0?w:w-1];if(x&&h.strides[v]<=0)throw Error("only stride 1 allowed on non-range indexing.");g=g&&1===h.strides[v];const D=!!(h.beginMask&1<<v&&h.endMask&1<<v);if(h.beginValid&&h.endValid){if(x){const V=h.begin[v]<0?w+h.begin[v]:h.begin[v];if(h.begin[v]=V,h.end[v]=h.begin[v]+1,V<0||V>=w)throw Error(`slice index ${h.begin[v]} of dimension ${v} out of bounds.`)}else h.begin[v]=yP(h.begin[v],0,h.strides[v],w,C,I),h.end[v]=yP(h.end[v],1,h.strides[v],w,C,I);const P=1===h.strides[v]&&0===h.begin[v]&&h.end[v]===w;p=p&&P,f=f&&(0===v&&1===h.strides[v]||P)}else p=p&&1===h.strides[v]&&D,f=f&&(0===v&&1===h.strides[v]||D);let E,N=!1;if(h.beginValid&&h.endValid?(E=h.end[v]-h.begin[v],N=!0):x?(E=1,N=!0):D&&w>=0&&(E=h.strides[v]<0?-w:w,N=!0),N){let P;P=0===E||E<0!=h.strides[v]<0?0:Math.trunc(E/h.strides[v])+(E%h.strides[v]!=0?1:0),m.push(P)}else m.push(-1)}for(let v=0;v<h.finalShapeGatherIndices.length;++v){const x=h.finalShapeGatherIndices[v];x>=0?y.push(m[x]):x===F_&&y.push(1)}return{finalShapeSparse:y.filter((v,x)=>h.finalShapeGatherIndices[x]!==F_),finalShape:y,isIdentity:p,sliceDim0:f,isSimpleSlice:g,begin:h.begin,end:h.end,strides:h.strides}}function yP(t,n,e,r,s,o){if(s[n])return e>0?o[n]:o[n+1&1];{const i=t<0?r+t:t;return i<o[0]?o[0]:i>o[1]?o[1]:i}}const bP=F({all_:function nQ(t,n=null,e=!1){const s={x:S(t,"x","all","bool")};return R.runKernel("All",s,{axis:n,keepDims:e})}}),V_=F({any_:function rQ(t,n=null,e=!1){const s={x:S(t,"x","any","bool")};return R.runKernel("Any",s,{axis:n,keepDims:e})}}),hp=F({argMax_:function sQ(t,n=0){const r={x:S(t,"x","argMax")};return R.runKernel(ug,r,{axis:n})}});function pp(t,n,e,r,s="NHWC",o){return cr(t,[...n,t[3]],e,o,r,null,null,zi(s))}function so(t,n,e,r,s,o,i="channelsLast"){const[a,l]=fp(n);let u;if("channelsLast"===i)u=[a,l,t[3],t[3]];else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);u=[a,l,t[1],t[1]]}return cr(t,u,e,r,s,o,!1,i)}function Bi(t,n,e,r,s,o,i="NDHWC"){const[a,l,u]=z_(n);let c,d;if("NDHWC"===i)d="channelsLast",c=[a,l,u,t[4],t[4]];else{if("NCDHW"!==i)throw new Error(`Unknown dataFormat ${i}`);d="channelsFirst",c=[a,l,u,t[1],t[1]]}return Ca(t,c,e,r,s,!1,d,o)}function cr(t,n,e,r,s,o,i=!1,a="channelsLast"){let[l,u,c,d]=[-1,-1,-1,-1];if("channelsLast"===a)[l,u,c,d]=t;else{if("channelsFirst"!==a)throw new Error(`Unknown dataFormat ${a}`);[l,d,u,c]=t}const[h,p,,f]=n,[g,m]=fp(e),[y,b]=fp(r),v=hc(h,y),x=hc(p,b),{padInfo:w,outHeight:C,outWidth:I}=function aQ(t,n,e,r,s,o,i,a,l){let u,c,d;if("number"==typeof t){u={top:t,bottom:t,left:t,right:t,type:0===t?"VALID":"NUMBER"};const p=function oQ(t,n,e,r,s){null==r&&(r=B_(t,n,e));const i=t[1];return[mp((t[0]-n+2*r)/e+1,s),mp((i-n+2*r)/e+1,s)]}([n,e],o,r,t,a);c=p[0],d=p[1]}else if("same"===t){c=Math.ceil(n/r),d=Math.ceil(e/s);const h=Math.max(0,(c-1)*r+o-n),p=Math.max(0,(d-1)*s+i-e),f=Math.floor(h/2),g=h-f,m=Math.floor(p/2);u={top:f,bottom:g,left:m,right:p-m,type:"SAME"}}else if("valid"===t)u={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((n-o+1)/r),d=Math.ceil((e-i+1)/s);else{if("object"!=typeof t)throw Error(`Unknown padding parameter: ${t}`);{const h="channelsLast"===l?t[1][0]:t[2][0],p="channelsLast"===l?t[1][1]:t[2][1],f="channelsLast"===l?t[2][0]:t[3][0],g="channelsLast"===l?t[2][1]:t[3][1];u={top:h,bottom:p,left:f,right:g,type:0===h&&0===p&&0===f&&0===g?"VALID":"EXPLICIT"},c=mp((n-o+h+p)/r+1,a),d=mp((e-i+f+g)/s+1,a)}}return{padInfo:u,outHeight:c,outWidth:d}}(s,u,c,g,m,v,x,o,a),D=i?f*d:f;let E;return"channelsFirst"===a?E=[l,D,C,I]:"channelsLast"===a&&(E=[l,C,I,D]),{batchSize:l,dataFormat:a,inHeight:u,inWidth:c,inChannels:d,outHeight:C,outWidth:I,outChannels:D,padInfo:w,strideHeight:g,strideWidth:m,filterHeight:h,filterWidth:p,effectiveFilterHeight:v,effectiveFilterWidth:x,dilationHeight:y,dilationWidth:b,inShape:t,outShape:E,filterShape:n}}function Ca(t,n,e,r,s,o=!1,i="channelsLast",a){let[l,u,c,d,h]=[-1,-1,-1,-1,-1];if("channelsLast"===i)[l,u,c,d,h]=t;else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);[l,h,u,c,d]=t}const[p,f,g,,m]=n,[y,b,v]=z_(e),[x,w,C]=z_(r),I=hc(p,x),D=hc(f,w),E=hc(g,C),{padInfo:N,outDepth:P,outHeight:V,outWidth:B}=function lQ(t,n,e,r,s,o,i,a,l,u,c){let d,h,p,f;if("valid"===t&&(t=0),"number"==typeof t){d={top:t,bottom:t,left:t,right:t,front:t,back:t,type:0===t?"VALID":"NUMBER"};const m=function iQ(t,n,e,r,s,o){null==s&&(s=B_(t,n[0],r[0]));const i=[0,0,0,e];for(let a=0;a<3;a++)t[a]+2*s>=n[a]&&(i[a]=mp((t[a]-n[a]+2*s)/r[a]+1,o));return i}([n,e,r,1],[a,l,u],1,[s,o,i],t,c);h=m[0],p=m[1],f=m[2]}else{if("same"!==t)throw Error(`Unknown padding parameter: ${t}`);{h=Math.ceil(n/s),p=Math.ceil(e/o),f=Math.ceil(r/i);const g=(h-1)*s+a-n,m=(p-1)*o+l-e,y=(f-1)*i+u-r,b=Math.floor(g/2),v=g-b,x=Math.floor(m/2),w=m-x,C=Math.floor(y/2);d={top:x,bottom:w,left:C,right:y-C,front:b,back:v,type:"SAME"}}}return{padInfo:d,outDepth:h,outHeight:p,outWidth:f}}(s,u,c,d,y,b,v,I,D,E,a),z=o?m*h:m;let U;return"channelsFirst"===i?U=[l,z,P,V,B]:"channelsLast"===i&&(U=[l,P,V,B,z]),{batchSize:l,dataFormat:i,inDepth:u,inHeight:c,inWidth:d,inChannels:h,outDepth:P,outHeight:V,outWidth:B,outChannels:z,padInfo:N,strideDepth:y,strideHeight:b,strideWidth:v,filterDepth:p,filterHeight:f,filterWidth:g,effectiveFilterDepth:I,effectiveFilterHeight:D,effectiveFilterWidth:E,dilationDepth:x,dilationHeight:w,dilationWidth:C,inShape:t,outShape:U,filterShape:n}}function B_(t,n,e,r=1){const s=hc(n,r);return Math.floor((t[0]*(e-1)-e+s)/2)}function fp(t){return"number"==typeof t?[t,t,t]:2===t.length?[t[0],t[1],1]:t}function z_(t){return"number"==typeof t?[t,t,t]:t}function hc(t,n){return n<=1?t:t+(t-1)*(n-1)}function mp(t,n){if(!n)return Math.trunc(t);switch(n){case"round":return Math.round(t);case"ceil":return Math.ceil(t);case"floor":return Math.floor(t);default:throw new Error(`Unknown roundingMode ${n}`)}}function _a(t){const[n,e,r]=fp(t);return 1===n&&1===e&&1===r}function vr(t,n){return _a(t)||_a(n)}function Tl(t){return fp(t).every(n=>n>0)}function zi(t){if("NHWC"===t)return"channelsLast";if("NCHW"===t)return"channelsFirst";throw new Error(`Unknown dataFormat ${t}`)}function Hr(t,n,e){if(null!=e){if("string"==typeof n)throw Error(`Error in ${t}: pad must be an integer when using dimRoundingMode ${e} but got pad ${n}.`);if("number"==typeof n)_(Zu(n),()=>`Error in ${t}: pad must be an integer when using dimRoundingMode ${e} but got pad ${n}.`);else{if("object"!=typeof n)throw Error(`Error in ${t}: Unknown padding parameter: ${n}`);n.forEach(r=>{r.forEach(s=>{_(Zu(s),()=>`Error in ${t}: pad must be an integer when using dimRoundingMode ${e} but got pad ${s}.`)})})}}}const M=F({reshape_:function uQ(t,n){const r={x:S(t,"x","reshape","string_or_numeric")};return R.runKernel(Xg,r,{shape:n})}}),U_=F({avgPool_:function cQ(t,n,e,r,s){const o=S(t,"x","avgPool","float32");_(vr(e,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${e} and dilations '1'`);let a=o,l=!1;3===o.rank&&(l=!0,a=M(o,[1,o.shape[0],o.shape[1],o.shape[2]])),_(4===a.rank,()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`),Hr("avgPool",r,s);let d=R.runKernel(dg,{x:a},{filterSize:n,strides:e,pad:r,dimRoundingMode:s});return d=xe(d,o.dtype),l?M(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),hQ=F({avgPool3d_:function dQ(t,n,e,r,s,o="NDHWC"){const i=S(t,"x","avgPool3d","float32");let a=i,l=!1;4===i.rank&&(l=!0,a=M(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),_(5===a.rank,()=>`Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`),_("NDHWC"===o,()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`),_("number"==typeof e&&e>0||Array.isArray(e)&&e[0]>0&&e[1]>0&&e[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${e}'`),Hr("avgPool3d",r,s);let d=R.runKernel(hg,{x:a},{filterSize:n,strides:e,pad:r,dimRoundingMode:s,dataFormat:o});return d=xe(d,a.dtype),l?M(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});function pQ(t){let n;return n=0===t.rank||1===t.rank?M(t,[1,1,1,t.size]):2===t.rank?M(t,[1,1,t.shape[0],t.shape[1]]):3===t.rank?M(t,[1,t.shape[0],t.shape[1],t.shape[2]]):t,n}const Dy=F({batchNorm_:function fQ(t,n,e,r,s,o){null==o&&(o=.001);const i=S(t,"x","batchNorm"),a=S(n,"mean","batchNorm"),l=S(e,"variance","batchNorm");let u,c;null!=s&&(u=S(s,"scale","batchNorm")),null!=r&&(c=S(r,"offset","batchNorm")),_(a.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),_(null==c||a.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),_(null==u||a.rank===u.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const h={x:pQ(i),scale:u,offset:c,mean:a,variance:l},f=R.runKernel(Ig,h,{varianceEpsilon:o});return M(f,i.shape)}}),gQ=F({batchNorm2d_:function mQ(t,n,e,r,s,o){const i=S(t,"x","batchNorm"),a=S(n,"mean","batchNorm"),l=S(e,"variance","batchNorm");let u,c;return null!=s&&(u=S(s,"scale","batchNorm")),null!=r&&(c=S(r,"offset","batchNorm")),_(2===i.rank,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`),_(2===a.rank||1===a.rank,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${a.rank}.`),_(2===l.rank||1===l.rank,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),null!=u&&_(2===u.rank||1===u.rank,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`),null!=c&&_(2===c.rank||1===c.rank,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`),Dy(i,a,l,c,u,o)}}),bQ=F({batchNorm3d_:function yQ(t,n,e,r,s,o){const i=S(t,"x","batchNorm"),a=S(n,"mean","batchNorm"),l=S(e,"variance","batchNorm");let u,c;return null!=s&&(u=S(s,"scale","batchNorm")),null!=r&&(c=S(r,"offset","batchNorm")),_(3===i.rank,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`),_(3===a.rank||1===a.rank,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${a.rank}.`),_(3===l.rank||1===l.rank,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),null!=u&&_(3===u.rank||1===u.rank,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`),null!=c&&_(3===c.rank||1===c.rank,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`),Dy(i,a,l,c,u,o)}}),xQ=F({batchNorm4d_:function vQ(t,n,e,r,s,o){const i=S(t,"x","batchNorm"),a=S(n,"mean","batchNorm"),l=S(e,"variance","batchNorm");let u,c;return null!=s&&(u=S(s,"scale","batchNorm")),null!=r&&(c=S(r,"offset","batchNorm")),_(4===i.rank,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`),_(4===a.rank||1===a.rank,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${a.rank}.`),_(4===l.rank||1===l.rank,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),null!=u&&_(4===u.rank||1===u.rank,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`),null!=c&&_(4===c.rank||1===c.rank,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`),Dy(i,a,l,c,u,o)}}),gp=F({broadcastTo_:function wQ(t,n){let e=S(t,"broadcastTo","x");const r=e.shape;if(Li(n),n.length<e.rank)throw new Error(`broadcastTo(): shape.length=${n.length} < input.rank=${e.rank}.`);if(n.length>e.rank){const u=e.shape.slice();for(;u.length<n.length;)u.unshift(1);e=M(e,u)}const s=e.shape,o=Array.from(n);for(let u=n.length-1;u>=0;u--)if(s[u]===n[u])o[u]=1;else if(1!==e.shape[u])throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${n}].`);return 0===o.map((u,c)=>u>1?c:-1).filter(u=>u>=0).length?Dl(e):R.runKernel(np,{x:e},{reps:o})}}),Os=F({clipByValue_:function CQ(t,n,e){const r=S(t,"x","clipByValue");return _(n<=e,()=>`Error in clip: min (${n}) must be less than or equal to max (${e}).`),n===e?dp(r.shape,n,r.dtype):R.runKernel(bh,{x:r},{clipValueMin:n,clipValueMax:e})}}),Ar=F({concat_:function _Q(t,n=0){_(t.length>=1,()=>"Pass at least one tensor to concat");const e=FM(t,"tensors","concat","string_or_numeric");return"complex64"===e[0].dtype&&e.forEach(o=>{if("complex64"!==o.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${o.dtype}. `)}),1===e.length?Dl(e[0]):R.runKernel(gg,e,{axis:n})}}),IQ=F({concat1d_:function SQ(t){return Ar(t,0)}}),TQ=F({concat2d_:function DQ(t,n){return Ar(t,n)}}),NQ=F({concat3d_:function EQ(t,n){return Ar(t,n)}}),AQ=F({concat4d_:function kQ(t,n){return Ar(t,n)}}),El=F({conv2d_:function RQ(t,n,e,r,s="NHWC",o=[1,1],i){const a=S(t,"x","conv2d","float32"),l=S(n,"filter","conv2d","float32");let u=a,c=!1;3===a.rank&&(c=!0,u=M(a,[1,a.shape[0],a.shape[1],a.shape[2]])),_(4===u.rank,()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`),_(4===l.rank,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),Hr("conv2d",r,i);const d="NHWC"===s?u.shape[3]:u.shape[1];_(d===l.shape[2],()=>`Error in conv2d: depth of input (${d}) must match input depth for filter ${l.shape[2]}.`),_(vr(e,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${o}'`),_(Tl(o),()=>"Error in conv2D: Dilated rates should be larger than 0."),_(Tl(e),()=>"Error in conv2D: Strides should be larger than 0.");const f=R.runKernel(yg,{x:u,filter:l},{strides:e,pad:r,dataFormat:s,dilations:o,dimRoundingMode:i});return c?M(f,[f.shape[1],f.shape[2],f.shape[3]]):f}}),vP=F({conv1d_:function FQ(t,n,e,r,s="NWC",o=1,i){const a=S(t,"x","conv1d"),l=S(n,"filter","conv1d");let u=a,c=!1;2===a.rank&&(c=!0,u=M(a,[1,a.shape[0],a.shape[1]])),_(3===u.rank,()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`),_(3===l.rank,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),Hr("conv1d",r,i),_(u.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`),_(vr(e,o),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${e} and dilation '${o}'`),_(Tl(o),()=>"Error in conv1D: Dilated rates should be larger than 0."),_(Tl(e),()=>"Error in conv1D: Stride should be larger than 0."),_("NWC"===s,()=>`Error in conv1d: got dataFormat of ${s} but only NWC is currently supported.`);const d=M(l,[1,l.shape[0],l.shape[1],l.shape[2]]),h=M(u,[u.shape[0],1,u.shape[1],u.shape[2]]),m=El(h,d,[1,e],r,"NHWC",[1,o],i);return M(m,c?[m.shape[2],m.shape[3]]:[m.shape[0],m.shape[2],m.shape[3]])}}),W_=F({conv2DBackpropInput_:function MQ(t,n,e,r,s,o="NHWC",i){_(t.length===n.rank,()=>`Length of inShape (${t.length}) and rank of dy (${n.rank}) must match`);let a=t,l=n,u=!1;3===n.rank&&(u=!0,l=M(n,[1,n.shape[0],n.shape[1],n.shape[2]]),a=[1,t[0],t[1],t[2]]),_(4===a.length,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`),_(4===l.rank,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),_(4===e.rank,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${e.rank}`);const c="NHWC"===o?a[3]:a[1],d="NHWC"===o?l.shape[3]:l.shape[1];_(c===e.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${e.shape[2]}.`),_(d===e.shape[3],()=>`Error in conv2dDerInput: depth of output (${d}) must match output depth for filter ${e.shape[3]}.`),Hr("conv2dDerInput",s,i);const f=R.runKernel(bg,{dy:l,filter:e},{strides:r,pad:s,dataFormat:o,dimRoundingMode:i,inputShape:a});return u?M(f,[f.shape[1],f.shape[2],f.shape[3]]):f}}),xP=F({conv2dTranspose_:function PQ(t,n,e,r,s,o){const i=S(t,"x","conv2dTranspose"),a=S(n,"filter","conv2dTranspose");return W_(e,i,a,r,s,"NHWC",o)}}),$Q=F({conv3d_:function OQ(t,n,e,r,s="NDHWC",o=[1,1,1]){const i=S(t,"x","conv3d"),a=S(n,"filter","conv3d");let l=i,u=!1;4===i.rank&&(u=!0,l=M(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),_(5===l.rank,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),_(5===a.rank,()=>`Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`),_(l.shape[4]===a.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${a.shape[3]}.`),_(vr(e,o),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${e} and dilations '${o}'`),_("NDHWC"===s,()=>`Error in conv3d: got dataFormat of ${s} but only NDHWC is currently supported.`),_(Tl(o),()=>"Error in conv3D: Dilated rates should be larger than 0."),_(Tl(e),()=>"Error in conv3D: Strides should be larger than 0.");const h=R.runKernel(vg,{x:l,filter:a},{strides:e,pad:r,dataFormat:s,dilations:o});return u?M(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}}),wP=F({conv3DBackpropInput_:function LQ(t,n,e,r,s){_(t.length===n.rank,()=>`Length of inShape (${t.length}) and rank of dy (${n.rank}) must match`);let o=t,i=n,a=!1;4===n.rank&&(a=!0,i=M(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]]),o=[1,t[0],t[1],t[2],t[3]]);const l=o[4],u=i.shape[4];_(5===o.length,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${o.length}.`),_(5===i.rank,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`),_(5===e.rank,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${e.rank}`),_(l===e.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${e.shape[3]}.`),_(u===e.shape[4],()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${e.shape[4]}.`);const h=R.runKernel(w0,{dy:i,filter:e},{pad:s,strides:r,inputShape:o});return a?M(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}}),BQ=F({conv3dTranspose_:function VQ(t,n,e,r,s){const o=S(t,"x","conv3dTranspose"),i=S(n,"filter","conv3dTranspose");return wP(e,o,i,r,s)}}),CP=F({denseBincount_:function zQ(t,n,e,r=!1){const s=S(t,"x","denseBincount"),o=S(n,"weights","denseBincount");return _("int32"===s.dtype,()=>`Error in denseBincount: input dtype must be int32, but got ${s.dtype}`),_(s.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${s.rank}.`),_(e>=0,()=>`size must be non-negative, but got ${e}.`),_(o.size===s.size||0===o.size,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${s.shape}, weights shape: ${o.shape}.`),R.runKernel(S0,{x:s,weights:o},{size:e,binaryOutput:r})}}),Ty=F({depthwiseConv2d_:function UQ(t,n,e,r,s="NHWC",o=[1,1],i){const a=S(t,"x","depthwiseConv2d","float32"),l=S(n,"filter","depthwiseConv2d","float32");let u=a,c=!1;3===a.rank&&(c=!0,u=M(a,[1,a.shape[0],a.shape[1],a.shape[2]])),_(4===u.rank,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`),_(4===l.rank,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);const d="NHWC"===s?u.shape[3]:u.shape[1];_(d===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${d}) must match the inChannels dimension in filter ${l.shape[2]}.`),Hr("depthwiseConv2d",r,i);const f=R.runKernel(wg,{x:u,filter:l},{strides:e,pad:r,dataFormat:s,dilations:o,dimRoundingMode:i});return c?M(f,[f.shape[1],f.shape[2],f.shape[3]]):f}}),Ey=F({elu_:function WQ(t){const e={x:S(t,"x","elu","float32")};return R.runKernel(Ch,e)}}),oi=F({equal_:function GQ(t,n){let e=S(t,"a","equal","string_or_numeric"),r=S(n,"b","equal","string_or_numeric");return[e,r]=Tn(e,r),st(e.shape,r.shape),R.runKernel(_g,{a:e,b:r})}}),oo=F({exp_:function HQ(t){const e={x:S(t,"x","exp")};return R.runKernel(Sh,e)}}),bs=F({expandDims_:function jQ(t,n=0){const e=S(t,"x","expandDims","string_or_numeric");return _(n<=e.rank,()=>"Axis must be <= rank of the tensor"),R.runKernel(Sg,{input:e},{dim:n})}}),No=F({tile_:function qQ(t,n){const e=S(t,"x","tile","string_or_numeric");return _(e.rank===n.length,()=>`Error in transpose: rank of input ${e.rank} must match length of reps ${n}.`),R.runKernel(np,{x:e},{reps:n})}}),_P=F({eye_:function KQ(t,n,e,r="float32"){null==n&&(n=t);const s=vt([t,n],r),o=t<=n?t:n;for(let a=0;a<o;++a)s.set(1,a,a);const i=M(s.toTensor(),[t,n]);if(null==e)return i;if(1===e.length)return No(bs(i,0),[e[0],1,1]);if(2===e.length)return No(bs(bs(i,0),0),[e[0],e[1],1,1]);if(3===e.length)return No(bs(bs(bs(i,0),0),0),[e[0],e[1],e[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${e.length}D.`)}}),Ny=F({floor_:function XQ(t){const e={x:S(t,"x","floor","float32")};return R.runKernel(Dh,e)}}),G_=F({gather_:function YQ(t,n,e=0,r=0){const s=S(t,"x","gather"),o=S(n,"indices","gather","int32");return R.runKernel(Dg,{x:s,indices:o},{axis:e,batchDims:r})}}),$s=F({greater_:function ZQ(t,n){let e=S(t,"a","greater","string_or_numeric"),r=S(n,"b","greater","string_or_numeric");return[e,r]=Tn(e,r),st(e.shape,r.shape),R.runKernel(Tg,{a:e,b:r})}}),Nl=F({greaterEqual_:function QQ(t,n){let e=S(t,"a","greaterEqual","string_or_numeric"),r=S(n,"b","greaterEqual","string_or_numeric");return[e,r]=Tn(e,r),st(e.shape,r.shape),R.runKernel(Eh,{a:e,b:r})}}),H_=F({leakyRelu_:function JQ(t,n=.2){const r={x:S(t,"x","leakyRelu")};return R.runKernel(Eg,r,{alpha:n})}}),ao=F({log_:function eJ(t){const e={x:S(t,"x","log","float32")};return R.runKernel(Fh,e)}}),j_=F({log1p_:function tJ(t){const e={x:S(t,"x","log1p")};return R.runKernel(Mh,e)}}),ko=F({max_:function nJ(t,n=null,e=!1){const s={x:S(t,"x","max")};return R.runKernel(Pg,s,{reductionIndices:n,keepDims:e})}}),Ae=F({sum_:function rJ(t,n=null,e=!1){let r=S(t,"x","sum");return"bool"===r.dtype&&(r=xe(r,"int32")),R.runKernel(ty,{x:r},{axis:n,keepDims:e})}}),SP=F({logSoftmax_:function sJ(t,n=-1){const e=S(t,"logits","logSoftmax");if(-1===n&&(n=e.rank-1),n!==e.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and axis was ${n}`);return Vi((s,o)=>{const a=ko(s,n,!0),l=ke(s,a),u=ke(xe(l,"float32"),ao(Ae(oo(l),n,!0)));return o([u]),{value:u,gradFunc:(d,h)=>{const[p]=h,g=oo(p);return ke(d,k(Ae(d,n,!0),g))}}})(e)}}),Ui=F({logicalAnd_:function oJ(t,n){const e=S(t,"a","logicalAnd","bool"),r=S(n,"b","logicalAnd","bool");return st(e.shape,r.shape),R.runKernel(Ag,{a:e,b:r})}}),zt=F({matMul_:function iJ(t,n,e=!1,r=!1){let s=S(t,"a","matMul"),o=S(n,"b","matMul");return[s,o]=Tn(s,o),R.runKernel(pg,{a:s,b:o},{transposeA:e,transposeB:r})}}),q_=F({maxPool_:function aJ(t,n,e,r,s){const o=S(t,"x","maxPool");let a=o,l=!1;3===o.rank&&(l=!0,a=M(o,[1,o.shape[0],o.shape[1],o.shape[2]])),_(4===a.rank,()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`),_(vr(e,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${e} and dilations '1'`),Hr("maxPool",r,s);const d=R.runKernel(Og,{x:a},{filterSize:n,strides:e,pad:r,dimRoundingMode:s});return l?M(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),uJ=F({maxPool3d_:function lJ(t,n=[1,1,1],e,r,s,o="NDHWC"){const i=S(t,"x","maxPool3d");let a=i,l=!1;4===i.rank&&(l=!0,a=M(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),_(5===a.rank,()=>`Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`),_("NDHWC"===o,()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`),Hr("maxPool3d",r,s);const d=R.runKernel($g,{x:a},{filterSize:n,strides:e,pad:r,dimRoundingMode:s,dataFormat:o});return l?M(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}}),Pn=F({mean_:function cJ(t,n=null,e=!1){const s={x:S(t,"x","mean")};return R.runKernel(Lg,s,{axis:n,keepDims:e})}}),ky=F({min_:function dJ(t,n=null,e=!1){const s={x:S(t,"x","min")};return R.runKernel(Vg,s,{axis:n,keepDims:e})}}),pc=F({minimum_:function hJ(t,n){let e=S(t,"a","minimum"),r=S(n,"b","minimum");return[e,r]=Tn(e,r),"bool"===e.dtype&&(e=xe(e,"int32"),r=xe(r,"int32")),st(e.shape,r.shape),R.runKernel(Oh,{a:e,b:r})}});function K_(t,n){for(let e=0;e<t.length;++e)if(t[t.length-e-1]!==n-1-e)return!1;return!0}function IP(t,n,e){const r=t.length+n.length,s=[];let o=0,i=0;for(let a=0;a<r;a++)-1===e.indexOf(a)?s.push(t[o++]):s.push(n[i++]);return s}function dr(t,n){const e=[],r=t.length;for(let o=0;o<r;o++)-1===n.indexOf(o)&&e.push(t[o]);return[e,n.map(o=>t[o])]}function On(t,n){return IP(t,n.map(r=>1),n)}function xr(t,n,e){_(K_(n,e),()=>`${t} supports only inner-most axes for now. Got axes ${n} and rank-${e} input.`)}function Cn(t,n){if(K_(t,n))return null;const e=[];for(let r=0;r<n;++r)-1===t.indexOf(r)&&e.push(r);return t.forEach(r=>e.push(r)),e}function Sa(t){return t.map((n,e)=>[e,n]).sort((n,e)=>n[1]-e[1]).map(n=>n[0])}function $n(t,n){const e=[];for(let r=n-t;r<n;++r)e.push(r);return e}const X_=F({moments_:function pJ(t,n=null,e=!1){const r=bt(n,(t=S(t,"x","moments")).shape),s=Pn(t,r,e);let o=s.shape;e||(o=On(s.shape,r));const i=rn(ke(xe(t,"float32"),M(s,o)));return{mean:s,variance:Pn(i,r,e)}}}),mn=F({neg_:function fJ(t){const e={x:S(t,"x","neg")};return R.runKernel(zg,e)}}),yp=F({notEqual_:function mJ(t,n){let e=S(t,"a","notEqual","string_or_numeric"),r=S(n,"b","notEqual","string_or_numeric");return[e,r]=Tn(e,r),st(e.shape,r.shape),R.runKernel(Ug,{a:e,b:r})}}),DP=F({oneHot_:function gJ(t,n,e=1,r=0,s="int32"){if(n<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${n}`);const i={indices:S(t,"indices","oneHot","int32")};return R.runKernel(Gg,i,{dtype:s,depth:n,onValue:e,offValue:r})}});function hr(t,n="float32"){if(Li(t),"complex64"===n){const r=hr(t,"float32"),s=hr(t,"float32");return _l(r,s)}const e=kr(G(t),n);return R.makeTensor(e,t,n)}function Ia(t,n="float32"){if(Li(t),"complex64"===n){const r=Ia(t,"float32"),s=hr(t,"float32");return _l(r,s)}const e=l0(G(t),n);return R.makeTensor(e,t,n)}const lo=F({onesLike_:function yJ(t){const e={x:S(t,"x","onesLike")};return R.runKernel(Wg,e)}}),Y_=F({pad_:function bJ(t,n,e=0){const r=S(t,"x","pad");if(0===r.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");return R.runKernel(jg,{x:r},{paddings:n,constantValue:e})}}),Z_=F({prelu_:function vJ(t,n){const e=S(t,"x","prelu"),r=S(n,"alpha","prelu");return R.runKernel(qg,{x:e,alpha:r})}});var Q_=de(340);class J_{constructor(n,e,r,s,o){this.mean=n,this.stdDev=e,this.dtype=r,this.nextVal=NaN,this.truncated=s,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const i=o||Math.random();this.random=Q_.alea(i.toString())}nextValue(){if(!isNaN(this.nextVal)){const s=this.nextVal;return this.nextVal=NaN,s}let n,e,r=!1;for(;!r;){let s,o,i;do{s=2*this.random()-1,o=2*this.random()-1,i=s*s+o*o}while(i>=1||0===i);const a=Math.sqrt(-2*Math.log(i)/i);n=this.mean+this.stdDev*s*a,e=this.mean+this.stdDev*o*a,(!this.truncated||this.isValidTruncated(n))&&(r=!0)}return(!this.truncated||this.isValidTruncated(e))&&(this.nextVal=this.convertValue(e)),this.convertValue(n)}convertValue(n){return null==this.dtype||"float32"===this.dtype?n:Math.round(n)}isValidTruncated(n){return n<=this.upper&&n>=this.lower}}class xJ{constructor(n=0,e=1,r,s){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=n,this.range=e-n,this.dtype=r,null==s&&(s=Math.random()),"number"==typeof s&&(s=s.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${n} - ${e} <= 1 and dtype is not float`);this.random=Q_.alea(s)}convertValue(n){return this.canReturnFloat()?n:Math.round(n)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const IJ=F({randomNormal_:function SJ(t,n=0,e=1,r,s){if(Li(t),null!=r&&"bool"===r)throw new Error(`Unsupported data type ${r}`);const o=new J_(n,e,r,!1,s),i=vt(t,r);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}}),Ay=F({randomUniform_:function DJ(t,n=0,e=1,r="float32",s){Li(t);const o=vt(t,r),i=new xJ(n,e,null,s);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}});function bp(t,n,e=1,r="float32"){if(0===e)throw new Error("Cannot have a step of zero");return R.runKernel(U0,{},{start:t,stop:n,step:e,dtype:r})}const Wi=F({relu_:function TJ(t){const e={x:S(t,"x","relu")};return R.runKernel(zh,e)}}),kl=F({reverse_:function EJ(t,n){const r={x:S(t,"x","reverse")};return R.runKernel(Qg,r,{dims:n})}}),TP=F({selu_:function NJ(t){const e={x:S(t,"x","selu")};return R.runKernel(Hh,e)}}),EP=F({separableConv2d_:function kJ(t,n,e,r,s,o=[1,1],i="NHWC"){const a=S(t,"x","separableConv2d"),l=S(n,"depthwiseFilter","separableConv2d"),u=S(e,"pointwiseFilter","separableConv2d");let c=a,d=!1;if(3===a.rank&&(d=!0,c=M(a,[1,a.shape[0],a.shape[1],a.shape[2]])),"NCHW"===i)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");_(4===c.rank,()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`),_(4===l.rank,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),_(4===u.rank,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),_(1===u.shape[0],()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`),_(1===u.shape[1],()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`);const h=l.shape[2],p=l.shape[3];_(u.shape[2]===h*p,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${h*p}, but got ${u.shape[2]}.`);const f=Ty(c,l,r,s,i,o),m=El(f,u,1,"valid",i);return d?M(m,[m.shape[1],m.shape[2],m.shape[3]]):m}}),fc=F({sigmoid_:function AJ(t){const e={x:S(t,"x","sigmoid","float32")};return R.runKernel(Xh,e)}}),Zt=F({slice_:function RJ(t,n,e){const r=S(t,"x","slice","string_or_numeric");if(0===r.rank)throw new Error("Slicing scalar is not possible");return R.runKernel(ey,{x:r},{begin:n,size:e})}}),tS=F({slice1d_:function FJ(t,n,e){const r=S(t,"x","slice1d");return _(1===r.rank,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),Zt(r,[n],[e])}}),NP=F({slice2d_:function MJ(t,n,e){const r=S(t,"x","slice2d");return _(2===r.rank,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),Zt(r,n,e)}}),nS=F({slice3d_:function PJ(t,n,e){const r=S(t,"x","slice3d");return _(3===r.rank,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),Zt(r,n,e)}}),Ry=F({slice4d_:function OJ(t,n,e){const r=S(t,"x","slice4d");return _(4===r.rank,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),Zt(r,n,e)}}),rS=F({softmax_:function $J(t,n=-1){const e=S(t,"logits","softmax","float32");if(-1===n&&(n=e.rank-1),n!==e.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and dim was ${n}`);return R.runKernel(sy,{logits:e},{dim:n})}}),vp=F({softplus_:function LJ(t){const e={x:S(t,"x","softplus")};return R.runKernel(Yh,e)}}),Ls=F({split_:function VJ(t,n,e=0){const s={x:S(t,"x","split")};return R.runKernel(ry,s,{numOrSizeSplits:n,axis:e})}}),xp=F({squeeze_:function BJ(t,n){const e=S(t,"x","squeeze","string_or_numeric");return M(e,fa(e.shape,n).newShape)}}),Da=F({stack_:function zJ(t,n=0){const e=FM(t,"tensors","stack","string_or_numeric");return _(e.length>=1,()=>"Pass at least one tensor to tf.stack"),e.length>0&&_(n<=e[0].rank,()=>"Axis must be <= rank of the tensor"),R.runKernel(Hg,e,{axis:n})}}),sS=F({tanh_:function UJ(t){const e={x:S(t,"x","tanh","float32")};return R.runKernel(tp,e)}});function vs(t,n){n0(t);const e=lp(t,n);if(1!==e.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return up(t,null,e,n)}const kP=F({truncatedNormal_:function GJ(t,n=0,e=1,r,s){if(Li(t),null!=r&&"bool"===r)throw new Error("Unsupported data type $ { dtype }");const o=new J_(n,e,r,!0,s),i=vt(t,r);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}}),Al=F({unstack_:function HJ(t,n=0){const e=S(t,"x","unstack","string_or_numeric");return _(n>=-e.shape.length&&n<e.shape.length,()=>`Axis = ${n} is not in [-${e.shape.length}, ${e.shape.length})`),R.runKernel(iy,{value:e},{axis:n})}}),jr=F({where_:function qJ(t,n,e){const r=S(n,"a","where"),s=S(e,"b","where"),o=S(t,"condition","where","bool"),i=st(st(o.shape,r.shape),s.shape),a=gp(o,i),l=gp(r,i),u=gp(s,i);return R.runKernel(Jg,{condition:a,t:l,e:u})}}),oS=F({imag_:function KJ(t){const e={input:S(t,"input","imag")};return R.runKernel(P0,e)}}),Fy=F({real_:function XJ(t){const e={input:S(t,"input","real")};return R.runKernel(W0,e)}}),Rt=F({transpose_:function YJ(t,n,e){const r=S(t,"x","transpose");if(null==n&&(n=r.shape.map((i,a)=>a).reverse()),_(r.rank===n.length,()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${n}.`),n.forEach(i=>{_(i>=0&&i<r.rank,()=>`All entries in 'perm' must be between 0 and ${r.rank-1} but got ${n}`)}),r.rank<=1)return r.clone();const s={x:r},o={perm:n};return"complex64"===r.dtype?$(()=>{let i=Fy(r),a=oS(r);return i=R.runKernel(nc,{x:i},o),a=R.runKernel(nc,{x:a},o),e&&(a=mn(a)),_l(i,a)}):R.runKernel(nc,s,o)}}),JJ=F({dropout_:function QJ(t,n,e,r){const s=S(t,"x","dropout");if(_("float32"===s.dtype,()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${s.dtype} tensor instead.`),_(n>=0&&n<1,()=>`rate must be a float in the range [0, 1), but got ${n}.`),0===n)return t instanceof Hn?s.clone():s;const o=function ZJ(t,n){if(null==n)return t.shape.slice();if(Bt(t.shape,n))return n;if(t.shape.length===n.length){const e=[];for(let r=0;r<t.shape.length;r++)e.push(null==n[r]&&null!=t.shape[r]?t.shape[r]:n[r]);return e}return n}(s,e),i=1-n,a=Oe(Ny(ie(Ay(o,0,1,"float32",r),i)),i);return k(s,a)}}),iS=F({fft_:function eee(t){return _("complex64"===t.dtype,()=>`The dtype for tf.spectral.fft() must be complex64 but got ${t.dtype}.`),R.runKernel("FFT",{input:t})}}),aS=F({rfft_:function tee(t,n){_("float32"===t.dtype,()=>`The dtype for rfft() must be real value but got ${t.dtype}`);let e=t.shape[t.shape.length-1];const r=t.size/e;let s;if(null!=n&&n<e){const f=t.shape.map(m=>0),g=t.shape.map(m=>m);g[t.shape.length-1]=n,s=Zt(t,f,g),e=n}else if(null!=n&&n>e){const f=t.shape.map(g=>g);f[t.shape.length-1]=n-e,s=Ar([t,hr(f)],t.shape.length-1),e=n}else s=t;const o=At(s),i=M(_l(s,o),[r,e]),a=iS(i),l=Math.floor(e/2)+1,u=Fy(a),c=oS(a),d=Ls(u,[l,e-l],u.shape.length-1),h=Ls(c,[l,e-l],c.shape.length-1),p=s.shape.slice();return p[s.shape.length-1]=l,M(_l(d[0],h[0]),p)}}),My=F({ifft_:function nee(t){return _("complex64"===t.dtype,()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${t.dtype}.`),R.runKernel(M0,{input:t})}}),AP=F({irfft_:function ree(t){const n=t.shape[t.shape.length-1],e=t.size/n;let r;if(n<=2){const s=M(t,[e,n]);r=My(s)}else{const s=[e,2*(n-1)],o=M(Fy(t),[e,n]),i=M(oS(t),[e,n]),a=kl(Zt(o,[0,1],[e,n-2]),1),l=k(kl(Zt(i,[0,1],[e,n-2]),1),rt(-1)),u=Ar([o,a],1),c=Ar([i,l],1),d=M(_l(u,c),[s[0],s[1]]);r=My(d)}if(r=Fy(r),3===t.rank&&0!==t.shape[0]){const s=r,o=t.shape[0];r=M(r,[o,r.shape[0]/o,r.shape[1]]),s.dispose()}return r}}),lS=F({conv2DBackpropFilter_:function see(t,n,e,r,s,o="NHWC",i){let a=t;3===t.rank&&(a=M(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l=n;3===l.rank&&(l=M(n,[1,n.shape[0],n.shape[1],n.shape[2]])),_(4===a.rank,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`),_(4===l.rank,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),_(4===e.length,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${e}.`);const u="NHWC"===o?a.shape[3]:a.shape[1],c="NHWC"===o?l.shape[3]:l.shape[1];return _(u===e[2],()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${e[2]}.`),_(c===e[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${e[3]}).`),Hr("conv2dDerFilter",s,i),R.runKernel(v0,{x:a,dy:l},{strides:r,pad:s,dataFormat:o,dimRoundingMode:i,filterShape:e})}}),RP=F({relu6_:function oee(t){const e={x:S(t,"x","relu6")};return R.runKernel(Uh,e)}}),wp=F({step_:function iee(t,n=0){const r={x:S(t,"x","step")};return R.runKernel(rp,r,{alpha:n})}});function Py(t,n,e){if(null==e||"linear"===e)return t;if("relu"===e)return k(t,wp(n));throw new Error(`Cannot compute gradient for fused activation ${e}.`)}function Oy(t,n){let e=n;const r=Qn(t.shape,n.shape);return r.length>0&&(e=Ae(e,r)),M(e,t.shape)}function $y(t,n,e,r){if("linear"===n)return t;if("relu"===n)return Wi(t);if("elu"===n)return Ey(t);if("relu6"===n)return RP(t);if("prelu"===n)return Z_(t,e);if("leakyrelu"===n)return H_(t,r);if("sigmoid"===n)return fc(t);throw new Error(`Unknown fused activation ${n}.`)}const Ly=(t,n)=>!(t>0)||"linear"===n,lee=F({fusedConv2d_:function aee({x:t,filter:n,strides:e,pad:r,dataFormat:s="NHWC",dilations:o=[1,1],dimRoundingMode:i,bias:a,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(!1===Ly(R.state.gradientDepth,l=l||"linear")){_("NHWC"===s,()=>`Error in fused conv2d: got dataFormat of ${s} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let C=El(t,n,e,r,s,o,i);return null!=a&&(C=ie(C,a)),$y(C,l,u,c)}const d=S(t,"x","conv2d","float32"),h=S(n,"filter","conv2d","float32");let p=d,f=!1;3===d.rank&&(f=!0,p=M(d,[1,d.shape[0],d.shape[1],d.shape[2]])),_(4===p.rank,()=>`Error in fused conv2d: input must be rank 4, but got rank ${p.rank}.`),_(4===h.rank,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${h.rank}.`),Hr("fused conv2d",r,i);const g="NHWC"===s?p.shape[3]:p.shape[1];_(h.shape[2]===g,()=>`Error in conv2d: depth of input (${g}) must match input depth for filter ${h.shape[2]}.`),_(vr(e,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${o}'`);const m=cr(p.shape,h.shape,e,o,r,i);let y,b;if(null!=a&&(y=S(a,"bias","fused conv2d"),[y]=Tn(y,d),"NHWC"===s?st(m.outShape,y.shape):(_(y.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${y.shape.length}.`),_(0===y.shape.length||y.shape[0]===m.outChannels||1===y.shape[0],()=>`Error in fused conv2d: bias shape (${y.shape}) is not compatible with the number of output channels (${m.outChannels})`))),null!=u){const C=u.shape;if(_(C.length<=1||3===C.length,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${C.length}.`),1===C.length)_(1===C[0]||C[0]===m.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${C}) is not compatible with the number of output channels (${m.outChannels}).`);else if(3===C.length)try{st(C,m.outShape)}catch{throw Error(`Error in fused conv2d: PReLU activation weights (${C}) is not compatible with the output shape of the conv2d (${m.outShape}).`)}b=S(u,"prelu weights","fused conv2d")}const v=(C,I)=>{_("NHWC"===s,()=>`Error in gradient of fused conv2D: got dataFormat of ${s} but only NHWC is currently supported.`);const[D,E,N,P]=I,V=Py(C,N,l);_(_a(o),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${o}'`);const U=[W_(E.shape,V,D,e,r),lS(E,V,D.shape,e,r)];if(null!=P){const j=Oy(P,V);U.push(j)}return U},x={x:p,filter:h,bias:y,preluActivationWeights:b},w={strides:e,pad:r,dataFormat:s,dilations:o,dimRoundingMode:i,activation:l,leakyreluAlpha:c};return null==a?Vi((I,D,E)=>{let N=R.runKernel(cy,x,w);return E([D,I,N]),f&&(N=M(N,[N.shape[1],N.shape[2],N.shape[3]])),{value:N,gradFunc:v}})(p,h):Vi((I,D,E,N)=>{let P=R.runKernel(cy,x,w);return N([D,I,P,E]),f&&(P=M(P,[P.shape[1],P.shape[2],P.shape[3]])),{value:P,gradFunc:v}})(p,h,y)}}),FP=F({depthwiseConv2dNativeBackpropFilter_:function uee(t,n,e,r,s,o=[1,1],i){let a=t;3===t.rank&&(a=M(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l=n;return 3===l.rank&&(l=M(n,[1,n.shape[0],n.shape[1],n.shape[2]])),R.runKernel(D0,{x:a,dy:l},{strides:r,pad:s,dimRoundingMode:i,dilations:o,filterShape:e})}}),MP=F({depthwiseConv2dNativeBackpropInput_:function cee(t,n,e,r,s,o=[1,1],i){let a=n,l=!1;3===n.rank&&(l=!0,a=M(n,[1,n.shape[0],n.shape[1],n.shape[2]]));const d=R.runKernel(T0,{dy:a,filter:e},{strides:r,pad:s,dimRoundingMode:i,dilations:o,inputShape:t});return l?M(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),PP=F({fusedMatMul_:function hee({a:t,b:n,transposeA:e=!1,transposeB:r=!1,bias:s,activation:o="linear",preluActivationWeights:i,leakyreluAlpha:a=.2}){if(!1===Ly(R.state.gradientDepth,o)){let P=zt(t,n,e,r);return null!=s&&(P=ie(P,s)),$y(P,o,i,a)}let l=S(t,"a","fused matMul"),u=S(n,"b","fused matMul");[l,u]=Tn(l,u);const c=e?l.shape[l.rank-2]:l.shape[l.rank-1],d=r?u.shape[u.rank-1]:u.shape[u.rank-2],h=e?l.shape[l.rank-1]:l.shape[l.rank-2],p=r?u.shape[u.rank-2]:u.shape[u.rank-1],f=l.shape.slice(0,-2),g=u.shape.slice(0,-2),m=G(f),y=G(g);_(c===d,()=>`Error in fused matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${l.shape} and ${u.shape} and transposeA=${e} and transposeB=${r} must match.`);const v=st(l.shape.slice(0,-2),u.shape.slice(0,-2)).concat([h,p]),x=M(l,e?[m,c,h]:[m,h,c]),w=M(u,r?[y,p,d]:[y,d,p]);let C,I;null!=s&&(C=S(s,"bias","fused matMul"),[C]=Tn(C,l),st(v,C.shape)),null!=i&&(I=S(i,"prelu weights","fused matMul"));const D=(P,V)=>{const[B,z,U,j]=V,q=Py(M(P,U.shape),U,o);let W,K;return e||r?!e&&r?(W=zt(q,z,!1,!1),K=zt(q,B,!0,!1)):e&&!r?(W=zt(z,q,!1,!0),K=zt(B,q,!1,!1)):(W=zt(z,q,!0,!0),K=zt(q,B,!0,!0)):(W=zt(q,z,!1,!0),K=zt(B,q,!0,!1)),null!=s?[W,K,Oy(j,q)]:[W,K]},E={a:x,b:w,bias:C,preluActivationWeights:I},N={transposeA:e,transposeB:r,activation:o,leakyreluAlpha:a};return null==s?Vi((V,B,z)=>{const U=R.runKernel(uy,E,N);return z([V,B,U]),{value:M(U,v),gradFunc:D}})(x,w):Vi((V,B,z,U)=>{const j=R.runKernel(uy,E,N);return U([V,B,j,z]),{value:M(j,v),gradFunc:D}})(x,w,C)}});function Vy(t,n,e){if(n0(t),null!=n&&2!==n.length)throw new Error("tensor2d() requires shape to have two numbers");const r=lp(t,e);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==n)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return up(t,n,r,e)}const wee=F({cropAndResize_:function xee(t,n,e,r,s="bilinear",o=0){const i=S(t,"image","cropAndResize"),a=S(n,"boxes","cropAndResize","float32"),l=S(e,"boxInd","cropAndResize","int32"),u=a.shape[0];return _(4===i.rank,()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`),_(2===a.rank&&4===a.shape[1],()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${a.shape}.`),_(1===l.rank&&l.shape[0]===u,()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${a.shape}.`),_(2===r.length,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),_(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),_("bilinear"===s||"nearest"===s,()=>`method must be bilinear or nearest, but was ${s}`),R.runKernel(_0,{image:i,boxes:a,boxInd:l},{method:s,extrapolationValue:o,cropSize:r})}}),_ee=F({flipLeftRight_:function Cee(t){const n=S(t,"image","flipLeftRight","float32");return _(4===n.rank,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${n.rank}.`),R.runKernel(F0,{image:n},{})}}),Iee=F({grayscaleToRGB_:function See(t){const n=S(t,"image","grayscaleToRGB"),e=n.rank-1,r=n.shape[e];_(n.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${n.rank}.`),_(1===r,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);const s=new Array(n.rank);return s.fill(1,0,e),s[e]=3,No(n,s)}}),Tee=F({rotateWithOffset_:function Dee(t,n,e=0,r=.5){const s=S(t,"image","rotateWithOffset","float32");return _(4===s.rank,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${s.rank}.`),R.runKernel(s_,{image:s},{radians:n,fillValue:e,center:r})}});function mc(t,n,e,r,s,o){null==r&&(r=.5),null==s&&(s=Number.NEGATIVE_INFINITY),null==o&&(o=0);const i=t.shape[0];return e=Math.min(e,i),_(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),_(2===t.rank,()=>`boxes must be a 2D tensor, but was of rank '${t.rank}'`),_(4===t.shape[1],()=>`boxes must have 4 columns, but 2nd dimension was ${t.shape[1]}`),_(1===n.rank,()=>"scores must be a 1D tensor"),_(n.shape[0]===i,()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${n.shape[0]}`),_(0<=o&&o<=1,()=>`softNmsSigma must be in [0, 1], but was '${o}'`),{maxOutputSize:e,iouThreshold:r,scoreThreshold:s,softNmsSigma:o}}const Nee=F({nonMaxSuppression_:function Eee(t,n,e,r=.5,s=Number.NEGATIVE_INFINITY){const o=S(t,"boxes","nonMaxSuppression","float32"),i=S(n,"scores","nonMaxSuppression","float32"),a=mc(o,i,e,r,s);return R.runKernel(V0,{boxes:o,scores:i},{maxOutputSize:e=a.maxOutputSize,iouThreshold:r=a.iouThreshold,scoreThreshold:s=a.scoreThreshold})}});function kee(t,n,e){const r=function Aee(t,n,e){return function Fee(t,n,e){let r=0,s=t.length,o=0,i=!1;for(;r<s;){o=r+(s-r>>>1);const a=e(n,t[o]);a>0?r=o+1:(s=o,i=!a)}return i?r:-r-1}(t,n,e||Ree)}(t,n,e);t.splice(r<0?-(r+1):r,0,n)}function Ree(t,n){return t>n?1:t<n?-1:0}function uS(t,n,e,r,s){return hS(t,n,e,r,s,0)}function cS(t,n,e,r,s,o){return hS(t,n,e,r,s,0,!1,o,!0)}function dS(t,n,e,r,s,o){return hS(t,n,e,r,s,o,!0)}function hS(t,n,e,r,s,o,i=!1,a=!1,l=!1){const u=[];for(let m=0;m<n.length;m++)n[m]>s&&u.push({score:n[m],boxIndex:m,suppressBeginIndex:0});u.sort(VP);const c=o>0?-.5/o:0,d=[],h=[];for(;d.length<e&&u.length>0;){const m=u.pop(),{score:y,boxIndex:b,suppressBeginIndex:v}=m;if(y<s)break;let x=!1;for(let w=d.length-1;w>=v;--w){const C=Mee(t,b,d[w]);if(C>=r){x=!0;break}if(m.score=m.score*Pee(r,c,C),m.score<=s)break}m.suppressBeginIndex=d.length,x||(m.score===y?(d.push(b),h.push(m.score)):m.score>s&&kee(u,m,VP))}const p=d.length,f=e-p;a&&f>0&&(d.push(...new Array(f).fill(0)),h.push(...new Array(f).fill(0)));const g={selectedIndices:d};return i&&(g.selectedScores=h),l&&(g.validOutputs=p),g}function Mee(t,n,e){const r=t.subarray(4*n,4*n+4),s=t.subarray(4*e,4*e+4),o=Math.min(r[0],r[2]),i=Math.min(r[1],r[3]),a=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),u=Math.min(s[0],s[2]),c=Math.min(s[1],s[3]),d=Math.max(s[0],s[2]),h=Math.max(s[1],s[3]),p=(a-o)*(l-i),f=(d-u)*(h-c);if(p<=0||f<=0)return 0;const g=Math.max(o,u),m=Math.max(i,c),y=Math.min(a,d),b=Math.min(l,h),v=Math.max(y-g,0)*Math.max(b-m,0);return v/(p+f-v)}function Pee(t,n,e){const r=Math.exp(n*e*e);return e<=t?r:0}function VP(t,n){return t.score-n.score||t.score===n.score&&n.boxIndex-t.boxIndex}function pS(){return(pS=J(function*(t,n,e,r=.5,s=Number.NEGATIVE_INFINITY){const o=S(t,"boxes","nonMaxSuppressionAsync"),i=S(n,"scores","nonMaxSuppressionAsync"),a=mc(o,i,e,r,s);e=a.maxOutputSize,r=a.iouThreshold,s=a.scoreThreshold;const l=yield Promise.all([o.data(),i.data()]),u=l[0],c=l[1],{selectedIndices:d}=uS(u,c,e,r,s);return o!==t&&o.dispose(),i!==n&&i.dispose(),vs(d,"int32")})).apply(this,arguments)}const Vee=F({nonMaxSuppressionWithScore_:function Lee(t,n,e,r=.5,s=Number.NEGATIVE_INFINITY,o=0){const i=S(t,"boxes","nonMaxSuppression"),a=S(n,"scores","nonMaxSuppression"),l=mc(i,a,e,r,s,o),d=R.runKernel(z0,{boxes:i,scores:a},{maxOutputSize:e=l.maxOutputSize,iouThreshold:r=l.iouThreshold,scoreThreshold:s=l.scoreThreshold,softNmsSigma:o=l.softNmsSigma});return{selectedIndices:d[0],selectedScores:d[1]}}});function fS(){return(fS=J(function*(t,n,e,r=.5,s=Number.NEGATIVE_INFINITY,o=0){const i=S(t,"boxes","nonMaxSuppressionAsync"),a=S(n,"scores","nonMaxSuppressionAsync"),l=mc(i,a,e,r,s,o);e=l.maxOutputSize,r=l.iouThreshold,s=l.scoreThreshold,o=l.softNmsSigma;const u=yield Promise.all([i.data(),a.data()]),c=u[0],d=u[1],{selectedIndices:h,selectedScores:p}=dS(c,d,e,r,s,o);return i!==t&&i.dispose(),a!==n&&a.dispose(),{selectedIndices:vs(h,"int32"),selectedScores:vs(p)}})).apply(this,arguments)}const Wee=F({nonMaxSuppressionPadded_:function Uee(t,n,e,r=.5,s=Number.NEGATIVE_INFINITY,o=!1){const i=S(t,"boxes","nonMaxSuppression"),a=S(n,"scores","nonMaxSuppression"),l=mc(i,a,e,r,s,null),f=R.runKernel(B0,{boxes:i,scores:a},{maxOutputSize:l.maxOutputSize,iouThreshold:l.iouThreshold,scoreThreshold:l.scoreThreshold,padToMaxOutputSize:o});return{selectedIndices:f[0],validOutputs:f[1]}}});function mS(){return(mS=J(function*(t,n,e,r=.5,s=Number.NEGATIVE_INFINITY,o=!1){const i=S(t,"boxes","nonMaxSuppressionAsync"),a=S(n,"scores","nonMaxSuppressionAsync"),l=mc(i,a,e,r,s,null),u=l.maxOutputSize,c=l.iouThreshold,d=l.scoreThreshold,[h,p]=yield Promise.all([i.data(),a.data()]),{selectedIndices:f,validOutputs:g}=cS(h,p,u,c,d,o);return i!==t&&i.dispose(),a!==n&&a.dispose(),{selectedIndices:vs(f,"int32"),validOutputs:rt(g,"int32")}})).apply(this,arguments)}const BP=F({resizeBilinear_:function jee(t,n,e=!1,r=!1){const s=S(t,"images","resizeBilinear");_(3===s.rank||4===s.rank,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${s.rank}.`),_(2===n.length,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${n}.`),_(!1===r||!1===e,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let o=s,i=!1;3===s.rank&&(i=!0,o=M(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const[]=n,u=R.runKernel(Zg,{images:o},{alignCorners:e,halfPixelCenters:r,size:n});return i?M(u,[u.shape[1],u.shape[2],u.shape[3]]):u}}),zP=F({resizeNearestNeighbor_:function qee(t,n,e=!1,r=!1){const s=S(t,"images","resizeNearestNeighbor");_(3===s.rank||4===s.rank,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${s.rank}.`),_(2===n.length,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${n}.`),_("float32"===s.dtype||"int32"===s.dtype,()=>"`images` must have `int32` or `float32` as dtype"),_(!1===r||!1===e,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let o=s,i=!1;3===s.rank&&(i=!0,o=M(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const[]=n,u=R.runKernel(Yg,{images:o},{alignCorners:e,halfPixelCenters:r,size:n});return i?M(u,[u.shape[1],u.shape[2],u.shape[3]]):u}}),Xee=F({bincount_:function Kee(t,n,e){const r=S(t,"x","bincount"),s=S(n,"weights","bincount");return _("int32"===r.dtype,()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),_(e>=0,()=>`size must be non-negative, but got ${e}.`),_(s.size===r.size||0===s.size,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${s.shape}.`),R.runKernel(y0,{x:r,weights:s},{size:e})}}),gc=F({lessEqual_:function Yee(t,n){let e=S(t,"a","lessEqual","string_or_numeric"),r=S(n,"b","lessEqual","string_or_numeric");return[e,r]=Tn(e,r),st(e.shape,r.shape),R.runKernel(kg,{a:e,b:r})}}),UP=F({round_:function Zee(t){const e={x:S(t,"x","round")};return R.runKernel(Wh,e)}}),ete=F({threshold_:function Qee(t,n="binary",e=!1,r=.5){const s=S(t,"image","threshold"),l=s.shape[0]*s.shape[1];let c,d,h,p,u=k(vs([r]),255);if(_(3===s.rank,()=>`Error in threshold: image must be rank 3,but got rank ${s.rank}.`),_(3===s.shape[2]||1===s.shape[2],()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${s.shape[2]}.`),_("int32"===s.dtype||"float32"===s.dtype,()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${s.dtype}.`),_("otsu"===n||"binary"===n,()=>`Method must be binary or otsu, but was ${n}`),3===s.shape[2]){[c,d,h]=Ls(s,[1,1,1],-1);const m=k(c,.2989),y=k(d,.587),b=k(h,.114);p=ie(ie(m,y),b)}else p=t;"otsu"===n&&(u=function Jee(t,n){let o,i,a,l,u,c,e=vs([-1]),r=vs([0]),s=vs([0]);for(let d=0;d<t.size-1;d++){o=Zt(t,0,d+1),i=Zt(t,d+1),u=Oe(Ae(o),n),c=Oe(Ae(i),n);const h=Ae(k(o,bp(0,o.size)));a=Oe(h,Ae(o));const p=dp(i.shape,o.size),f=ie(bp(0,i.size),p),g=k(i,f);l=Oe(Ae(g),Ae(i));const m=ke(a,l),y=ke(a,l),b=k(u,c);s=k(k(b,m),y);const v=$s(s,r);r=jr(v,s,r),e=jr(v,vs([d]),e)}return e}(Xee(xe(UP(p),"int32"),cp([]),256),l));const f=e?gc(p,u):$s(p,u);return xe(k(f,255),"int32")}}),nte=F({transform_:function tte(t,n,e="nearest",r="constant",s=0,o){const i=S(t,"image","transform","float32"),a=S(n,"transforms","transform","float32");return _(4===i.rank,()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`),_(2===a.rank&&(a.shape[0]===i.shape[0]||1===a.shape[0])&&8===a.shape[1],()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),_(null==o||2===o.length,()=>`Error in transform: outputShape must be [height, width] or null, but got ${o}.`),R.runKernel(n_,{image:i,transforms:a},{interpolation:e,fillMode:r,fillValue:s,outputShape:o})}}),By=F({less_:function rte(t,n){let e=S(t,"a","less","string_or_numeric"),r=S(n,"b","less","string_or_numeric");return[e,r]=Tn(e,r),st(e.shape,r.shape),R.runKernel(Ng,{a:e,b:r})}}),ote=F({bandPart_:function ste(t,n,e){const r=S(t,"a","bandPart");_(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);const s=r.shape,[o,i]=r.shape.slice(-2);let a,l;"number"==typeof n?(_(n%1==0,()=>`bandPart(): numLower must be an integer, got ${n}.`),_(n<=o,()=>`bandPart(): numLower (${n}) must not be greater than the number of rows (${o}).`),a=S(n<0?o:n,"numLower","bandPart")):(_("int32"===n.dtype,()=>"bandPart(): numLower's dtype must be an int32."),a=jr(By(n,0),o,pc(n,o))),"number"==typeof e?(_(e%1==0,()=>`bandPart(): numUpper must be an integer, got ${e}.`),_(e<=i,()=>`bandPart(): numUpper (${e}) must not be greater than the number of columns (${i}).`),l=S(e<0?i:e,"numUpper","bandPart")):(_("int32"===e.dtype,()=>"bandPart(): numUpper's dtype must be an int32."),l=jr(By(e,0),i,pc(e,i)));const u=M(bp(0,o,1,"int32"),[-1,1]),c=bp(0,i,1,"int32"),d=ke(u,c),h=Ui(gc(d,a),Nl(d,mn(l))),p=hr([o,i],r.dtype);return M(Da(Al(M(r,[-1,o,i])).map(f=>jr(h,f,p))),s)}});function WP(t,n,e=null){if(0===t.rank)return ur(t);if(1!==t.rank&&null===e)return WP(M(t,[-1]),n,e);if(1===t.rank||"number"==typeof e||Array.isArray(e)&&1===e.length){if(1===n)return Ae(ur(t),e);if(n===1/0)return ko(ur(t),e);if(n===-1/0)return ky(ur(t),e);if("euclidean"===n||2===n)return Gr(Ae(cc(ur(t),rt(2,"int32")),e));throw new Error(`Error in norm: invalid ord value: ${n}`)}if(Array.isArray(e)&&2===e.length){if(1===n)return ko(Ae(ur(t),e[0]),e[1]-1);if(n===1/0)return ko(Ae(ur(t),e[1]),e[0]);if(n===-1/0)return ky(Ae(ur(t),e[1]),e[0]);if("fro"===n||"euclidean"===n)return Gr(Ae(rn(t),e));throw new Error(`Error in norm: invalid ord value: ${n}`)}throw new Error(`Error in norm: invalid axis: ${e}`)}const zy=F({norm_:function ite(t,n="euclidean",e=null,r=!1){const s=WP(t=S(t,"x","norm"),n,e);let o=s.shape;if(r){const i=bt(e,t.shape);o=On(s.shape,i)}return M(s,o)}}),lte=F({gramSchmidt_:function ate(t){let n;if(Array.isArray(t)){n=!1,_(null!=t&&t.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const s=t[0].shape[0];for(let o=1;o<t.length;++o)_(t[o].shape[0]===s,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${t[o].shape[0]} vs. ${s})`)}else n=!0,t=Ls(t,t.shape[0],0).map(s=>xp(s,[0]));_(t.length<=t[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${t.length}) exceeds number of dimensions (${t[0].shape[0]}).`);const e=[],r=t;for(let s=0;s<t.length;++s)e.push(R.tidy(()=>{let o=r[s];if(s>0)for(let i=0;i<s;++i){const a=k(Ae(k(e[i],o)),e[i]);o=ke(o,a)}return Oe(o,zy(o,"euclidean"))}));return n?Da(e,0):e}});function GP(t,n=!1){return R.tidy(()=>{_(2===t.shape.length,()=>`qr2d() requires a 2D Tensor, but got a ${t.shape.length}D Tensor.`);const e=t.shape[0],r=t.shape[1];let s=_P(e),o=Dl(t);const i=Vy([[1]],[1,1]);let a=Dl(i);const l=e>=r?r:e;for(let u=0;u<l;++u){const c=o,d=a,h=s;[a,o,s]=R.tidy(()=>{const p=Zt(o,[u,u],[e-u,1]),f=zy(p),g=Zt(o,[u,u],[1,1]),m=jr($s(g,0),Vy([[-1]]),Vy([[1]])),y=ke(g,k(m,f)),b=Oe(p,y);a=1===b.shape[0]?Dl(i):Ar([i,Zt(b,[1,0],[b.shape[0]-1,b.shape[1]])],0);const v=mn(Oe(zt(m,y),f)),x=Zt(o,[u,0],[e-u,r]),w=k(v,a),C=Rt(a);if(0===u)o=ke(x,zt(w,zt(C,x)));else{const E=ke(x,zt(w,zt(C,x)));o=Ar([Zt(o,[0,0],[u,r]),E],0)}const I=Rt(w),D=Zt(s,[0,u],[e,s.shape[1]-u]);if(0===u)s=ke(D,zt(zt(D,a),I));else{const E=ke(D,zt(zt(D,a),I));s=Ar([Zt(s,[0,0],[e,u]),E],1)}return[a,o,s]}),ft([c,d,h])}return!n&&e>r&&(s=Zt(s,[0,0],[e,r]),o=Zt(o,[0,0],[r,r])),[s,o]})}const cte=F({qr_:function ute(t,n=!1){if(_(t.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${t.rank}`),2===t.rank)return GP(t,n);{const e=t.shape.slice(0,t.shape.length-2).reduce((l,u)=>l*u),r=Al(M(t,[e,t.shape[t.shape.length-2],t.shape[t.shape.length-1]]),0),s=[],o=[];return r.forEach(l=>{const[u,c]=GP(l,n);s.push(u),o.push(c)}),[M(Da(s,0),t.shape),M(Da(o,0),t.shape)]}}}),HP=F({squaredDifference_:function Cte(t,n){let e=S(t,"a","squaredDifference"),r=S(n,"b","squaredDifference");return[e,r]=Tn(e,r),st(e.shape,r.shape),R.runKernel(Qh,{a:e,b:r},{})}}),jP=F({logSumExp_:function Ete(t,n=null,e=!1){const r=S(t,"x","logSumExp"),s=bt(n,r.shape),o=ko(r,s,!0),i=ke(r,o),a=oo(i),l=Ae(a,s),u=ao(l),c=ie(M(o,u.shape),u);if(e){const d=On(c.shape,s);return M(c,d)}return c}}),Rl={flipLeftRight:_ee,grayscaleToRGB:Iee,resizeNearestNeighbor:zP,resizeBilinear:BP,rotateWithOffset:Tee,cropAndResize:wee,nonMaxSuppression:Nee,nonMaxSuppressionAsync:function Oee(t,n,e){return pS.apply(this,arguments)},nonMaxSuppressionWithScore:Vee,nonMaxSuppressionWithScoreAsync:function Bee(t,n,e){return fS.apply(this,arguments)},nonMaxSuppressionPadded:Wee,nonMaxSuppressionPaddedAsync:function Gee(t,n,e){return mS.apply(this,arguments)},threshold:ete,transform:nte},Kte={bandPart:ote,gramSchmidt:lte,qr:cte},yc=class Xte{static sgd(n){return new E_(n)}static momentum(n,e,r=!1){return new JM(n,e,r)}static rmsprop(n,e=.9,r=0,s=null,o=!1){return new eP(n,e,r,s,o)}static adam(n=.001,e=.9,r=.999,s=null){return new ZM(n,e,r,s)}static adadelta(n=.001,e=.95,r=null){return new XM(n,e,r)}static adamax(n=.002,e=.9,r=.999,s=null,o=0){return new QM(n,e,r,s,o)}static adagrad(n,e=.1){return new YM(n,e)}},Yte=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:t=>t();function qP(){return new Promise(t=>Yte(()=>t()))}function gS(t,n){const e=t[0].length;t.forEach((s,o)=>{_(s.length===e,()=>`Error in concat${e}D: rank of tensors[${o}] must be the same as the rank of the rest (${e})`)}),_(n>=0&&n<e,()=>`Error in concat${e}D: axis must be between 0 and ${e-1}.`);const r=t[0];t.forEach((s,o)=>{for(let i=0;i<e;i++)_(i===n||s[i]===r[i],()=>`Error in concat${e}D: Shape of tensors[${o}] (${s}) does not match the shape of the rest (${r}) along the non-concatenated axis ${o}.`)})}function ii(t,n){const e=t[0].slice();for(let r=1;r<t.length;r++)e[n]+=t[r][n];return e}var uo=(()=>{return(t=uo||(uo={}))[t.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",t[t.VALUE_ROWIDS=1]="VALUE_ROWIDS",t[t.ROW_LENGTHS=2]="ROW_LENGTHS",t[t.ROW_SPLITS=3]="ROW_SPLITS",t[t.ROW_LIMITS=4]="ROW_LIMITS",t[t.ROW_STARTS=5]="ROW_STARTS",uo;var t})();function KP(t,n,e){let r=new Array;if(null==e&&null==n)return r;if(null==n)for(;r.length<t+e.length;)r.push(-1);else r=n.slice();if(null==e)return r;if(t+e.length!==r.length)throw new Error(`rt input.shape and shape=${n} are incompatible: rt input.rank = ${t+e.length}, but shape.rank = ${r.length}`);for(let s=1;s<e.length;++s){const o=e[s],i=r[r.length-e.length+s],a=r[i];if(o>=0)if(a>=0){if(a!==o)throw new Error(`rt input.shape and shape=${n} are incompatible: rt input.shape[${s+t}] = ${o} but shape[${s+t}] = ${a}`)}else r[i]=o}return r}function XP(t){const n={FIRST_DIM_SIZE:uo.FIRST_DIM_SIZE,VALUE_ROWIDS:uo.VALUE_ROWIDS,ROW_LENGTHS:uo.ROW_LENGTHS,ROW_SPLITS:uo.ROW_SPLITS,ROW_LIMITS:uo.ROW_LIMITS,ROW_STARTS:uo.ROW_STARTS},e=[];for(const r of t){if(!(r in n))break;e.push(n[r])}return e}function YP(t){return 0===t.length?0:t[0]===uo.FIRST_DIM_SIZE?t.length-1:t.length}function ZP(t,n){if(null==t||null==n)return;const e=t.length,r=n.length;if(e>=r)throw new Error(`defaultValue.shape=${t} and ragged tensor flatValues.shape=${n}, are incompatible: defaultValue.rank = ${e} must be less than ragged tensor input flatValues.rank = ${r})`);for(let s=0;s<Math.min(e,r-1);++s){const o=t[s],i=n[s+1];if(o>=0&&i>=0&&1!==o&&o!==i)throw new Error(`defaultValue.shape=${t}, and ragged tensor input flatValues.shape=${n} are incompatible: defaultValue.shape[${s-t.length}] = ${o} but ragged tensor input.flatValues.shape[${s-t.length}] = ${i}`)}}const yS=30;function Uy(t){return t<=yS?t:a0(t,Math.floor(Math.sqrt(t)))}function bS(t,n,e){return[e*("number"==typeof t?t:t[0]),n*("number"==typeof t?t:t[1])]}function Cp(t,n,e,r=!0){let s=[];if(r)s=s.concat(n.slice(0)),s.push(t[0]/e),s=s.concat(t.slice(1));else{s=s.concat(t[0]);const o=n.length;for(let i=0;i<o;++i)s=s.concat([t[i+1]/n[i],n[i]]);s=s.concat(t.slice(o+1))}return s}function _p(t,n,e=!0){const r=[];if(e){r.push(n);for(let s=n+1;s<t;++s)s<=2*n?(r.push(s),r.push(s-(n+1))):r.push(s)}else{const s=[],o=[];for(let i=1;i<t;++i)i>=2*n+1||i%2==1?o.push(i):s.push(i);r.push(...s),r.push(0),r.push(...o)}return r}function Sp(t,n,e,r=!0){const s=[];s.push(r?t[0]/e:t[0]*e);for(let o=1;o<t.length;++o)s.push(o<=n.length?r?n[o-1]*t[o]:t[o]/n[o-1]:t[o]);return s}function vS(t,n){const e=[0];for(let r=0;r<n;++r)e.push(t[r][0]);return e}function xS(t,n,e){const r=t.slice(0,1);for(let s=0;s<e;++s)r.push(t[s+1]-n[s][0]-n[s][1]);return r}function wS(t,n){const e=t.shape.length,r=n.shape.length;if(e<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${e}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if("int32"!==n.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${n.dtype}.`);if(n.shape[r-1]>e)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${n.shape[r-1]} vs. ${e}`);if(0===G(t.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${t.shape}.`);const s=n.shape,o=s[s.length-1];let i=1;for(let d=0;d<s.length-1;++d)i*=s[d];const a=t.shape,l=s.slice();l.pop();let u=1;for(let d=o;d<e;++d)u*=a[d],l.push(a[d]);const c=[...Pe(t.shape).map(d=>d/u),1].slice(0,o);return[l,i,u,c]}function QP(t,n,e){const r=n.rank>1?n.shape[n.rank-1]:1,s=n.rank>1?n.rank-1:1,o=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${e.shape}, indices.shape: ${n.shape}, shape: ${t}, sliceDim: ${r}, and batchDim: ${s}.`;if(e.rank<s)throw new Error(o+` update.rank < ${s}. `);if(t.length<r+(e.rank-s))throw new Error(o+` Output shape length < ${r+(e.rank-s)}`);if(e.rank!==s+t.length-r)throw new Error(o+" update.rank != "+(s+t.length-r));for(let i=0;i<s;++i)if(e.shape[i]!==n.shape[i])throw new Error(o+` updates.shape[${i}] (${e.shape[i]}) != indices.shape[${i}] (${n.shape[i]}).`);for(let i=0;i<e.rank-s;++i)if(e.shape[i+s]!==t[i+r])throw new Error(o+` updates.shape[${i+s}] (${e.shape[i+s]}) != shape[${i+s}] (${t[i+s]})`)}function Zte(t,n,e){if(n.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${n.rank}.`);if(t.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${t.rank}.`);if("int32"!==n.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${n.dtype}`);if(e.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${e}`);if(0===e.length){if(0===n.size)throw new Error(`Indices specified for empty output. indices shape: ${n.shape}`);if(0===t.size)throw new Error(`Updates specified for empty output. updates shape: ${t.shape}`)}QP(e,n,t)}function Fl(t,n,e){const r=n.shape.length,s=r>1?n.shape[r-1]:1,o=e.length;let i=1;for(let d=s;d<o;++d)i*=e[d];const a=s<1?1:s;return{sliceRank:s,numUpdates:G(n.shape)/a,sliceSize:i,strides:[...Pe(e.slice(0,s)),1],outputSize:G(e)}}const Wy=1.7580993408473768,Gy=1.0507009873554805,CS=.3275911,_S=.254829592,SS=-.284496736,IS=1.421413741,DS=-1.453152027,TS=1.061405429;function Hi(t,n){if(t.length!==n.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${t.length}, imag: ${n.length}.`);const e=new Float32Array(2*t.length);for(let r=0;r<e.length;r+=2)e[r]=t[r/2],e[r+1]=n[r/2];return e}function JP(t){const n=new Float32Array(t.length/2),e=new Float32Array(t.length/2);for(let r=0;r<t.length;r+=2)n[r/2]=t[r],e[r/2]=t[r+1];return{real:n,imag:e}}function eO(t){const n=Math.ceil(t.length/4),e=new Float32Array(n),r=new Float32Array(n);for(let s=0;s<t.length;s+=4)e[Math.floor(s/4)]=t[s],r[Math.floor(s/4)]=t[s+1];return{real:e,imag:r}}function tO(t){const n=Math.floor(t.length/4),e=new Float32Array(n),r=new Float32Array(n);for(let s=2;s<t.length;s+=4)e[Math.floor(s/4)]=t[s],r[Math.floor(s/4)]=t[s+1];return{real:e,imag:r}}function ES(t,n){return{real:t[2*n],imag:t[2*n+1]}}function nO(t,n,e,r){t[2*r]=n,t[2*r+1]=e}function rO(t,n){const e=new Float32Array(t/2),r=new Float32Array(t/2);for(let s=0;s<Math.ceil(t/2);s++){const o=(n?2:-2)*Math.PI*(s/t);e[s]=Math.cos(o),r[s]=Math.sin(o)}return{real:e,imag:r}}function sO(t,n,e){const r=(e?2:-2)*Math.PI*(t/n);return{real:Math.cos(r),imag:Math.sin(r)}}const NS="->",Qte=/->/g,oO=",",iO="...";function kS(t,n){const e=((t=t.replace(/\s/g,"")).length-t.replace(Qte,"").length)/NS.length;if(e<1)throw new Error("Equations without an arrow are not supported.");if(e>1)throw new Error(`Equation must contain exactly one arrow ("${NS}").`);const[r,s]=t.split(NS);_(-1===r.indexOf(iO),()=>`The ellipsis notation ("${iO}") is not supported yet.`);const o=r.split(oO),i=o.length;if(n!==i)throw new Error(`Expected ${i} input tensors, received ${n}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const a=[];for(let h=0;h<s.length;++h){const p=s[h];if(!o.some(f=>-1!==f.indexOf(p)))throw new Error(`Output subscripts contain the label ${p} not present in the input subscripts.`);-1===a.indexOf(p)&&a.push(p)}for(let h=0;h<r.length;++h){const p=r[h];-1===a.indexOf(p)&&p!==oO&&a.push(p)}const l=new Array(o.length);for(let h=0;h<i;++h){if(new Set(o[h].split("")).size!==o[h].length)throw new Error(`Found duplicate axes in input component ${o[h]}. Support for duplicate axes in input is not implemented yet.`);l[h]=[];for(let p=0;p<o[h].length;++p)l[h].push(a.indexOf(o[h][p]))}const u=a.length,d=[];for(let h=s.length;h<u;++h)d.push(h);return{allDims:a,summedDims:d,idDims:l}}function AS(t,n){let e=new Array(t);e.fill(-1);for(let s=0;s<n.length;++s)e[n[s]]=s;const r=[];for(let s=0;s<t;++s)-1===e[s]&&r.push(s);return e=e.filter(s=>-1!==s),{permutationIndices:e,expandDims:r}}function RS(t,n,e){const r=new Array(t);for(let s=0;s<e.length;++s){const o=e[s].shape;for(let i=0;i<n[s].length;++i)void 0===r[n[s][i]]?r[n[s][i]]=o[i]:_(r[n[s][i]]===o[i],()=>`Expected dimension ${r[n[s][i]]} at axis ${i} of input shaped ${JSON.stringify(o)}, but got dimension ${o[i]}`)}}function FS(t,n){const e=t,r=[];let s=0;0===t.length&&e.push(-1),s=t.length+1;for(let i=0;i<s;++i)r.push([]);const o=[];for(let i=0;i<e.length;++i){const l=Jte(n,e[i]);for(const u of l)-1===o.indexOf(u)&&(r[i].push(u),o.push(u))}return{path:e,steps:r}}function MS(t){return t.every((n,e)=>n===e)}function Jte(t,n){const e=[];for(let r=0;r<t.length;++r)(0===t[r].length||-1!==t[r].indexOf(n)||-1===n)&&e.push(r);return e}function PS(t,n,e=0){let r=[];if("number"==typeof n)_(t.shape[e]%n==0,()=>"Number of splits must evenly divide the axis."),r=new Array(n).fill(t.shape[e]/n);else{_(n.reduce((i,a)=>(-1===a&&(i+=1),i),0)<=1,()=>"There should be only one negative value in split array.");const o=n.indexOf(-1);if(-1!==o){const i=n.reduce((a,l)=>l>0?a+l:a);n[o]=t.shape[e]-i}_(t.shape[e]===n.reduce((i,a)=>i+a),()=>"The sum of sizes must match the size of the axis dimension."),r=n}return r}function aO(t){return`Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ${t}`}function lO(t,n){return`indices(${t}, 0) is invalid: ${n} < 0`}function uO(t,n,e){return`indices(${t}, 0) is invalid: ${n} >= ${e}`}function cO(t,n){return`only one output dimension may be -1, not both ${t} and ${n}`}function dO(t,n){return`size ${t} must be non-negative, not ${n}`}function hO(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function pO(t,n){return`Input to reshape is a SparseTensor with ${G(t)}\n  dense values, but the requested shape requires a multiple of ${G(n)}. inputShape=${t} outputShape= ${n}`}function fO(t,n){return`Input to reshape is a tensor with ${G(t)} dense values, but the requested shape has ${G(n)}. inputShape=${t} outputShape=${n}`}function OS(){return"segment ids must be >= 0"}function mO(){return"segment ids are not increasing"}function gO(t,n){return`Segment id ${t} out of range [0, ${n}), possibly because segmentIds input is not sorted.`}function yO(t,n,e){return`Bad: indices[${t}] == ${n} out of range [0, ${e})`}function bO(t,n){let r,e=!1;for(t<=yS?(r=t,e=!0):r=a0(t,Math.floor(Math.sqrt(t)));!e;)r>n||r===t?e=!0:r=a0(t,r+1);return r}function vO(t,n,e){const r=[],s=t.length;for(let o=0;o<s;o++)r.push(o!==n?t[o]:e);return r}function $S(t,n,e,r){const s=n.shape.length,o=t.shape.length;if(0!==r&&(r<-s||r>s))throw new Error(`Expect batchDims in the range of [-${s}, ${s}], but got ${r}`);if(r<0&&(r+=s),r>o)throw new Error(`batchDims (${r}) must be less than rank(x) (\n    ${o}).`);if(e<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${e}).`);for(let d=0;d<r;++d)if(t.shape[d]!==n.shape[d])throw new Error(`x.shape[${d}]: ${t.shape[d]} should be equal to indices.shape[${d}]: ${n.shape[d]}.`);const i=t.shape[e],a=[];let l=1,u=1,c=1;for(let d=0;d<r;++d)a.push(t.shape[d]),l*=t.shape[d];for(let d=r;d<e;d++)a.push(t.shape[d]),u*=t.shape[d];for(let d=r;d<s;d++)a.push(n.shape[d]);for(let d=e+1;d<o;d++)a.push(t.shape[d]),c*=t.shape[d];return{batchSize:l,sliceSize:c,outerSize:u,dimSize:i,outputShape:a}}function ji(t){try{return t.map(n=>ba(n))}catch(n){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${n}`)}}function xO(t){return t.map(n=>ya(n))}function wO(t,n){const e=[];for(let o=0;o<n.length;o++)n[o]&&e.push(o);const r=vt(t,"int32"),s=vt([e.length,t.length],"int32");for(let o=0;o<e.length;o++){const i=r.indexToLoc(e[o]);s.values.set(i,o*t.length)}return s.toTensor()}!function $Z(){for(const t of OZ)se(t)}();const CO={kernelName:lg,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>k(t,wp(xe(e,"float32"),-1))}}},ene={kernelName:uh,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>{const r=rn(xe(e,"float32")),s=Gr(ke(rt(1),r));return mn(Oe(t,s))}}}},tne={kernelName:ch,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>{const r=Gr(ke(rn(xe(e,"float32")),1));return Oe(t,r)}}}},nne={kernelName:tc,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,r]=n,s=st(e.shape,r.shape);return{a:()=>{let a=t;const l=Qn(e.shape,s);return l.length>0&&(a=Ae(a,l)),M(a,e.shape)},b:()=>{let a=t;const l=Qn(r.shape,s);return l.length>0&&(a=Ae(a,l)),M(a,r.shape)}}}},rne={kernelName:h0,saveAllInputs:!0,gradFunc:(t,n)=>{const e={};return n.forEach((r,s)=>{e[s]=()=>t.clone()}),e}},sne={kernelName:ug,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>At(e)}}},one={kernelName:cg,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>At(e)}}},ine={kernelName:dh,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>Oe(t,Gr(ke(rt(1),rn(xe(e,"float32")))))}}},ane={kernelName:hh,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>{const r=Gr(ie(rt(1),rn(xe(e,"float32"))));return Oe(t,r)}}}},lne={kernelName:mh,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,r]=n,s=st(e.shape,r.shape);return{a:()=>{const a=ie(rn(e),rn(r));let l=k(t,Oe(r,a));const u=Qn(e.shape,s);return u.length>0&&(l=Ae(l,u)),M(l,e.shape)},b:()=>{const a=ie(rn(e),rn(r));let l=mn(k(t,Oe(e,a)));const u=Qn(r.shape,s);return u.length>0&&(l=Ae(l,u)),M(l,r.shape)}}}},une={kernelName:ph,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>Oe(t,ie(rn(xe(e,"float32")),1))}}},cne={kernelName:fh,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>Oe(t,ke(rt(1),rn(xe(e,"float32"))))}}},hne=F({avgPool3dGrad_:function dne(t,n,e,r,s,o){const i=S(t,"dy","avgPool3dGrad"),a=S(n,"input","avgPool3dGrad");let l=i,u=a,c=!1;4===a.rank&&(c=!0,l=M(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),u=M(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),_(5===l.rank,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),_(5===u.rank,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`),Hr("avgPool3dGrad",s,o);const p=R.runKernel(g0,{dy:l,input:u},{filterSize:e,strides:r,pad:s,dimRoundingMode:o});return c?M(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}}),pne={kernelName:hg,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[r]=n,{filterSize:s,strides:o,pad:i,dimRoundingMode:a}=e;return{x:()=>hne(t,r,s,o,i,a)}}},mne=F({avgPoolGrad_:function fne(t,n,e,r,s){const o=S(t,"dy","avgPoolGrad"),i=S(n,"input","avgPoolGrad");_(i.rank===o.rank,()=>`Rank of input (${i.rank}) does not match rank of dy (${o.rank})`);let a=i,l=o,u=!1;3===i.rank&&(u=!0,a=M(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=M(o,[1,o.shape[0],o.shape[1],o.shape[2]])),_(4===l.rank,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),_(4===a.rank,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${a.rank}.`);const h=R.runKernel(m0,{dy:l,input:a},{filterSize:e,strides:r,pad:s});return u?M(h,[h.shape[1],h.shape[2],h.shape[3]]):h}}),gne={kernelName:dg,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[r]=n,{filterSize:s,strides:o,pad:i}=e;return{x:()=>mne(t,r,s,o,i)}}},yne={kernelName:pg,inputsToSave:["a","b"],gradFunc:(t,n,e)=>{const[r,s]=n,{transposeA:o,transposeB:i}=e;return o||i?!o&&i?{a:()=>zt(t,s,!1,!1),b:()=>zt(t,r,!0,!1)}:o&&!i?{a:()=>zt(s,t,!1,!0),b:()=>zt(r,t,!1,!1)}:{a:()=>zt(s,t,!0,!0),b:()=>zt(t,r,!0,!0)}:{a:()=>zt(t,s,!1,!0),b:()=>zt(r,t,!0,!1)}}},LS=F({spaceToBatchND_:function bne(t,n,e){const r=S(t,"x","spaceToBatchND");return _(r.rank>=1+n.length,()=>`input rank ${r.rank} should be > than [blockShape] ${n.length}`),_(e.length===n.length,()=>`paddings.shape[0] ${e.length} must be equal to [blockShape] ${n.length}`),_(r.shape.reduce((i,a,l)=>l>0&&l<=n.length?i&&(a+e[l-1][0]+e[l-1][1])%n[l-1]==0:i,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${e.toString()} must be divisible by blockShapes ${n.toString()}`),R.runKernel(ny,{x:r},{blockShape:n,paddings:e})}}),vne={kernelName:fg,gradFunc:(t,n,e)=>{const{blockShape:r,crops:s}=e;return{x:()=>LS(t,r,s)}}},xne={kernelName:"BroadcastTo",gradFunc:(t,n,e)=>{const s=e.inputShape,o=e.shape,i=Array.from(o);for(let l=s.length-1;l>=0;l--)if(s[l]===o[l])i[l]=1;else if(1!==s[l])throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${o}].`);const a=[];for(let l=0;l<i.length;l++)i[l]>1&&a.push(l);return{x:()=>Ae(t,a,!0)}}},wne={kernelName:gh,gradFunc:t=>({x:()=>t.clone()})},Cne={kernelName:yh,gradFunc:t=>({x:()=>At(t)})},_ne={kernelName:bh,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[r]=n,{clipValueMin:s,clipValueMax:o}=e;return{x:()=>jr(Ui(Nl(r,s),gc(r,o)),t,At(t))}}},Sne={kernelName:mg,inputsToSave:["x"],gradFunc:CO.gradFunc},Ine={kernelName:gg,saveAllInputs:!0,gradFunc:(t,n,e)=>{const r=n.map(l=>l.shape),{axis:s}=e,o=bt(s,n[0].shape)[0],i=r.map(l=>l[o]);return Ls(t,i,o).map(l=>()=>l)}},Dne={kernelName:yg,inputsToSave:["x","filter"],gradFunc:(t,n,e)=>{const[r,s]=n,{dilations:o,strides:i,pad:a,dataFormat:l}=e;return _(_a(o),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${o}'`),{x:()=>W_(r.shape,t,s,i,a,l),filter:()=>lS(r,t,s.shape,i,a,l)}}},Tne={kernelName:bg,inputsToSave:["dy","filter"],gradFunc:(t,n,e)=>{const[r,s]=n,{strides:o,pad:i,dataFormat:a,dimRoundingMode:l}=e;return{dy:()=>El(t,s,o,i,a,1,l),filter:()=>lS(t,r,s.shape,o,i,a,l)}}},Nne=F({conv3DBackpropFilter_:function Ene(t,n,e,r,s){let o=t;4===t.rank&&(o=M(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]));let i=n;return 4===i.rank&&(i=M(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]])),_(5===o.rank,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${o.shape}.`),_(5===i.rank,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`),_(5===e.length,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${e}.`),_(o.shape[4]===e[3],()=>`Error in conv3dDerFilter: depth of input ${o.shape[4]}) must match input depth in filter (${e[3]}.`),_(i.shape[4]===e[4],()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${e[4]}).`),R.runKernel(x0,{x:o,dy:i},{strides:r,pad:s,filterShape:e})}}),kne={kernelName:vg,inputsToSave:["x","filter"],gradFunc:(t,n,e)=>{const{dilations:r,strides:s,pad:o}=e;_(_a(r),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`);const[i,a]=n;return{x:()=>wP(i.shape,t,a,s,o),filter:()=>Nne(i,t,a.shape,s,o)}}},_O=F({sin_:function Ane(t){const e={x:S(t,"x","sin","float32")};return R.runKernel(jh,e)}}),Rne={kernelName:vh,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>k(mn(_O(xe(e,"float32"))),t)}}},SO=F({sinh_:function Fne(t){const e={x:S(t,"x","sinh")};return R.runKernel(qh,e)}}),Mne={kernelName:xh,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>k(SO(xe(e,"float32")),t)}}},IO=F({cumsum_:function Pne(t,n=0,e=!1,r=!1){const o={x:S(t,"x","cumsum")};return R.runKernel(xg,o,{axis:n,exclusive:e,reverse:r})}}),One={kernelName:xg,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[r]=n,{axis:s,exclusive:o,reverse:i}=e;return{x:()=>{const a=Cn([s],r.rank);let l=IO(t,s,o,!i);return null!=a&&(l=Rt(l,a)),l}}}},$ne={kernelName:wg,inputsToSave:["x","filter"],gradFunc:(t,n,e)=>{const{dilations:r,strides:s,pad:o,dimRoundingMode:i}=e,a=r??[1,1];_(_a(a),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);const[l,u]=n;return _(4===l.rank,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),_(4===u.rank,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`),_(l.shape[3]===u.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`),_(vr(s,a),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${s} and dilations '${a}'.`),Hr("depthwiseConv2d",o,i),{x:()=>MP(l.shape,t,u,s,o,a,i),filter:()=>FP(l,t,u.shape,s,o,a,i)}}},Lne={kernelName:Cg,inputsToSave:["x","filter"],gradFunc:(t,n,e)=>{const[r,s]=n,o={x:r,filter:s,dy:t},i={x:r,filter:s,dy:t};return{x:()=>R.runKernel(E0,o,e),filter:()=>R.runKernel(N0,i,e)}}},Vne={kernelName:Ch,outputsToSave:[!0],gradFunc:(t,n)=>{const[e]=n,r={dy:t,y:e};return{x:()=>R.runKernel(k0,r)}}},Bne={kernelName:_h,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n,r=k(oo(mn(rn(e))),2/Math.sqrt(Math.PI));return{x:()=>k(t,r)}}},zne={kernelName:Sh,outputsToSave:[!0],gradFunc:(t,n)=>{const[e]=n;return{x:()=>k(t,e)}}},Une={kernelName:Sg,inputsToSave:["input"],gradFunc:(t,n)=>{const[e]=n;return{input:()=>M(t,e.shape)}}},Wne={kernelName:Ih,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>k(t,oo(e))}}},Gne={kernelName:Dh,gradFunc:t=>({x:()=>At(t)})},Hne={kernelName:Th,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,r]=n,s=st(e.shape,r.shape);return{a:()=>{const a=Oe(t,xe(r,"float32")),l=Qn(e.shape,s);return l.length>0?M(Ae(a,l),e.shape):a},b:()=>{let a=k(t,xe(e,"float32"));const l=Qn(r.shape,s);l.length>0&&(a=M(Ae(a,l),r.shape));const u=rn(r);return mn(Oe(a,xe(u,"float32")))}}}},DO=F({rsqrt_:function jne(t){const e={x:S(t,"x","rsqrt","float32")};return R.runKernel(Gh,e)}}),qne={kernelName:Ig,inputsToSave:["x","mean","variance","scale"],gradFunc:(t,n,e)=>{const{varianceEpsilon:r}=e,[s,o,i,a]=n,l=a??rt(1),u=Qn(o.shape,s.shape),c=[];if(1===o.rank){for(let x=0;x<s.shape.length-1;++x)c.push(s.shape[x]);c.push(1)}const d=ke(s,o),h=k(t,l),p=DO(ie(i,rt(r))),f=k(k(k(p,p),p),rt(-.5));return{x:()=>M(k(k(t,1===o.rank?No(M(p,[1,1,1,o.shape[0]]),c):p),l),s.shape),mean:()=>{let x=k(k(p,rt(-1)),h);return 1===o.rank&&(x=Ae(x,u)),M(x,o.shape)},variance:()=>{let x=k(k(f,d),h);return 1===o.rank&&(x=Ae(x,u)),M(x,o.shape)},scale:()=>{const x=k(d,p);let w=k(t,x);return 1===o.rank&&(w=Ae(w,u)),M(w,o.shape)},offset:()=>{let x=t;return 1===o.rank&&(x=Ae(x,u)),M(x,o.shape)}}}},TO=F({unsortedSegmentSum_:function Kne(t,n,e){const r=S(t,"x","unsortedSegmentSum"),s=S(n,"segmentIds","unsortedSegmentSum","int32");return _(Zu(e),()=>"numSegments must be of dtype int"),R.runKernel(ay,{x:r,segmentIds:s},{numSegments:e})}}),Xne={kernelName:Dg,inputsToSave:["x","indices"],gradFunc:(t,n,e)=>{const[r,s]=n,{axis:o}=e,i=bt(o,r.shape)[0];return{x:()=>{const l=r.shape,u=s.size,c=l.slice(0,i),d=c.length,h=l.slice(o,l.length).slice(1),p=h.length,f=EO(0,d),g=EO(d+1,d+1+p),m=NO([c,[u],h]),y=M(t,m),b=M(s,[u]),v=NO([[d],f,g]),x=Rt(y,v);let w=TO(x,b,r.shape[i]);const C=Sa(v);return w=Rt(w,C),w},indices:()=>s}}};function EO(t,n){const e=[];for(let r=t;r<n;++r)e.push(r);return e}function NO(t){const n=[];for(let e=0;e<t.length;++e)for(let r=0;r<t[e].length;++r)n.push(t[e][r]);return n}const Yne={kernelName:Eh,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,r]=n;return{a:()=>At(e),b:()=>At(r)}}},Zne={kernelName:Nh,gradFunc:t=>({x:()=>xe(t,"float32")})},Qne={kernelName:kh,gradFunc:t=>({x:()=>At(t)})},Jne={kernelName:Ah,gradFunc:t=>({x:()=>At(t)})},ere={kernelName:Rh,gradFunc:t=>({x:()=>At(t)})},tre={kernelName:Eg,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[r]=n,{alpha:s}=e,o=$s(r,0);return{x:()=>jr(o,t,k(t,s))}}},nre={kernelName:Mh,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>Oe(t,ie(e,1))}}},rre={kernelName:Fh,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>Oe(t,xe(e,"float32"))}}},sre={kernelName:"LogSoftmax",inputsToSave:[],outputsToSave:[!0],gradFunc:(t,n,e)=>{const[r]=n,{axis:s}=e;return{logits:()=>{const i=oo(r);return ke(t,k(Ae(t,s,!0),i))}}}},ire=F({localResponseNormalizationBackprop_:function ore(t,n,e,r=5,s=1,o=1,i=.5){return R.runKernel(O0,{x:t,y:n,dy:e},{depthRadius:r,bias:s,alpha:o,beta:i})}}),are={kernelName:Mg,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,n,e)=>{const[r,s]=n,{depthRadius:o,bias:i,alpha:a,beta:l}=e;return{x:()=>ire(r,s,t,o,i,a,l)}}};function kO(t,n,e,r){return n.rank<e.rank&&(n=M(n,On(n.shape,r))),t.rank<e.rank&&(t=M(t,On(t.shape,r))),{x:()=>k(t,xe(oi(e,n),t.dtype))}}const AO={kernelName:Pg,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,n,e)=>{const r=e,{reductionIndices:s}=r,o=n[0],l=kO(t,n[1],o,bt(s,o.shape));return{x:()=>l.x()}}},lre={kernelName:Ph,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,r]=n;return{a:()=>k(t,xe(Nl(e,r),"float32")),b:()=>k(t,xe(By(e,r),"float32"))}}},cre=F({maxPool3dGrad_:function ure(t,n,e,r,s,o,i){const a=S(t,"dy","maxPool3dGrad"),l=S(n,"input","maxPool3dGrad"),u=S(e,"output","maxPool3dGrad");let c=a,d=l,h=u,p=!1;4===l.rank&&(p=!0,c=M(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),d=M(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),h=M(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),_(5===c.rank,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`),_(5===d.rank,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${d.rank}.`),_(5===h.rank,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${h.rank}.`),Hr("maxPool3dGrad",o,i);const m=R.runKernel(L0,{dy:c,input:d,output:h},{filterSize:r,strides:s,pad:o,dimRoundingMode:i});return p?M(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}}),dre={kernelName:$g,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,n,e)=>{const[r,s]=n,{filterSize:o,strides:i,pad:a,dimRoundingMode:l}=e;return{x:()=>cre(t,r,s,o,i,a,l)}}},pre=F({maxPoolGrad_:function hre(t,n,e,r,s,o,i){const a=S(t,"dy","maxPoolGrad"),l=S(n,"input","maxPoolGrad"),u=S(e,"output","maxPoolGrad");return _(l.rank===a.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${a.rank})`),_(4===a.rank,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${a.rank}.`),_(4===l.rank,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),Hr("maxPoolGrad",o,i),R.runKernel($0,{dy:a,input:l,output:u},{filterSize:r,strides:s,pad:o,dimRoundingMode:i})}}),fre={kernelName:Og,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,n,e)=>{const[r,s]=n,{filterSize:o,strides:i,pad:a}=e;return{x:()=>pre(t,r,s,o,i,a)}}},mre={kernelName:Lg,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[r]=n,{axis:s}=e,o=bt(s,r.shape),l=G(dr(r.shape,o)[1]);return{x:()=>{const c=r.shape.slice();o.forEach(p=>{c[p]=1});const d=M(t,c);return Oe(k(d,Ia(r.shape,"float32")),l)}}}},gre={kernelName:Vg,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,n,e)=>{const r=e,{axis:s}=r,[o,i]=n,l=kO(t,i,o,bt(s,o.shape));return{x:()=>l.x()}}},yre={kernelName:Oh,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,r]=n;return{a:()=>k(t,xe(gc(e,r),"float32")),b:()=>k(t,xe($s(e,r),"float32"))}}},bre={kernelName:Bg,inputsToSave:["x"],gradFunc:(t,n,e)=>{const r=n[0],{paddings:s}=e,o=s.map(i=>i[0]);return{x:()=>Zt(t,o,r.shape)}}},vre={kernelName:$h,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,r]=n,s=st(e.shape,r.shape);return{a:()=>{const a=Qn(e.shape,s);return a.length>0?M(Ae(t,a),e.shape):t},b:()=>{const a=k(t,mn(Ny(Oe(e,r)))),l=Qn(r.shape,s);return l.length>0?M(Ae(a,l),r.shape):a}}}},xre={kernelName:Lh,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,r]=n,s=st(e.shape,r.shape);return{a:()=>{const a=k(t,xe(r,"float32")),l=Qn(e.shape,s);return l.length>0?M(Ae(a,l),e.shape):a},b:()=>{const a=k(t,xe(e,"float32")),l=Qn(r.shape,s);return l.length>0?M(Ae(a,l),r.shape):a}}}},wre={kernelName:zg,gradFunc:t=>({x:()=>mn(t)})},Cre={kernelName:Gg,inputsToSave:["indices"],gradFunc:(t,n)=>{const e=n[0];return{indices:()=>hr(e.shape,"float32")}}},_re={kernelName:Wg,gradFunc:t=>({x:()=>At(t)})},Sre={kernelName:Hg,saveAllInputs:!0,gradFunc:(t,n,e)=>{const{axis:r}=e;return Al(t,r).map(o=>()=>o)}},RO={kernelName:jg,inputsToSave:["x"],gradFunc:(t,n,e)=>{const r=n[0],{paddings:s}=e,o=s.map(i=>i[0]);return{x:()=>Zt(t,o,r.shape)}}},Ire={kernelName:Vh,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(t,n)=>{const[e,r,s]=n,o=e,i=r,a=st(o.shape,i.shape);return{a:()=>{const c=xe(i,"float32");let d=k(t,k(c,cc(o,ke(c,rt(1)))));const h=Qn(o.shape,a);return h.length>0&&(d=Ae(d,h)),M(d,o.shape)},b:()=>{const c=$s(o,0),d=jr(c,ao(o),At(o));let h=k(t,k(s,d));const p=Qn(i.shape,a);return p.length>0&&(h=Ae(h,p)),M(h,i.shape)}}}},Dre={kernelName:qg,inputsToSave:["x","alpha"],gradFunc:(t,n)=>{const[e,r]=n,s=$s(e,0);return{x:()=>jr(s,t,k(t,r)),alpha:()=>{let o=jr(s,At(t),k(t,e));const i=Qn(r.shape,t.shape);return i.length>0&&(o=Ae(o,i)),M(o,r.shape)}}}},VS=F({cumprod_:function Tre(t,n=0,e=!1,r=!1){const o={x:S(t,"x","cumprod")};return R.runKernel(C0,o,{axis:n,exclusive:e,reverse:r})}});const kre={kernelName:Kg,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[r]=n,{axis:s}=e;let o=[];return o=null==s?r.shape.map((i,a)=>a):"number"==typeof s?[s]:s,{x:()=>function Nre(t,n,e){const r=t.shape.length,s=r-e.length,o=Cn(e,r);let i=t;null!=o&&(i=Rt(t,o));const a=i.shape.slice(),u=a.splice(r-e.length,e.length).reduce((h,p)=>h*p,1);a.push(u);let d=function Ere(t,n,e){const r=t.shape.slice();r[e]=1;const s=M(n,r),o=VS(t,e,!0,!1),i=VS(t,e,!0,!0),a=k(o,i);return k(s,a)}(i.reshape(a),n,s);if(d=d.reshape(i.shape),null!=o){const h=Sa(o);d=Rt(d,h)}return d}(r,t,o)}}},Are={kernelName:wh,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,r]=n,s=st(e.shape,r.shape);return{a:()=>{const a=Oe(t,xe(r,"float32")),l=Qn(e.shape,s);return l.length>0?M(Ae(a,l),e.shape):a},b:()=>{let a=k(t,xe(e,"float32"));const l=Qn(r.shape,s);l.length>0&&(a=M(Ae(a,l),r.shape));const u=rn(r);return mn(Oe(a,xe(u,"float32")))}}}},Rre={kernelName:Bh,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>Oe(t,mn(rn(e)))}}},Fre={kernelName:Uh,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n,r=k(gc(e,6),wp(e));return{x:()=>k(t,xe(r,"float32"))}}},Mre={kernelName:zh,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>k(t,xe(wp(e),"float32"))}}},Pre={kernelName:Xg,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>M(t,e.shape)}}},Ore={kernelName:Zg,inputsToSave:["images"],gradFunc:(t,n,e)=>{const[r]=n,s={dy:t,images:r};return{images:()=>R.runKernel(H0,s,e)}}},$re={kernelName:Yg,inputsToSave:["images"],gradFunc:(t,n,e)=>{const[r]=n,s={dy:t,images:r};return{images:()=>R.runKernel(G0,s,e)}}},Lre={kernelName:Qg,gradFunc:(t,n,e)=>{const{dims:r}=e,s=bt(r,t.shape);return{x:()=>kl(t,s)}}},Vre={kernelName:Wh,gradFunc:t=>({x:()=>At(t)})},Bre={kernelName:Gh,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>mn(Oe(t,k(cc(e,1.5),2)))}}},BS=F({logicalNot_:function zre(t){const e={x:S(t,"x","logicalNot","bool")};return R.runKernel(Rg,e)}}),Ure={kernelName:Jg,inputsToSave:["condition"],gradFunc:(t,n)=>{const[e]=n;return{condition:()=>xe(At(e),"float32"),t:()=>k(t,xe(e,t.dtype)),e:()=>k(t,xe(BS(e),t.dtype))}}},Wre={kernelName:Hh,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>{const r=$s(e,rt(0)),s=rt(Wy),o=rt(Gy),i=k(t,o),a=k(k(t,s),oo(xe(e,"float32")));return jr(r,i,a)}}}},Gre={kernelName:Xh,outputsToSave:[!0],gradFunc:(t,n)=>{const[e]=n;return{x:()=>k(t,k(e,ke(rt(1),e)))}}},Hre={kernelName:Kh,gradFunc:t=>({x:()=>At(t)})},zS=F({cos_:function jre(t){const e={x:S(t,"x","cos","float32")};return R.runKernel(vh,e)}}),qre={kernelName:jh,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>k(zS(xe(e,"float32")),t)}}},FO=F({cosh_:function Kre(t){const e={x:S(t,"x","cosh","float32")};return R.runKernel(xh,e)}}),Xre={kernelName:qh,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>k(FO(xe(e,"float32")),t)}}},Yre={kernelName:ey,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[r]=n,{begin:s,size:o}=e,i=r.shape,[a,l]=Iy(r,s,o),u=[];for(let c=0;c<t.rank;c++)u.push([a[c],i[c]-a[c]-l[c]]);return{x:()=>Y_(t,u)}}},Zre={kernelName:sy,outputsToSave:[!0],gradFunc:(t,n,e)=>{const[r]=n,{dim:s}=e,i=k(t,r);return{logits:()=>ke(i,k(Ae(i,[s],!0),r))}}},Qre={kernelName:Yh,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>k(t,fc(e))}}},US=F({batchToSpaceND_:function Jre(t,n,e){const r=S(t,"x","batchToSpaceND"),s=n.reduce((a,l)=>a*l);return _(r.rank>=1+n.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${n.length}`),_(e.length===n.length,()=>`crops.length is ${e.length} but should be equal to blockShape.length  ${n.length}`),_(r.shape[0]%s==0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${n.join(" * ")} === ${s}`),R.runKernel(fg,{x:r},{blockShape:n,crops:e})}}),MO={kernelName:ny,gradFunc:(t,n,e)=>{const{blockShape:r,paddings:s}=e;return{x:()=>US(t,r,s)}}},PO={kernelName:ry,gradFunc:(t,n,e)=>{const{axis:r}=e;return{x:()=>Ar(t,r)}}},fse=[CO,ene,tne,nne,rne,sne,one,ine,ane,lne,une,cne,pne,gne,yne,vne,xne,wne,Cne,_ne,Sne,Ine,Tne,Dne,kne,Rne,Mne,One,$ne,Lne,Are,Vne,Bne,zne,Une,Wne,Hne,Gne,qne,Xne,Yne,Zne,Qne,Jne,ere,tre,nre,rre,sre,are,AO,AO,lre,dre,fre,mre,gre,yre,bre,vre,xre,wre,Cre,_re,Sre,RO,RO,Ire,Dre,kre,Rre,Fre,Mre,Pre,Ore,$re,Lre,Vre,Bre,Ure,Wre,Gre,Hre,qre,Xre,Yre,Zre,Qre,MO,MO,PO,PO,{kernelName:Zh,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>Oe(t,k(Gr(xe(e,"float32")),2))}}},{kernelName:Qh,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,r]=n,s=rt(2);return{a:()=>k(t,k(s,ke(e,r))),b:()=>k(t,k(s,ke(r,e)))}}},{kernelName:Y0,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>k(t,k(xe(e,"float32"),2))}}},{kernelName:rp,gradFunc:t=>({x:()=>At(t)})},{kernelName:Jh,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,r]=n,s=st(e.shape,r.shape);return{a:()=>{let a=t;const l=Qn(e.shape,s);return l.length>0&&(a=Ae(a,l)),M(a,e.shape)},b:()=>{let a=t;const l=Qn(r.shape,s);return l.length>0&&(a=Ae(a,l)),M(mn(a),r.shape)}}}},{kernelName:ty,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[r]=n,s=r.shape.slice(),{axis:o}=e;bt(o,r.shape).forEach(u=>{s[u]=1});const a=M(t,s),l=k(a,Ia(r.shape,"float32"));return{x:()=>l}}},{kernelName:ep,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>Oe(t,rn(zS(e)))}}},{kernelName:tp,outputsToSave:[!0],gradFunc:(t,n)=>{const[e]=n;return{x:()=>k(ke(rt(1),rn(e)),t)}}},{kernelName:np,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[r]=n,{reps:s}=e;return{x:()=>{let i=At(r);if(1===r.rank)for(let a=0;a<s[0];++a)i=ie(i,Zt(t,[a*r.shape[0]],[r.shape[0]]));else if(2===r.rank)for(let a=0;a<s[0];++a)for(let l=0;l<s[1];++l)i=ie(i,Zt(t,[a*r.shape[0],l*r.shape[1]],[r.shape[0],r.shape[1]]));else if(3===r.rank)for(let a=0;a<s[0];++a)for(let l=0;l<s[1];++l)for(let u=0;u<s[2];++u)i=ie(i,Zt(t,[a*r.shape[0],l*r.shape[1],u*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else{if(4!==r.rank)throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);for(let a=0;a<s[0];++a)for(let l=0;l<s[1];++l)for(let u=0;u<s[2];++u)for(let c=0;c<s[3];++c)i=ie(i,Zt(t,[a*r.shape[0],l*r.shape[1],u*r.shape[2],c*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]))}return i}}}},{kernelName:nc,gradFunc:(t,n,e)=>{const r=e,{perm:s}=r,o=Sa(s);return{x:()=>Rt(t,o)}}},{kernelName:iy,gradFunc:(t,n,e)=>{const r=e,{axis:s}=r;return{value:()=>Da(t,s)}}},{kernelName:ay,inputsToSave:["segmentIds"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>function hse(t,n){const e=wa(n,At(n)),r=G_(t,e);let s=Nl(n,rt(0,"int32"));const o=r.rank-s.rank;for(let a=0;a<o;++a)s=bs(s,a+1);s=Ui(s,Ia(r.shape,"bool"));const i=At(r);return jr(s,r,i)}(t,e)}}},{kernelName:ly,gradFunc:t=>({x:()=>At(t)})}];for(const t of fse)_Y(t);H().prototype.abs=function(){return this.throwIfDisposed(),ur(this)};const gse=F({acos_:function mse(t){const e={x:S(t,"x","acos")};return R.runKernel(uh,e)}});H().prototype.acos=function(){return this.throwIfDisposed(),gse(this)};const bse=F({acosh_:function yse(t){const e={x:S(t,"x","acosh")};return R.runKernel(ch,e)}});H().prototype.acosh=function(){return this.throwIfDisposed(),bse(this)},H().prototype.add=function(t){return this.throwIfDisposed(),ie(this,t)},H().prototype.all=function(t,n){return this.throwIfDisposed(),bP(this,t,n)},H().prototype.any=function(t,n){return this.throwIfDisposed(),V_(this,t,n)},H().prototype.argMax=function(t){return this.throwIfDisposed(),hp(this,t)};const xse=F({argMin_:function vse(t,n=0){const r={x:S(t,"x","argMin")};return R.runKernel(cg,r,{axis:n})}});H().prototype.argMin=function(t){return this.throwIfDisposed(),xse(this,t)},H().prototype.asScalar=function(){return this.throwIfDisposed(),_(1===this.size,()=>"The array must have only 1 element."),M(this,[])},H().prototype.asType=function(t){return this.throwIfDisposed(),xe(this,t)},H().prototype.as1D=function(){return this.throwIfDisposed(),M(this,[this.size])},H().prototype.as2D=function(t,n){return this.throwIfDisposed(),M(this,[t,n])},H().prototype.as3D=function(t,n,e){return this.throwIfDisposed(),M(this,[t,n,e])},H().prototype.as4D=function(t,n,e,r){return this.throwIfDisposed(),M(this,[t,n,e,r])},H().prototype.as5D=function(t,n,e,r,s){return this.throwIfDisposed(),M(this,[t,n,e,r,s])};const Cse=F({asin_:function wse(t){const e={x:S(t,"x","asin")};return R.runKernel(dh,e)}});H().prototype.asin=function(){return this.throwIfDisposed(),Cse(this)};const Sse=F({asinh_:function _se(t){const e={x:S(t,"x","asinh")};return R.runKernel(hh,e)}});H().prototype.asinh=function(){return this.throwIfDisposed(),Sse(this)};const Dse=F({atan_:function Ise(t){const e={x:S(t,"x","atan")};return R.runKernel(ph,e)}});H().prototype.atan=function(){return this.throwIfDisposed(),Dse(this)};const Ese=F({atan2_:function Tse(t,n){let e=S(t,"a","atan2"),r=S(n,"b","atan2");return[e,r]=Tn(e,r),R.runKernel(mh,{a:e,b:r})}});H().prototype.atan2=function(t){return this.throwIfDisposed(),Ese(this,t)};const kse=F({atanh_:function Nse(t){const e={x:S(t,"x","atanh")};return R.runKernel(fh,e)}});H().prototype.atanh=function(){return this.throwIfDisposed(),kse(this)},H().prototype.avgPool=function(t,n,e,r){return this.throwIfDisposed(),U_(this,t,n,e,r)},H().prototype.batchToSpaceND=function(t,n){return this.throwIfDisposed(),US(this,t,n)},H().prototype.batchNorm=function(t,n,e,r,s){return this.throwIfDisposed(),Dy(this,t,n,e,r,s)},H().prototype.broadcastTo=function(t){return this.throwIfDisposed(),gp(this,t)},H().prototype.cast=function(t){return this.throwIfDisposed(),xe(this,t)};const Rse=F({ceil_:function Ase(t){const e={x:S(t,"x","ceil","float32")};return R.runKernel(yh,e)}});H().prototype.ceil=function(){return this.throwIfDisposed(),Rse(this)},H().prototype.clipByValue=function(t,n){return this.throwIfDisposed(),Os(this,t,n)},H().prototype.concat=function(t,n){return this.throwIfDisposed(),t instanceof Hn&&(t=[t]),Ar([this,...t],n)},H().prototype.conv1d=function(t,n,e,r,s,o){return this.throwIfDisposed(),vP(this,t,n,e,r,s,o)},H().prototype.conv2dTranspose=function(t,n,e,r,s){return this.throwIfDisposed(),xP(this,t,n,e,r,s)},H().prototype.conv2d=function(t,n,e,r,s,o){return this.throwIfDisposed(),El(this,t,n,e,r,s,o)},H().prototype.cos=function(){return this.throwIfDisposed(),zS(this)},H().prototype.cosh=function(){return this.throwIfDisposed(),FO(this)},H().prototype.cumprod=function(t,n,e){return this.throwIfDisposed(),VS(this,t,n,e)},H().prototype.cumsum=function(t,n,e){return this.throwIfDisposed(),IO(this,t,n,e)};const Mse=F({depthToSpace_:function Fse(t,n,e="NHWC"){const r=S(t,"x","depthToSpace","float32"),s="NHWC"===e?r.shape[1]:r.shape[2],o="NHWC"===e?r.shape[2]:r.shape[3],i="NHWC"===e?r.shape[3]:r.shape[1];return _(n>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${n}`),_(s*n>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${s} and ${n}  for depthToSpace with input shape\n    ${r.shape}`),_(o*n>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${o} and ${n} for depthToSpace with input shape\n        ${r.shape}`),_(i%(n*n)==0,()=>`Dimension size must be evenly divisible by ${n*n} but is ${i} for depthToSpace with input shape ${r.shape}`),R.runKernel(I0,{x:r},{blockSize:n,dataFormat:e})}});H().prototype.depthToSpace=function(t,n){return this.throwIfDisposed(),Mse(this,t,n)},H().prototype.depthwiseConv2d=function(t,n,e,r,s,o){return this.throwIfDisposed(),Ty(this,t,n,e,r,s,o)};const Ose=F({dilation2d_:function Pse(t,n,e,r,s=[1,1],o="NHWC"){const i=S(t,"x","dilation2d"),a=S(n,"filter","dilation2d");_(3===i.rank||4===i.rank,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`),_(3===a.rank,()=>`Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`),_("NHWC"===o,()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${o}`);let l=i,u=!1;3===i.rank&&(l=M(i,[1,i.shape[0],i.shape[1],i.shape[2]]),u=!0),_(l.shape[3]===a.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${a.shape[2]}`);const h=R.runKernel(Cg,{x:l,filter:a},{strides:e,pad:r,dilations:s});return u?M(h,[h.shape[1],h.shape[2],h.shape[3]]):h}});H().prototype.dilation2d=function(t,n,e,r,s){return this.throwIfDisposed(),Ose(this,t,n,e,r,s)};const Lse=F({divNoNan_:function $se(t,n){let e=S(t,"a","div"),r=S(n,"b","div");[e,r]=Tn(e,r);const s=Oe(e,r),o=At(s),i=oi(r,o);return jr(i,o,s)}});H().prototype.divNoNan=function(t){return this.throwIfDisposed(),Lse(this,t)},H().prototype.div=function(t){return this.throwIfDisposed(),Oe(this,t)};const Bse=F({dot_:function Vse(t,n){const e=S(t,"t1","dot"),r=S(n,"t2","dot");_(!(1!==e.rank&&2!==e.rank||1!==r.rank&&2!==r.rank),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${e.rank} and ${r.rank}.`);const s=1===e.rank?e.size:e.shape[1],o=1===r.rank?r.size:r.shape[0];if(_(s===o,()=>`Error in dot: inner dimensions of inputs must match, but got ${s} and ${o}.`),1===e.rank&&1===r.rank){const i=M(e,[1,-1]),a=M(r,[-1,1]),l=zt(i,a);return M(l,[])}if(1===e.rank&&2===r.rank){const i=M(e,[1,-1]),a=M(r,[r.shape[0],r.shape[1]]),l=zt(i,a);return M(l,[l.size])}if(2===e.rank&&1===r.rank){const i=M(r,[-1,1]),a=zt(e,i);return M(a,[a.size])}{const i=M(r,[r.shape[0],r.shape[1]]);return zt(e,i)}}});H().prototype.dot=function(t){return this.throwIfDisposed(),Bse(this,t)},H().prototype.elu=function(){return this.throwIfDisposed(),Ey(this)},H().prototype.equal=function(t){return this.throwIfDisposed(),oi(this,t)};const Use=F({erf_:function zse(t){let n=S(t,"x","erf");return _("int32"===n.dtype||"float32"===n.dtype,()=>"Input dtype must be `int32` or `float32`."),"int32"===n.dtype&&(n=xe(n,"float32")),R.runKernel(_h,{x:n})}});H().prototype.erf=function(){return this.throwIfDisposed(),Use(this)};const Gse=F({euclideanNorm_:function Wse(t,n=null,e=!1){return zy(t,"euclidean",n,e)}});H().prototype.euclideanNorm=function(t,n){return this.throwIfDisposed(),Gse(this,t,n)},H().prototype.exp=function(){return this.throwIfDisposed(),oo(this)},H().prototype.expandDims=function(t){return this.throwIfDisposed(),bs(this,t)};const jse=F({expm1_:function Hse(t){const e={x:S(t,"x","expm1")};return R.runKernel(Ih,e)}});H().prototype.expm1=function(){return this.throwIfDisposed(),jse(this)},H().prototype.fft=function(){return this.throwIfDisposed(),iS(this)},H().prototype.flatten=function(){return this.throwIfDisposed(),M(this,[this.size])},H().prototype.floor=function(){return this.throwIfDisposed(),Ny(this)},H().prototype.floorDiv=function(t){return this.throwIfDisposed(),KM(this,t)},H().prototype.gather=function(t,n,e){return this.throwIfDisposed(),G_(this,t,n,e)},H().prototype.greaterEqual=function(t){return this.throwIfDisposed(),Nl(this,t)},H().prototype.greater=function(t){return this.throwIfDisposed(),$s(this,t)},H().prototype.ifft=function(){return this.throwIfDisposed(),My(this)},H().prototype.irfft=function(){return this.throwIfDisposed(),AP(this)};const Kse=F({isFinite_:function qse(t){const e={x:S(t,"x","isFinite")};return R.runKernel(kh,e)}});H().prototype.isFinite=function(){return this.throwIfDisposed(),Kse(this)};const Yse=F({isInf_:function Xse(t){const e={x:S(t,"x","isInf")};return R.runKernel(Ah,e)}});H().prototype.isInf=function(){return this.throwIfDisposed(),Yse(this)};const Qse=F({isNaN_:function Zse(t){const e={x:S(t,"x","isNaN")};return R.runKernel(Rh,e)}});H().prototype.isNaN=function(){return this.throwIfDisposed(),Qse(this)},H().prototype.leakyRelu=function(t){return this.throwIfDisposed(),H_(this,t)},H().prototype.lessEqual=function(t){return this.throwIfDisposed(),gc(this,t)},H().prototype.less=function(t){return this.throwIfDisposed(),By(this,t)};const eoe=F({localResponseNormalization_:function Jse(t,n=5,e=1,r=1,s=.5){const o=S(t,"x","localResponseNormalization");_(4===o.rank||3===o.rank,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${o.rank}.`),_(Zu(n),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${n}.`);let i=o,a=!1;3===o.rank&&(a=!0,i=M(o,[1,o.shape[0],o.shape[1],o.shape[2]]));const c=R.runKernel(Mg,{x:i},{depthRadius:n,bias:e,alpha:r,beta:s});return a?M(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});H().prototype.localResponseNormalization=function(t,n,e,r){return this.throwIfDisposed(),eoe(this,t,n,e,r)};const noe=F({logSigmoid_:function toe(t){const n=S(t,"x","logSigmoid");return Vi(r=>({value:mn(vp(mn(r))),gradFunc:i=>k(i,fc(mn(r)))}))(n)}});H().prototype.logSigmoid=function(){return this.throwIfDisposed(),noe(this)},H().prototype.logSoftmax=function(t){return this.throwIfDisposed(),SP(this,t)},H().prototype.logSumExp=function(t,n){return this.throwIfDisposed(),jP(this,t,n)},H().prototype.log=function(){return this.throwIfDisposed(),ao(this)},H().prototype.log1p=function(){return this.throwIfDisposed(),j_(this)},H().prototype.logicalAnd=function(t){return this.throwIfDisposed(),Ui(this,t)},H().prototype.logicalNot=function(){return this.throwIfDisposed(),BS(this)};const OO=F({logicalOr_:function roe(t,n){const e=S(t,"a","logicalOr","bool"),r=S(n,"b","logicalOr","bool");return st(e.shape,r.shape),R.runKernel(Fg,{a:e,b:r})}});H().prototype.logicalOr=function(t){return this.throwIfDisposed(),OO(this,t)};const ooe=F({logicalXor_:function soe(t,n){const e=S(t,"a","logicalXor","bool"),r=S(n,"b","logicalXor","bool");return st(e.shape,r.shape),Ui(OO(t,n),BS(Ui(t,n)))}});H().prototype.logicalXor=function(t){return this.throwIfDisposed(),ooe(this,t)},H().prototype.matMul=function(t,n,e){return this.throwIfDisposed(),zt(this,t,n,e)},H().prototype.maxPool=function(t,n,e,r){return this.throwIfDisposed(),q_(this,t,n,e,r)},H().prototype.max=function(t,n){return this.throwIfDisposed(),ko(this,t,n)},H().prototype.maximum=function(t){return this.throwIfDisposed(),wa(this,t)},H().prototype.mean=function(t,n){return this.throwIfDisposed(),Pn(this,t,n)},H().prototype.min=function(t,n){return this.throwIfDisposed(),ky(this,t,n)},H().prototype.minimum=function(t){return this.throwIfDisposed(),pc(this,t)};const aoe=F({mirrorPad_:function ioe(t,n,e){_("reflect"===e||"symmetric"===e,()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${e}.`);const r=S(t,"x","mirrorPad");if(0===r.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");_(n.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${n.length}.`);const s="reflect"===e?1:0;for(let a=0;a<r.rank;a++)_(2===n[a].length,()=>"Invalid number of paddings. Must be length of 2 each."),_(n[a][0]>=0&&n[a][0]<=r.shape[a]-s&&n[a][1]>=0&&n[a][1]<=r.shape[a]-s,()=>`Padding in dimension ${a} cannot be greater than or equal to ${r.shape[a]-s} or less than 0 for input of shape ${r.shape}`);return R.runKernel(Bg,{x:r},{paddings:n,mode:e})}});H().prototype.mirrorPad=function(t,n){return this.throwIfDisposed(),aoe(this,t,n)};const uoe=F({mod_:function loe(t,n){let e=S(t,"a","mod"),r=S(n,"b","mod");return[e,r]=Tn(e,r),R.runKernel($h,{a:e,b:r})}});H().prototype.mod=function(t){return this.throwIfDisposed(),uoe(this,t)},H().prototype.mul=function(t){return this.throwIfDisposed(),k(this,t)},H().prototype.neg=function(){return this.throwIfDisposed(),mn(this)},H().prototype.norm=function(t,n,e){return this.throwIfDisposed(),zy(this,t,n,e)},H().prototype.notEqual=function(t){return this.throwIfDisposed(),yp(this,t)},H().prototype.oneHot=function(t,n=1,e=0){return this.throwIfDisposed(),DP(this,t,n,e)},H().prototype.onesLike=function(){return this.throwIfDisposed(),lo(this)},H().prototype.pad=function(t,n){return this.throwIfDisposed(),Y_(this,t,n)};const poe=F({pool_:function coe(t,n,e,r,s,o,i){null==s&&(s=[1,1]),null==o&&(o=1),0===r&&(r="valid");const a=S(t,"x","maxPool");let l=a,u=!1;3===a.rank&&(u=!0,l=M(a,[1,a.shape[0],a.shape[1],a.shape[2]])),_(vr(o,s),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${o} and dilations '${s}'`);const c=so(l.shape,n,o,s,r),d=[c.dilationHeight,c.dilationWidth];let h;h="same"===r?function hoe(t,n){const r=t.map((i,a)=>i+(i-1)*(n[a]-1)).map(i=>i-1),s=r.map(i=>Math.floor(i/2)),o=r.map((i,a)=>i-s[a]);return r.map((i,a)=>[s[a],o[a]])}([c.filterHeight,c.filterWidth],d):[[0,0],[0,0]];const p=1===d[0]&&1===d[1],[f,g]=function doe(t,n,e){const r=e.map(c=>c[0]),s=e.map(c=>c[1]),o=t.concat(r,s),i=n.map((c,d)=>(c-o[d]%c)%c),a=s.map((c,d)=>c+i[d]),l=n.map((c,d)=>[r[d],a[d]]),u=n.map((c,d)=>[0,i[d]]);return[l,u]}([c.inHeight,c.inWidth],d,h),m=p?r:"valid",y=p?l:LS(l,d,f),v=("avg"===e?()=>U_(y,n,o,m,i):()=>q_(y,n,o,m,i))(),x=p?v:US(v,d,g);return u?M(x,[x.shape[1],x.shape[2],x.shape[3]]):x}});H().prototype.pool=function(t,n,e,r,s,o){return this.throwIfDisposed(),poe(this,t,n,e,r,s,o)},H().prototype.pow=function(t){return this.throwIfDisposed(),cc(this,t)},H().prototype.prelu=function(t){return this.throwIfDisposed(),Z_(this,t)};const moe=F({prod_:function foe(t,n=null,e=!1){let r=S(t,"x","prod");return"bool"===r.dtype&&(r=xe(r,"int32")),R.runKernel(Kg,{x:r},{axis:n,keepDims:e})}});H().prototype.prod=function(t,n){return this.throwIfDisposed(),moe(this,t,n)};const yoe=F({reciprocal_:function goe(t){const e={x:S(t,"x","reciprocal")};return R.runKernel(Bh,e)}});H().prototype.reciprocal=function(){return this.throwIfDisposed(),yoe(this)},H().prototype.relu=function(){return this.throwIfDisposed(),Wi(this)},H().prototype.relu6=function(){return this.throwIfDisposed(),RP(this)},H().prototype.reshapeAs=function(t){return this.throwIfDisposed(),M(this,t.shape)},H().prototype.reshape=function(t){return this.throwIfDisposed(),M(this,t)},H().prototype.resizeBilinear=function(t,n,e){return this.throwIfDisposed(),BP(this,t,n,e)},H().prototype.resizeNearestNeighbor=function(t,n,e){return this.throwIfDisposed(),zP(this,t,n,e)},H().prototype.reverse=function(t){return this.throwIfDisposed(),kl(this,t)},H().prototype.rfft=function(){return this.throwIfDisposed(),aS(this)},H().prototype.round=function(){return this.throwIfDisposed(),UP(this)},H().prototype.rsqrt=function(){return this.throwIfDisposed(),DO(this)},H().prototype.selu=function(){return this.throwIfDisposed(),TP(this)},H().prototype.separableConv2d=function(t,n,e,r,s,o){return this.throwIfDisposed(),EP(this,t,n,e,r,s,o)},H().prototype.sigmoid=function(){return this.throwIfDisposed(),fc(this)};const voe=F({sign_:function boe(t){const e={x:S(t,"x","sign")};return R.runKernel(Kh,e)}});H().prototype.sign=function(){return this.throwIfDisposed(),voe(this)},H().prototype.sin=function(){return this.throwIfDisposed(),_O(this)},H().prototype.sinh=function(){return this.throwIfDisposed(),SO(this)},H().prototype.slice=function(t,n){return this.throwIfDisposed(),Zt(this,t,n)},H().prototype.softmax=function(t){return this.throwIfDisposed(),rS(this,t)},H().prototype.softplus=function(){return this.throwIfDisposed(),vp(this)},H().prototype.spaceToBatchND=function(t,n){return this.throwIfDisposed(),LS(this,t,n)},H().prototype.split=function(t,n){return this.throwIfDisposed(),Ls(this,t,n)},H().prototype.sqrt=function(){return this.throwIfDisposed(),Gr(this)},H().prototype.square=function(){return this.throwIfDisposed(),rn(this)},H().prototype.squaredDifference=function(t){return this.throwIfDisposed(),HP(this,t)},H().prototype.squeeze=function(t){return this.throwIfDisposed(),xp(this,t)},H().prototype.stack=function(t,n){this.throwIfDisposed();const e=t instanceof Hn?[this,t]:[this,...t];return Da(e,n)},H().prototype.step=function(t){return this.throwIfDisposed(),wp(this,t)};const woe=F({stridedSlice_:function xoe(t,n,e,r,s=0,o=0,i=0,a=0,l=0){const c={x:S(t,"x","stridedSlice","string_or_numeric")};return R.runKernel(Z0,c,{begin:n,end:e,strides:r,beginMask:s,endMask:o,ellipsisMask:i,newAxisMask:a,shrinkAxisMask:l})}});H().prototype.stridedSlice=function(t,n,e,r,s,o,i,a){return this.throwIfDisposed(),woe(this,t,n,e,r,s,o,i,a)},H().prototype.sub=function(t){return this.throwIfDisposed(),ke(this,t)},H().prototype.sum=function(t,n){return this.throwIfDisposed(),Ae(this,t,n)};const _oe=F({tan_:function Coe(t){const e={x:S(t,"x","tan","float32")};return R.runKernel(ep,e)}});H().prototype.tan=function(){return this.throwIfDisposed(),_oe(this)},H().prototype.tanh=function(){return this.throwIfDisposed(),sS(this)},H().prototype.tile=function(t){return this.throwIfDisposed(),No(this,t)},H().prototype.toBool=function(){return this.throwIfDisposed(),xe(this,"bool")},H().prototype.toFloat=function(){return this.throwIfDisposed(),xe(this,"float32")},H().prototype.toInt=function(){return this.throwIfDisposed(),xe(this,"int32")};const Ioe=F({topk_:function Soe(t,n=1,e=!0){const r=S(t,"x","topk");if(0===r.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const s=r.shape[r.shape.length-1];if(n<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${n}`);if(n>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got ${n}`);const o={x:r},i={k:n,sorted:e},[a,l]=R.runKernel(t_,o,i);return{values:a,indices:l}}});H().prototype.topk=function(t,n){return this.throwIfDisposed(),Ioe(this,t,n)},H().prototype.transpose=function(t){return this.throwIfDisposed(),Rt(this,t)};const Toe=F({unique_:function Doe(t,n=0){const e=S(t,"x","unique","string_or_numeric");_(e.rank>0,()=>"The input tensor must be at least 1D");const r={x:e},s={axis:n},[o,i]=R.runKernel(r_,r,s);return{values:o,indices:i}}});H().prototype.unique=function(t){return this.throwIfDisposed(),Toe(this,t)},H().prototype.unsortedSegmentSum=function(t,n){return this.throwIfDisposed(),TO(this,t,n)},H().prototype.unstack=function(t){return this.throwIfDisposed(),Al(this,t)},H().prototype.where=function(t,n){return this.throwIfDisposed(),jr(t,this,n)},H().prototype.zerosLike=function(){return this.throwIfDisposed(),At(this)};class ai extends Error{constructor(n){super(n),Object.setPrototypeOf(this,ai.prototype)}}class co extends Error{constructor(n){super(n),Object.setPrototypeOf(this,co.prototype)}}class A extends Error{constructor(n){super(n),Object.setPrototypeOf(this,A.prototype)}}class lt extends Error{constructor(n){super(n),Object.setPrototypeOf(this,lt.prototype)}}class WS extends Error{constructor(n){super(n),Object.setPrototypeOf(this,WS.prototype)}}class $O extends Error{constructor(n){super(n),Object.setPrototypeOf(this,$O.prototype)}}class LO{constructor(n){this.maxEntries=n||100,this.cache=new Map}get(n){let e;return this.cache.has(n)&&(e=this.cache.get(n),this.cache.delete(n),this.cache.set(n,e)),e}put(n,e){if(this.cache.has(n))this.cache.delete(n);else if(this.cache.size>=this.maxEntries){const r=this.cache.keys().next().value;this.cache.delete(r)}this.cache.set(n,e)}getMaxEntries(){return this.maxEntries}setMaxEntries(n){if(n<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${n}.`);if(this.maxEntries>n)for(let e=0;e<this.maxEntries-n;e++){const r=this.cache.keys().next().value;this.cache.delete(r)}this.maxEntries=n}}function Ml(t,n){if(Array.isArray(t)){let e=[];for(let r=0;r<n;r++)e=e.concat(t);return e}{const e=new Array(n);return e.fill(t),e}}function Vs(t,n){if(!t)throw new WS(n)}function VO(t,n){let e=0;for(const r of t)r===n&&e++;return e}function ls(t){return 1===t.length?t[0]:t}function sn(t){return Array.isArray(t)?t:[t]}function qi(t){const e=t.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==e[0]?e:"private"+e}function Pl(t){return t.length<=1||-1===t.indexOf("_")?t:t.replace(/[_]+(\w|$)/g,(n,e)=>e.toUpperCase())}let ho={};function GS(t){if(null==t)return null;const n={};return n.className=t.getClassName(),n.config=t.getConfig(),n}function HS(t){if(null!=t&&"object"==typeof t)if(Array.isArray(t))t.forEach(n=>HS(n));else{const n=Object.keys(t);for(const e of n){const r=t[e];null!=r&&"object"==typeof r&&(Array.isArray(r)||"ndarray"!==r.type||"number"!=typeof r.value?HS(r):t[e]=r.value)}}}function Ip(t,n={},e={},r="object",s=!1){if("string"==typeof t){let i;if(t in e)i=e[t];else if(t in ho)i=ho[t];else if(i=n[t],null==i)throw new A(`Unknown ${r}: ${t}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return i}{const o=t;if(null==o.className||null==o.config)throw new A(`${r}: Improper config format: ${JSON.stringify(o)}.\n'className' and 'config' must set.`);const i=o.className;let a,l;if(i in e?[a,l]=e[i]:i in ho?[a,l]=ho.className:i in n&&([a,l]=n[i]),null==a)throw new A(`Unknown ${r}: ${i}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(null!=l){const u={};for(const p of Object.keys(ho))u[p]=ho[p];for(const p of Object.keys(e))u[p]=e[p];o.config.customObjects=u;const d=Object.assign({},ho);for(const p of Object.keys(e))ho[p]=e[p];HS(o.config);const h=l(a,o.config,e,s);return ho=Object.assign({},d),h}{const u=Object.assign({},ho);for(const d of Object.keys(e))ho[d]=e[d];const c=new a(o.config);return ho=Object.assign({},u),c}}}function Hy(t,n){return-1*function Eoe(t,n){return t<n?-1:t>n?1:0}(t,n)}function Ta(t){if(null==t)return t;const n=[];for(const e of t)-1===n.indexOf(e)&&n.push(e);return n}function Noe(t){if(null==t)throw new A(`Invalid value in obj: ${JSON.stringify(t)}`);for(const n in t)if(t.hasOwnProperty(n))return!1;return!0}function Ol(t,n,e){if(null!=e&&t.indexOf(e)<0)throw new A(`${e} is not a valid ${n}.  Valid values are ${t} or null/undefined.`)}function jS(t,n,e=0,r=1/0){return Vs(e>=0),Vs(r>=e),Array.isArray(t)&&t.length>=e&&t.length<=r&&t.every(s=>typeof s===n)}function pr(t,n){Array.isArray(t)?(_(t.length>0,()=>`${n} is unexpectedly an empty array.`),t.forEach((e,r)=>pr(e,`element ${r+1} of ${n}`))):_(Number.isInteger(t)&&t>0,()=>`Expected ${n} to be a positive integer, but got ${BO(t)}.`)}function BO(t){return null===t?"null":Array.isArray(t)?"["+t.map(n=>BO(n)).join(",")+"]":"string"==typeof t?`"${t}"`:`${t}`}function zO(t){return"relu"===t?"relu":"linear"===t?"linear":"elu"===t?"elu":null}let Aoe=0;function UO(){return Aoe++}const jy={};function qy(t=""){return t in jy||(jy[t]=0),jy[t]+=1,t+jy[t].toString()}const Roe=["channelsFirst","channelsLast"],Foe=["nearest","bilinear"],Moe=["valid","same","causal"],Poe=["max","avg"],Ooe=["sum","mul","concat","ave"],bc=new Map;function Ln(t){Ol(Roe,"DataFormat",t)}function Bs(t){Ol(Moe,"PaddingMode",t)}function WO(t){Ol(Poe,"PoolMode",t)}const Dp=[],GO="/";function $l(t,n){Dp.push(t);try{const e=n();return Dp.pop(),e}catch(e){throw Dp.pop(),e}}function HO(t){if(!qO(t))throw new Error("Not a valid tensor name: '"+t+"'");return function Loe(){return 0===Dp.length?"":Dp.join(GO)+GO}()+t}function jO(t){if(!qO(t))throw new Error("Not a valid tensor name: '"+t+"'");bc.has(t)||bc.set(t,0);const n=bc.get(t);if(bc.set(t,bc.get(t)+1),n>0){const e=`${t}_${n}`;return bc.set(e,1),e}return t}const Voe=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function qO(t){return!!t.match(Voe)}function Boe(t){return t===parseInt(t.toString(),10)}function Ea(t,n,e){null==n&&(n=0),null==e&&(e=t.length);let r=1;for(let s=n;s<e;++s)r*=t[s];return r}function vc(t){if(0===t.length)return Number.NaN;let n=Number.POSITIVE_INFINITY;for(let e=0;e<t.length;e++){const r=t[e];r<n&&(n=r)}return n}function Na(t){if(0===t.length)return Number.NaN;let n=Number.NEGATIVE_INFINITY;for(let e=0;e<t.length;e++){const r=t[e];r>n&&(n=r)}return n}function Ao(t,n){if(n<t)throw new A(`end (${n}) < begin (${t}) is forbidden.`);const e=[];for(let r=t;r<n;++r)e.push(r);return e}let Ky;function Jn(){return null==Ky&&(Ky=function _Z(){return R.backend}().epsilon()),Ky}function li(t,n){return xe(t,n)}function Tp(t,n=-1){const e=t.shape.slice();return n<0&&(n=e.length+n+1),e.splice(n,0,1),M(t,e)}function Ll(t,n,e){return $(()=>{switch(t.rank){case 1:return tS(t,n,e);case 2:return NP(t,[n,0],[e,t.shape[1]]);case 3:return nS(t,[n,0,0],[e,t.shape[1],t.shape[2]]);case 4:return Ry(t,[n,0,0,0],[e,t.shape[1],t.shape[2],t.shape[3]]);case 5:return Zt(t,[n,0,0,0,0],[e,t.shape[1],t.shape[2],t.shape[3],t.shape[4]]);case 6:return Zt(t,[n,0,0,0,0,0],[e,t.shape[1],t.shape[2],t.shape[3],t.shape[4],t.shape[5]]);default:throw new A(`sliceAlongFirstAxis() received an unsupported tensor rank: ${t.rank}`)}})}function qS(t,n,e){return $(()=>{switch(t.rank){case 1:return tS(t,n,e);case 2:return NP(t,[0,n],[t.shape[0],e]);case 3:return nS(t,[0,0,n],[t.shape[0],t.shape[1],e]);case 4:return Ry(t,[0,0,0,n],[t.shape[0],t.shape[1],t.shape[2],e]);default:throw new A(`sliceAlongLastAxis() received an unsupported tensor rank: ${t.rank}`)}})}function Xy(t,n,e,r){return $(()=>{switch(t.rank){case 1:return tS(t,n,e);case 2:switch(r){case 1:return Ll(t,n,e);case 2:return qS(t,n,e);default:throw new A(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return Ll(t,n,e);case 2:return nS(t,[0,n,0],[t.shape[0],e,t.shape[2]]);case 3:return qS(t,n,e);default:throw new A(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return Ll(t,n,e);case 2:return Ry(t,[0,n,0,0],[t.shape[0],e,t.shape[2],t.shape[3]]);case 3:return Ry(t,[0,0,n,0],[t.shape[0],t.shape[1],e,t.shape[3]]);case 4:return qS(t,n,e);default:throw new A(`The axis is not within the rank of the tensor ${r}`)}default:throw new A(`sliceAlongLastAxis() received an unsupported tensor rank: ${t.rank}`)}})}function KS(t,n=-1){let e;return n<0&&(e=t[0].rank,n=0!==e?e:0),n===t[0].rank&&(n=-1),Ar(t,n)}function XO(t,n){switch(t.rank){case 1:return IQ([t,n]);case 2:return TQ([t,n],0);case 3:return NQ([t,n],0);case 4:return AQ([t,n],0);default:throw new A(`concatAlongFirstAxis() received an unsupported tensor rank: ${t.rank}`)}}function XS(t,n){if(Array.isArray(n)||(n=[n]),t.rank!==n.length)throw new A(`The length of input n (${n.length}) does not match the number of dimensions in input x (${t.rank})`);return No(t,n)}function Yy(t,n=0,e=1,r,s){return IJ(t,n,e,r,s)}function ui(t,n,e,r){if(t.rank<2||n.rank<2)throw new lt(`dot requires both inputs to be rank >= 2 but got x shape = ${t.shape} and y shape = ${n.shape}`);if(n.rank>=3&&t.shape.slice(-1)[0]!==n.shape.slice(-2)[0])throw new lt(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${t.shape} and  y shape = ${n.shape}`);if(2===t.rank&&2===n.rank)return PP({a:t,b:n,transposeA:!1,transposeB:!1,bias:r?YS(t.rank,r,"channelsLast"):null,activation:e});{const s=t.shape.slice(),o=s.pop();t=M(t,[-1,o]);const i=n.shape.slice(),a=i.pop(),l=i.pop(),u=[...i,a],c=Array.from({length:n.rank},(f,g)=>0===g?n.rank-2:g<=n.rank-2?g-1:g);n=M(Rt(n,c),[l,-1]);const d=[...s,...u];return M(PP({a:t,b:n,transposeA:!1,transposeB:!1,bias:r?YS(t.rank,r,"channelsLast"):null,activation:e}),d)}}function YO(t,n,e){return $(()=>(n=Array.isArray(n)?vs(n,"int32"):xe(n,"int32"),G_(t,n,e)))}function Ep(t){return k(t,t)}function YS(t,n,e){const r=n.shape;if(1!==n.rank&&n.rank!==t)throw new A(`Unexpected bias dimensions: ${n.rank}; expected it to be 1 or ${t}`);if(5===t){if("channelsFirst"===e)return M(n,1===r.length?[1,r[0],1,1,1]:[1,r[3],r[0],r[1],r[2]]);if("channelsLast"===e)return M(n,1===r.length?[1,1,1,1,r[0]]:[1].concat(r))}else if(4===t){if("channelsFirst"===e)return M(n,1===r.length?[1,r[0],1,1]:[1,r[2],r[0],r[1]]);if("channelsLast"===e)return M(n,1===r.length?[1,1,1,r[0]]:[1].concat(r))}else if(3===t){if("channelsFirst"===e)return M(n,1===r.length?[1,r[0],1]:[1,r[1],r[0]]);if("channelsLast"===e)return M(n,1===r.length?[1,1,r[0]]:[1].concat(r))}else if(t<3)return n;throw new A(`Unsupported input rank by biasAdd: ${n.rank}`)}function Fo(t,n,e){return $(()=>(null==e&&(e="channelsLast"),Ln(e),ie(t,YS(t.rank,n,e))))}function ZO(t,n,e,r){return $(()=>JJ(t,n,e,r))}function Np(t,n,e=!1){return e?t():n()}const Xoe=["fanIn","fanOut","fanAvg"],Yoe=["normal","uniform","truncatedNormal"];class po extends uc{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}se((()=>{class t extends po{apply(e,r){return hr(e,r)}}return t.className="Zeros",t})());let QO=(()=>{class t extends po{apply(e,r){return Ia(e,r)}}return t.className="Ones",t})();se(QO),se((()=>{class t extends po{constructor(e){if(super(),"object"!=typeof e)throw new A(`Expected argument of type ConstantConfig but got ${e}`);if(void 0===e.value)throw new A(`config must have value set but got ${e}`);this.value=e.value}apply(e,r){return $(()=>k(rt(this.value),Ia(e,r)))}getConfig(){return{value:this.value}}}return t.className="Constant",t})()),se((()=>{class t extends po{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,r){return Ay(e,this.minval,this.maxval,r,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}return t.className="RandomUniform",t})()),se((()=>{class t extends po{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,r){if("float32"!==(r=r||"float32")&&"int32"!==r)throw new lt(`randomNormal does not support dType ${r}.`);return Yy(e,this.mean,this.stddev,r,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}return t.className="RandomNormal",t})()),se((()=>{class t extends po{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,r){if("float32"!==(r=r||"float32")&&"int32"!==r)throw new lt(`truncatedNormal does not support dType ${r}.`);return kP(e,this.mean,this.stddev,r,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}return t.className="TruncatedNormal",t})()),se((()=>{class t extends po{constructor(e){super(),this.gain=null!=e.gain?e.gain:1}apply(e,r){return $(()=>{if(2!==e.length||e[0]!==e[1])throw new A("Identity matrix initializer can only be used for 2D square matrices.");return k(this.gain,_P(e[0]))})}getConfig(){return{gain:this.gain}}}return t.className="Identity",t})());let zs=(()=>{class t extends po{constructor(e){if(super(),e.scale<0)throw new A(`scale must be a positive float. Got: ${e.scale}`);this.scale=null==e.scale?1:e.scale,this.mode=null==e.mode?"fanIn":e.mode,function Zoe(t){Ol(Xoe,"FanMode",t)}(this.mode),this.distribution=null==e.distribution?"normal":e.distribution,function Qoe(t){Ol(Yoe,"Distribution",t)}(this.distribution),this.seed=e.seed}apply(e,r){const s=function Joe(t,n="channelsLast"){let e,r;if(Ln(n),2===t.length)e=t[0],r=t[1];else if(-1!==[3,4,5].indexOf(t.length)){if("channelsFirst"===n){const s=Ea(t,2);e=t[1]*s,r=t[0]*s}else if("channelsLast"===n){const s=Ea(t,0,t.length-2);e=t[t.length-2]*s,r=t[t.length-1]*s}}else{const s=Ea(t);e=Math.sqrt(s),r=Math.sqrt(s)}return[e,r]}(e),o=s[0],i=s[1];let a=this.scale;if(a/="fanIn"===this.mode?Math.max(1,o):"fanOut"===this.mode?Math.max(1,i):Math.max(1,(o+i)/2),"normal"===this.distribution){const l=Math.sqrt(a);if("float32"!==(r=r||"float32")&&"int32"!==r)throw new lt(`${this.getClassName()} does not support dType ${r}.`);return kP(e,0,l,r,this.seed)}{const l=Math.sqrt(3*a);return Ay(e,-l,l,r,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}return t.className="VarianceScaling",t})();se(zs);let JO=(()=>{class t extends zs{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return zs.className}}return t.className="GlorotUniform",t})();se(JO);let e$=(()=>{class t extends zs{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return zs.className}}return t.className="GlorotNormal",t})();se(e$);let t$=(()=>{class t extends zs{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return zs.className}}return t.className="HeNormal",t})();se(t$);let n$=(()=>{class t extends zs{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return zs.className}}return t.className="HeUniform",t})();se(n$);let r$=(()=>{class t extends zs{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return zs.className}}return t.className="LeCunNormal",t})();se(r$);let s$=(()=>{class t extends zs{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return zs.className}}return t.className="LeCunUniform",t})();se(s$),se((()=>{class t extends po{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=null==e.gain?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,r){return $(()=>{if(e.length<2)throw new lt("Shape must be at least 2D.");if("int32"!==r&&"float32"!==r&&void 0!==r)throw new TypeError(`Unsupported data type ${r}.`);const s=G(e.slice(0,-1)),o=e[e.length-1],i=s*o;i>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${i}) elements: Slowness may result.`);const l=Yy([Math.max(o,s),Math.min(o,s)],0,1,r,this.seed),u=Kte.qr(l,!1);let c=u[0];const h=u[1].flatten().stridedSlice([0],[Math.min(o,s)*Math.min(o,s)],[Math.min(o,s)+1]);return c=k(c,h.sign()),s<o&&(c=c.transpose()),k(rt(this.gain),c.reshape(e))})}getConfig(){return{gain:this.gain,seed:this.seed}}}return t.className="Orthogonal",t})());const o$={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function i$(t,n={}){return Ip(t,ro.getMap().classNameMap,n,"initializer")}function _n(t){return GS(t)}function gn(t){if("string"==typeof t){const n=t in o$?o$[t]:t;if("GlorotNormal"===n)return new e$;if("GlorotUniform"===n)return new JO;if("HeNormal"===n)return new t$;if("HeUniform"===n)return new n$;if("LeCunNormal"===n)return new r$;if("LeCunUniform"===n)return new s$;{const e={};return e.className=n,e.config={},i$(e)}}return t instanceof po?t:i$(t)}function ZS(t){return Array.isArray(t)&&Array.isArray(t[0])}function Zy(t){return 0===t.length?[]:Array.isArray(t[0])?t:[t]}function nt(t){let n;if(Array.isArray(t)){if(1!==t.length)throw new A(`Expected Tensor length to be 1; got ${t.length}`);n=t[0]}else n=t;return n}function $t(t){if(Array.isArray(t)&&Array.isArray(t[0])){if(1===t.length)return t[0];throw new A(`Expected exactly 1 Shape; got ${t.length}`)}return t}function Qy(t){let n=0;for(const e of t)n+=0===e.shape.length?1:e.shape.reduce((r,s)=>r*s);return n}const a$="Variable";class ci{constructor(n,e="float32",r=a$,s=!0,o=null){this.dtype=e??"float32",this.shape=n.shape,this.id=UO(),this.originalName=HO(r=r??a$),this.name=jO(this.originalName),this.trainable_=s,this.constraint=o,this.val=function jJ(t,n=!0,e,r){return R.makeVariable(t,n,e,r)}(n,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(n){return this.assertNotDisposed(),function eie(t,n){if(t.shape.toString()!==n.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(t.shape)+" vs. "+JSON.stringify(n.shape))}(this.val,n),this.val.id!==n.id&&(this.val.assign(n),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(n){this.trainable_=n,this.val.trainable=n}}function QS(t){return t.map(n=>n.read())}function JS(t){t.forEach(n=>{n[0].write(n[1])})}class er{constructor(n){this.dtype=n.dtype,this.shape=n.shape,this.ndim=null!=n.shape?n.shape.length:n.ndim,this.maxNDim=n.maxNDim,this.minNDim=n.minNDim,this.axes=n.axes||{}}}class di{constructor(n,e,r,s,o,i,a){this.dtype=n,this.shape=e,this.sourceLayer=r,this.inputs=s,this.callArgs=o,this.outputTensorIndex=a,this.id=UO(),null!=i&&(this.originalName=HO(i),this.name=jO(this.originalName)),this.rank=e.length}}let tie=0;class Jy{constructor(n,e){this.callArgs=e,this.id=tie++,this.outboundLayer=n.outboundLayer,this.inboundLayers=n.inboundLayers,this.nodeIndices=n.nodeIndices,this.tensorIndices=n.tensorIndices,this.inputTensors=n.inputTensors,this.outputTensors=n.outputTensors,this.inputMasks=n.inputMasks,this.outputMasks=n.outputMasks,this.inputShapes=n.inputShapes,this.outputShapes=n.outputShapes;for(const r of n.inboundLayers)r?.outboundNodes.push(this);n.outboundLayer.inboundNodes.push(this)}getConfig(){const n=[];for(const e of this.inboundLayers)n.push(null!=e?e.name:null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:n,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let nie=0;class wt extends uc{constructor(n={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=nie++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let e=n.name;if(!e){const r=this.getClassName();e=qi(r)+"_"+qy(r)}if(this.name=e,this.trainable_=null==n.trainable||n.trainable,null!=n.inputShape||null!=n.batchInputShape){let r;if(null!=n.batchInputShape)r=n.batchInputShape;else if(null!=n.inputShape){let o=null;null!=n.batchSize&&(o=n.batchSize),r=[o].concat(n.inputShape)}this.batchInputShape=r;let s=n.dtype;null==s&&(s=n.inputDType),null==s&&(s="float32"),this.dtype=s}this.initialWeights=null!=n.weights?n.weights:null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(n,e){return n.name+"_ib-"+e.toString()}getNodeAtIndex(n,e){if(0===this.inboundNodes.length)throw new co(`The layer has never been called and thus has no defined ${e}.`);if(this.inboundNodes.length<=n)throw new A(`Asked to get ${e} at node ${n}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[n]}getInputAt(n){return ls(this.getNodeAtIndex(n,"input").inputTensors)}getOutputAt(n){return ls(this.getNodeAtIndex(n,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new ai(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(0===this.inboundNodes.length)throw new ai(`Layer ${this.name} is not connected, no input to return.`);return ls(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new ai(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new ai(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return ls(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(n=>n())}get updates(){return this._updates}get built(){return this._built}set built(n){this._built=n}get trainable(){return this.trainable_}set trainable(n){this._trainableWeights.forEach(e=>e.trainable=n),this.trainable_=n}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(n=>n.trainable):[]}set trainableWeights(n){this._trainableWeights=n}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(n=>!n.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(n){this._nonTrainableWeights=n}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(n){if(n=sn(n),null==this.inputSpec||0===this.inputSpec.length)return;const e=sn(this.inputSpec);if(n.length!==e.length)throw new A(`Layer ${this.name} expects ${e.length} inputs, but it received ${n.length} input tensors. Input received: ${n}`);for(let r=0;r<n.length;r++){const s=n[r],o=e[r];if(null==o)continue;const i=s.rank;if(null!=o.ndim&&i!==o.ndim)throw new A(`Input ${r} is incompatible with layer ${this.name}: expected ndim=${o.ndim}, found ndim=${i}`);if(null!=o.maxNDim&&i>o.maxNDim)throw new A(`Input ${r} is incompatible with layer ${this.name}: expected max_ndim=${o.maxNDim}, found ndim=${i}`);if(null!=o.minNDim&&i<o.minNDim)throw new A(`Input ${r} is incompatible with layer ${this.name}: expected min_ndim=${o.minNDim}, found ndim=${i}.`);if(null!=o.dtype&&s.dtype!==o.dtype)throw new A(`Input ${r} is incompatible with layer ${this.name} : expected dtype=${o.dtype}, found dtype=${s.dtype}.`);if(o.axes){const a=s.shape;for(const l in o.axes){const u=Number(l),c=o.axes[l];if(null!=c&&-1===[c,null].indexOf(u>=0?a[u]:a[a.length+u]))throw new A(`Input ${r} is incompatible with layer ${this.name}: expected axis ${u} of input shape to have value ${c} but got shape ${a}.`)}}if(null!=o.shape)for(let a=0;a<o.shape.length;++a){const l=o.shape[a],u=s.shape[a];if(null!=l&&null!=u&&l!==u)throw new A(`Input ${r} is incompatible with layer ${this.name}: expected shape=${o.shape}, found shape=${s.shape}.`)}}}call(n,e){return n}invokeCallHook(n,e){null!=this._callHook&&this._callHook(n,e)}setCallHook(n){this._callHook=n}clearCallHook(){this._callHook=null}apply(n,e){e=e||{},this.assertNotDisposed();const r=sn(n);let s=!0;for(const i of r)if(!(i instanceof di)){s=!1;break}let o=!0;for(const i of r)if(i instanceof di){o=!1;break}if(s===o)throw new A("Arguments to apply() must be all SymbolicTensors or all Tensors");return $l(this.name,()=>{if(!this.built){this.assertInputCompatibility(n);const i=[];for(const a of sn(n))i.push(a.shape);this.build(ls(i)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&o&&(this._refCount=1)}if(this.assertInputCompatibility(n),o){let i=this.call(n,e);const a=sn(i),l=[];for(let u of a)-1!==r.indexOf(u)&&(u=u.clone()),l.push(u);if(i=ls(l),null!=this.activityRegularizer)throw new lt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return i}{const i=function rie(t){t=sn(t);const n=[];for(const e of t)n.push(e.shape);return ls(n)}(n),a=this.computeOutputShape(i);let l;const u="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(n)?i[0]:i),l=null!=a&&a.length>0&&Array.isArray(a[0])?a.map((c,d)=>new di(u,c,this,sn(n),e,this.name,d)):new di(u,a,this,sn(n),e,this.name),this.addInboundNode(n,l,null,null,i,a,e),this._refCount++,null!=this.activityRegularizer)throw new lt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return l}})}warnOnIncompatibleInputShape(n){if(null!=this.batchInputShape)if(n.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(n)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let e=!1;this.batchInputShape.forEach((r,s)=>{null!=r&&null!=n[s]&&n[s]!==r&&(e=!0)}),e&&console.warn(`The shape of the input tensor (${JSON.stringify(n)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new ai(`The layer ${this.name} has never been called and thus has no defined output shape.`);const n=[];for(const e of this.inboundNodes){const r=JSON.stringify(e.outputShapes);-1===n.indexOf(r)&&n.push(r)}if(1===n.length){const e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&1===e.length?e[0]:e}throw new ai(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new co(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return Qy(this.weights)}build(n){this.built=!0}getWeights(n=!1){return QS(n?this.trainableWeights:this.weights)}setWeights(n){$(()=>{const e=this.weights;if(e.length!==n.length)throw new A(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${n.length}, but the layer was expecting ${e.length} weights. Provided weights: ${n}...`);if(0===e.length)return;const r=[],s=QS(e);for(let o=0;o<s.length;++o){const i=s[o],a=e[o],l=n[o];if(!Bt(i.shape,l.shape))throw new A(`Layer weight shape ${i.shape} not compatible with provided weight shape ${l.shape}`);r.push([a,l])}JS(r)})}addWeight(n,e,r,s,o,i,a,l){if(-1!==this._addedWeightNames.indexOf(n))throw new A(`Duplicate weight name ${n} for layer ${this.name}`);this._addedWeightNames.push(n),null==r&&(r="float32"),this.fastWeightInitDuringBuild&&(s=null!=l?l():gn("zeros"));const u=s.apply(e,r),c=new ci(u,r,n,i,a);return u.dispose(),null!=o&&this.addLoss(()=>o.apply(c.read())),null==i&&(i=!0),i?this._trainableWeights.push(c):this._nonTrainableWeights.push(c),c}setFastWeightInitDuringBuild(n){this.fastWeightInitDuringBuild=n}addLoss(n){null==n||Array.isArray(n)&&0===n.length||(n=sn(n),null!=this._losses&&this.losses.push(...n))}computeOutputShape(n){return n}computeMask(n,e){if(!this.supportsMasking){if(null!=e){if(!Array.isArray(e))throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);e.forEach(r=>{if(null!=r)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)})}return null}return e}addInboundNode(n,e,r,s,o,i,a=null){const l=sn(n);e=sn(e),r=sn(r),s=sn(s),o=Zy(o),i=Zy(i);const u=[],c=[],d=[];for(const h of l)u.push(h.sourceLayer),c.push(h.nodeIndex),d.push(h.tensorIndex);new Jy({outboundLayer:this,inboundLayers:u,nodeIndices:c,tensorIndices:d,inputTensors:l,outputTensors:e,inputMasks:r,outputMasks:s,inputShapes:o,outputShapes:i},a);for(let h=0;h<e.length;h++)e[h].sourceLayer=this,e[h].nodeIndex=this.inboundNodes.length-1,e[h].tensorIndex=h}getConfig(){const n={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(n.batchInputShape=this.batchInputShape),null!=this.dtype&&(n.dtype=this.dtype),n}disposeWeights(){return this.weights.forEach(n=>n.dispose()),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(null===this._refCount)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let n=0;return 0==--this._refCount&&(n=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:n}}}function l$(t,n,e){if((null==n||null!=e&&e>0)&&(n=t.sourceLayer,e=t.nodeIndex),0===n.inboundNodes.length)return[t];{const r=n.inboundNodes[e];if(0===r.inboundLayers.length)return r.inputTensors;{const s=[];for(let o=0;o<r.inboundLayers.length;o++){const u=l$(r.inputTensors[o],r.inboundLayers[o],r.nodeIndices[o]);for(const c of u)-1===s.indexOf(c)&&s.push(c)}return s}}}let eb=(()=>{class t extends wt{constructor(e){if(super({dtype:e.dtype,name:null!=e.name?e.name:qy("input").toString()}),null==e.batchSize&&(e.batchSize=null),null==e.sparse&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,null!=e.inputShape&&null!=e.batchInputShape)throw new A("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let r=e.batchInputShape;if(null==r){if(null==e.inputShape)throw new A("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");r=[e.batchSize].concat(e.inputShape)}else if(null!=e.batchSize)throw new A("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const s=e.dtype||"float32";this.batchInputShape=r,this.dtype=s,this.inputSpec=[{shape:r}];const o=new di(this.dtype,this.batchInputShape,this,[],{},this.name);o.nodeIndex=0,o.tensorIndex=0,new Jy({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[o],outputTensors:[o],inputMasks:[null],outputMasks:[null],inputShapes:[r],outputShapes:[r]})}apply(e,r){throw new A(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}return t.className="InputLayer",t})();se(eb);class ka{constructor(n){if(this.id2Value={},this.id2Mask={},this.name2Id={},n instanceof ka)for(const e in n.id2Value)this.id2Value[e]=n.id2Value[e],e in n.id2Mask&&(this.id2Mask[e]=n.id2Mask[e]);else{if(null==n)return;for(const e of n)this.add(e.key,e.value)}}add(n,e,r){if(null!=this.id2Value[n.id])throw new A(`Duplicate key: name=${n.name}, id=${n.id}`);return this.id2Value[n.id]=function iie(t,n){if(null==t.dtype||t.dtype===n.dtype)return n;try{return xe(n,t.dtype)}catch{throw new A(`The dtype of the feed (${n.dtype}) can not be cast to the dtype of the key '${t.name}' (${t.dtype}).`)}}(n,e),this.name2Id[n.name]=n.id,null!=r&&(this.id2Mask[n.id]=r),this}addFeed(n){this.add(n.key,n.value)}hasKey(n){return null!=this.id2Value[n.id]}names(){return Object.keys(this.name2Id)}getValue(n){if(n instanceof di){if(null==this.id2Value[n.id])throw new A(`Nonexistent key: ${n.name}`);return this.id2Value[n.id]}{const e=this.name2Id[n];if(null==e)throw new A(`Feed dict has no SymbolicTensor name: ${n}`);return this.id2Value[e]}}getMask(n){if(n instanceof di){if(null==this.id2Value[n.id])throw new A(`Nonexistent key: ${n.name}`);return this.id2Mask[n.id]}{const e=this.name2Id[n];if(null==e)throw new A(`Feed dict has no SymbolicTensor name: ${n}`);return this.id2Mask[e]}}disposeMasks(){null!=this.id2Mask&&ft(this.id2Mask)}}const tb=new LO,nb=new LO;function kp(t,n,e,r){const s=null!=e&&e.training,o=Array.isArray(t),i=o?t:[t],a=i.map(f=>f.name),l=[],u=n.names();for(const f of a)-1!==u.indexOf(f)?l.push(n.getValue(f)):l.push(null);null!=r&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);const c=a.join(",")+"|"+n.names().sort().join(",");let h,d=tb.get(c);if(null==d){const f=function lie(t,n){_(null!=t&&t.length>0,()=>"Expected at least one fetch, got none");let e=[],r={};if(1===t.length){const s=u$(t[0],n);e=s.sorted,r=s.recipientMap}else{const s=new Set;for(const o of t){const{sorted:i,recipientMap:a}=u$(o,n);for(const l of i)s.has(l.name)||(e.push(l),s.add(l.name));for(const l in a)null==r[l]&&(r[l]=new Set),a[l].forEach(u=>r[l].add(u))}}return{sorted:e,recipientCounts:uie(r)}}(i,n);d=f.sorted,h=f.recipientCounts,tb.put(c,d),nb.put(c,h)}h={},s||Object.assign(h,nb.get(c));const p=new ka(n);for(let f=0;f<d.length;++f){if(null!=r){const E=T_().numTensors;E>r.maxNumTensors&&(r.maxNumTensors=E),E<r.minNumTensors&&(r.minNumTensors=E)}const g=d[f],m=g.sourceLayer;if(m instanceof eb)continue;const y=[],b=[],v=[];let x=!1;for(const E of g.inputs){const N=p.getValue(E),P=p.getMask(E);y.push(N),b.push(P),null!=P&&(x=!0),s||(h[E.name]--,0===h[E.name]&&!n.hasKey(E)&&-1===a.indexOf(E.name)&&!N.isDisposed&&!0!==E.sourceLayer.stateful&&v.push(N))}x&&((e=e||{}).mask=b[0]);const w=sn(m.apply(y,e));let C=null;m.supportsMasking&&(C=m.computeMask(y,b));const I=cie(g),D=Array.isArray(I)?I:[I];for(let E=0;E<D.length;++E){p.hasKey(D[E])||p.add(D[E],w[E],Array.isArray(C)?C[0]:C);const N=a.indexOf(D[E].name);-1!==N&&(l[N]=w[E])}s||ft(v)}return p.disposeMasks(),o?l:l[0]}function uie(t){const n={};for(const e in t)n[e]=t[e].size;return n}function u$(t,n){const e=new Set,r=[],s={};for(const a of n.names())e.add(a);const o=[],i=[];for(o.push(t);o.length>0;){const a=o[o.length-1];if(e.has(a.name)){o.pop();continue}const l=i[i.length-1]===o.length-1;if(0===a.inputs.length||l)o.pop(),r.push(a),e.add(a.name),l&&i.pop();else{i.push(o.length-1);for(const u of a.inputs)null==s[u.name]&&(s[u.name]=new Set),s[u.name].add(a.name),!e.has(u.name)&&o.push(u)}}return{sorted:r,recipientMap:s}}function cie(t){let n;if(1===t.sourceLayer.inboundNodes.length)n=t.sourceLayer.output;else{let e=null;for(let r=0;r<t.sourceLayer.inboundNodes.length;++r)for(const s of t.sourceLayer.inboundNodes[r].outputTensors)if(s.id===t.id){e=r;break}n=t.sourceLayer.getOutputAt(e)}return n}function eI(t,n){return $(()=>Gr(Ae(k(t,t),n,!0)))}L().registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,function aie(t){tb?.setMaxEntries(t),nb?.setMaxEntries(t)});class Ap extends uc{getConfig(){return{}}}se((()=>{class t extends Ap{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return $(()=>{const r=eI(e,this.axis),s=Os(r,0,this.maxValue);return k(e,Oe(s,ie(Jn(),r)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}return t.className="MaxNorm",t})()),se((()=>{class t extends Ap{constructor(e){super(),this.defaultAxis=0,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return $(()=>Oe(e,ie(Jn(),eI(e,this.axis))))}getConfig(){return{axis:this.axis}}}return t.className="UnitNorm",t})()),se((()=>{class t extends Ap{apply(e){return Wi(e)}}return t.className="NonNeg",t})()),se((()=>{class t extends Ap{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=e.minValue?e.minValue:this.defaultMinValue,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.rate=null!=e.rate?e.rate:this.defaultRate,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return $(()=>{const r=eI(e,this.axis),s=ie(k(this.rate,Os(r,this.minValue,this.maxValue)),k(1-this.rate,r));return k(e,Oe(s,ie(Jn(),r)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}return t.className="MinMaxNorm",t})());const c$={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function tr(t){return GS(t)}function d$(t,n={}){return Ip(t,ro.getMap().classNameMap,n,"constraint")}function nr(t){return null==t?null:"string"==typeof t?d$({className:t in c$?c$[t]:t,config:{}}):t instanceof Ap?t:d$(t)}function Aa(t){return tI.apply(this,arguments)}function tI(){return(tI=J(function*(t){if(null==t)return;const n=[],e=[],r=[];for(const s in t){const o=t[s];if("number"!=typeof o){const i=o;n.push(i.data()),e.push(s),r.push(i)}}if(n.length>0){const s=yield Promise.all(n);for(let o=0;o<s.length;++o)t[e[o]]=s[o][0];ft(r)}})).apply(this,arguments)}function h$(t){if(null!=t)for(const n in t){const e=t[n];"number"!=typeof e&&e.dispose()}}class xc{constructor(){this.validationData=null}setParams(n){this.params=n}onEpochBegin(n,e){return J(function*(){})()}onEpochEnd(n,e){return J(function*(){})()}onBatchBegin(n,e){return J(function*(){})()}onBatchEnd(n,e){return J(function*(){})()}onTrainBegin(n){return J(function*(){})()}onTrainEnd(n){return J(function*(){})()}setModel(n){}}class hie{constructor(n,e=10){null==n&&(n=[]),this.callbacks=n,this.queueLength=e}append(n){this.callbacks.push(n)}setParams(n){for(const e of this.callbacks)e.setParams(n)}setModel(n){for(const e of this.callbacks)e.setModel(n)}onEpochBegin(n,e){var r=this;return J(function*(){null==e&&(e={});for(const s of r.callbacks)yield s.onEpochBegin(n,e)})()}onEpochEnd(n,e){var r=this;return J(function*(){null==e&&(e={});for(const s of r.callbacks)yield s.onEpochEnd(n,e)})()}onBatchBegin(n,e){var r=this;return J(function*(){null==e&&(e={});for(const s of r.callbacks)yield s.onBatchBegin(n,e)})()}onBatchEnd(n,e){var r=this;return J(function*(){null==e&&(e={});for(const s of r.callbacks)yield s.onBatchEnd(n,e)})()}onTrainBegin(n){var e=this;return J(function*(){null==n&&(n={});for(const r of e.callbacks)yield r.onTrainBegin(n)})()}onTrainEnd(n){var e=this;return J(function*(){null==n&&(n={});for(const r of e.callbacks)yield r.onTrainEnd(n)})()}}class pie extends xc{constructor(){super()}onEpochBegin(n){var e=this;return J(function*(){e.seen=0,e.totals={}})()}onBatchEnd(n,e){var r=this;return J(function*(){null==e&&(e={});const s=null==e.size?0:e.size;r.seen+=s;for(const o in e){const i=e[o];if("number"==typeof i)r.totals.hasOwnProperty(o)||(r.totals[o]=0),r.totals[o]=r.totals[o]+i*s;else{let a;o in r.totals?a=r.totals[o]:r.totals[o]=0;const l=$(()=>ie(r.totals[o],k(i,s)));r.totals[o]=l,a?.dispose()}}})()}onEpochEnd(n,e){var r=this;return J(function*(){if(null!=e)for(const s of r.params.metrics)null!=r.totals[s]&&("number"==typeof r.totals[s]?e[s]=r.totals[s]/r.seen:$(()=>{const o=k(Oe(1,r.seen),r.totals[s]);e[s]=o,r.totals[s].dispose(),si(e[s])}))})()}}class fie extends xc{onTrainBegin(n){var e=this;return J(function*(){e.epoch=[],e.history={}})()}onEpochEnd(n,e){var r=this;return J(function*(){null==e&&(e={}),r.epoch.push(n);for(const s in e)null==r.history[s]&&(r.history[s]=[]),r.history[s].push(e[s])})()}syncData(){var n=this;return J(function*(){const e=[],r=[],s=[];for(const i in n.history){const a=n.history[i];for(let l=0;l<a.length;++l)"number"!=typeof a[l]&&(e.push(a[l].data()),r.push(i),s.push(l))}const o=yield Promise.all(e);for(let i=0;i<o.length;++i)n.history[r[i]][s[i]].dispose(),n.history[r[i]][s[i]]=o[i][0]})()}}class mie extends xc{constructor(n,e){if(super(),this.currentEpoch=0,this.nowFunc=n.nowFunc,this.nextFrameFunc=n.nextFrameFunc||qP,this.yieldEvery=e||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=n.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");s0(this.yieldEvery)&&(this.maybeWait=function koe(t,n,e){let s,r=null!=e?e():is();return(...i)=>{const a=null!=e?e():is();return a-r<n||(r=a,s=t(...i)),s}}(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=n.onTrainBegin,this.trainEnd=n.onTrainEnd,this.epochBegin=n.onEpochBegin,this.epochEnd=n.onEpochEnd,this.batchBegin=n.onBatchBegin,this.batchEnd=n.onBatchEnd,this.yield=n.onYield}maybeWait(n,e,r){var s=this;return J(function*(){const o=[];null!=s.yield&&(yield Aa(r),o.push(s.yield(n,e,r))),o.push(s.nextFrameFunc()),yield Promise.all(o)})()}onEpochBegin(n,e){var r=this;return J(function*(){r.currentEpoch=n,null!=r.epochBegin&&(yield Aa(e),yield r.epochBegin(n,e))})()}onEpochEnd(n,e){var r=this;return J(function*(){const s=[];null!=r.epochEnd&&(yield Aa(e),s.push(r.epochEnd(n,e))),"epoch"===r.yieldEvery&&s.push(r.nextFrameFunc()),yield Promise.all(s)})()}onBatchBegin(n,e){var r=this;return J(function*(){null!=r.batchBegin&&(yield Aa(e),yield r.batchBegin(n,e))})()}onBatchEnd(n,e){var r=this;return J(function*(){const s=[];null!=r.batchEnd&&(yield Aa(e),s.push(r.batchEnd(n,e))),"batch"===r.yieldEvery?s.push(r.nextFrameFunc()):s0(r.yieldEvery)&&s.push(r.maybeWait(r.currentEpoch,n,e)),yield Promise.all(s)})()}onTrainBegin(n){var e=this;return J(function*(){null!=e.trainBegin&&(yield Aa(n),yield e.trainBegin(n))})()}onTrainEnd(n){var e=this;return J(function*(){null!=e.trainEnd&&(yield Aa(n),yield e.trainEnd(n))})()}}function p$(t,n){return null==t&&(t={}),t instanceof xc?[t]:Array.isArray(t)&&t[0]instanceof xc?t:sn(t).map(r=>new mie(r,n))}let gie=(()=>{class t{constructor(){}static registerCallbackConstructor(e,r){_(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),t.checkForDuplicate(r),null==t.constructors[e]&&(t.constructors[e]=[]),t.constructors[e].push(r)}static checkForDuplicate(e){for(const r in t.constructors)t.constructors[+r].forEach(o=>{if(o===e)throw new A("Duplicate callback constructor.")})}static clear(){t.constructors={}}static createCallbacks(e){const r=[];for(const s in t.constructors){const o=+s;e>=o&&r.push(...t.constructors[o])}return r.map(s=>new s)}}return t.constructors={},t})();function f$(t,n,e,r,s,o,i,a,l){const u=new fie,c=[new pie,...gie.createCallbacks(n)];null!=t&&c.push(...t),c.push(u);const d=new hie(c);return d.setParams({epochs:e,initialEpoch:r,samples:s,steps:o,batchSize:i,verbose:n,doValidation:a,metrics:l}),{callbackList:d,history:u}}function hi(t,n={},e=!1){return Ip(t,ro.getMap().classNameMap,n,"layer",e)}function rb(t,n){return $(()=>{"float32"!==t.dtype&&(t=xe(t,"float32"));const e=Ae(Ep(t),n,!0),r=dp(e.shape,Jn()),s=Gr(wa(e,r));return Oe(t,s)})}function sb(t,n){return $(()=>Pn(Ep(ke(n,t)),-1))}function nI(t,n){return $(()=>Pn(ur(ke(n,t)),-1))}function rI(t,n){return $(()=>{const e=ke(t,n),r=Os(ur(t),Jn(),Number.MAX_VALUE),s=ur(Oe(e,r));return k(100,Pn(s,-1))})}function Rp(t,n,e=!1){return $(()=>{if(e)n=rS(n);else{const r=Ae(n,n.shape.length-1,!0);n=Oe(n,r)}return n=Os(n,Jn(),1-Jn()),mn(Ae(k(xe(t,"float32"),ao(n)),n.shape.length-1))})}function ob(t,n,e=!1){return $(()=>{const r=xe(Ny(function Goe(t){const n=[Ea(t.shape)];return M(t,n)}(t)),"int32"),s=(n=Os(n,Jn(),1-Jn())).shape;return Rp(M(DP(r,s[s.length-1]),s),n,e)})}function ib(t,n){return $(()=>{let e;return e=Os(n,Jn(),1-Jn()),e=ao(Oe(e,ke(1,e))),Pn(function Cie(t,n){if(!Bt(t.shape,n.shape))throw new A(`logits and labels must have the same shape, but got shapes ${JSON.stringify(t.shape)} and ${JSON.stringify(n.shape)}`);return $(()=>{const e=Wi(n),r=mn(ur(n));return ie(ke(e,k(n,t)),j_(oo(r)))})}(t,e),-1)})}function m$(t,n){return $(()=>{const e=rb(t,-1),r=rb(n,-1),s=k(e,r);return mn(Ae(s,-1))})}const ab={meanSquaredError:sb,meanAbsoluteError:nI,meanAbsolutePercentageError:rI,meanSquaredLogarithmicError:function yie(t,n){return $(()=>{const e=Os(n,Jn(),Number.MAX_VALUE),r=ao(ie(1,e)),s=Os(t,Jn(),Number.MAX_VALUE),o=ao(ie(1,s));return Pn(Ep(ke(r,o)),-1)})},squaredHinge:function bie(t,n){return $(()=>{const e=wa(0,ke(1,k(t,n)));return Pn(Ep(e),-1)})},hinge:function vie(t,n){return $(()=>{const e=wa(0,ke(1,k(t,n)));return Pn(e,-1)})},categoricalHinge:function xie(t,n){return $(()=>{const e=Ae(k(t,n),-1),r=ko(k(ke(1,t),n),-1);return wa(0,ie(1,ke(r,e)))})},logcosh:function wie(t,n){return $(()=>{const e=Math.log(2),r=ke(n,t),s=ke(ie(r,vp(k(-2,r))),e);return Pn(s,-1)})},categoricalCrossentropy:Rp,sparseCategoricalCrossentropy:ob,binaryCrossentropy:ib,kullbackLeiblerDivergence:function _ie(t,n){return $(()=>{const e=Os(t,Jn(),1),r=Os(n,Jn(),1);return Ae(k(t,ao(Oe(e,r))),-1)})},poisson:function Sie(t,n){return $(()=>{const e=ao(ie(Jn(),n));return Pn(ke(n,k(t,e)),-1)})},cosineProximity:m$};function sI(t){if("string"==typeof t){if(t in ab)return ab[t];let n=`Unknown loss ${t}`;throw t.toLowerCase().includes("softmaxcrossentropy")&&(n=`Unknown loss ${t}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new A(n)}return t}function g$(t,n){return $(()=>{const e=k(.5,lo(n)),r=li($s(n,e),t.dtype);return Pn(oi(t,r),-1)})}function y$(t,n){return $(()=>li(oi(hp(t,-1),hp(n,-1)),"float32"))}function Eie(t,n){return ib(t,n)}function Nie(t,n){return t.rank===n.rank&&(t=xp(t,[t.rank-1])),(n=hp(n,-1)).dtype!==t.dtype&&(n=xe(n,t.dtype)),xe(oi(t,n),"float32")}const v$=Rp,x$=ob,lb={binaryAccuracy:g$,categoricalAccuracy:y$,precision:function Tie(t,n){return $(()=>{const e=function b$(t,n){return $(()=>xe(Ae(Ui(oi(t,1),oi(n,1))),"float32"))}(t,n),r=function Die(t,n){return $(()=>xe(Ae(Ui(oi(t,0),oi(n,1))),"float32"))}(t,n),s=ie(e,r);return xe(jr($s(s,0),Oe(e,s),0),"float32")})},categoricalCrossentropy:v$,sparseCategoricalCrossentropy:x$,mse:sb,MSE:sb,mae:nI,MAE:nI,mape:rI,MAPE:rI,cosine:m$};function $ie(t){if("string"==typeof t&&t in lb)return lb[t];if("string"!=typeof t&&null!=t)return t;throw new A(`Unknown metric ${t}`)}function ub(t){if(Vs(null!==t,`Unknown LossOrMetricFn ${t}`),"string"==typeof t)return t;{let n;for(const e of Object.keys(ab))if(ab[e]===t){n=e;break}if(void 0!==n)return n;for(const e of Object.keys(lb))if(lb[e]===t){n=e;break}return void 0!==n?n:t.name}}const w$=1048576;function C$(t,n,e=!1){if(null==t||"object"!=typeof t||Object.getPrototypeOf(t)!==Object.prototype||!oI(t))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(e){const r=JSON.stringify(t);r.length>w$&&console.warn(`User-defined metadata of model "${n}" is too large in size (length=${r.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${w$}.`)}}function oI(t){if(null===t)return!0;if("object"==typeof t){if(Object.getPrototypeOf(t)===Object.prototype){const n=Object.keys(t);for(const e of n)if("string"!=typeof e||!oI(t[e]))return!1;return!0}if(Array.isArray(t)){for(const n of t)if(!oI(n))return!1;return!0}return!1}{const n=typeof t;return"string"===n||"number"===n||"boolean"===n}}function cb(t,n,e=console.log){let r="";for(let s=0;s<t.length;++s)s>0&&(r=r.slice(0,r.length-1)+" "),r+=t[s],r=r.slice(0,n[s]),r+=" ".repeat(n[s]-r.length);e(r)}function Uie(t,n,e){let r,s;try{s=t.inboundNodes.map(l=>JSON.stringify(l.inputShapes)).join(",")}catch{s="multiple"}try{r=JSON.stringify(t.outputShape)}catch{r="multiple"}cb([`${t.name} (${t.getClassName()})`,s,r,t.countParams().toString()],n,e)}function Wie(t,n,e,r){let s,o;try{o=t.inboundNodes.map(d=>JSON.stringify(d.inputShapes)).join(",")}catch{o="multiple"}try{s=JSON.stringify(t.outputShape)}catch{s="multiple"}const i=[];for(const d of t.inboundNodes)if(!(null!=e&&e.length>0&&-1===e.indexOf(d)))for(let h=0;h<d.inboundLayers.length;++h)i.push(`${d.inboundLayers[h].name}[${d.nodeIndices[h]}][${d.tensorIndices[h]}]`);const a=t.name,l=t.getClassName(),u=0===i.length?"":i[0];cb([`${a} (${l})`,o,s,t.countParams().toString(),u],n,r);for(let d=1;d<i.length;++d)cb(["","","","",i[d]],n,r)}function _$(t,n,e){return("inboundNodes"===t||"outputLayers"===t||"inputLayers"===t)&&0===n&&"string"==typeof e}function db(t,n){if(null===t)return null;if("string"==typeof t)return Pl(t);if("number"==typeof t||"boolean"==typeof t)return t;if(t instanceof Array){const e=[],r=t.length;for(let s=0;s<r;++s){const o=t[s];_$(n,s,o)?e.push(o):e.push(db(o,n))}return e}{const e={};for(const r of Object.keys(t)){const s=t[r];if("name"===r&&"string"==typeof s)e[r]=s;else{const o=Pl(r);e[o]=db(s,o)}}return e}}function iI(t,n){if(null==t)return null;if("string"==typeof t)return qi(t);if("number"==typeof t||"boolean"==typeof t)return t;if(t instanceof Array){const e=[],r=t.length;for(let s=0;s<r;++s){const o=t[s];_$(n,s,o)?e.push(o):e.push(iI(o,n))}return e}{const e={};for(const r of Object.keys(t)){const s=t[r];e[qi(r)]="name"!==r&&"className"!==r||"string"!=typeof s?iI(s,r):s}return e}}class Mo extends wt{constructor(n){if(super({}),this.containerNodes=new Set,this.name=n.name,null==this.name){const b=this.getClassName().toLowerCase();this.name=qy(b)}if(this.supportsMasking=!1,this.trainable_=!0,this.inputs=Array.isArray(n.inputs)?n.inputs.slice():[n.inputs],this.outputs=Array.isArray(n.outputs)?n.outputs.slice():[n.outputs],Ta(this.inputs).length!==this.inputs.length)throw new A(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(b=>b.name)}`);Ta(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(b=>b.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const b of this.outputs){const x=b.nodeIndex,w=b.tensorIndex;this.outputLayers.push(b.sourceLayer),this.outputLayersNodeIndices.push(x),this.outputLayersTensorIndices.push(w)}for(const b of this.inputs){const v=b.sourceLayer,x=b.nodeIndex,w=b.tensorIndex;Vs(0===x,"input layer has >1 nodes"),Vs(0===w,"input layer has >1 tensors"),this.inputLayers.push(v),this.inputLayersNodeIndices.push(x),this.inputLayersTensorIndices.push(w)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let b=0;b<this.inputLayers.length;b++){const v=this.inputLayers[b];if(!(v instanceof eb))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${n.inputs}. Input ${b} (0-based) originates from layer type ${v.getClassName()}.`);this.inputNames.push(v.name),this.feedInputShapes.push(v.batchInputShape),this.feedInputNames.push(v.name)}for(const b of this.outputLayers)this.outputNames.push(b.name);this.internalInputShapes=this.inputs.map(b=>b.shape),this.internalOutputShapes=this.outputs.map(b=>b.shape);const e={},r={},s={},o={},i={},a=[],l=(b,v,x,w,C,I)=>{(null==w||null==C||null==I)&&(w=b.sourceLayer,C=b.nodeIndex,I=b.tensorIndex);const D=w.inboundNodes[C];if(-1!==x.indexOf(D))throw new co(`The tensor ${b.name} at layer "${w.name}" is part of a cycle.`);if(-1!==v.indexOf(D))return;this.containerNodes.add(Mo.nodeKey(w,C)),w.id in i||(i[w.id]=Object.keys(i).length),-1===x.indexOf(D)&&x.push(D);const E=D.inboundLayers.length;for(let N=0;N<E;N++)l(D.inputTensors[N],v,x,D.inboundLayers[N],D.nodeIndices[N],D.tensorIndices[N]);for(v.push(D);x.indexOf(D)>=0;)x.splice(x.indexOf(D),1);a.push(D)},u=[],c=[];for(const b of this.outputs)l(b,u,c);const d=a.slice().reverse();for(const b of d){r[b.id]=b,b.id in e||(e[b.id]=0);let v=e[b.id];v=Math.max(v,null==s[b.outboundLayer.id]?0:s[b.outboundLayer.id]),s[b.outboundLayer.id]=v,o[b.outboundLayer.id]=b.outboundLayer,e[b.id]=v;for(let w=0;w<b.inboundLayers.length;w++){const D=b.inboundLayers[w].inboundNodes[b.nodeIndices[w]];e[D.id]=Math.max(v+1,null==e[D.id]?0:e[D.id]),r[D.id]=D}}const h={};for(const b in e){const v=e[b];v in h||(h[v]=[]),h[v].push(r[b])}const p={};for(const b in s){const v=s[b];v in p||(p[v]=[]),p[v].push(o[b])}let f=Object.keys(p).map(b=>parseInt(b,10)).sort(Hy);this.layers=[];for(const b of f){const v=p[b];v.sort((x,w)=>{const C=i[x.id],I=i[w.id];return C<I?-1:C>I?1:0});for(const x of v)x instanceof Mo&&this.internalContainerRefs.push(x),this.layers.push(x)}this.layersByDepth=p,f=Object.keys(h).map(b=>parseInt(b,10)).sort(Hy);const g=this.inputs.slice(),m=[];for(const b of f)for(const v of h[b]){const x=v.outboundLayer;if(null!=x){for(const w of v.inputTensors)if(-1===g.indexOf(w))throw new co(`Graph disconnected: cannot obtain value for tensor ${w} at layer "${x.name}". The following previous layers were accessed without issue: ${m}`);for(const w of v.outputTensors)g.push(w);m.push(x.name)}}this.nodesByDepth=h;const y=this.layers.map(b=>b.name);for(const b of y){const v=y.filter(x=>x===b).length;if(1!==v)throw new co(`The name "${b}" is used ${v} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(y))}this.outboundNodes=[],this.inboundNodes=[],new Jy({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(b=>null),outputMasks:this.outputs.map(b=>null),inputShapes:this.inputs.map(b=>b.shape),outputShapes:this.outputs.map(b=>b.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const n={refCountAfterDispose:null,numDisposedVariables:0};if(0==--this._refCount){for(const e of this.layers)n.numDisposedVariables+=e.dispose().numDisposedVariables;for(const e of this.internalContainerRefs)n.numDisposedVariables+=e.dispose().numDisposedVariables}return n.refCountAfterDispose=this._refCount,n}get trainable(){return this.trainable_}set trainable(n){this.layers.forEach(e=>{e._trainableWeights.forEach(r=>r.trainable=n)}),this.trainable_=n}get trainableWeights(){if(this._trainableWeights.length>0)throw new A("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let n=[];for(const e of this.layers)n=n.concat(e.trainableWeights);return n}get nonTrainableWeights(){const n=[];for(const e of this.layers)n.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const r of this.layers)e.push(...r.trainableWeights);return e.concat(n)}return n}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(n,e=!0){const r={};let s=0;for(const i of this.layers)for(const a of i.weights){if(null!=r[a.originalName])throw new A(`Duplicate weight name: ${a.originalName}`);r[a.originalName]=a,s++}const o=[];for(const i in n){let a=i;if(null==r[i]){const l=i.split("/");a=l.slice(0,-2).concat([l[l.length-1]]).join("/")}if(null!=r[a])o.push([r[a],n[i]]);else if(e)throw new A(`Provided weight data has no target variable: ${i}`);delete r[a]}if(e){const i=[];for(const a in r)i.push(a);if(i.length>0)throw new A(`${i.length} of ${s} weights are not set: ${i}`)}JS(o)}updatedConfig(){const n=this.getConfig(),e={};return e.className=this.getClassName(),e.config=n,e.kerasVersion="tfjs-layers 4.3.0",e.backend="TensorFlow.js",e}toJSON(n,e=!0){const r=iI(this.updatedConfig());return e?JSON.stringify(r):r}call(n,e){return $(()=>{n=sn(n);const r=new ka;for(let s=0;s<this.inputs.length;++s)r.add(this.inputs[s],n[s]);return kp(this.outputs,r,e)})}computeMask(n,e){return $(()=>{let r;return n=sn(n),r=null==e?Ml(null,n.length):sn(e),this.runInternalGraph(n,r)[1]})}computeOutputShape(n){const e=Zy(n);if(e.length!==this.inputLayers.length)throw new A(`Invalid inputShape argument ${n}: model has ${this.inputLayers.length} tensor inputs.`);const r={};for(let a=0;a<e.length;a++)r[this.inputLayers[a].name+"_0_0"]=e[a];const s=Object.keys(this.nodesByDepth).map(a=>parseInt(a,10)).sort(Hy);if(s.length>1)for(const a of s){const l=this.nodesByDepth[a];for(const u of l){const c=u.outboundLayer;if(-1!==this.inputLayers.map(g=>g.id).indexOf(c.id))continue;const d=[];for(let g=0;g<u.inboundLayers.length;g++)d.push(r[`${u.inboundLayers[g].name}_${u.nodeIndices[g]}_${u.tensorIndices[g]}`]);const p=Zy(c.computeOutputShape(ls(d))),f=c.inboundNodes.indexOf(u);for(let g=0;g<p.length;g++)r[`${c.name}_${f}_${g}`]=p[g]}}const o=[],i=[];for(let a=0;a<this.outputLayers.length;a++)i.push(`${this.outputLayers[a].name}_${this.outputLayersNodeIndices[a]}_${this.outputLayersTensorIndices[a]}`);for(let a=0;a<i.length;a++){const l=i[a];Vs(l in r),o.push(r[l])}return ls(o)}runInternalGraph(n,e){null==e&&(e=Ml(null,n.length));const r={};for(let l=0;l<this.inputs.length;++l)r[this.inputs[l].id]=[n[l],e[l]];const s=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(Hy);for(const l of s){const u=this.nodesByDepth[l];for(const c of u){const d=c.outboundLayer,h=c.inputTensors,p=c.outputTensors,f=new Array;for(const g of h)g.id in r&&f.push(r[g.id]);if(f.length===h.length){let m,y,b,v,g={};if(null!=c.callArgs&&(g=c.callArgs),1===f.length){const[x,w]=f[0];null==g.mask&&(g.mask=w),b=sn(d.call(x,g)),v=sn(d.computeMask(x,w)),m=[x],y=[w]}else m=f.map(x=>x[0]),y=f.map(x=>x[1]),null==g.mask&&(g.mask=y),b=sn(d.call(m,g)),v=sn(d.computeMask(m,y));if(d.activityRegularizer)throw new lt("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let x=0;x<p.length;++x)r[p[x].id]=[b[x],v[x]]}}}const o=[],i=[],a=[];for(const l of this.outputs){Vs(l.id in r,`Could not compute output ${l.name} : ${l.id}`);const[u,c]=r[l.id];a.push(u.shape),o.push(u),i.push(c)}return[o,i,a]}buildNodeConversionMap(n){const e={};let r;for(const s of this.layers){r=s instanceof Mo?1:0;for(let o=0;o<s.inboundNodes.length;o++){const i=Mo.nodeKey(s,o);this.containerNodes.has(i)&&(e[i]=r,r+=1)}}return e}getLayer(n,e){if(null!=e){if(this.layers.length<=e)throw new A(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}if(null==n)throw new A("Provide either a layer name or layer index");for(const r of this.layers)if(r.name===n)return r;throw new A(`No such layer: ${n}`)}calculateLosses(){return $(()=>{const n=[];for(const e of this.layers)for(let r=0;r<e.inboundNodes.length;++r){const s=Mo.nodeKey(e,r);this.containerNodes.has(s)&&n.push(...e.calculateLosses())}return n})}getConfig(){const n={name:this.name},e=this.buildNodeConversionMap(this.layers),r=[];for(const i of this.layers){const a=i.getClassName(),l=i.getConfig(),u=[];for(let d=0;d<i.inboundNodes.length;d++){const h=i.inboundNodes[d],p=Mo.nodeKey(i,d);let f={};if(this.containerNodes.has(p)){if(h.callArgs)try{JSON.stringify(h.callArgs),f=h.callArgs}catch{console.warn(`Layer ${i.name} was passed non-serializable keyword arguments: ${h.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),f={}}if(h.inboundLayers.length>0){const g=[];for(let m=0;m<h.inboundLayers.length;m++){const y=h.inboundLayers[m],v=h.tensorIndices[m];let w=e[Mo.nodeKey(y,h.nodeIndices[m])];null==w&&(w=0),g.push([y.name,w,v,f])}u.push(g)}}}const c={};c.name=i.name,c.className=a,c.config=l,c.inboundNodes=u,r.push(c)}n.layers=r;const s=[];for(let i=0;i<this.inputLayers.length;i++){const a=this.inputLayers[i],u=Mo.nodeKey(a,this.inputLayersNodeIndices[i]);if(!this.containerNodes.has(u))continue;let c=e[u];null==c&&(c=0),s.push([a.name,c,this.inputLayersTensorIndices[i]])}n.inputLayers=s;const o=[];for(let i=0;i<this.outputLayers.length;i++){const a=this.outputLayers[i],u=Mo.nodeKey(a,this.outputLayersNodeIndices[i]);if(!this.containerNodes.has(u))continue;let c=e[u];null==c&&(c=0),o.push([a.name,c,this.outputLayersTensorIndices[i]])}return n.outputLayers=o,n}static fromConfig(n,e,r={},s=!1){const o={},i={};function a(m,y){m.name in i?i[m.name].push(y):i[m.name]=[y]}function l(m,y){const b=[];let v;for(const x of y){const w=x[0],C=x[1],I=x[2];if(v=null==x[3]?{}:x[3],!(w in o))return void a(m,y);const D=o[w];if(D.inboundNodes.length<=C)return void a(m,y);b.push(D.inboundNodes[C].outputTensors[I])}b.length>0&&m.apply(ls(b),v)}function u(m){const y=m.name,b=hi(m,null!=e.customObjects?e.customObjects:{});b.setFastWeightInitDuringBuild(s),o[y]=b,m.inboundNodes.forEach(x=>{if(!(x instanceof Array))throw new A(`Corrupted configuration, expected array for nodeData: ${x}`);a(b,x)})}const c=e.name,d=e.layers;for(const m of d)u(m);for(;!Noe(i);)for(const m of d){const y=o[m.name];if(y.name in i){const b=i[y.name];delete i[y.name];for(const v of b)l(y,v)}}const h=[],p=[],f=e.inputLayers;for(const m of f){const y=m[0],b=m[1],v=m[2];Vs(y in o),h.push(o[y].inboundNodes[b].outputTensors[v])}const g=e.outputLayers;for(const m of g){const y=m[0],b=m[1],v=m[2];Vs(y in o),p.push(o[y].inboundNodes[b].outputTensors[v])}return new n({inputs:h,outputs:p,name:c})}get stateful(){if(this._stateful)throw new A("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const n of this.layers)if(n.stateful)return!0;return!1}resetStates(){$(()=>{this.layers.forEach(n=>{n.stateful&&n.resetStates()})})}}function I$(t,n){return function S$(t,n,e){const r=n.length;if(null==t||Array.isArray(t)&&0===t.length)return n.map(s=>null);if(1===r)return Array.isArray(t)&&1===t.length?t:"object"==typeof t&&n[0]in t?[t[n[0]]]:[t];if(Array.isArray(t)){if(t.length!==r)throw new Error(`Provided ${e} is an array of ${t.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return t}if("object"==typeof t&&Object.keys(t).length>0&&"object"==typeof t[Object.keys(t)[0]]){const s=[];return n.forEach(o=>{s.push(o in t?t[o]:null)}),s}throw new Error(`The model has multiple (${r}) outputs, so ${e} must be either an array with ${r} elements or an object with ${n} keys. Provided ${e} not understood: ${JSON.stringify(t)}`)}(t,n,"classWeight")}function D$(t,n,e,r){return lI.apply(this,arguments)}function lI(){return(lI=J(function*(t,n,e,r){if(null!=n||null!=r)throw new Error("Support sampleWeight is not implemented yet");if(null!=e){const s=$(()=>{if(1===t.shape.length)return Dl(t);if(2===t.shape.length){if(t.shape[1]>1)return hp(t,1);if(1===t.shape[1])return M(t,[t.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${t.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}throw new Error(`Unexpected rank of target (y) tensor (${t.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),o=Array.from(yield s.data());ft(s);const i=[];return o.forEach(a=>{if(null==e[a])throw new Error(`classWeight must contain all classes in the training data. The class ${a} exists in the data but not in classWeight`);i.push(e[a])}),vs(i,"float32")}return null})).apply(this,arguments)}function Gie(t,n){return k(t,n)}const Hie=32;function T$(t,n){let e,r;e=n.xs,r=n.ys,_(null!=e&&null!=r,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${n}`);const o=E$("input",t.inputNames,e),i=E$("output",t.outputNames,r),a=o[0].shape[0];_(o.length===t.inputs.length,()=>`LayersModel has ${t.inputs.length} inputs, but the dataset provides ${o.length} inputs.  (Expected input keys: ${JSON.stringify(t.inputNames)})`),_(i.length===t.outputs.length,()=>`LayersModel has ${t.outputs.length} outputs, but the dataset provides ${i.length} outputs.  (Expected output keys: ${JSON.stringify(t.outputNames)})`);for(let l=0;l<o.length;l++)_(o[l].shape[0]===a,()=>`Batch size mismatch: input ${t.inputNames[l]} has ${o[l].shape[0]}; expected  ${a} based on input ${t.inputNames[0]}.`);for(let l=0;l<i.length;l++)_(i[l].shape[0]===a,()=>`Batch size mismatch: output ${t.outputNames[l]} has ${i[l].shape[0]}; expected  ${a} based on input ${t.inputNames[0]}.`);return{xs:o,ys:i}}function E$(t,n,e){if(e instanceof Hn)return[e];if(Array.isArray(e))return _(e.length===n.length,()=>`Received an array of ${e.length} Tensors, but expected ${n.length} to match the ${t} keys ${n}.`),e;{const r=[];for(const s of n){if(null==e[s])throw new A(`The feature data generated by the dataset lacks the required ${t} key '${s}'.`);r.push(e[s])}return r}}function uI(){return(uI=J(function*(t,n,e){const r=null!=e.batchesPerEpoch;if(_(null!=t.optimizer,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),_(null!=e,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),_(null!=e.epochs&&e.epochs>0&&Number.isInteger(e.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${e.epochs}`),_(!r||e.batchesPerEpoch>0&&Number.isInteger(e.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${e.batchesPerEpoch}`),_(null==e.validationSplit,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),t.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");t.isTraining=!0;try{const s=null!=e.validationData;let o,i;if(s)if(N$(e.validationData))_(null==e.validationBatches||e.validationBatches>0&&Number.isInteger(e.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${e.validationBatches}`);else{const m=function jie(t){if(3===t.length)throw new lt("Validation with sample weights is not implemented yet.");return{xs:t[0],ys:t[1]}}(e.validationData);o=m.xs,i=m.ys}const a=t.makeTrainFunction(),l=t.getDedupedMetricsNames();let u;u=s?l.slice().concat(l.map(m=>"val_"+m)):l.slice();const c=p$(e.callbacks,e.yieldEvery),d=null==e.verbose?1:e.verbose,{callbackList:h,history:p}=f$(c,d,e.epochs,null,null,function Kie(t,n){let e=null;return null!=n.batchesPerEpoch?e=n.batchesPerEpoch:Number.isFinite(t.size)&&(e=t.size),e}(n,e),null,s,u);h.setModel(t),t.history=p,yield h.onTrainBegin(),t.stopTraining_=!1;let f=null==e.initialEpoch?0:e.initialEpoch,g=yield n.iterator();for(;f<e.epochs;){const m={};yield h.onEpochBegin(f);let y=0,b=0;for(r||(g=yield n.iterator());!r||y<e.batchesPerEpoch;){const v=yield g.next();if(r&&v.done){console.warn(`You provided \`batchesPerEpoch\` as ${e.batchesPerEpoch}, but your dataset iterator ran out of data after ${y} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${e.batchesPerEpoch*e.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(null!=v.value){const{xs:x,ys:w}=T$(t,v.value),C={};C.batch=b,C.size=x[0].shape[0],yield h.onBatchBegin(b,C);const I=[];if(null!=e.classWeight){const N=I$(e.classWeight,t.outputNames);for(let P=0;P<N.length;++P)I.push(yield D$(w[P],null,N[P]))}const D=x.concat(w).concat(I),E=a(D);ft(D);for(let N=0;N<l.length;++N){const V=E[N];C[l[N]]=V,si(V)}yield h.onBatchEnd(b,C),h$(C),b++,y++}if(r?y>=e.batchesPerEpoch:v.done){if(s){let x;x=N$(e.validationData)?sn(yield t.evaluateDataset(e.validationData,{batches:e.validationBatches})):sn(t.evaluate(o,i,{batchSize:null==e.validationBatchSize?Hie:e.validationBatchSize,verbose:0}));for(let w=0;w<t.metricsNames.length;++w)m[`val_${t.metricsNames[w]}`]=x[w]}break}if(t.stopTraining_)break}if(yield h.onEpochEnd(f,m),f++,t.stopTraining_)break}return yield h.onTrainEnd(),yield t.history.syncData(),t.history}finally{t.isTraining=!1}})).apply(this,arguments)}function N$(t){return"function"==typeof t.iterator}function cI(){return(cI=J(function*(t,n,e){const r=null!=(e=e||{}).batches,s=t.testFunction;let o=[];if(e.verbose>0)throw new lt("Verbose mode is not implemented yet.");_(!r||e.batches>0&&Number.isInteger(e.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(e.batches)}`);const i=function Xie(t){return"function"==typeof t.next}(n)?n:yield n.iterator();let a=0,l=0;for(;!r||l<e.batches;){const u=yield i.next();if(o=$(()=>{if(u.value){const{xs:c,ys:d}=T$(t,u.value),h=c.concat(d),p=$(()=>s(h));if(ft(h),0===l)for(let g=0;g<p.length;++g)o.push(rt(0));const f=h[0].shape[0];for(let g=0;g<p.length;++g){const m=p[g],y=o[g];o[g]=$(()=>ie(o[g],k(f,m))),l>0&&ft(y)}ft(p),a+=f,++l}return o}),u.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${e.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let u=0;u<o.length;++u){const c=o[u];o[u]=Oe(o[u],a),ft(c)}return ls(o)})).apply(this,arguments)}function dI(t){_(t>0&&Number.isInteger(t),()=>`batchSize is required to be a positive integer, but got ${t}`)}function Fp(t,n,e){return null==t?[null]:Array.isArray(t)?t.map(r=>Ll(r,n,e-n)):Ll(t,n,e-n)}function hI(t,n){return $(()=>null==t?null:Array.isArray(t)?t.map(e=>hI(e,n)):YO(t,"int32"===n.dtype?n:xe(n,"int32")))}function pI(t,n){const e=[];let r=0,s=null;for(;r<t;)s=r+n,s>=t&&(s=t),e.push([r,s]),r=s;return e}function k$(t){const n=[];t instanceof Hn&&(t=[t]);for(let e=0;e<t.length;++e){const r=t[e];if(1===r.rank)n.push(Tp(r,1));else{if(0===r.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");n.push(r)}}return n}function Po(t,n){if(null==t)return;const e=[];if(n instanceof Hn)e.push(n.id);else if(Array.isArray(n))n.forEach(s=>e.push(s.id));else if(null!=n)for(const s in n)e.push(n[s].id);const r=[];if(t instanceof Hn)-1===e.indexOf(t.id)&&r.push(t);else if(Array.isArray(t))t.forEach(s=>{-1===e.indexOf(s.id)&&r.push(s)});else if(null!=t)for(const s in t){const o=t[s];-1===e.indexOf(o.id)&&r.push(o)}r.forEach(s=>{s.isDisposed||s.dispose()})}function fI(t){return Array.isArray(t)}function A$(t){return!function Zie(t){return t instanceof Hn}(t)&&!fI(t)}function R$(t,n,e,r=!0,s=""){if(null==n||0===n.length){if(null!=t){let i=!1;if(fI(t)&&t.length>0)i=!0;else if(A$(t)){for(const a in t)if(t.hasOwnProperty(a)){i=!0;break}}else i=!0;if(i)throw new A(`Error when checking model ${s} expected no data, but got ${t}`)}return[]}if(null==t)return n.map(i=>null);let o;if(A$(t)){o=[];for(const i of n){if(null==t[i])throw new A(`No data provided for "${i}". Need data for each key in: ${n}`);o.push(t[i])}}else if(fI(t)){if(t.length!==n.length)throw new A(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${n.length} Tensor(s), but instead got the following list of Tensor(s): ${t}`);o=t}else{if(n.length>1)throw new A(`The model ${s} expects ${n.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${t.shape}`);o=[t]}if(o=k$(o),null!=e)for(let i=0;i<n.length;++i){if(null==e[i])continue;const a=o[i];if(a.shape.length!==e[i].length)throw new A(`Error when checking ${s}: expected ${n[i]} to have ${e[i].length} dimension(s). but got array with shape ${a.shape}`);for(let l=0;l<e[i].length;++l){if(0===l&&!r)continue;const c=e[i][l];if(null!=c&&c>=0&&a.shape[l]!==c)throw new A(`${s} expected a batch of elements where each example has shape [${e[i].slice(1,e[i].length)}] (i.e.,tensor shape [*,${e[i].slice(1,e[i].length)}]) but the ${s} received an input with ${a.shape[0]} examples, each with shape [${a.shape.slice(1,a.shape.length)}] (tensor shape [${a.shape}])`)}}return o}function F$(t,n,e,r=!0,s=""){let o;if(Array.isArray(t)){if(t.length!==n.length)throw new A(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${n.length} Tensor(s), but instead got ${t.length} Tensors(s).`);o=t}else{if(n.length>1)throw new A(`The model expects ${n.length} ${s} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(t.shape)}.`);o=[t]}if(null!=e)for(let i=0;i<n.length;++i){if(null==e[i])continue;const a=o[i];if(a.shape.length!==e[i].length)throw new A(`Error when checking ${s}: expected ${n[i]} to have ${e[i].length} dimension(s), but got array with shape ${JSON.stringify(a.shape)}`);for(let l=0;l<e[i].length;++l){if(0===l&&!r)continue;const c=e[i][l];if(null!=c&&c!==a.shape[l])throw new A(`Error when checking ${s}: expected ${n[i]} to have shape ${JSON.stringify(e[i])} but got array with shape ${JSON.stringify(a.shape)}.`)}}}let wc=(()=>{class t extends Mo{constructor(e){super(e),this.isTraining=!1}summary(e,r,s=console.log){if(!this.built)throw new A("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");!function Vie(t,n,e,r=console.log){const s=function zie(t){let n=!0;const e=[],r=[];for(const s in t.nodesByDepth)e.push(t.nodesByDepth[s]);for(const s of e){if(s.length>1||1===s.length&&s[0].inboundLayers.length>1){n=!1;break}r.push(...s)}if(n)for(const s of t.layers){let o=!1;for(const i of s.inboundNodes)if(-1!==r.indexOf(i)){if(o){n=!1;break}o=!0}if(!n)break}return n}(t),o=["Layer (type)","Input Shape","Output shape","Param #"];let i;if(s?(n=n||90,e=e||[.32,.61,.89,1]):(n=n||115,e=e||[.24,.48,.7,.8,1]),e[e.length-1]<=1&&(e=e.map(c=>Math.floor(n*c))),!s){o.push("Receives inputs"),i=[];for(const c in t.nodesByDepth)i.push(...t.nodesByDepth[c])}r("_".repeat(n)),cb(o,e,r),r("=".repeat(n));const a=t.layers;for(let c=0;c<a.length;++c)s?Uie(a[c],e,r):Wie(a[c],e,i,r),r((c===a.length-1?"=":"_").repeat(n));t.checkTrainableWeightsConsistency();const l=function Bie(t){let n;return n=Qy(null!=t.collectedTrainableWeights?t.collectedTrainableWeights:t.trainableWeights),n}(t),u=Qy(t.nonTrainableWeights);r(`Total params: ${l+u}`),r(`Trainable params: ${l}`),r(`Non-trainable params: ${u}`),r("_".repeat(n))}(this,e,r,s)}compile(e){if(null==e.loss&&(e.loss=[]),this.loss=e.loss,"string"==typeof e.optimizer)this.optimizer_=function Lie(t){const n={Adagrad:()=>yc.adagrad(.01),Adadelta:()=>yc.adadelta(1,.95,Jn()),Adam:()=>yc.adam(.001,.9,.999,Jn()),Adamax:()=>yc.adamax(.002,.9,.999,Jn(),0),RMSProp:()=>yc.rmsprop(.001,.9,0,Jn()),SGD:()=>yc.sgd(.01)};if(n.adagrad=n.Adagrad,n.adadelta=n.Adadelta,n.adam=n.Adam,n.adamax=n.Adamax,n.rmsprop=n.RMSProp,n.sgd=n.SGD,t in n)return n[t]();throw new A(`Unknown Optimizer ${t}`)}(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof xa))throw new A("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let r=[];if(Array.isArray(e.loss)||"string"==typeof e.loss||"function"==typeof e.loss)if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new A(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);r=e.loss.map(l=>sI(l))}else{const a=sI(e.loss);this.outputs.forEach(l=>{r.push(a)})}else{e.loss=e.loss;for(const a in e.loss)if(-1===this.outputNames.indexOf(a))throw new A(`Unknown entry in loss dictionary: "${a}". Only expected the following keys: ${this.outputNames}`);for(const a of this.outputNames)null==e.loss[a]&&console.warn(`Output "${a}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${a} during training`),r.push(sI(e.loss[a]))}this.lossFunctions=r,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let a=0;a<this.outputs.length;++a){const l=this.internalOutputShapes[a];this.feedOutputNames.push(this.outputNames[a]),this.feedOutputShapes.push(l),this.feedLossFns.push(this.lossFunctions[a])}const s=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],$l("loss",()=>{for(let a=0;a<this.outputs.length;++a)-1===s.indexOf(a)&&this.outputs.length>1&&(this.metricsTensors.push([this.lossFunctions[a],a]),this.metricsNames.push(this.outputNames[a]+"_loss"))});const o=function eae(t,n){if(null==t||Array.isArray(t)&&0===t.length)return n.map(r=>[]);let e;if("string"==typeof t||"function"==typeof t)e=[t];else{if(!Array.isArray(t)&&"object"!=typeof t)throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${t}`);e=t}if(Array.isArray(e))return n.map(r=>e);{const r=[];for(const s of n){let o=e.hasOwnProperty(s)?e[s]:[];Array.isArray(o)||(o=[o]),r.push(o)}return r}}(e.metrics,this.outputNames),i=(a,l,u)=>{this.outputNames.length>1&&(l=this.outputNames[a]+"_"+l),this.metricsNames.push(l),this.metricsTensors.push([u,a])};$l("metric",()=>{for(let a=0;a<this.outputs.length;++a)-1===s.indexOf(a)&&(c=>{let h,p,f;for(const g of c){if("string"==typeof g&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(g)){const y=this.internalOutputShapes[a];let b;1===y[y.length-1]||this.lossFunctions[a]===ib?-1!==["accuracy","acc"].indexOf(g)?p=g$:-1!==["crossentropy","ce"].indexOf(g)&&(p=Eie):this.lossFunctions[a]===ob?-1!==["accuracy","acc"].indexOf(g)?p=Nie:-1!==["crossentropy","ce"].indexOf(g)&&(p=x$):-1!==["accuracy","acc"].indexOf(g)?p=y$:-1!==["crossentropy","ce"].indexOf(g)&&(p=v$),-1!==["accuracy","acc"].indexOf(g)?b="acc":-1!==["crossentropy","ce"].indexOf(g)&&(b="ce"),f=p,h=""+b}else f=$ie(g),h=""+ub(g);let m;$l(h,()=>{m=f}),i(a,h,m)}})(o[a])}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,r,s={}){const o=null==s.batchSize?32:s.batchSize;dI(o);const a=this.standardizeUserDataXY(e,r,!0,o);try{const l=a[0].concat(a[1]);return this.makeTestFunction(),ls(this.testLoop(this.testFunction,l,o,s.verbose,s.steps))}finally{Po(a[0],e),Po(a[1],r)}}evaluateDataset(e,r){var s=this;return J(function*(){return s.makeTestFunction(),function Yie(t,n,e){return cI.apply(this,arguments)}(s,e,r)})()}checkNumSamples(e,r,s,o="steps"){let i;if(null!=s){if(i=null,null!=r)throw new A(`If ${o} is set, batchSize must be null or undefined.Got batchSize = ${r}`)}else{if(null==e)throw new A(`Either the input data should have a defined shape, or ${o} shoud be specified.`);i=Array.isArray(e)?e[0].shape[0]:e.shape[0]}return i}execute(e,r){if(Array.isArray(r)&&0===r.length)throw new A("`outputs` is an empty Array, which is not allowed.");const s=Array.isArray(r),i=this.retrieveSymbolicTensors(s?r:[r]),a=new ka;if(e instanceof Hn&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new A(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let u=0;u<this.inputs.length;++u)a.add(this.inputs[u],e[u])}else for(const u of this.inputs){const c=e[u.name];if(null==c)throw new A(`No value is provided for the model's input ${u.name}`);a.add(u,c)}const l=kp(i,a);return s?l:l[0]}retrieveSymbolicTensors(e){const r=Ml(null,e.length);let s=e.length;for(const o of this.layers){const i=Array.isArray(o.output)?o.output:[o.output],a=i.map(l=>l.name);for(let l=0;l<e.length;++l){const u=a.indexOf(e[l]);if(-1!==u&&(r[l]=i[u],s--),0===s)break}if(0===s)break}if(s>0){const o=[];throw r.forEach((i,a)=>{null==i&&o.push(e[a])}),new A(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(o)}`)}return r}predictLoop(e,r=32,s=!1){return $(()=>{const o=this.checkNumSamples(e);if(s)throw new lt("Verbose predictLoop() is not implemented yet.");const i=pI(o,r),a=this.outputs.map(l=>[]);for(let l=0;l<i.length;++l)$(()=>{const h=Fp(e,i[l][0],i[l][1]),p=[];if(Array.isArray(h))for(let g=0;g<h.length;++g)p.push({key:this.inputs[g],value:h[g]});else p.push({key:this.inputs[0],value:h});const f=new ka(p);return kp(this.outputs,f)}).forEach((c,d)=>a[d].push(c));return ls(a.map(l=>Ar(l,0)))})}predict(e,r={}){const s=k$(e);F$(s,this.inputNames,this.feedInputShapes,!1);try{const o=null==r.batchSize?32:r.batchSize;return dI(o),this.predictLoop(s,o)}finally{Po(s,e)}}predictOnBatch(e){F$(e,this.inputNames,this.feedInputShapes,!0);const r=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,r)}standardizeUserDataXY(e,r,s=!0,o){if(null==this.optimizer_)throw new co("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const i=[];for(let a=0;a<this.feedOutputShapes.length;++a){const l=this.feedOutputShapes[a];i.push(this.feedLossFns[a]===ob?l.slice(0,l.length-1).concat([1]):l)}if(function Qie(t,n,e){const r=Ta(t.map(o=>o.shape[0]));r.sort();const s=Ta(n.map(o=>o.shape[0]));if(s.sort(),r.length>1)throw new A(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(o=>o.shape))}`);if(s.length>1)throw new A(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(n.map(o=>o.shape))}`);if(r.length>0&&s.length>0&&!Bt(r,s))throw new A(`Input Tensors should have the same number of samples as target Tensors. Found ${r[0]} input sample(s) and ${s[0]} target sample(s).`)}(e=R$(e,this.feedInputNames,this.feedInputShapes,!1,"input"),r=R$(r,this.feedOutputNames,i,!1,"target")),function Jie(t,n,e){const r=[sb,ib,Rp];for(let s=0;s<t.length;++s){const o=t[s],i=n[s],a=e[s];if(null!=i){if(i===Rp&&1===o.shape[o.shape.length-1])throw new A(`You are passing a target array of shape ${o.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(-1!==r.indexOf(i)){const l=o.shape.slice(1),u=a.slice(1);for(let c=0;c<l.length;++c){const h=u[c];if(null!=h&&l[c]!==h)throw new A(`A target Tensor with shape ${o.shape} was passed for an output of shape ${a}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}(r,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=o&&o>0&&e[0].shape[0]%o!=0)throw new A(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${o}. Found: ${e[0].shape[0]} sample(s).`);return[e,r]}standardizeUserData(e,r,s,o,i=!0,a){var l=this;return J(function*(){const[u,c]=l.standardizeUserDataXY(e,r,i,a);if(null!=s)throw new Error("sample weight is not supported yet.");let d=null;if(null!=o){const h=I$(o,l.outputNames);d=[];for(let p=0;p<h.length;++p)d.push(yield D$(c[p],null,h[p]))}return[u,c,d]})()}testLoop(e,r,s,o=0,i){return $(()=>{const a=this.checkNumSamples(r,s,i,"steps"),l=[];if(o>0)throw new lt("Verbose mode is not implemented yet.");if(null!=i)throw new lt("steps mode in testLoop() is not implemented yet");{const u=pI(a,s),c=vs(Ao(0,a));for(let d=0;d<u.length;++d){const h=u[d][0],p=u[d][1],f=Ll(c,h,p-h),g=hI(r,f),m=e(g);if(0===d)for(let y=0;y<m.length;++y)l.push(rt(0));for(let y=0;y<m.length;++y)l[y]=ie(l[y],k(p-h,m[y]))}for(let d=0;d<l.length;++d)l[d]=Oe(l[d],a)}return l})}getDedupedMetricsNames(){const e=this.metricsNames,r=[];for(let s=0;s<e.length;++s){const o=e[s];let i=o;VO(e,o)>1&&(i+=`_${VO(e.slice(0,s),o)}`),r.push(i)}return r}makeTrainFunction(){return e=>{const r=[],s=e.slice(0,this.inputs.length),o=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),a=[],u=this.collectedTrainableWeights.map(h=>h.read());return[this.optimizer_.minimize(()=>{const h=[];for(let m=0;m<this.inputs.length;++m)h.push({key:this.inputs[m],value:s[m]});const p=new ka(h),f=kp(this.outputs,p,{training:!0});let g;for(let m=0;m<this.lossFunctions.length;++m){let b=(0,this.lossFunctions[m])(o[m],f[m]);null!=i[m]&&(b=Gie(b,i[m]));const v=Pn(b);r.push(v),g=0===m?b:ie(g,b)}for(let m=0;m<this.metricsTensors.length;++m){let y;if(this.outputs.length>1&&m<this.outputs.length)y=r[m];else{const v=this.metricsTensors[m][1];y=Pn((0,this.metricsTensors[m][0])(o[v],f[v]))}si(y),a.push(y)}return g=Pn(g),this.calculateLosses().forEach(m=>{g=ie(g,m)}),g},!0,u)].concat(a)}}makeTestFunction(){this.testFunction=e=>$(()=>{const r=[];let s;const o=e.slice(0,this.inputs.length),i=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=[];for(let c=0;c<this.inputs.length;++c)a.push({key:this.inputs[c],value:o[c]});const l=new ka(a),u=kp(this.outputs,l);for(let c=0;c<this.lossFunctions.length;++c){const h=Pn((0,this.lossFunctions[c])(i[c],u[c]));s=0===c?h:ie(s,h),r.push(s)}for(let c=0;c<this.metricsTensors.length;++c){const h=this.metricsTensors[c][1],p=Pn((0,this.metricsTensors[c][0])(i[h],u[h]));r.push(p)}return r})}fit(e,r,s={}){var o=this;return J(function*(){if(o.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");let i,a,l,u,c,d,h,p,f;o.isTraining=!0;try{const g=null==s.batchSize?32:s.batchSize;dI(g);const m=!1,y=yield o.standardizeUserData(e,r,s.sampleWeight,s.classWeight,m,g);i=y[0],a=y[1],f=y[2];let v,b=!1;if(null!=s.validationData&&s.validationData.length>0){if(b=!0,2!==s.validationData.length)throw 3===s.validationData.length?new lt("validationData including sample weights is not supported yet."):new A(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${s.validationData} is invalid.`);c=s.validationData[0],d=s.validationData[1];const P=!0,V=yield o.standardizeUserData(c,d,null,null,P,g);h=V[0],p=V[1],v=h.concat(p)}else if(null!=s.validationSplit&&s.validationSplit>0&&s.validationSplit<1){b=!0;const P=Math.floor(i[0].shape[0]*(1-s.validationSplit)),V=i[0].shape[0];h=Fp(i,P,V),l=i,i=Fp(i,0,P),p=Fp(a,P,V),u=a,a=Fp(a,0,P),v=h.concat(p)}else null!=s.validationSteps&&(b=!0);const x=i.concat(a).concat(f);o.checkTrainableWeightsConsistency();const w=o.makeTrainFunction(),C=o.getDedupedMetricsNames();let I,D;b?(o.makeTestFunction(),I=o.testFunction,D=C.slice().concat(C.map(P=>"val_"+P))):(I=null,v=[],D=C.slice());const E=p$(s.callbacks,s.yieldEvery);return yield o.fitLoop(w,x,C,g,s.epochs,s.verbose,E,I,v,s.shuffle,D,s.initialEpoch,null,null)}finally{o.isTraining=!1,Po(i,e),Po(a,r),Po(l,e),Po(u,r),Po(h,c),Po(p,d),null!=f&&ft(f)}})()}fitLoop(e,r,s,o,i,a,l,u,c,d,h,p,f,g){var m=this;return J(function*(){null==o&&(o=32),null==i&&(i=1),null==d&&(d=!0),null==p&&(p=0);let y=!1;if(null!=u&&null!=c&&(y=!0),null!=g&&(y=!0,null==f))throw new A("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const b=m.checkNumSamples(r,o,f,"steps_per_epoch");let v;null!=b&&(v=Ao(0,b)),null==a&&(a=1);const{callbackList:x,history:w}=f$(l,a,i,p,b,f,o,y,h);x.setModel(m),m.history=w,yield x.onTrainBegin(),m.stopTraining_=!1;for(let C=p;C<i;++C){yield x.onEpochBegin(C);const I={};if(null!=f)throw new lt("stepsPerEpoch mode is not implemented yet.");{if("batch"===d)throw new lt("batch shuffling is not implemneted yet");d&&HF(v);const D=vs(v),E=pI(b,o);for(let N=0;N<E.length;++N){const P={};if(yield x.onBatchBegin(N,P),$(()=>{const V=E[N][0],B=E[N][1],z=Ll(D,V,B-V);P.batch=N,P.size=B-V;const U=hI(r,z),j=e(U);for(let q=0;q<s.length;++q){const K=j[q];P[s[q]]=K,si(K)}if(N===E.length-1&&y){const q=m.testLoop(u,c,o);for(let W=0;W<s.length;++W){const K=s[W],ne=q[W];si(ne),I["val_"+K]=ne}}}),yield x.onBatchEnd(N,P),h$(P),m.stopTraining_)break}D.dispose()}if(yield x.onEpochEnd(C,I),m.stopTraining_)break}return yield x.onTrainEnd(),yield m.history.syncData(),m.history})()}fitDataset(e,r){var s=this;return J(function*(){return function qie(t,n,e){return uI.apply(this,arguments)}(s,e,r)})()}trainOnBatch(e,r){var s=this;return J(function*(){const o=yield s.standardizeUserData(e,r),i=o[0],a=o[1],u=s.makeTrainFunction()(i.concat(a)),c=[];for(const d of u){const h=yield d.data();c.push(h[0])}return ft(u),Po(o[0],e),Po(o[1],r),ls(c)})()}getNamedWeights(e){const r=[],s=null!=e&&e.trainableOnly,o=s?this.trainableWeights:this.weights,i=this.getWeights(s);for(let a=0;a<o.length;++a)s&&!o[a].trainable||r.push({name:o[a].originalName,tensor:i[a]});return r}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(0===e.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const r=T_().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=r-T_().numTensors}return e}getLossIdentifiers(){let e;if("string"==typeof this.loss)e=qi(this.loss);else if(Array.isArray(this.loss)){for(const r of this.loss)if("string"!=typeof r)throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(r=>qi(r))}else{const r=Object.keys(this.loss);e={};const s=this.loss;for(const o of r){if("string"!=typeof s[o])throw new Error("Serialization of non-string loss is not supported.");e[o]=qi(s[o])}}return e}getMetricIdentifiers(){if("string"==typeof this.metrics||"function"==typeof this.metrics)return[qi(ub(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>qi(ub(e)));{const e={};for(const r in this.metrics)e[r]=qi(ub(this.metrics[r]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(null!=e.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=e.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=e.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const s=hi(db(e.optimizer_config));let o,i;if("string"==typeof e.loss)o=Pl(e.loss);else if(Array.isArray(e.loss))o=e.loss.map(a=>Pl(a));else if(null!=e.loss){o={};for(const a in e.loss)o[a]=Pl(e.loss[a])}if(Array.isArray(e.metrics))i=e.metrics.map(a=>Pl(a));else if(null!=e.metrics){i={};for(const a in e.metrics)i[a]=Pl(e.metrics[a])}this.compile({loss:o,metrics:i,optimizer:s})}save(e,r){var s=this;return J(function*(){if("string"==typeof e){const d=(t=>wn.getSaveHandlers(t))(e);if(0===d.length)throw new A(`Cannot find any save handlers for URL '${e}'`);if(d.length>1)throw new A(`Found more than one (${d.length}) save handlers for URL '${e}'`);e=d[0]}if(null==e.save)throw new A("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const o=yield MM(s.getNamedWeights(r)),u={modelTopology:s.toJSON(null,!1),format:"layers-model",generatedBy:"TensorFlow.js tfjs-layers v4.3.0",convertedBy:null};if(null!=r&&r.includeOptimizer&&null!=s.optimizer){u.trainingConfig=s.getTrainingConfig();const d="optimizer",{data:h,specs:p}=yield MM(yield s.optimizer.getWeights(),d);o.specs.push(...p),o.data=g_([o.data,h])}return null!=s.userDefinedMetadata&&(C$(s.userDefinedMetadata,s.name,!0),u.userDefinedMetadata=s.userDefinedMetadata),u.weightData=o.data,u.weightSpecs=o.specs,e.save(u)})()}setUserDefinedMetadata(e){C$(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}return t.className="Model",t})();function gI(){return gI=J(function*(t,n){if(null==n&&(n={}),"string"==typeof t){const e=oZ(t,n);if(0===e.length)e.push(function KZ(t,n){return aP(t,n)}(t,n));else if(e.length>1)throw new A(`Found more than one (${e.length}) load handlers for URL '${t}'`);t=e[0]}return function rae(t,n,e){return yI.apply(this,arguments)}(t,void 0,n)}),gI.apply(this,arguments)}function yI(){return(yI=J(function*(t,n,e){if(null==e&&(e={}),null==t.load)throw new A("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const r=yield t.load();let s=r.modelTopology;null!=s.model_config&&(s=s.model_config);const o=null==e.strict||e.strict,i=null!=r.weightData&&null!=r.weightSpecs&&o,a=hi(db(s),n,i),l=r.trainingConfig;if(null!=l&&a.loadTrainingConfig(l),null!=r.userDefinedMetadata&&a.setUserDefinedMetadata(r.userDefinedMetadata),null!=r.weightData){if(null==r.weightSpecs)throw new A("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");const{modelWeights:u,optimizerWeights:c}=function sae(t,n){const e=function PM(t,n){const e={};let r,s=0;for(const o of n){const i=o.name,a=o.dtype,l=o.shape,u=G(l);let c;if("quantization"in o){const d=o.quantization;if("uint8"===d.dtype||"uint16"===d.dtype){if(!("min"in d)||!("scale"in d))throw new Error(`Weight ${o.name} with quantization ${d.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==d.dtype)throw new Error(`Weight ${o.name} has unknown quantization dtype ${d.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==a)throw new Error(`Weight ${o.name} is quantized with ${d.dtype} which only supports weights of type float32 not ${a}.`)}const h=p_[d.dtype],p=t.slice(s,s+u*h),f="uint8"===d.dtype?new Uint8Array(p):new Uint16Array(p);if("float32"===a)if("uint8"===d.dtype||"uint16"===d.dtype){c=new Float32Array(f.length);for(let g=0;g<f.length;g++)c[g]=f[g]*d.scale+d.min}else{if("float16"!==d.dtype)throw new Error(`Unsupported quantization type ${d.dtype} for weight type float32.`);void 0===r&&(r=rZ()),c=r(f)}else{if("int32"!==a)throw new Error(`Unsupported dtype in weight '${i}': ${a}`);if("uint8"!==d.dtype&&"uint16"!==d.dtype)throw new Error(`Unsupported quantization type ${d.dtype} for weight type int32.`);c=new Int32Array(f.length);for(let g=0;g<f.length;g++)c[g]=Math.round(f[g]*d.scale+d.min)}s+=u*h}else if("string"===a){const d=G(o.shape);c=[];for(let h=0;h<d;h++){const p=new Uint32Array(t.slice(s,s+xy))[0];s+=xy;const f=new Uint8Array(t.slice(s,s+p));c.push(f),s+=p}}else{const d=p_[a],h=t.slice(s,s+u*d);if("float32"===a)c=new Float32Array(h);else if("int32"===a)c=new Int32Array(h);else if("bool"===a)c=new Uint8Array(h);else{if("complex64"!==a)throw new Error(`Unsupported dtype in weight '${i}': ${a}`);{c=new Float32Array(h);const p=new Float32Array(c.length/2),f=new Float32Array(c.length/2);for(let y=0;y<p.length;y++)p[y]=c[2*y],f[y]=c[2*y+1];const g=cp(p,l,"float32"),m=cp(f,l,"float32");e[i]=_l(g,m),g.dispose(),m.dispose()}}s+=u*d}"complex64"!==a&&(e[i]=cp(c,l,a))}return e}(t,n),r={},s=[];return n.forEach(o=>{"optimizer"===o.group?s.push({name:o.name,tensor:e[o.name]}):r[o.name]=e[o.name]}),{modelWeights:r,optimizerWeights:s}}(r.weightData,r.weightSpecs);a.loadWeights(u,o),null!=a.optimizer&&c.length>0&&(yield a.optimizer.setWeights(c)),ft(u),ft(c.map(d=>d.tensor))}return a})).apply(this,arguments)}se(wc),se((()=>{class t extends wc{}return t.className="Functional",t})()),se((()=>{class t extends wc{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=null!=e.name?e.name:qy("sequential_"),null!=e.layers)for(const r of e.layers)this.add(r)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(s=>s<0))throw new A(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const r=e instanceof t||e instanceof wc;let s;if(r){if(s=e,1!==s.outputs.length)throw new A("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==s.inputs.length)throw new A("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===e.inboundNodes.length){if(null==e.batchInputShape)throw new A("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const o=function oie(t){if(null==t.batchShape&&null==t.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=t.batchShape&&null!=t.shape)throw new A("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let n=t.batchShape;null!=t.shape&&null==n&&(n=[null].concat(t.shape));let e=t.dtype;return null==e&&(e="float32"),new eb({batchInputShape:n,name:t.name,dtype:e,sparse:t.sparse}).inboundNodes[0].outputTensors[0]}({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(o)}if(r)this.outputs=s.outputs,this.inputs=s.inputs;else{if(1!==e.inboundNodes.length)throw new A(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(1!==e.inboundNodes[0].outputTensors.length)throw new A("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=l$(this.outputs[0])}this.inboundNodes=[],new Jy({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:Ml(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(o=>o.shape),outputShapes:this.outputs[0].shape})}else{const o=e.apply(this.outputs[0]);if(Array.isArray(o))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[o],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,r){return null==this.model&&this.build(),this.model.call(e,r)}build(e){if($t(e),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new wc({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,r,s=console.log){this.built||this.build(),super.summary(e,r,s)}setWeights(e){null==this.model&&this.build(),this.model.setWeights(e)}evaluate(e,r,s={}){if(!this.built)throw new co("The model needs to be compiled before being used.");return this.model.evaluate(e,r,s)}evaluateDataset(e,r){var s=this;return J(function*(){if(!s.built)throw new co("The model needs to be compiled before being used.");return s.model.evaluateDataset(e,r)})()}predict(e,r={}){return null==this.model&&this.build(),this.model.predict(e,r)}predictOnBatch(e){return null==this.model&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}fit(e,r,s={}){var o=this;return J(function*(){if(!o.built)throw new co("The model needs to be compiled before being used.");return o.model.fit(e,r,s)})()}fitDataset(e,r){var s=this;return J(function*(){if(!s.built)throw new co("The model needs to be compiled before being used.");return s.model.fitDataset(e,r)})()}trainOnBatch(e,r){var s=this;return J(function*(){return s.model.trainOnBatch(e,r)})()}static fromConfig(e,r,s={},o=!1){let i,a={};if(r instanceof Array){if(null==r[0].className||"Merge"===r[0].className)throw new A("Legacy serialization format not supported yet.");i=r}else _(null!=r.layers,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),i=r.layers,delete r.layers,a=r;const l=new e(a);if(!(l instanceof t))throw new lt(`Sequential.fromConfig called on non-Sequential input: ${l}`);for(const u of i){const d=hi(u,void 0,o);o&&d.setFastWeightInitDuringBuild(!0),l.add(d)}return l}set stopTraining(e){if(null==this.model)throw new A("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(null==this.model)throw new A("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const r of this.layers){const s={};s.className=r.getClassName(),s.config=r.getConfig(),e.push(s)}return{name:this.name,layers:e}}}return t.className="Sequential",t})());class us extends uc{getConfig(){return{}}}se((()=>{class t extends us{apply(e,r=1){return function joe(t,n=1){if(1!==n)throw new lt(`Support for alpha values other than 1 (${n}) is not implemented yet.`);return Ey(t)}(e,r)}}return t.className="elu",t})()),se((()=>{class t extends us{apply(e){return TP(e)}}return t.className="selu",t})()),se((()=>{class t extends us{apply(e){return Wi(e)}}return t.className="relu",t})()),se((()=>{class t extends us{apply(e){return $(()=>pc(6,Wi(e)))}}return t.className="relu6",t})()),se((()=>{class t extends us{apply(e){return e}}return t.className="linear",t})()),se((()=>{class t extends us{apply(e){return fc(e)}}return t.className="sigmoid",t})()),se((()=>{class t extends us{apply(e){return function Koe(t){return $(()=>{const n=ie(.5,k(.2,t));return Os(n,0,1)})}(e)}}return t.className="hardSigmoid",t})()),se((()=>{class t extends us{apply(e){return vp(e)}}return t.className="softplus",t})()),se((()=>{class t extends us{apply(e){return function qoe(t){return $(()=>Oe(t,ie(ur(t),1)))}(e)}}return t.className="softsign",t})()),se((()=>{class t extends us{apply(e){return sS(e)}}return t.className="tanh",t})());let M$=(()=>{class t extends us{apply(e,r=-1){return rS(e,r)}}return t.className="softmax",t})();function Ra(t){return t.getClassName()}function bI(t,n={}){return Ip(t,ro.getMap().classNameMap,n,"activation")}function Fa(t){if(null==t){return bI({className:"linear",config:{}})}if("string"==typeof t){const n={};return n.className=t,n.config={},bI(n)}return t instanceof us?t:bI(t)}se(M$),se((()=>{class t extends us{apply(e,r=-1){return SP(e,r)}}return t.className="logSoftmax",t})()),se((()=>{class t extends us{apply(e,r=1){return $(()=>k(fc(k(e,r)),e))}}return t.className="swish",t})()),se((()=>{class t extends us{apply(e){return $(()=>k(e,sS(vp(e))))}}return t.className="mish",t})());class P$ extends uc{}se((()=>{class t extends P${constructor(e){super(),function vI(t){if(null!=t&&"object"!=typeof t)throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${t}`)}(e),this.l1=null==e||null==e.l1?.01:e.l1,this.l2=null==e||null==e.l2?.01:e.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(e){return $(()=>{let r=hr([1]);return this.hasL1&&(r=ie(r,Ae(k(this.l1,ur(e))))),this.hasL2&&(r=ie(r,Ae(k(this.l2,Ep(e))))),M(r,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,r){return new e({l1:r.l1,l2:r.l2})}}return t.className="L1L2",t})());const O$={l1l2:"L1L2"};function en(t){return GS(t)}function $$(t,n={}){return Ip(t,ro.getMap().classNameMap,n,"regularizer")}function yn(t){return null==t?null:"string"==typeof t?$$({className:t in O$?O$[t]:t,config:{}}):t instanceof P$?t:$$(t)}function Cc(t,n,e){if("number"==typeof t)return Ml(t,n);if(t.length!==n)throw new A(`The ${e} argument must be an integer or tuple of ${n} integers. Received: ${t.length} elements.`);for(let r=0;r<n;++r){const s=t[r];if(!Boe(s))throw new A(`The ${e} argument must be an integer or tuple of ${n} integers. Received: ${JSON.stringify(t)} including a non-integer number ${s}`)}return t}function Oo(t,n,e,r,s=1){if(null==t)return t;let i;return i="same"===e?t:t-(n+(n-1)*(s-1))+1,Math.floor((i+r-1)/r)}function pi(t,n,e,r){if(null==t)return null;if("valid"===r)t=t*n+Na([e-n,0]);else{if("same"!==r)throw new A(`Unsupport padding mode: ${r}.`);t*=n}return t}function wI(t,n){return $(()=>(Ln(n),"channelsFirst"===n?Rt(t,[0,2,3,1]):t))}function L$(t,n){return $(()=>(Ln(n),"channelsFirst"===n?Rt(t,[0,2,3,4,1]):t))}function CI(t,n,e,r=[1,1],s="valid",o,i,a=null){return $(()=>{if(null==o&&(o="channelsLast"),Ln(o),3!==t.rank&&4!==t.rank)throw new A(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${t.rank}.`);if(3!==n.rank&&4!==n.rank)throw new A(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${t.rank}.`);let l=wI(t,o);if("causal"===s)throw new lt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=lee({x:l,filter:n,strides:r,pad:"same"===s?"same":"valid",dilations:i,dataFormat:"NHWC",bias:e,activation:a}),"channelsFirst"===o&&(l=Rt(l,[0,3,1,2])),l})}se((()=>{class t extends wt{constructor(e){super(e??{}),this.supportsMasking=!0,null!=e&&(this.maxValue=e.maxValue)}call(e,r){e=nt(e);let s=Wi(e);return null!=this.maxValue&&(s=Os(s,0,this.maxValue)),s}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},r=super.getConfig();return Object.assign(e,r),e}}return t.className="ReLU",t})()),se((()=>{class t extends wt{constructor(e){super(e??{}),this.DEFAULT_ALPHA=.3,null==e&&(e={}),this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,r){const s=nt(e);return H_(s,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},r=super.getConfig();return Object.assign(e,r),e}}return t.className="LeakyReLU",t})()),se((()=>{class t extends wt{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==e&&(e={}),this.supportsMasking=!0,this.alphaInitializer=gn(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=yn(e.alphaRegularizer),this.alphaConstraint=nr(e.alphaConstraint),null==e.sharedAxes)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else{if("number"!=typeof e.sharedAxes)throw new A(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`);this.sharedAxes=[e.sharedAxes]}}build(e){const r=(e=$t(e)).slice(1);if(null!=this.sharedAxes)for(const o of this.sharedAxes)r[o-1]=1;this.alpha=this.addWeight("alpha",r,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const s={};if(null!=this.sharedAxes)for(let o=1;o<e.length;++o)s[o]=e[o];this.inputSpec=[new er({ndim:e.length,axes:s})],this.built=!0}call(e,r){return e=nt(e),Z_(e,this.alpha.read())}getConfig(){const e={alphaInitializer:_n(this.alphaInitializer),alphaRegularizer:en(this.alphaRegularizer),alphaConstraint:tr(this.alphaConstraint),sharedAxes:this.sharedAxes},r=super.getConfig();return Object.assign(e,r),e}}return t.className="PReLU",t})()),se((()=>{class t extends wt{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA=1,null==e&&(e={}),null!=e.alpha&&e.alpha!==this.DEFAULT_ALPHA)throw new lt(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,r){const s=nt(e);return Ey(s)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},r=super.getConfig();return Object.assign(e,r),e}}return t.className="ELU",t})()),se((()=>{class t extends wt{constructor(e){super(e??{}),this.DEFAULT_THETA=1,null==e&&(e={}),this.theta=null==e.theta?this.DEFAULT_THETA:e.theta}call(e,r){const s=nt(e);return k(s,xe($s(s,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},r=super.getConfig();return Object.assign(e,r),e}}return t.className="ThresholdedReLU",t})()),se((()=>{class t extends wt{constructor(e){super(e??{}),this.DEFAULT_AXIS=1,null==e&&(e={}),this.softmax=(new M$).apply,this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis}call(e,r){const s=nt(e);return this.softmax(s,this.axis)}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},r=super.getConfig();return Object.assign(e,r),e}}return t.className="Softmax",t})());class hb extends wt{constructor(n,e){if(super(e),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",hb.verifyArgs(e),this.rank=n,pr(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new lt(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=Cc(e.kernelSize,n,"kernelSize"),this.strides=Cc(null==e.strides?1:e.strides,n,"strides"),this.padding=null==e.padding?"valid":e.padding,Bs(this.padding),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,Ln(this.dataFormat),this.activation=Fa(e.activation),this.useBias=null==e.useBias||e.useBias,this.biasInitializer=gn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=nr(e.biasConstraint),this.biasRegularizer=yn(e.biasRegularizer),this.activityRegularizer=yn(e.activityRegularizer),this.dilationRate=Cc(null==e.dilationRate?1:e.dilationRate,n,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new A(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(2===this.rank){if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new A(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(3===this.rank)if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new A(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}static verifyArgs(n){if(Vs("kernelSize"in n,"required key 'kernelSize' not in config"),"number"!=typeof n.kernelSize&&!jS(n.kernelSize,"number",1,3))throw new A(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(n.kernelSize)}.`)}getConfig(){const n={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:Ra(this.activation),useBias:this.useBias,biasInitializer:_n(this.biasInitializer),biasRegularizer:en(this.biasRegularizer),activityRegularizer:en(this.activityRegularizer),biasConstraint:tr(this.biasConstraint)},e=super.getConfig();return Object.assign(n,e),n}}class _c extends hb{constructor(n,e){super(n,e),this.kernel=null,_c.verifyArgs(e),this.filters=e.filters,pr(this.filters,"filters"),this.kernelInitializer=gn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=nr(e.kernelConstraint),this.kernelRegularizer=yn(e.kernelRegularizer)}build(n){n=$t(n);const e="channelsFirst"===this.dataFormat?1:n.length-1;if(null==n[e])throw new A(`The channel dimension of the input should be defined. Found ${n[e]}`);const r=n[e],s=this.kernelSize.concat([r,this.filters]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[e]:r}}],this.built=!0}call(n,e){return $(()=>{let r;n=nt(n);const s=null==this.bias?null:this.bias.read(),o=zO(this.activation.getClassName());if(null!=o&&2===this.rank)r=CI(n,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate,o);else{if(1===this.rank)r=function V$(t,n,e,r=1,s="valid",o,i=1){return $(()=>{if(null==o&&(o="channelsLast"),Ln(o),3!==t.shape.length)throw new A(`The input of a conv1dWithBias operation should be 3, but is ${t.shape.length} instead.`);if(3!==n.shape.length)throw new A(`The kernel for a conv1dWithBias operation should be 3, but is ${n.shape.length} instead`);if(null!=e&&1!==e.shape.length)throw new A(`The bias for a conv1dWithBias operation should be 1, but is ${n.shape.length} instead`);if("channelsFirst"===o&&(t=Rt(t,[0,2,1])),"causal"===s)throw new lt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let a=vP(t,n,r,"same"===s?"same":"valid","NWC",i);return null!=e&&(a=Fo(a,e)),a})}(n,this.kernel.read(),s,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)r=CI(n,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new lt("convolutions greater than 3D are not implemented yet.");r=function B$(t,n,e,r=[1,1,1],s="valid",o,i){return $(()=>{if(null==o&&(o="channelsLast"),Ln(o),4!==t.rank&&5!==t.rank)throw new A(`conv3dWithBias expects input to be of rank 4 or 5, but received ${t.rank}.`);if(4!==n.rank&&5!==n.rank)throw new A(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${t.rank}.`);let a=L$(t,o);if("causal"===s)throw new lt("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return a=$Q(a,n,r,"same"===s?"same":"valid","NDHWC",i),null!=e&&(a=Fo(a,e)),"channelsFirst"===o&&(a=Rt(a,[0,4,1,2,3])),a})}(n,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(r=this.activation.apply(r))}return r})}computeOutputShape(n){n=$t(n);const e=[],r="channelsLast"===this.dataFormat?n.slice(1,n.length-1):n.slice(2);for(let o=0;o<r.length;++o){const i=Oo(r[o],this.kernelSize[o],this.padding,this.strides[o],"number"==typeof this.dilationRate?this.dilationRate:this.dilationRate[o]);e.push(i)}let s=[n[0]];return"channelsLast"===this.dataFormat?(s=s.concat(e),s.push(this.filters)):(s.push(this.filters),s=s.concat(e)),s}getConfig(){const n={filters:this.filters,kernelInitializer:_n(this.kernelInitializer),kernelRegularizer:en(this.kernelRegularizer),kernelConstraint:tr(this.kernelConstraint)},e=super.getConfig();return Object.assign(n,e),n}static verifyArgs(n){if(!("filters"in n)||"number"!=typeof n.filters||n.filters<1)throw new A(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(n.filters)}`)}}let z$=(()=>{class t extends _c{constructor(e){super(2,e),t.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!jS(e.kernelSize,"number",1,2))throw new A(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}return t.className="Conv2D",t})();se(z$);let U$=(()=>{class t extends _c{constructor(e){super(3,e),t.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&(!Array.isArray(e.kernelSize)||1!==e.kernelSize.length&&3!==e.kernelSize.length))throw new A(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}return t.className="Conv3D",t})();se(U$),se((()=>{class t extends z${constructor(e){if(super(e),this.inputSpec=[new er({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new A(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(4!==(e=$t(e)).length)throw new A("Input should have rank 4; Received input shape: "+JSON.stringify(e));const r="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[r])throw new A("The channel dimension of the inputs should be defined. Found `None`.");const s=e[r],o=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",o,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new er({ndim:4,axes:{[r]:s}})],this.built=!0}call(e,r){return $(()=>{let s=nt(e);if(4!==s.shape.length)throw new A(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const o=s.shape;let a,l;"channelsFirst"===this.dataFormat?(a=2,l=3):(a=1,l=2);const c=o[l],h=this.kernelSize[1],f=this.strides[1],y=[o[0],pi(o[a],this.strides[0],this.kernelSize[0],this.padding),pi(c,f,h,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(s=Rt(s,[0,2,3,1]));let b=xP(s,this.kernel.read(),y,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(b=Rt(b,[0,3,1,2])),null!=this.bias&&(b=Fo(b,this.bias.read(),this.dataFormat)),null!=this.activation&&(b=this.activation.apply(b)),b})}computeOutputShape(e){const r=(e=$t(e)).slice();let s,o,i;"channelsFirst"===this.dataFormat?(s=1,o=2,i=3):(s=3,o=1,i=2);const a=this.kernelSize[0],l=this.kernelSize[1],u=this.strides[0],c=this.strides[1];return r[s]=this.filters,r[o]=pi(r[o],u,a,this.padding),r[i]=pi(r[i],c,l,this.padding),r}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}return t.className="Conv2DTranspose",t})()),se((()=>{class t extends U${constructor(e){if(super(e),this.inputSpec=[new er({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new A(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(5!==(e=$t(e)).length)throw new A("Input should have rank 5; Received input shape: "+JSON.stringify(e));const r="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[r])throw new A("The channel dimension of the inputs should be defined. Found `None`.");const s=e[r],o=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",o,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new er({ndim:5,axes:{[r]:s}})],this.built=!0}call(e,r){return $(()=>{let s=nt(e);if(5!==s.shape.length)throw new A(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const o=s.shape;let a,l,u;"channelsFirst"===this.dataFormat?(u=2,a=3,l=4):(u=1,a=2,l=3);const d=o[a],h=o[l],f=this.kernelSize[1],g=this.kernelSize[2],y=this.strides[1],b=this.strides[2],C=[o[0],pi(o[u],this.strides[0],this.kernelSize[0],this.padding),pi(d,y,f,this.padding),pi(h,b,g,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(s=Rt(s,[0,2,3,4,1]));let I=BQ(s,this.kernel.read(),C,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(I=Rt(I,[0,4,1,2,3])),null!==this.bias&&(I=Fo(I,this.bias.read(),this.dataFormat)),null!==this.activation&&(I=this.activation.apply(I)),I})}computeOutputShape(e){const r=(e=$t(e)).slice();let s,o,i,a;"channelsFirst"===this.dataFormat?(s=1,o=2,i=3,a=4):(s=4,o=1,i=2,a=3);const l=this.kernelSize[0],u=this.kernelSize[1],c=this.kernelSize[2],d=this.strides[0],h=this.strides[1],p=this.strides[2];return r[s]=this.filters,r[o]=pi(r[o],d,l,this.padding),r[i]=pi(r[i],h,u,this.padding),r[a]=pi(r[a],p,c,this.padding),r}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}return t.className="Conv3DTranspose",t})());let oae=(()=>{class t extends _c{constructor(e,r){if(super(e,r),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==r.filters)throw new A("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=r.kernelInitializer||null!=r.kernelRegularizer||null!=r.kernelConstraint)throw new A("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=r.padding&&"same"!==r.padding&&"valid"!==r.padding)throw new A(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(r.padding)}`);this.depthMultiplier=null==r.depthMultiplier?1:r.depthMultiplier,this.depthwiseInitializer=gn(r.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=yn(r.depthwiseRegularizer),this.depthwiseConstraint=nr(r.depthwiseConstraint),this.pointwiseInitializer=gn(r.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=yn(r.pointwiseRegularizer),this.pointwiseConstraint=nr(r.pointwiseConstraint)}build(e){if((e=$t(e)).length<this.rank+2)throw new A(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const r="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[r]||e[r]<0)throw new A(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[r])}`);const s=e[r],o=this.kernelSize.concat([s,this.depthMultiplier]),i=[];for(let l=0;l<this.rank;++l)i.push(1);i.push(s*this.depthMultiplier,this.filters);const a=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",o,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,a,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",i,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,a,this.pointwiseConstraint),this.bias=this.useBias?this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,a,this.biasConstraint):null,this.inputSpec=[new er({ndim:this.rank+2,axes:{[r]:s}})],this.built=!0}call(e,r){return $(()=>{let s;if(e=nt(e),1===this.rank)throw new lt("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(e=Rt(e,[0,2,3,1])),s=EP(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(s=Fo(s,this.bias.read(),this.dataFormat)),null!=this.activation&&(s=this.activation.apply(s)),"channelsFirst"===this.dataFormat&&(s=Rt(s,[0,3,1,2])),s})}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=_n(this.depthwiseInitializer),e.pointwiseInitializer=_n(this.pointwiseInitializer),e.depthwiseRegularizer=en(this.depthwiseRegularizer),e.pointwiseRegularizer=en(this.pointwiseRegularizer),e.depthwiseConstraint=tr(this.depthwiseConstraint),e.pointwiseConstraint=tr(this.pointwiseConstraint),e}}return t.className="SeparableConv",t})();function W$(t,n,e,r){if(Array.isArray(t)){if(null!=n||null!=e)throw new A("When inputs is an array, neither initialState or constants should be provided");null!=r&&(e=t.slice(t.length-r,t.length),t=t.slice(0,t.length-r)),t.length>1&&(n=t.slice(1,t.length)),t=t[0]}function s(o){return null==o||Array.isArray(o)?o:[o]}return{inputs:t,initialState:n=s(n),constants:e=s(e)}}function G$(t,n,e,r=!1,s,o,i=!1,a=!1){return $(()=>{const l=n.shape.length;if(l<3)throw new A(`Input should be at least 3D, but is ${l}D.`);const u=[1,0].concat(Ao(2,l));if(n=Rt(n,u),null!=o)throw new lt("The rnn() functoin of the deeplearn.js backend does not support constants yet.");i&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=s&&((s=xe(xe(s,"bool"),"float32")).rank===l-1&&(s=bs(s,-1)),s=Rt(s,u)),r&&(n=kl(n,0),null!=s&&(s=kl(s,0)));const c=[];let d,h=e;const p=n.shape[0],f=Al(n);let g,m;null!=s&&(g=Al(s));for(let y=0;y<p;++y){const b=f[y],v=$(()=>t(b,h));if(null==s)d=v[0],h=v[1];else{const x=$(()=>{const w=g[y],C=ke(lo(w),w);return{output:ie(k(v[0],w),k(h[0],C)),newStates:h.map((E,N)=>ie(k(v[1][N],w),k(E,C)))}});d=x.output,h=x.newStates}a&&c.push(d)}return a&&(m=Da(c,1)),[d,m,h]})}se((()=>{class t extends oae{constructor(e){super(2,e)}}return t.className="SeparableConv2D",t})()),se((()=>{class t extends _c{constructor(e){super(1,e),t.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!jS(e.kernelSize,"number",1,1))throw new A(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}return t.className="Conv1D",t})()),se((()=>{class t extends wt{constructor(e){super(e),this.cropping="number"==typeof e.cropping?[[e.cropping,e.cropping],[e.cropping,e.cropping]]:"number"==typeof e.cropping[0]?[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:e.cropping,this.dataFormat=void 0===e.dataFormat?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,r){return $(()=>{if(e=nt(e),"channelsLast"===this.dataFormat){const s=Xy(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return Xy(s,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const s=Xy(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return Xy(s,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},r=super.getConfig();return Object.assign(e,r),e}}return t.className="Cropping2D",t})()),se((()=>{class t extends wt{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==e.size?this.DEFAULT_SIZE:e.size,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,Ln(this.dataFormat),this.interpolation=null==e.interpolation?"nearest":e.interpolation,function $oe(t){Ol(Foe,"InterpolationFormat",t)}(this.interpolation)}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],null==e[2]?null:this.size[0]*e[2],null==e[3]?null:this.size[1]*e[3]]:[e[0],null==e[1]?null:this.size[0]*e[1],null==e[2]?null:this.size[1]*e[2],e[3]]}call(e,r){return $(()=>{let s=nt(e);const o=s.shape;if("channelsFirst"===this.dataFormat){s=Rt(s,[0,2,3,1]);const i=this.size[0]*o[2],a=this.size[1]*o[3],l="nearest"===this.interpolation?Rl.resizeNearestNeighbor(s,[i,a]):Rl.resizeBilinear(s,[i,a]);return Rt(l,[0,3,1,2])}{const i=this.size[0]*o[1],a=this.size[1]*o[2];return"nearest"===this.interpolation?Rl.resizeNearestNeighbor(s,[i,a]):Rl.resizeBilinear(s,[i,a])}})}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},r=super.getConfig();return Object.assign(e,r),e}}return t.className="UpSampling2D",t})()),se((()=>{class t extends hb{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=gn(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=nr(e.depthwiseConstraint),this.depthwiseRegularizer=yn(e.depthwiseRegularizer)}build(e){if((e=$t(e)).length<4)throw new A(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const r="channelsFirst"===this.dataFormat?1:3;if(null==e[r]||e[r]<0)throw new A(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[r]}).`);const s=e[r];this.depthwiseKernel=this.addWeight("depthwise_kernel",[this.kernelSize[0],this.kernelSize[1],s,this.depthMultiplier],null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.bias=this.useBias?this.addWeight("bias",[s*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(e,r){return $(()=>{let s=function iae(t,n,e=[1,1],r="valid",s,o){return $(()=>{null==s&&(s="channelsLast"),Ln(s);let i=wI(t,s);if(4!==t.rank)throw new A(`Input for depthwiseConv2d is required to be 4-D, but is instead ${t.rank}-D`);if(4!==n.rank)throw new A(`depthwiseKernel is required to be 4-D, but is instead ${n.rank}-D`);return i=Ty(i,n,e,"same"===r?"same":"valid","NHWC",o),"channelsFirst"===s&&(i=Rt(i,[0,3,1,2])),i})}(e=nt(e),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(s=Fo(s,this.bias.read(),this.dataFormat)),null!=this.activation&&(s=this.activation.apply(s)),s})}computeOutputShape(e){e=$t(e);const s="channelsFirst"===this.dataFormat?e[3]:e[2],o="channelsFirst"===this.dataFormat?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,i=Oo("channelsFirst"===this.dataFormat?e[2]:e[1],this.kernelSize[0],this.padding,this.strides[0]),a=Oo(s,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[e[0],o,i,a]:[e[0],i,a,o]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=_n(this.depthwiseInitializer),e.depthwiseRegularizer=en(this.depthwiseRegularizer),e.depthwiseConstraint=tr(this.depthwiseRegularizer),e}}return t.className="DepthwiseConv2D",t})());let Mp=(()=>{class t extends wt{constructor(e){let r;if(super(e),null==e.cell)throw new A("cell property is missing for the constructor of RNN.");if(r=Array.isArray(e.cell)?new q$({cells:e.cell}):e.cell,null==r.stateSize)throw new A("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=r,this.returnSequences=null!=e.returnSequences&&e.returnSequences,this.returnState=null!=e.returnState&&e.returnState,this.goBackwards=null!=e.goBackwards&&e.goBackwards,this._stateful=null!=e.stateful&&e.stateful,this.unroll=null!=e.unroll&&e.unroll,this.supportsMasking=!0,this.inputSpec=[new er({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){return null==this.states_?Ao(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map(r=>null):this.states_}setStates(e){this.states_=e}computeOutputShape(e){ZS(e)&&(e=e[0]);let r=this.cell.stateSize;Array.isArray(r)||(r=[r]);const s=r[0];let o;if(o=this.returnSequences?[e[0],e[1],s]:[e[0],s],this.returnState){const i=[];for(const a of r)i.push([e[0],a]);return[o].concat(i)}return o}computeMask(e,r){return $(()=>{Array.isArray(r)&&(r=r[0]);const s=this.returnSequences?r:null;if(this.returnState){const o=this.states.map(i=>null);return[s].concat(o)}return s})}get states(){if(null==this.states_){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,r=[];for(let s=0;s<e;++s)r.push(null);return r}return this.states_}set states(e){this.states_=e}build(e){if(null!=this.numConstants)throw new lt("Constants support is not implemented in RNN yet.");ZS(e)&&(e=e[0]);const s=this.stateful?e[0]:null,o=e.slice(2);this.inputSpec[0]=new er({shape:[s,null,...o]});const i=[e[0]].concat(e.slice(2));let a;if(this.cell.build(i),a=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!Bt(this.stateSpec.map(l=>l.shape[l.shape.length-1]),a))throw new A(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=a.map(l=>new er({shape:[null,l]}));this.stateful&&this.resetStates()}resetStates(e,r=!1){$(()=>{if(!this.stateful)throw new ai("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape[0];if(null==s)throw new A("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)this.states_=Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(o=>hr([s,o])):[hr([s,this.cell.stateSize])];else if(null==e)ft(this.states_),null!=this.keptStates&&(ft(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(o=>hr([s,o])):this.states_[0]=hr([s,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new A(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);!0===r?this.keptStates.push(this.states_.slice()):ft(this.states_);for(let o=0;o<this.states_.length;++o){const i=e[o],a=Array.isArray(this.cell.stateSize)?this.cell.stateSize[o]:this.cell.stateSize,l=[s,a];if(!Bt(i.shape,l))throw new A(`State ${o} is incompatible with layer ${this.name}: expected shape=${l}, received shape=${i.shape}`);this.states_[o]=i}}this.states_=this.states_.map(o=>si(o.clone()))})}apply(e,r){let s=null==r?null:r.initialState,o=null==r?null:r.constants;null==r&&(r={});const i=W$(e,s,o,this.numConstants);e=i.inputs,s=i.initialState,o=i.constants;let a=[],l=[];if(null!=s){r.initialState=s,a=a.concat(s),this.stateSpec=[];for(const c of s)this.stateSpec.push(new er({shape:c.shape}));l=l.concat(this.stateSpec)}if(null!=o&&(r.constants=o,a=a.concat(o),this.numConstants=o.length),a[0]instanceof di){const c=[e].concat(a),d=this.inputSpec.concat(l),h=this.inputSpec;this.inputSpec=d;const p=super.apply(c,r);return this.inputSpec=h,p}return super.apply(e,r)}call(e,r){return $(()=>{const s=null==r?null:r.mask,o=null==r?null:r.training;let i=null==r?null:r.initialState;e=nt(e),null==i&&(i=this.stateful?this.states_:this.getInitialState(e));const a=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(i.length!==a)throw new A(`RNN Layer has ${a} state(s) but was passed ${i.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const l={training:o},c=G$((g,m)=>{const y=this.cell.call([g].concat(m),l);return[y[0],y.slice(1)]},e,i,this.goBackwards,s,null,this.unroll,this.returnSequences),d=c[0],h=c[1],p=c[2];this.stateful&&this.resetStates(p,o);const f=this.returnSequences?h:d;return this.returnState?[f].concat(p):f})}getInitialState(e){return $(()=>{let r=hr(e.shape);return r=Ae(r,[1,2]),r=Tp(r),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(s=>s>1?XS(r,[1,s]):r):this.cell.stateSize>1?[XS(r,[1,this.cell.stateSize])]:[r]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),r={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(r.numConstants=this.numConstants);const s=this.cell.getConfig();return this.getClassName()===t.className&&(r.cell={className:this.cell.getClassName(),config:s}),Object.assign(Object.assign(Object.assign({},s),e),r)}static fromConfig(e,r,s={}){const i=hi(r.cell,s);return new e(Object.assign(r,{cell:i}))}}return t.className="RNN",t})();se(Mp);class pb extends wt{}let H$=(()=>{class t extends pb{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,pr(this.units,"units"),this.activation=Fa(null==e.activation?this.DEFAULT_ACTIVATION:e.activation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=gn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=gn(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=gn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=yn(e.kernelRegularizer),this.recurrentRegularizer=yn(e.recurrentRegularizer),this.biasRegularizer=yn(e.biasRegularizer),this.kernelConstraint=nr(e.kernelConstraint),this.recurrentConstraint=nr(e.recurrentConstraint),this.biasConstraint=nr(e.biasConstraint),this.dropout=vc([1,Na([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=vc([1,Na([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=$t(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.bias=this.useBias?this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(e,r){return $(()=>{if(2!==e.length)throw new A(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let s=e[1];e=e[0];const o=null!=r.training&&r.training;let i;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Ma({ones:()=>lo(e),rate:this.dropout,training:o,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Ma({ones:()=>lo(s),rate:this.recurrentDropout,training:o,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,l=this.recurrentDropoutMask;i=ui(null!=a?k(e,a):e,this.kernel.read()),null!=this.bias&&(i=Fo(i,this.bias.read())),null!=l&&(s=k(s,l));let u=ie(i,ui(s,this.recurrentKernel.read()));return null!=this.activation&&(u=this.activation.apply(u)),[u,u]})}getConfig(){const e=super.getConfig(),r={units:this.units,activation:Ra(this.activation),useBias:this.useBias,kernelInitializer:_n(this.kernelInitializer),recurrentInitializer:_n(this.recurrentInitializer),biasInitializer:_n(this.biasInitializer),kernelRegularizer:en(this.kernelRegularizer),recurrentRegularizer:en(this.recurrentRegularizer),biasRegularizer:en(this.biasRegularizer),activityRegularizer:en(this.activityRegularizer),kernelConstraint:tr(this.kernelConstraint),recurrentConstraint:tr(this.recurrentConstraint),biasConstraint:tr(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),r)}}return t.className="SimpleRNNCell",t})();se(H$),se((()=>{class t extends Mp{constructor(e){e.cell=new H$(e),super(e)}call(e,r){return $(()=>(null!=this.cell.dropoutMask&&(ft(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(ft(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(e,{mask:null==r?null:r.mask,training:null==r?null:r.training,initialState:null==r?null:r.initialState})))}static fromConfig(e,r){return new e(r)}}return t.className="SimpleRNN",t})());let j$=(()=>{class t extends pb{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new A("GRUCell does not support reset_after parameter set to true.");this.units=e.units,pr(this.units,"units"),this.activation=Fa(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=Fa(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=gn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=gn(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=gn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=yn(e.kernelRegularizer),this.recurrentRegularizer=yn(e.recurrentRegularizer),this.biasRegularizer=yn(e.biasRegularizer),this.kernelConstraint=nr(e.kernelConstraint),this.recurrentConstraint=nr(e.recurrentConstraint),this.biasConstraint=nr(e.biasConstraint),this.dropout=vc([1,Na([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=vc([1,Na([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=$t(e),this.kernel=this.addWeight("kernel",[e[e.length-1],3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.bias=this.useBias?this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(e,r){return $(()=>{if(2!==e.length)throw new A(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const s=null!=r.training&&r.training;let o=e[1];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Ma({ones:()=>lo(e),rate:this.dropout,training:s,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Ma({ones:()=>lo(o),rate:this.recurrentDropout,training:s,count:3,dropoutFunc:this.dropoutFunc}));const a=this.recurrentDropoutMask;let l,u,c;0<this.dropout&&this.dropout<1&&(e=k(e,this.dropoutMask[0]));let d=ui(e,this.kernel.read());this.useBias&&(d=Fo(d,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(o=k(o,a[0]));const h=this.recurrentKernel.read(),[p,f]=Ls(h,[2*this.units,this.units],h.rank-1),g=ui(o,p),[m,y,b]=Ls(d,3,d.rank-1),[v,x]=Ls(g,2,g.rank-1);l=this.recurrentActivation.apply(ie(m,v)),u=this.recurrentActivation.apply(ie(y,x));const w=ui(k(u,o),f);c=this.activation.apply(ie(b,w));const C=ie(k(l,o),k(ie(1,mn(l)),c));return[C,C]})}getConfig(){const e=super.getConfig(),r={units:this.units,activation:Ra(this.activation),recurrentActivation:Ra(this.recurrentActivation),useBias:this.useBias,kernelInitializer:_n(this.kernelInitializer),recurrentInitializer:_n(this.recurrentInitializer),biasInitializer:_n(this.biasInitializer),kernelRegularizer:en(this.kernelRegularizer),recurrentRegularizer:en(this.recurrentRegularizer),biasRegularizer:en(this.biasRegularizer),activityRegularizer:en(this.activityRegularizer),kernelConstraint:tr(this.kernelConstraint),recurrentConstraint:tr(this.recurrentConstraint),biasConstraint:tr(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),r)}}return t.className="GRUCell",t})();se(j$),se((()=>{class t extends Mp{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new j$(e),super(e)}call(e,r){return $(()=>(null!=this.cell.dropoutMask&&(ft(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(ft(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(e,{mask:null==r?null:r.mask,training:null==r?null:r.training,initialState:null==r?null:r.initialState})))}static fromConfig(e,r){return 0===r.implmentation&&(r.implementation=1),new e(r)}}return t.className="GRU",t})());let _I=(()=>{class t extends pb{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,pr(this.units,"units"),this.activation=Fa(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=Fa(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=gn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=gn(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=gn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=yn(e.kernelRegularizer),this.recurrentRegularizer=yn(e.recurrentRegularizer),this.biasRegularizer=yn(e.biasRegularizer),this.kernelConstraint=nr(e.kernelConstraint),this.recurrentConstraint=nr(e.recurrentConstraint),this.biasConstraint=nr(e.biasConstraint),this.dropout=vc([1,Na([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=vc([1,Na([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var r;let o;if(e=$t(e),this.kernel=this.addWeight("kernel",[e[e.length-1],4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const i=this.biasInitializer,a=this.units;o=new((r=class extends po{apply(u,c){const d=i.apply([a]),h=(new QO).apply([a]),p=i.apply([2*a]);return XO(XO(d,h),p)}}).className="CustomInit",r)}else o=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,o,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,r){return $(()=>{const s=null!=r.training&&r.training;if(3!==e.length)throw new A(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let o=e[1];const i=e[2];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Ma({ones:()=>lo(e),rate:this.dropout,training:s,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Ma({ones:()=>lo(o),rate:this.recurrentDropout,training:s,count:4,dropoutFunc:this.dropoutFunc}));const l=this.recurrentDropoutMask;let u,c,d,h;0<this.dropout&&this.dropout<1&&(e=k(e,this.dropoutMask[0]));let p=ui(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(o=k(o,l[0])),p=ie(p,ui(o,this.recurrentKernel.read())),this.useBias&&(p=Fo(p,this.bias.read()));const[f,g,m,y]=Ls(p,4,p.rank-1);u=this.recurrentActivation.apply(f),c=this.recurrentActivation.apply(g),d=ie(k(c,i),k(u,this.activation.apply(m))),h=this.recurrentActivation.apply(y);const b=k(h,this.activation.apply(d));return[b,b,d]})}getConfig(){const e=super.getConfig(),r={units:this.units,activation:Ra(this.activation),recurrentActivation:Ra(this.recurrentActivation),useBias:this.useBias,kernelInitializer:_n(this.kernelInitializer),recurrentInitializer:_n(this.recurrentInitializer),biasInitializer:_n(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:en(this.kernelRegularizer),recurrentRegularizer:en(this.recurrentRegularizer),biasRegularizer:en(this.biasRegularizer),activityRegularizer:en(this.activityRegularizer),kernelConstraint:tr(this.kernelConstraint),recurrentConstraint:tr(this.recurrentConstraint),biasConstraint:tr(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),r)}}return t.className="LSTMCell",t})();se(_I),se((()=>{class t extends Mp{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new _I(e),super(e)}call(e,r){return $(()=>(null!=this.cell.dropoutMask&&(ft(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(ft(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(e,{mask:null==r?null:r.mask,training:null==r?null:r.training,initialState:null==r?null:r.initialState})))}static fromConfig(e,r){return 0===r.implmentation&&(r.implementation=1),new e(r)}}return t.className="LSTM",t})());let q$=(()=>{class t extends pb{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const r of this.cells.slice().reverse())Array.isArray(r.stateSize)?e.push(...r.stateSize):e.push(r.stateSize);return e}call(e,r){return $(()=>{let s=e.slice(1);const o=[];for(const l of this.cells.slice().reverse())Array.isArray(l.stateSize)?o.push(s.splice(0,l.stateSize.length)):o.push(s.splice(0,1));o.reverse();const i=[];let a;for(let l=0;l<this.cells.length;++l){const u=this.cells[l];s=o[l],a=0===l?[e[0]].concat(s):[a[0]].concat(s),a=u.call(a,r),i.push(a.slice(1))}s=[];for(const l of i.slice().reverse())s.push(...l);return[a[0]].concat(s)})}build(e){let r;ZS(e)&&(e=e[0]),this.cells.forEach((s,o)=>{$l(`RNNCell_${o}`,()=>{s.build(e),r=Array.isArray(s.stateSize)?s.stateSize[0]:s.stateSize,e=[e[0],r]})}),this.built=!0}getConfig(){const e=super.getConfig(),o={cells:this.cells.map(i=>({className:i.getClassName(),config:i.getConfig()}))};return Object.assign(Object.assign({},e),o)}static fromConfig(e,r,s={}){const o=[];for(const i of r.cells)o.push(hi(i,s));return new e({cells:o})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const r of this.cells)e.push(...r.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const r of this.cells)e.push(...r.nonTrainableWeights);if(!this.trainable){const r=[];for(const s of this.cells)r.push(...s.trainableWeights);return r.concat(e)}return e}getWeights(){const e=[];for(const r of this.cells)e.push(...r.weights);return QS(e)}setWeights(e){const r=[];for(const s of this.cells){const i=e.splice(s.weights.length);for(let a=0;a<s.weights.length;++a)r.push([s.weights[a],i[a]])}JS(r)}}return t.className="StackedRNNCells",t})();function Ma(t){const{ones:n,rate:e,training:r=!1,count:s=1,dropoutFunc:o}=t,i=()=>null!=o?o(n(),e):ZO(n(),e),a=()=>Np(i,n,r);return!s||s<=1?si(a().clone()):Array(s).fill(void 0).map(a).map(u=>si(u.clone()))}se(q$);let lae=(()=>{class t extends Mp{constructor(e){if(e.unroll)throw new lt("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new lt("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new er({ndim:5})]}call(e,r){return $(()=>{if(null!=this.cell.dropoutMask&&(ft(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(ft(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),r&&r.constants)throw new A("ConvRNN2D cell does not support constants");return super.call(e,{mask:null==r?null:r.mask,training:null==r?null:r.training,initialState:null==r?null:r.initialState})})}computeOutputShape(e){let r=this.computeSingleOutputShape(e);return this.returnSequences||(r=[r[0],...r.slice(2)]),this.returnState&&(r=[r,...Array(2).fill([e[0],...r.slice(-3)])]),r}getInitialState(e){return $(()=>{const{stateSize:r}=this.cell,o=this.computeSingleOutputShape(e.shape),a=hr([o[0],...o.slice(2)]);return Array.isArray(r)?Array(r.length).fill(a):[a]})}resetStates(e,r=!1){$(()=>{if(!this.stateful)throw new ai("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape,o=this.computeSingleOutputShape(s),i=[o[0],...o.slice(2)];if(null==s[0])throw new A("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())this.states_=Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(()=>hr(i)):[hr(i)];else if(null==e)ft(this.states_),null!=this.keptStates&&(ft(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>hr(i)):this.states_[0]=hr(i);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new A(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);r?this.keptStates.push(this.states_.slice()):ft(this.states_);for(let l=0;l<this.states_.length;++l){const u=e[l],c=i;if(!Bt(u.shape,c))throw new A(`State ${l} is incompatible with layer ${this.name}: expected shape=${c}, received shape=${u.shape}`);this.states_[l]=u}}this.states_=this.states_.map(l=>si(l.clone()))})}computeSingleOutputShape(e){const{dataFormat:r,filters:s,kernelSize:o,padding:i,strides:a,dilationRate:l}=this.cell,u="channelsFirst"===r,d=e[u?4:3],h=Oo(e[u?3:2],o[0],i,a[0],l[0]),p=Oo(d,o[1],i,a[1],l[1]);return[...e.slice(0,2),...u?[s,h,p]:[h,p,s]]}}return t.className="ConvRNN2D",t})(),K$=(()=>{class t extends _I{constructor(e){const{filters:r,kernelSize:s,strides:o,padding:i,dataFormat:a,dilationRate:l}=e;super(Object.assign(Object.assign({},e),{units:r})),this.filters=r,pr(this.filters,"filters"),this.kernelSize=Cc(s,2,"kernelSize"),this.kernelSize.forEach(u=>pr(u,"kernelSize")),this.strides=Cc(o||1,2,"strides"),this.strides.forEach(u=>pr(u,"strides")),this.padding=i||"valid",Bs(this.padding),this.dataFormat=a||"channelsLast",Ln(this.dataFormat),this.dilationRate=Cc(l||1,2,"dilationRate"),this.dilationRate.forEach(u=>pr(u,"dilationRate"))}build(e){var r;e=$t(e);const s="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[s])throw new A(`The channel dimension of the input should be defined. Found ${e[s]}`);const a=this.kernelSize.concat([e[s],4*this.filters]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const l=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",l,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let u;if(this.unitForgetBias){const c=this.biasInitializer,d=this.filters;u=new((r=class extends po{apply(p,f){return KS([c.apply([d]),Ia([d]),c.apply([2*d])])}}).className="CustomInit",r)}else u=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,u,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,r){return $(()=>{if(3!==e.length)throw new A(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const s=r.training||!1,o=e[0],i=e[1],a=e[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Ma({ones:()=>lo(o),rate:this.dropout,training:s,count:4,dropoutFunc:this.dropoutFunc}));const u=this.dropoutMask,c=(ae,he,le)=>he&&he[le]?k(he[le],ae):ae;let d=c(o,u,0),h=c(o,u,1),p=c(o,u,2),f=c(o,u,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Ma({ones:()=>lo(i),rate:this.recurrentDropout,training:s,count:4,dropoutFunc:this.dropoutFunc}));const g=this.recurrentDropoutMask;let m=c(i,g,0),y=c(i,g,1),b=c(i,g,2),v=c(i,g,3);const[w,C,I,D]=Ls(this.kernel.read(),4,3),[E,N,P,V]=this.useBias?Ls(this.bias.read(),4):[null,null,null,null];d=this.inputConv(d,w,E,this.padding),h=this.inputConv(h,C,N,this.padding),p=this.inputConv(p,I,P,this.padding),f=this.inputConv(f,D,V,this.padding);const[B,z,U,j]=Ls(this.recurrentKernel.read(),4,3);m=this.recurrentConv(m,B),y=this.recurrentConv(y,z),b=this.recurrentConv(b,U),v=this.recurrentConv(v,j);const q=this.recurrentActivation.apply(ie(d,m)),W=this.recurrentActivation.apply(ie(h,y)),K=ie(k(W,a),k(q,this.activation.apply(ie(p,b)))),ne=k(this.recurrentActivation.apply(ie(f,v)),this.activation.apply(K));return[ne,ne,K]})}getConfig(){const s=function(t,n){var e={};for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&n.indexOf(r)<0&&(e[r]=t[r]);if(null!=t&&"function"==typeof Object.getOwnPropertySymbols){var s=0;for(r=Object.getOwnPropertySymbols(t);s<r.length;s++)n.indexOf(r[s])<0&&Object.prototype.propertyIsEnumerable.call(t,r[s])&&(e[r[s]]=t[r[s]])}return e}(super.getConfig(),["units"]),o={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},s),o)}inputConv(e,r,s,o){const i=El(e,r,this.strides,o||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return s?Fo(i,s,this.dataFormat):i}recurrentConv(e,r){return El(e,r,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}return t.className="ConvLSTM2DCell",t})();se(K$),se((()=>{class t extends lae{constructor(e){const r=new K$(e);super(Object.assign(Object.assign({},e),{cell:r}))}static fromConfig(e,r){return new e(r)}}return t.className="ConvLSTM2D",t})());let X$=(()=>{class t extends wt{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(null==this.noiseShape)return this.noiseShape;const r=e.shape,s=[];for(let o=0;o<this.noiseShape.length;++o)s.push(null==this.noiseShape[o]?r[o]:this.noiseShape[o]);return s}call(e,r){return $(()=>{this.invokeCallHook(e,r);const s=nt(e);if(0<this.rate&&this.rate<1){const o=null!=r.training&&r.training,i=this.getNoiseShape(s);return Np(()=>ZO(s,this.rate,i,this.seed),()=>s,o)}return e})}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},r=super.getConfig();return Object.assign(e,r),e}dispose(){return super.dispose()}}return t.className="Dropout",t})();se(X$),se((()=>{class t extends X${constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const r=e.shape;return[r[0],1,r[2]]}}return t.className="SpatialDropout1D",t})()),se((()=>{class t extends wt{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==e.batchInputShape&&null==e.inputShape&&null!=e.inputDim){let r=null;null!=e.batchSize&&(r=e.batchSize),this.batchInputShape=[r,e.inputDim]}this.units=e.units,pr(this.units,"units"),this.activation=Fa(e.activation),null!=e.useBias&&(this.useBias=e.useBias),this.kernelInitializer=gn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=gn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=nr(e.kernelConstraint),this.biasConstraint=nr(e.biasConstraint),this.kernelRegularizer=yn(e.kernelRegularizer),this.biasRegularizer=yn(e.biasRegularizer),this.activityRegularizer=yn(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){const r=(e=$t(e))[e.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[r,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:r}}],this.built=!0}computeOutputShape(e){const r=(e=$t(e)).slice();return r[r.length-1]=this.units,r}call(e,r){return $(()=>{this.invokeCallHook(e,r);const s=nt(e),o=zO(this.activation.getClassName());let i;return null!=o?i=ui(s,this.kernel.read(),o,this.bias?this.bias.read():null):(i=ui(s,this.kernel.read()),null!=this.bias&&(i=Fo(i,this.bias.read())),null!=this.activation&&(i=this.activation.apply(i))),i})}getConfig(){const e={units:this.units,activation:Ra(this.activation),useBias:this.useBias,kernelInitializer:_n(this.kernelInitializer),biasInitializer:_n(this.biasInitializer),kernelRegularizer:en(this.kernelRegularizer),biasRegularizer:en(this.biasRegularizer),activityRegularizer:en(this.activityRegularizer),kernelConstraint:tr(this.kernelConstraint),biasConstraint:tr(this.biasConstraint)},r=super.getConfig();return Object.assign(e,r),e}}return t.className="Dense",t})()),se((()=>{class t extends wt{constructor(e){super(e=e||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=$t(e);for(const r of e.slice(1))if(null==r)throw new A(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],Ea(e,1)]}call(e,r){return $(()=>{this.invokeCallHook(e,r);let s=nt(e);if("channelsFirst"===this.dataFormat&&s.rank>1){const o=[0];for(let i=2;i<s.rank;++i)o.push(i);o.push(1),s=Rt(s,o)}return function Hoe(t){if(t.rank<=1)throw new A(`batchFlatten requires a minimum rank of 2. Got rank: ${t.rank}.`);const n=[t.shape[0],Ea(t.shape,1)];return M(t,n)}(s)})}getConfig(){const e={};null!=this.dataFormat&&(e.dataFormat=this.dataFormat);const r=super.getConfig();return Object.assign(e,r),e}}return t.className="Flatten",t})()),se((()=>{class t extends wt{constructor(e){super(e),this.supportsMasking=!0,this.activation=Fa(e.activation)}call(e,r){return $(()=>{this.invokeCallHook(e,r);const s=nt(e);return this.activation.apply(s)})}getConfig(){const e={activation:Ra(this.activation)},r=super.getConfig();return Object.assign(e,r),e}}return t.className="Activation",t})()),se((()=>{class t extends wt{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,r){return $(()=>function Woe(t,n){return $(()=>{if(2!==t.shape.length)throw new A(`repeat() expects a rank-2 tensor, but received a rank-${t.shape.length} tensor.`);return XS(Tp(t,1),[1,n,1])})}(e=nt(e),this.n))}getConfig(){const e={n:this.n},r=super.getConfig();return Object.assign(e,r),e}}return t.className="RepeatVector",t})()),se((()=>{class t extends wt{constructor(e){super(e),this.targetShape=e.targetShape;for(let r=0;r<this.targetShape.length;++r)this.isUnknown(this.targetShape[r])&&(this.targetShape[r]=null)}isUnknown(e){return e<0||null==e}fixUnknownDimension(e,r){const s="Total size of new array must be unchanged.",o=r.slice();let i=1,a=null;for(let u=0;u<o.length;++u){const c=o[u];if(this.isUnknown(c)){if(null!==a)throw new A("Can only specifiy one unknown dimension.");a=u}else i*=c}const l=Ea(e);if(null!==a){if(0===i||l%i!=0)throw new A(s);o[a]=l/i}else if(l!==i)throw new A(s);return o}computeOutputShape(e){let r=!1;for(let s=0;s<e.length;++s)if(this.isUnknown(e[s])){r=!0;break}return r?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,r){return $(()=>{this.invokeCallHook(e,r);const s=nt(e),o=s.shape,i=o.slice(0,1).concat(this.fixUnknownDimension(o.slice(1),this.targetShape));return M(s,i)})}getConfig(){const e={targetShape:this.targetShape},r=super.getConfig();return Object.assign(e,r),e}}return t.className="Reshape",t})()),se((()=>{class t extends wt{constructor(e){if(super(e),null==e.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const r=Ao(1,e.dims.length+1);if(!Bt(e.dims.slice().sort(),r))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new er({ndim:this.dims.length+1})]}computeOutputShape(e){const r=(e=$t(e)).slice();return this.dims.forEach((s,o)=>{r[o+1]=e[s]}),r}call(e,r){return Rt(nt(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},r=super.getConfig();return Object.assign(e,r),e}}return t.className="Permute",t})()),se((()=>{class t extends wt{constructor(e){super(e??{}),this.supportsMasking=!0,this.maskValue=null!=e?null==e.maskValue?0:e.maskValue:0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),r={maskValue:this.maskValue};return Object.assign(r,e),r}computeMask(e,r){const s=nt(e);return V_(yp(s,this.maskValue),-1)}call(e,r){return $(()=>{this.invokeCallHook(e,r);const s=nt(e),a=V_(yp(s,this.maskValue),-1,!0);return k(s,xe(a,s.dtype))})}}return t.className="Masking",t})()),se((()=>{class t extends wt{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==e.batchInputShape&&null==e.inputShape){let r=null;null!=e.batchSize&&(r=e.batchSize),this.batchInputShape=null==e.inputLength?[r,null]:[r].concat(sn(e.inputLength))}this.inputDim=e.inputDim,pr(this.inputDim,"inputDim"),this.outputDim=e.outputDim,pr(this.outputDim,"outputDim"),this.embeddingsInitializer=gn(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=yn(e.embeddingsRegularizer),this.activityRegularizer=yn(e.activityRegularizer),this.embeddingsConstraint=nr(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,r){return $(()=>this.maskZero?(e=nt(e),yp(e,At(e))):null)}computeOutputShape(e){if(e=$t(e),null==this.inputLength)return[...e,this.outputDim];const r=sn(this.inputLength);if(r.length!==e.length-1)throw new A(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let s=0;for(let o=0;o<r.length;++o){const i=r[o],a=e[o+1];if(null!=i&&null!=a&&i!==a)throw new A(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);null==i&&(r[s]=a),s++}}return[e[0],...r,this.outputDim]}call(e,r){return $(()=>{this.invokeCallHook(e,r);let s=nt(e);"int32"!==s.dtype&&(s=li(s,"int32"));const o=YO(this.embeddings.read(),M(s,[s.size]));return M(o,$t(this.computeOutputShape(s.shape)))})}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:_n(this.embeddingsInitializer),embeddingsRegularizer:en(this.embeddingsRegularizer),activityRegularizer:en(this.activityRegularizer),embeddingsConstraint:tr(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},r=super.getConfig();return Object.assign(e,r),e}}return t.className="Embedding",t})());class Vl extends wt{constructor(n){super(n||{}),this.supportsMasking=!0}mergeFunction(n){throw new lt}computeElementwiseOpOutputShape(n,e){if(null==n||null==e)return null;if(n.length<e.length)return this.computeElementwiseOpOutputShape(e,n);if(0===e.length)return n;const r=n.slice(0,n.length-e.length);for(let s=0;s<e.length;++s){const o=n[n.length-e.length+s],i=e[s];if(null==o||null==i||o<0||i<0)r.push(null);else if(1===o)r.push(i);else if(1===i)r.push(o);else{if(o!==i)throw new A("Operands could not be broadcast together with shapes "+JSON.stringify(n)+" "+JSON.stringify(e));r.push(o)}}return r}build(n){if(Array.isArray(n)&&!Array.isArray(n[0])&&(n=[$t(n)]),n.length<2)throw new A(`A merge layer should be called on an Array of at least 2 inputs. Got ${n.length} input(s).`);let e=[];for(const o of n)null!=o&&null!==o[0]&&e.push(o[0]);if(e=Ta(e),e.length>1)throw new A(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(n)}.`);let r=null==n[0]?null:n[0].slice(1);for(let o=1;o<n.length;++o){const i=null==n[o]?null:n[o].slice(1);r=this.computeElementwiseOpOutputShape(r,i)}const s=n.map(o=>o.length);this.reshapeRequired=-1!==n.indexOf(null)||1!==Ta(s).length}call(n,e){return $(()=>{if(this.reshapeRequired){const r=[],s=n.map(o=>o.rank);if(-1===s.indexOf(null)){const o=Na(s);for(let i of n){const a=i.rank;for(let l=0;l<o-a;++l)i=Tp(i,1);r.push(i)}return this.mergeFunction(r)}{let o=!1;for(const l of n){const u=l.rank;if(null==u){const c=l.shape,d=c[0],h=c.slice(1).concat([d]);let p=M(l,[d].concat(Ea(c.slice(1))));p=Rt(p,[1,0]),p=M(p,h),r.push(p),o=!0}else if(u>1){const c=Ao(1,u).concat([0]);r.push(Rt(l,c)),o=!0}else r.push(l)}let i=this.mergeFunction(r);const a=i.rank;if(o)if(null==a){const l=i.shape,c=l[l.length-1],d=[c].concat(l.slice(0,l.length-1));i=M(Rt(M(i,[-1,c]),[1,0]),d)}else if(a>1){const l=[a-1].concat(Ao(0,a-1));i=Rt(i,l)}return i}}return this.mergeFunction(n)})}computeOutputShape(n){let e;e=null==n[0]?null:n[0].slice(1);for(let s=1;s<n.length;++s){const o=null==n[s]?null:n[s].slice(1);e=this.computeElementwiseOpOutputShape(e,o)}let r=[];for(const s of n)null!=s&&null!==s[0]&&r.push(s[0]);return r=Ta(r),e=1===r.length?r.concat(e):[null].concat(e),e}computeMask(n,e){return $(()=>{if(null==e)return null;if(!Array.isArray(e))throw new A("`mask` should be an Array");if(!Array.isArray(n))throw new A("`inputs` should be an Array");if(e.length!==n.length)throw new A(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${n.length} vs ${e.length})`);if(e.every(s=>null==s))return null;let r=(e=e.map(s=>null==s?s:bs(s,0)))[0];for(let s=1;s<e.length-1;++s)r=Ui(r,e[s]);return r})}}function Pp(t,n){for(;t<0;)t+=n;return t}function Op(t,n,e,r,s,o=.001){let i;if(2===t.rank)i=gQ(t,n,e,r,s,o);else if(3===t.rank)i=bQ(t,n,e,r,s,o);else{if(4!==t.rank)throw new lt(`batchNormalization is not implemented for array of rank ${t.rank} yet`);i=xQ(t,n,e,r,s,o)}return i}function fb(t,n,e,r,s,o){return $(()=>{let i;Ln(s),WO(o),Bs(r),null==e&&(e=[1,1]),null==r&&(r="valid"),null==s&&(s="channelsLast"),null==o&&(o="max"),t=wI(t,s);const a="same"===r?"same":"valid";return i="max"===o?q_(t,n,e,a):U_(t,n,e,a),"channelsFirst"===s&&(i=Rt(i,[0,3,1,2])),i})}function Y$(t,n,e,r,s,o){return $(()=>{let i;Ln(s),WO(o),Bs(r),null==e&&(e=[1,1,1]),null==r&&(r="valid"),null==s&&(s="channelsLast"),null==o&&(o="max"),t=L$(t,s);const a="same"===r?"same":"valid";return i="max"===o?uJ(t,n,e,a):hQ(t,n,e,a),"channelsFirst"===s&&(i=Rt(i,[0,4,1,2,3])),i})}se((()=>{class t extends Vl{constructor(e){super(e)}mergeFunction(e){return $(()=>{let r=e[0].clone();for(let s=1;s<e.length;++s)r=ie(r,e[s]);return r})}}return t.className="Add",t})()),se((()=>{class t extends Vl{constructor(e){super(e)}mergeFunction(e){return $(()=>{let r=e[0].clone();for(let s=1;s<e.length;++s)r=k(r,e[s]);return r})}}return t.className="Multiply",t})()),se((()=>{class t extends Vl{constructor(e){super(e)}mergeFunction(e){return $(()=>{let r=e[0].clone();for(let s=1;s<e.length;++s)r=ie(r,e[s]);return k(1/e.length,r)})}}return t.className="Average",t})()),se((()=>{class t extends Vl{constructor(e){super(e)}mergeFunction(e){return $(()=>{let r=e[0];for(let s=1;s<e.length;++s)r=wa(r,e[s]);return r})}}return t.className="Maximum",t})()),se((()=>{class t extends Vl{constructor(e){super(e)}mergeFunction(e){return $(()=>{let r=e[0];for(let s=1;s<e.length;++s)r=pc(r,e[s]);return r})}}return t.className="Minimum",t})()),se((()=>{class t extends Vl{constructor(e){super(e),this.DEFAULT_AXIS=-1,null==e&&(e={}),this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!Array.isArray(e)||!Array.isArray(e[0])||1===e.length)throw new A("A `Concatenate` layer should be called on a list of at least 2 inputs");let r=!0;for(const o of e)if(null!=o){r=!1;break}if(r)return;const s=[];for(let o=0;o<e.length;++o){const i=e[o].slice();i.splice(this.axis,1);let a=!1;for(const l of s)if(Bt(l,i)){a=!0;break}a||s.push(i)}if(s.length>1)throw new A("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return $(()=>KS(e,this.axis))}computeOutputShape(e){if(!Array.isArray(e)||!Array.isArray(e[0]))throw new A("A `Concatenate` layer should be called on a list of inputs.");const r=e,s=r[0].slice(),o=this.axis<0?s.length+this.axis:this.axis;for(const i of r.slice(1)){if(null==s[o]||null==i[o]){s[o]=null;break}s[o]+=i[o]}return s}computeMask(e,r){if(null==r)return null;if(!Array.isArray(r))throw new A("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new A("`inputs` should be an array for Concatenate");if(r.length!==e.length)throw new A(`Mismatch in the length of mask (${r.length}) and the legnth of inputs (${e.length})`);return $(()=>{let s=!0;if(r.forEach(a=>{null==a||(s=!1)}),s)return null;const o=[];for(let a=0;a<e.length;++a)o.push(null==r[a]?xe(lo(e[a]),"bool"):r[a].rank<e[a].rank?bs(r[a],-1):r[a]);const i=Ar(o,this.axis);return bP(i,-1,!1)})}getConfig(){const e={axis:this.axis},r=super.getConfig();return Object.assign(e,r),e}}return t.className="Concatenate",t})()),se((()=>{class t extends Vl{constructor(e){super(e),this.axes=e.axes,this.normalize=null!=e.normalize&&e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){_(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const r=e[0],s=e[1];if(r.length>3||s.length>3)throw new lt("Dot layer does not support tensors of 4D or higher rank yet.");const o=this.interpretAxes(r,s);if(r[o[0]]!==s[o[1]])throw new A(`Dimension incompatibility: ${r[o[0]]} !== ${s[o[1]]}`)}mergeFunction(e){if(2!==e.length)throw new A(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let o,r=e[0],s=e[1];return o=Array.isArray(this.axes)?this.axes.map((i,a)=>Pp(i,e[a].shape.length)):[Pp(this.axes,r.shape.length),Pp(this.axes,s.shape.length)],this.normalize&&(r=rb(r,o[0]),s=rb(s,o[1])),function uae(t,n,e){if(t.shape.length>3||n.shape.length>3)throw new lt("batchDot is not implemented for tensors of 4D or higher rank yet");if(_(t.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${t.shape.length}`),_(t.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${n.shape.length}`),"number"==typeof e&&(e=[e,e]),"complex64"===t.dtype||"complex64"===n.dtype)throw new lt("batchDot is not implemented for complex64-type Tensors yet.");const r=t.shape.length,s=n.shape.length;null==e&&(e=[r-1,s-2]);const o=e;return $(()=>{let i,a;if(r>s){i=r-s;const l=[];for(let u=0;u<i;++u)l.push(1);n=M(n,n.shape.concat(l))}else if(s>r){i=s-r;const l=[];for(let u=0;u<i;++u)l.push(1);t=M(t,t.shape.concat(l))}else i=0;if(a=2===t.shape.length&&2===n.shape.length?o[0]===o[1]?Ae(k(t,n),o[0]):Ae(k(Rt(t,[1,0]),n),o[1]):zt(t,n,o[0]!==t.shape.length-1,o[1]===n.shape.length-1),i>0){let l;l=r>s?r+s-3:r-1;const u=[];for(let c=l;c<l+i;++c)u.push(c);a=xp(a,u)}return 1===a.shape.length&&(a=bs(a,1)),a})}(r,s,o)}interpretAxes(e,r){let s;return s=Array.isArray(this.axes)?this.axes:[Pp(this.axes,e.length),Pp(this.axes,r.length)],s}computeOutputShape(e){_(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const r=e[0].slice(),s=e[1].slice();if(r.length>3||s.length>3)throw new lt("Dot layer does not support tensors of 4D or higher rank yet.");const o=this.interpretAxes(r,s);r.splice(o[0],1),s.splice(o[1],1),s.splice(0,1);const i=r.concat(s);return 1===i.length&&i.push(1),i}computeMask(e,r){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},r=super.getConfig();return Object.assign(e,r),e}}return t.className="Dot",t})()),se((()=>{class t extends wt{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),r={stddev:this.stddev};return Object.assign(r,e),r}call(e,r){return $(()=>{this.invokeCallHook(e,r);const s=nt(e);return Np(()=>ie(Yy(s.shape,0,this.stddev),s),()=>s,r.training||!1)})}}return t.className="GaussianNoise",t})()),se((()=>{class t extends wt{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),r={rate:this.rate};return Object.assign(r,e),r}call(e,r){return $(()=>{this.invokeCallHook(e,r);const s=nt(e);return this.rate>0&&this.rate<1?Np(()=>{const i=Math.sqrt(this.rate/(1-this.rate));return k(s,Yy(s.shape,1,i))},()=>s,r.training||!1):s})}}return t.className="GaussianDropout",t})()),se((()=>{class t extends wt{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||nt(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),r={rate:this.rate};return Object.assign(r,e),r}call(e,r){return $(()=>{if(this.rate<1&&this.rate>0){const s=this._getNoiseShape(e);return Np(()=>{const i=nt(e),u=-1.7580993408473766;let c=Nl(Ay(s),this.rate);c=li(c,"float32");const d=((1-this.rate)*(1+this.rate*u**2))**-.5,h=-d*u*this.rate,p=ie(k(i,c),k(ie(c,-1),u));return ie(k(p,d),h)},()=>nt(e),r.training||!1)}return e})}}return t.className="AlphaDropout",t})()),se((()=>{class t extends wt{constructor(e){null==e&&(e={}),super(e),this.supportsMasking=!0,this.axis=null==e.axis?-1:e.axis,this.momentum=null==e.momentum?.99:e.momentum,this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=gn(e.betaInitializer||"zeros"),this.gammaInitializer=gn(e.gammaInitializer||"ones"),this.movingMeanInitializer=gn(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=gn(e.movingVarianceInitializer||"ones"),this.betaConstraint=nr(e.betaConstraint),this.gammaConstraint=nr(e.gammaConstraint),this.betaRegularizer=yn(e.betaRegularizer),this.gammaRegularizer=yn(e.gammaRegularizer)}build(e){e=$t(e);const r=this.axis>=0?this.axis:this.axis+e.length,s=e[r];if(null==s)throw new A(`Axis ${r} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new er({ndim:e.length,axes:{[r]:s}})];const o=[s];this.scale&&(this.gamma=this.addWeight("gamma",o,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",o,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",o,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",o,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,r){return $(()=>{const s=null!=r.training&&r.training,o=nt(e),i=o.shape,a=i.length,l=Ao(0,a),u=this.axis>=0?this.axis:this.axis+a;l.splice(u,1);const c=Ml(1,a);c[u]=i[u];const d=l.slice();d.sort();const h=!Bt(d,Ao(0,a).slice(0,a-1));if(!s)return(()=>{if(h){const v=M(this.movingMean.read(),c),x=M(this.movingVariance.read(),c),w=this.center?M(this.beta.read(),c):null,C=this.scale?M(this.gamma.read(),c):null;return Op(o,v,x,w,C,this.epsilon)}return Op(o,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[f,g,m]=function hae(t,n,e,r,s=.001){return Bt(r.slice().sort(),Ao(0,t.rank-1))?function cae(t,n,e,r,s=.001){return $(()=>{const o=X_(t,r),i=o.mean,a=o.variance;return[Op(t,i,a,e,n,s),i,a]})}(t,n,e,r,s):function dae(t,n,e,r,s=.001){return $(()=>{const o=X_(t,r),i=o.mean,a=o.variance,l=[];for(const f of Ao(0,t.rank))-1!==r.indexOf(f)?l.push(1):l.push(t.shape[f]);const u=M(i,l),c=M(a,l),d=null==n?null:M(n,l),h=null==e?null:M(e,l);return[Op(t,u,c,h,d,s),i,a]})}(t,n,e,r,s)}(o,this.gamma.read(),this.beta.read(),l,this.epsilon),y=(v,x,w)=>{$(()=>{const C=1-w,I=v.read(),D=k(ke(I,x),C);v.write(ke(I,D))})};return(()=>{y(this.movingMean,g,this.momentum),y(this.movingVariance,m,this.momentum)})(),f})}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:_n(this.betaInitializer),gammaInitializer:_n(this.gammaInitializer),movingMeanInitializer:_n(this.movingMeanInitializer),movingVarianceInitializer:_n(this.movingVarianceInitializer),betaRegularizer:en(this.betaRegularizer),gammaRegularizer:en(this.gammaRegularizer),betaConstraint:tr(this.betaConstraint),gammaConstraint:tr(this.gammaConstraint)},r=super.getConfig();return Object.assign(e,r),e}}return t.className="BatchNormalization",t})()),se((()=>{class t extends wt{constructor(e){if(null==e&&(e={}),super(e),this.axis=null==e.axis?-1:e.axis,"number"==typeof this.axis){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else{if(!Array.isArray(this.axis))throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);for(const r of this.axis)if(!Number.isInteger(r))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=gn(e.betaInitializer||"zeros"),this.gammaInitializer=gn(e.gammaInitializer||"ones"),this.betaRegularizer=yn(e.betaRegularizer),this.gammaRegularizer=yn(e.gammaRegularizer),this.supportsMasking=!0}build(e){const r=(e=$t(e)).length;"number"==typeof this.axis&&(this.axis=[this.axis]);for(let i=0;i<this.axis.length;++i)this.axis[i]<0&&(this.axis[i]+=r);for(const i of this.axis)if(i<0||i>=r)throw new Error(`Invalid axis: ${i}`);if(this.axis.length!==Ta(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const s=this.axis.map(i=>e[i]);this.gamma=this.scale?this.addWeight("gamma",s,"float32",this.gammaInitializer,this.gammaRegularizer,!0):null,this.beta=this.center?this.addWeight("beta",s,"float32",this.betaInitializer,this.betaRegularizer,!0):null,this.built=!0}call(e,r){const s=nt(e),o=s.shape,i=o.length;return $(()=>{let{mean:l,variance:u}=X_(s,this.axis,!0);const c=Ml(1,i);for(const m of this.axis)c[m]=o[m];const d=m=>null!=m&&m.shape.length!==i?M(m,c):m;let h=this.scale?d(this.gamma.read()):null,p=this.center?d(this.beta.read()):null;const f=[],g=[];for(let m=0;m<i;++m)-1!==this.axis.indexOf(m)?(f.push(o[m]),g.push(1)):(f.push(1),g.push(o[m]));return l=No(l,f),u=No(u,f),null!=h&&(h=No(h,g)),null!=p&&(p=No(p,g)),Op(s,l,u,p,h,this.epsilon)})}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:_n(this.betaInitializer),gammaInitializer:_n(this.gammaInitializer),betaRegularizer:en(this.betaRegularizer),gammaRegularizer:en(this.gammaRegularizer)},r=super.getConfig();return Object.assign(e,r),e}}return t.className="LayerNormalization",t})()),se((()=>{class t extends wt{constructor(e){if(null==e&&(e={}),super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,null==e.padding)this.padding=[[1,1],[1,1]];else if("number"==typeof e.padding)this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,2!==e.padding.length)throw new A(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let r,s;if("number"==typeof e.padding[0])r=[e.padding[0],e.padding[0]],s=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,2!==e.padding[0].length)throw new A(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(r=e.padding[0],2!==e.padding[1].length)throw new A(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);s=e.padding[1]}this.padding=[r,s]}this.inputSpec=[new er({ndim:4})]}computeOutputShape(e){let r,s;return e=$t(e),"channelsFirst"===this.dataFormat?(r=null!=e[2]&&e[2]>=0?e[2]+this.padding[0][0]+this.padding[0][1]:null,s=null!=e[3]&&e[3]>=0?e[3]+this.padding[1][0]+this.padding[1][1]:null,[e[0],e[1],r,s]):(r=null!=e[1]&&e[1]>=0?e[1]+this.padding[0][0]+this.padding[0][1]:null,s=null!=e[2]&&e[2]>=0?e[2]+this.padding[1][0]+this.padding[1][1]:null,[e[0],r,s,e[3]])}call(e,r){return $(()=>function pae(t,n,e){return $(()=>{if(4!==t.rank)throw new A(`temporalPadding expects input tensor to be 4-D, but received a ${t.rank}-D tensor.`);if(null==n&&(n=[[1,1],[1,1]]),2!==n.length||2!==n[0].length||2!==n[1].length)throw new A("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==e&&(e="channelsLast"),"channelsLast"!==e&&"channelsFirst"!==e)throw new A(`Unknown data format: ${e}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let r;return r="channelsFirst"===e?[[0,0],[0,0],n[0],n[1]]:[[0,0],n[0],n[1],[0,0]],Y_(t,r)})}(nt(e),this.padding,this.dataFormat))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},r=super.getConfig();return Object.assign(e,r),e}}return t.className="ZeroPadding2D",t})());class Z$ extends wt{constructor(n){if(null==n.poolSize&&(n.poolSize=2),super(n),"number"==typeof n.poolSize)this.poolSize=[n.poolSize];else{if(!Array.isArray(n.poolSize)||1!==n.poolSize.length||"number"!=typeof n.poolSize[0])throw new A(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(n.poolSize)}`);this.poolSize=n.poolSize}if(pr(this.poolSize,"poolSize"),null==n.strides)this.strides=this.poolSize;else if("number"==typeof n.strides)this.strides=[n.strides];else{if(!Array.isArray(n.strides)||1!==n.strides.length||"number"!=typeof n.strides[0])throw new A(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(n.strides)}`);this.strides=n.strides}pr(this.strides,"strides"),this.padding=null==n.padding?"valid":n.padding,Bs(this.padding),this.inputSpec=[new er({ndim:3})]}computeOutputShape(n){const e=Oo((n=$t(n))[1],this.poolSize[0],this.padding,this.strides[0]);return[n[0],e,n[2]]}call(n,e){return $(()=>{this.invokeCallHook(n,e),n=Tp(nt(n),2);const r=this.poolingFunction(nt(n),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return xp(r,[2])})}getConfig(){const n={poolSize:this.poolSize,padding:this.padding,strides:this.strides},e=super.getConfig();return Object.assign(n,e),n}}se((()=>{class t extends Z${constructor(e){super(e)}poolingFunction(e,r,s,o,i){return Ln(i),Bs(o),fb(e,r,s,o,i,"max")}}return t.className="MaxPooling1D",t})()),se((()=>{class t extends Z${constructor(e){super(e)}poolingFunction(e,r,s,o,i){return Ln(i),Bs(o),fb(e,r,s,o,i,"avg")}}return t.className="AveragePooling1D",t})());class Q$ extends wt{constructor(n){if(null==n.poolSize&&(n.poolSize=[2,2]),super(n),this.poolSize=Array.isArray(n.poolSize)?n.poolSize:[n.poolSize,n.poolSize],null==n.strides)this.strides=this.poolSize;else if(Array.isArray(n.strides)){if(2!==n.strides.length)throw new A(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${n.strides.length}.`);this.strides=n.strides}else this.strides=[n.strides,n.strides];pr(this.poolSize,"poolSize"),pr(this.strides,"strides"),this.padding=null==n.padding?"valid":n.padding,this.dataFormat=null==n.dataFormat?"channelsLast":n.dataFormat,Ln(this.dataFormat),Bs(this.padding),this.inputSpec=[new er({ndim:4})]}computeOutputShape(n){n=$t(n);let e="channelsFirst"===this.dataFormat?n[2]:n[1],r="channelsFirst"===this.dataFormat?n[3]:n[2];return e=Oo(e,this.poolSize[0],this.padding,this.strides[0]),r=Oo(r,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[n[0],n[1],e,r]:[n[0],e,r,n[3]]}call(n,e){return $(()=>(this.invokeCallHook(n,e),this.poolingFunction(nt(n),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const n={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(n,e),n}}se((()=>{class t extends Q${constructor(e){super(e)}poolingFunction(e,r,s,o,i){return Ln(i),Bs(o),fb(e,r,s,o,i,"max")}}return t.className="MaxPooling2D",t})()),se((()=>{class t extends Q${constructor(e){super(e)}poolingFunction(e,r,s,o,i){return Ln(i),Bs(o),fb(e,r,s,o,i,"avg")}}return t.className="AveragePooling2D",t})());class J$ extends wt{constructor(n){if(null==n.poolSize&&(n.poolSize=[2,2,2]),super(n),this.poolSize=Array.isArray(n.poolSize)?n.poolSize:[n.poolSize,n.poolSize,n.poolSize],null==n.strides)this.strides=this.poolSize;else if(Array.isArray(n.strides)){if(3!==n.strides.length)throw new A(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${n.strides.length}.`);this.strides=n.strides}else this.strides=[n.strides,n.strides,n.strides];pr(this.poolSize,"poolSize"),pr(this.strides,"strides"),this.padding=null==n.padding?"valid":n.padding,this.dataFormat=null==n.dataFormat?"channelsLast":n.dataFormat,Ln(this.dataFormat),Bs(this.padding),this.inputSpec=[new er({ndim:5})]}computeOutputShape(n){n=$t(n);let e="channelsFirst"===this.dataFormat?n[2]:n[1],r="channelsFirst"===this.dataFormat?n[3]:n[2],s="channelsFirst"===this.dataFormat?n[4]:n[3];return e=Oo(e,this.poolSize[0],this.padding,this.strides[0]),r=Oo(r,this.poolSize[1],this.padding,this.strides[1]),s=Oo(s,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[n[0],n[1],e,r,s]:[n[0],e,r,s,n[4]]}call(n,e){return $(()=>(this.invokeCallHook(n,e),this.poolingFunction(nt(n),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const n={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(n,e),n}}se((()=>{class t extends J${constructor(e){super(e)}poolingFunction(e,r,s,o,i){return Ln(i),Bs(o),Y$(e,r,s,o,i,"max")}}return t.className="MaxPooling3D",t})()),se((()=>{class t extends J${constructor(e){super(e)}poolingFunction(e,r,s,o,i){return Ln(i),Bs(o),Y$(e,r,s,o,i,"avg")}}return t.className="AveragePooling3D",t})());class eL extends wt{constructor(n){super(n),this.inputSpec=[new er({ndim:3})]}computeOutputShape(n){return[n[0],n[2]]}call(n,e){throw new lt}}se((()=>{class t extends eL{constructor(e){super(e||{})}call(e,r){return $(()=>{const s=nt(e);return Pn(s,1)})}}return t.className="GlobalAveragePooling1D",t})()),se((()=>{class t extends eL{constructor(e){super(e||{})}call(e,r){return $(()=>{const s=nt(e);return ko(s,1)})}}return t.className="GlobalMaxPooling1D",t})());class tL extends wt{constructor(n){super(n),this.dataFormat=null==n.dataFormat?"channelsLast":n.dataFormat,Ln(this.dataFormat),this.inputSpec=[new er({ndim:4})]}computeOutputShape(n){return"channelsLast"===this.dataFormat?[n[0],n[3]]:[n[0],n[1]]}call(n,e){throw new lt}getConfig(){const n={dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(n,e),n}}se((()=>{class t extends tL{call(e,r){return $(()=>{const s=nt(e);return Pn(s,"channelsLast"===this.dataFormat?[1,2]:[2,3])})}}return t.className="GlobalAveragePooling2D",t})()),se((()=>{class t extends tL{call(e,r){return $(()=>{const s=nt(e);return ko(s,"channelsLast"===this.dataFormat?[1,2]:[2,3])})}}return t.className="GlobalMaxPooling2D",t})());class nL extends wt{constructor(n){super(n),this.layer=n.layer}build(n){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(n){null!=this.layer&&(this.layer.trainable=n)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(n){this.layer.setWeights(n)}getConfig(){const n={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},e=super.getConfig();return Object.assign(n,e),n}setFastWeightInitDuringBuild(n){super.setFastWeightInitDuringBuild(n),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(n)}static fromConfig(n,e,r={}){const o=hi(e.layer,r);delete e.layer;const i={layer:o};return Object.assign(i,e),new n(i)}}se((()=>{class t extends nL{constructor(e){super(e),this.supportsMasking=!0}build(e){if((e=$t(e)).length<3)throw new A(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const r=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(r),this.layer.built=!0),super.build(e)}computeOutputShape(e){const r=[(e=$t(e))[0]].concat(e.slice(2)),s=this.layer.computeOutputShape(r);return[s[0],e[1]].concat(s.slice(1))}call(e,r){return $(()=>G$((a,l)=>[nt(this.layer.call(a,r)),[]],e=nt(e),[],!1,null,null,!1,!0)[1])}}return t.className="TimeDistributed",t})()),se((()=>{class t extends nL{constructor(e){super(e);const r=e.layer.getConfig(),s={};s.className=e.layer.getClassName(),s.config=r,this.forwardLayer=hi(s),r.goBackwards=!0!==r.goBackwards;const o={};if(o.className=e.layer.getClassName(),o.config=r,this.backwardLayer=hi(o),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===e.mergeMode?"concat":e.mergeMode,function fae(t){Ol(Ooe,"BidirectionalMergeMode",t)}(this.mergeMode),e.weights)throw new lt("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,null!=this.forwardLayer&&(this.forwardLayer.trainable=e),null!=this.backwardLayer&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const s=Math.floor(e.length/2);this.forwardLayer.setWeights(e.slice(0,s)),this.backwardLayer.setWeights(e.slice(s))}computeOutputShape(e){let s,o,i,r=this.forwardLayer.computeOutputShape(e);return Array.isArray(r)&&Array.isArray(r[0])||(r=[r]),this.returnState&&(i=r.slice(1)),s=r[0],"concat"===this.mergeMode?(s[s.length-1]*=2,o=[s]):o=null==this.mergeMode?[s,s.slice()]:[s],this.returnState?null==this.mergeMode?o.concat(i).concat(i.slice()):[s].concat(i).concat(i.slice()):ls(o)}apply(e,r){let s=null==r?null:r.initialState,o=null==r?null:r.constants;null==r&&(r={});const i=W$(e,s,o,this.numConstants);if(e=i.inputs,s=i.initialState,o=i.constants,Array.isArray(e)&&(s=e.slice(1),e=e[0]),(null==s||0===s.length)&&null==o)return super.apply(e,r);const a=[],l=[];if(null!=s){const c=s.length;if(c%2>0)throw new A("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");r.initialState=s,a.push(...s);const d=s.map(h=>new er({shape:h.shape}));this.forwardLayer.stateSpec=d.slice(0,c/2),this.backwardLayer.stateSpec=d.slice(c/2),l.push(...d)}if(null!=o)throw new lt("Support for constants in Bidirectional layers is not implemented yet.");const u=a[0]instanceof di;for(const c of a)if(c instanceof di!==u)throw new A("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(u){const c=[e].concat(a),d=this.inputSpec.concat(l),h=this.inputSpec;this.inputSpec=d;const p=super.apply(c,r);return this.inputSpec=h,p}return super.apply(e,r)}call(e,r){return $(()=>{const s=r.initialState;let o,i,a,l;if(null==s)o=this.forwardLayer.call(e,r),i=this.backwardLayer.call(e,r);else{const u=s.slice(0,s.length/2),c=s.slice(s.length/2);o=this.forwardLayer.call(e,Object.assign(r,{initialState:u})),i=this.backwardLayer.call(e,Object.assign(r,{initialState:c}))}return this.returnState&&(Array.isArray(o)&&(a=o.slice(1).concat(i.slice(1))),o=o[0],i=i[0]),this.returnSequences&&(i=kl(i,1)),"concat"===this.mergeMode?l=KS([o,i]):"sum"===this.mergeMode?l=ie(o,i):"ave"===this.mergeMode?l=k(.5,ie(o,i)):"mul"===this.mergeMode?l=k(o,i):null==this.mergeMode&&(l=[o,i]),this.returnState?null==this.mergeMode?l.concat(a):[l].concat(a):l})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){$l(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),$l(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,r){let s;if(Array.isArray(r)&&(r=r[0]),s=this.returnSequences?null==this.mergeMode?[r,r]:r:null==this.mergeMode?[null,null]:null,this.returnState){const i=this.forwardLayer.states.map(a=>null);return Array.isArray(s)?s.concat(i).concat(i):[s].concat(i).concat(i)}return s}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(e),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},r=super.getConfig();return Object.assign(e,r),e}static fromConfig(e,r){const s=hi(r.layer);if(delete r.layer,null!=r.numConstants)throw new lt("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const o=r;return o.layer=s,new e(o)}}return t.className="Bidirectional",t})()),se((()=>{class t extends wt{constructor(e){super(e),this.scale=e.scale,this.offset=e.offset?e.offset:0}getConfig(){const e={scale:this.scale,offset:this.offset},r=super.getConfig();return Object.assign(e,r),e}call(e,r){return $(()=>("float32"!==(e=nt(e)).dtype&&(e=li(e,"float32")),ie(k(e,this.scale),this.offset)))}}return t.className="Rescaling",t})());const{resizeBilinear:gae,cropAndResize:yae}=Rl;se((()=>{class t extends wt{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,r,s,o,i,a,l,u){return $(()=>{let c,d=!1;const m=[r/a,s/l,(o+r)/a,(i+s)/l],y=[];3===e.rank?(d=!0,c=Da([e])):c=e;for(let C=0;C<c.shape[0];C++)y.push(m);const b=cp(y,[y.length,4]),v=bp(0,y.length,1,"int32"),w=yae(c,b,v,[o,i],"nearest");return li(d?nt(Al(w)):w,u)})}upsize(e,r,s,o){return $(()=>li(gae(e,[r,s]),o))}call(e,r){return $(()=>{const s=nt(e),o=s.dtype,i=s.shape,a=i[i.length-3],l=i[i.length-2];let u=0;a!==this.height&&(u=Math.floor((a-this.height)/2));let c=0;return l!==this.width&&(c=Math.floor((l-this.width)/2),0===c&&(c=1)),u>=0&&c>=0?this.centerCrop(s,u,c,this.height,this.width,a,l,o):this.upsize(e,this.height,this.width,o)})}getConfig(){const e={height:this.height,width:this.width},r=super.getConfig();return Object.assign(e,r),e}computeOutputShape(e){const s=(e=$t(e)).length-2;return e[e.length-3]=this.height,e[s]=this.width,e}}return t.className="CenterCrop",t})()),se((()=>{class t extends wt{constructor(e){super(e),this.numTokens=e.numTokens,this.outputMode=e.outputMode?e.outputMode:"multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},r=super.getConfig();return Object.assign(e,r),e}computeOutputShape(e){return null==(e=$t(e))?[this.numTokens]:"oneHot"===this.outputMode&&1!==e[e.length-1]?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,r){return $(()=>{let s;if("int32"!==(e=nt(e)).dtype&&(e=li(e,"int32")),typeof r.countWeights<"u"){if("count"!==this.outputMode)throw new A(`countWeights is not used when outputMode !== count.\n              Received countWeights=${r.countWeights}`);s=nt(r.countWeights)}const o=ko(e),i=ky(e),a=$s(this.numTokens,o).bufferSync().get(0),l=Nl(i,0).bufferSync().get(0);if(!a||!l)throw new A(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return function bae(t,n,e,r){let s=nt(t);if("int32"!==s.dtype&&(s=li(s,"int32")),"int"===n)return s;const o=s.shape;if(0===s.rank&&(s=bs(s,-1)),"oneHot"===n&&1!==s.shape[s.shape.length-1]&&(s=bs(s,-1)),s.rank>2)throw new A(`When outputMode is not int, maximum output rank is 2 Received outputMode ${n} and input shape ${o} which would result in output rank ${s.rank}.`);const i=["multiHot","oneHot"].includes(n);let l;if(l=CP(s,typeof r<"u"&&"count"===n?r:[],e,i),"tfIdf"!==n)return l;if(r)return k(l,r);throw new A("When outputMode is 'tfIdf', weights must be provided.")}(e,this.outputMode,this.numTokens,s)})}}return t.className="CategoryEncoding",t})());const rL=new Set(["bilinear","nearest"]);var lL;se((()=>{class t extends wt{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation){if(!rL.has(e.interpolation))throw new A(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);this.interpolation=e.interpolation}else this.interpolation="bilinear";this.cropToAspectRatio=Boolean(e.cropToAspectRatio)}computeOutputShape(e){return e=$t(e),[this.height,this.width,e[2]]}getConfig(){const e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},r=super.getConfig();return Object.assign(e,r),e}call(e,r){return $(()=>{const s=[this.height,this.width];if("bilinear"===this.interpolation)return Rl.resizeBilinear(e,s,!this.cropToAspectRatio);if("nearest"===this.interpolation)return Rl.resizeNearestNeighbor(e,s,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...rL]} are supported`)})}}return t.className="Resizing",t})()),L().registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,t=>{t&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")}),function(t){let n;var e;(e=n=t.CheckpointFormatVersion||(t.CheckpointFormatVersion={}))[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"}(lL||(lL={}));class yb extends Error{constructor(n){super(`NodesExecutionOrderError: ${n}`)}}function Ne(t,n){Array.isArray(t)||(t=[t]),t.forEach(e=>{null!=e&&_("complex64"!==e.dtype,()=>`${n} does not support complex64 tensors in the CPU backend.`)})}Symbol("out"),Symbol("field"),Symbol("quote"),Symbol("quoteafterquote"),Symbol("quoteinquote");const ale=wO;let lle=(()=>{class t extends e0{nextDataId(){return t.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new GF(this,ri())}write(e,r,s){this.firstUse&&(this.firstUse=!1,L().get("IS_NODE")&&Ps("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));const o={id:this.nextDataId()};return this.data.set(o,{values:e,dtype:s,refCount:1}),o}makeTensorInfo(e,r,s){let o;if("string"===r&&null!=s&&s.length>0&&lh(s[0])){const i=s.map(a=>ya(a));o=this.write(i,e,r)}else o=this.write(s,e,r);return{dataId:o,shape:e,dtype:r}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){this.data.get(e).refCount++}decRef(e){this.data.has(e)&&this.data.get(e).refCount--}move(e,r,s,o,i){this.data.set(e,{values:r,dtype:o,refCount:i})}numDataIds(){return this.data.numDataIds()}read(e){var r=this;return J(function*(){return r.readSync(e)})()}readSync(e){const{dtype:r,complexTensorInfos:s}=this.data.get(e);return"complex64"===r?Hi(this.readSync(s.real.dataId),this.readSync(s.imag.dataId)):function hY(t,n){if(Array.isArray(t))return t;if("float32"===n)return t instanceof Float32Array?t:new Float32Array(t);if("int32"===n)return t instanceof Int32Array?t:new Int32Array(t);if("bool"===n||"string"===n)return Uint8Array.from(new Int32Array(t));throw new Error(`Unknown dtype ${n}`)}(this.data.get(e).values,r)}bufferSync(e){const r=this.readSync(e.dataId);if("string"===e.dtype)try{const s=r.map(o=>ba(o));return vt(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return vt(e.shape,e.dtype,r)}makeOutput(e,r,s){return ri().makeTensorFromTensorInfo(this.makeTensorInfo(r,s,e),this)}disposeData(e,r=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!r&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:s}=this.data.get(e);null!=s&&(this.disposeData(s.real.dataId,!0),this.disposeData(s.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}time(e){return J(function*(){const r=is();return e(),{kernelMs:is()-r}})()}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){Ne([e],"where");const r=this.readSync(e.dataId);return ale(e.shape,r)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}return t.nextDataId=0,t})();function fi(t){return(n,e,r)=>{const s=Mn(e,n.length);for(let o=0;o<n.length;++o)s[o]=t(n[o],r);return s}}function qt(t,n,e){return Pa(t,fi(n),e)}function Pa(t,n,e){return({inputs:r,attrs:s,backend:o})=>{const{x:i}=r;Ne(i,t);const a=o,l=a.data.get(i.dataId).values;let u;if("string"===i.dtype){if(!Array.isArray(l))throw new Error("String tensor's value was not an instance of Array");u=ji(l)}else u=l;const c=e||i.dtype,d=n(u,c,s);return a.makeTensorInfo(i.shape,c,d)}}qM("cpu",()=>new lle,1);const BL=qt(Ch,t=>t>=0?t:Math.exp(t)-1),cle={kernelName:Ch,backendName:"cpu",kernelFunc:BL};function mi(t){const{inputs:n,backend:e}=t,{x:r}=n;return e.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const dle={kernelName:Nh,backendName:"cpu",kernelFunc:mi};function zL(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{alpha:o}=r;Ne([s],"leakyRelu");const i=G(s.shape),a=e.data.get(s.dataId).values,l=Nr("float32",i);for(let u=0;u<a.length;u++)l[u]=a[u]<0?o*a[u]:a[u];return e.makeTensorInfo(s.shape,"float32",l)}const hle={kernelName:Eg,backendName:"cpu",kernelFunc:zL};function jn(t){return(n,e,r,s,o)=>{const i=st(n,e),a=i.length,l=Pe(i),c=Nr(o,G(i)),d=n.length,h=e.length,p=Pe(n),f=Pe(e),g=dc(n,i),m=dc(e,i);if(g.length+m.length===0)for(let y=0;y<c.length;++y)c[y]=t(r[y%r.length],s[y%s.length]);else for(let y=0;y<c.length;++y){const b=ec(y,a,l),v=b.slice(-d);g.forEach(I=>v[I]=0);const x=ti(v,d,p),w=b.slice(-h);m.forEach(I=>w[I]=0);const C=ti(w,h,f);c[y]=t(r[x],s[C])}return[c,i]}}const ple=jn((t,n)=>t<0?n*t:t);function UL(t){const{inputs:n,backend:e}=t,{x:r,alpha:s}=n;Ne([r,s],"prelu");const o=e.data.get(r.dataId).values,i=e.data.get(s.dataId).values,[a,l]=ple(r.shape,s.shape,o,i,"float32");return e.makeTensorInfo(l,"float32",a)}const fle={kernelName:qg,backendName:"cpu",kernelFunc:UL},WL=qt(zh,t=>Math.max(0,t)),mle={kernelName:zh,backendName:"cpu",kernelFunc:WL},GL=qt(Uh,t=>Math.min(Math.max(0,t),6)),gle={kernelName:Uh,backendName:"cpu",kernelFunc:GL},yle=fi(t=>1/(1+Math.exp(-t))),HL=qt(Xh,t=>1/(1+Math.exp(-t))),ble={kernelName:Xh,backendName:"cpu",kernelFunc:HL};function wb(t,n,e,r,s){if("linear"===e)return mi({inputs:{x:n},backend:t});if("relu"===e)return WL({inputs:{x:n},backend:t});if("elu"===e)return BL({inputs:{x:n},backend:t});if("relu6"===e)return GL({inputs:{x:n},backend:t});if("prelu"===e)return UL({inputs:{x:n,alpha:r},backend:t});if("leakyrelu"===e)return zL({inputs:{x:n},backend:t,attrs:{alpha:s}});if("sigmoid"===e)return HL({inputs:{x:n},backend:t});throw new Error(`Activation ${e} has not been implemented for the CPU backend.`)}function xs(t){const{inputs:n,backend:e}=t,{real:r,imag:s}=n,o=e.data.get(r.dataId).values,i=e.data.get(s.dataId).values,a=e.makeTensorInfo(r.shape,"complex64");return e.data.get(a.dataId).complexTensorInfos={real:e.makeTensorInfo(r.shape,"float32",o),imag:e.makeTensorInfo(s.shape,"float32",i)},a}const vle={kernelName:b0,backendName:"cpu",kernelFunc:xs};function Cb(t,n,e="float32"){if("complex64"===e)return xs({inputs:{real:Cb(t,n,"float32"),imag:Cb(t,n,"float32")},backend:t});const r=kr(G(n),e);return t.makeTensorInfo(n,e,r)}function zl(t){const{inputs:n,backend:e}=t,{input:r}=n,s=e.data.get(r.dataId).complexTensorInfos.real,o=e.data.get(s.dataId).values;return e.makeTensorInfo(s.shape,s.dtype,o)}const xle={kernelName:W0,backendName:"cpu",kernelFunc:zl};function jL(t,n,e,r){if("int32"===r)return[n,"int32",Int32Array.from(t)];if("bool"===r){const s=wl([0],e),[o,i]=jn((a,l)=>a!==l?1:0)(n,[],t,s,"bool");return[i,"bool",o]}throw new Error(`Error in Cast: failed to cast ${e} to ${r}`)}function Oa(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{dtype:o}=r;if("complex64"===o){if("complex64"===s.dtype)return mi({inputs:{x:s},backend:e});const c=Cb(e,s.shape,s.dtype),d=Oa({inputs:{x:s},backend:e,attrs:{dtype:"float32"}}),h=xs({inputs:{real:d,imag:c},backend:e});return e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(d),h}if("complex64"===s.dtype){const c=zl({inputs:{input:s},backend:e}),d=Oa({inputs:{x:c},backend:e,attrs:{dtype:o}});return e.disposeIntermediateTensorInfo(c),d}if(!KF(s.dtype,o)){const c=mi({inputs:{x:s},backend:e});return{dataId:c.dataId,shape:c.shape,dtype:o}}const i=e.data.get(s.dataId).values,[a,l,u]=jL(i,s.shape,s.dtype,o);return e.makeTensorInfo(a,l,u)}const wle={kernelName:gh,backendName:"cpu",kernelFunc:Oa};function fr(t,n,e,r){return null==e?({inputs:s,backend:o})=>{const{a:i,b:a}=s,l=o;Ne([i,a],t);const u=l.data.get(i.dataId).values,c=l.data.get(a.dataId).values,d="string"===i.dtype?ji(u):u,h="string"===i.dtype?ji(c):c,p=r||i.dtype,[f,g]=n(i.shape,a.shape,d,h,p);return l.makeTensorInfo(g,p,f)}:({inputs:s,backend:o})=>{const{a:i,b:a}=s,l=o;if("complex64"===i.dtype||"complex64"===a.dtype){const u=Oa({inputs:{x:i},backend:l,attrs:{dtype:"complex64"}}),c=l.data.get(u.dataId),h=c.complexTensorInfos.imag,p=l.data.get(c.complexTensorInfos.real.dataId).values,f=l.data.get(h.dataId).values,g=Oa({inputs:{x:a},backend:l,attrs:{dtype:"complex64"}}),m=l.data.get(g.dataId),b=m.complexTensorInfos.imag,v=l.data.get(m.complexTensorInfos.real.dataId).values,x=l.data.get(b.dataId).values,[w,C,I]=e(i.shape,a.shape,p,f,v,x),D=l.makeTensorInfo(I,"float32",w),E=l.makeTensorInfo(I,"float32",C),N=xs({inputs:{real:D,imag:E},backend:l});return l.disposeIntermediateTensorInfo(u),l.disposeIntermediateTensorInfo(g),l.disposeIntermediateTensorInfo(D),l.disposeIntermediateTensorInfo(E),N}{const u=l.data.get(i.dataId).values,c=l.data.get(a.dataId).values,d=r||i.dtype,[h,p]=n(i.shape,a.shape,u,c,d);return l.makeTensorInfo(p,d,h)}}}function BI(t){return(n,e,r,s,o,i)=>{const a=st(n,e),l=G(a),u=a.length,c=Pe(a),d=Nr("float32",l),h=Nr("float32",l),p=dc(n,a),f=dc(e,a),g=Hi(r,s),m=Hi(o,i),y=n.length,b=Pe(n),v=e.length,x=Pe(e);if(p.length+f.length===0)for(let w=0;w<d.length;w++){const C=w%g.length,I=w%m.length,D=t(g[2*C],g[2*C+1],m[2*I],m[2*I+1]);d[w]=D.real,h[w]=D.imag}else for(let w=0;w<d.length;w++){const C=ec(w,u,c),I=C.slice(-y);p.forEach(V=>I[V]=0);const D=ti(I,y,b),E=C.slice(-v);f.forEach(V=>E[V]=0);const N=ti(E,v,x),P=t(g[2*D],g[2*D+1],m[2*N],m[2*N+1]);d[w]=P.real,h[w]=P.imag}return[d,h,a]}}const qL=jn((t,n)=>t+n),Cle=BI((t,n,e,r)=>({real:t+e,imag:n+r})),Sc=fr(tc,qL,Cle),_le={kernelName:tc,backendName:"cpu",kernelFunc:Sc};function on(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{shape:o}=r,i=G(s.shape),a=qF(o,i),l=G(a);_(i===l,()=>`The new shape (${a}) has ${l} elements and the old shape (${s.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`),e.incRef(s.dataId);const u=e.data.get(s.dataId);if(null!=u.complexTensorInfos){const d=u.complexTensorInfos.imag;u.complexTensorInfos.real.shape=a,d.shape=a}return{dataId:s.dataId,shape:a,dtype:s.dtype}}const Sle={kernelName:Xg,backendName:"cpu",kernelFunc:on};function KL(t){const{inputs:n,backend:e,attrs:r}=t,{a:s,b:o}=n,{transposeA:i,transposeB:a}=r;Ne([s,o],"matMul");const l=s.shape.length,u=o.shape.length,c=i?s.shape[l-2]:s.shape[l-1],d=a?o.shape[u-1]:o.shape[u-2],h=i?s.shape[l-1]:s.shape[l-2],p=a?o.shape[u-2]:o.shape[u-1],f=s.shape.slice(0,-2),g=o.shape.slice(0,-2),m=G(f),y=G(g),v=st(s.shape.slice(0,-2),o.shape.slice(0,-2)).concat([h,p]);_(c===d,()=>`Error in matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${s.shape} and ${o.shape} and transposeA=${i} and transposeB=${a} must match.`);const w=a?[y,p,d]:[y,d,p],C=on({inputs:{x:s},backend:e,attrs:{shape:i?[m,c,h]:[m,h,c]}}),I=on({inputs:{x:o},backend:e,attrs:{shape:w}}),D=i?C.shape[1]:C.shape[2],E=i?C.shape[2]:C.shape[1],N=a?I.shape[1]:I.shape[2],P=Math.max(m,y),V=e.data.get(C.dataId).values,B=e.data.get(I.dataId).values,z=Pe(C.shape),U=Pe(I.shape),[j,q,W]=i?[z[0],1,z[1]]:[z[0],z[1],1],[K,ne,ae]=a?[1,U[1],U[0]]:[U[1],1,U[0]],he=E*N,le=vt([P,E,N],C.dtype),be=le.values,pe=e.blockSize;for(let Se=0;Se<P;Se++){const $e=Se%m,qe=Se%y;for(let ze=0;ze<E;ze+=pe){const dt=Math.min(ze+pe,E);for(let mt=0;mt<N;mt+=pe){const Kt=Math.min(mt+pe,N);for(let an=0;an<D;an+=pe){const En=Math.min(an+pe,D);for(let ln=ze;ln<dt;ln++)for(let Jt=mt;Jt<Kt;Jt++){let Sn=0;for(let bn=an;bn<En;bn++)Sn+=V[$e*j+ln*q+bn*W]*B[bn*K+Jt*ne+qe*ae];be[Se*he+(ln*N+Jt)]+=Sn}}}}}return e.disposeIntermediateTensorInfo(C),e.disposeIntermediateTensorInfo(I),e.makeTensorInfo(v,le.dtype,le.values)}const Ile={kernelName:pg,backendName:"cpu",kernelFunc:KL},Tle={kernelName:uy,backendName:"cpu",kernelFunc:function Dle(t){const{inputs:n,backend:e,attrs:r}=t,{a:s,b:o,bias:i,preluActivationWeights:a}=n,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:d}=r;let h,p,f;const g=[];h=KL({inputs:{a:s,b:o},attrs:{transposeA:l,transposeB:u},backend:e}),i&&(p=Sc({inputs:{a:h,b:i},backend:e}),g.push(h),h=p),c&&(f=wb(e,h,c,a,d),g.push(h),h=f);for(const y of g)e.disposeIntermediateTensorInfo(y);return h}};function XL(t){const n=new Float32Array(t.length);for(let e=0;e<t.length;++e)n[e]=Math.abs(t[e]);return n}const Ele={kernelName:lg,backendName:"cpu",kernelFunc:t=>{const{x:n}=t.inputs,e=t.backend;Ne(n,"abs");let r=new Float32Array(G(n.shape));return r=XL(e.data.get(n.dataId).values),e.makeOutput(r,n.shape,n.dtype)}},Nle=qt(uh,t=>Math.acos(t)),kle={kernelName:uh,backendName:"cpu",kernelFunc:Nle},Ale=qt(ch,t=>Math.acosh(t)),Rle={kernelName:ch,backendName:"cpu",kernelFunc:Ale},Mle={kernelName:h0,backendName:"cpu",kernelFunc:function Fle(t){const{inputs:n,backend:e}=t,r=n;Ne(n,"addN");const s=r.map(a=>e.data.get(a.dataId).values),o=vt(r[0].shape,r[0].dtype),i=o.values;for(let a=0;a<r.length;a++){const l=s[a];for(let u=0;u<i.length;u++)i[u]+=l[u]}return e.makeTensorInfo(o.shape,o.dtype,o.values)}};function zI(t,n,e,r,s){const o=n.length,i=G(n),a=Pe(n),l=Pe(s),u=Nr(e,G(s));for(let c=0;c<i;++c){const d=ec(c,o,a),h=new Array(d.length);for(let f=0;f<h.length;f++)h[f]=d[r[f]];u[ti(h,o,l)]=t[c]}return u}function cs(t){const{inputs:n,attrs:e,backend:r}=t,{x:s}=n,{perm:o}=e;Ne(s,"transpose");const a=new Array(s.shape.length);for(let d=0;d<a.length;d++)a[d]=s.shape[o[d]];const u=zI(r.data.get(s.dataId).values,s.shape,s.dtype,o,a);return{dataId:r.write(u,a,s.dtype),shape:a,dtype:s.dtype}}const Ple={kernelName:nc,backendName:"cpu",kernelFunc:cs},$le={kernelName:"All",backendName:"cpu",kernelFunc:function Ole(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o,keepDims:i}=r;Ne(s,"all");const a=bt(o,s.shape);let l=a;const u=Cn(l,s.shape.length);let c=s;null!=u&&(c=cs({inputs:{x:s},backend:e,attrs:{perm:u}}),l=$n(l.length,s.shape.length)),xr("all",l,c.shape.length);const[d,h]=dr(c.shape,l),p=G(h),f=kr(G(d),c.dtype),g=e.data.get(c.dataId).values;for(let y=0;y<f.length;++y){const b=y*p;let v=g[b];for(let x=0;x<p;++x)v=v&&g[b+x];f[y]=v}null!=u&&e.disposeIntermediateTensorInfo(c);const m=e.makeTensorInfo(d,c.dtype,f);if(i){const b=on({inputs:{x:m},backend:e,attrs:{shape:On(d,a)}});return e.disposeIntermediateTensorInfo(m),b}return m}},Vle={kernelName:"Any",backendName:"cpu",kernelFunc:function Lle(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o,keepDims:i}=r;Ne(s,"any");const a=bt(o,s.shape);let l=a;const u=Cn(l,s.shape.length);let c=s;null!=u&&(c=cs({inputs:{x:s},backend:e,attrs:{perm:u}}),l=$n(l.length,s.shape.length)),xr("any",l,c.shape.length);const[d,h]=dr(c.shape,l),p=G(h),f=kr(G(d),c.dtype),g=e.data.get(c.dataId).values;for(let y=0;y<f.length;++y){const b=y*p;let v=g[b];for(let x=0;x<p;++x)v=v||g[b+x];f[y]=v}null!=u&&e.disposeIntermediateTensorInfo(c);const m=e.makeTensorInfo(d,c.dtype,f);if(i){const b=on({inputs:{x:m},backend:e,attrs:{shape:On(d,a)}});return e.disposeIntermediateTensorInfo(m),b}return m}},zle={kernelName:ug,backendName:"cpu",kernelFunc:function Ble(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o}=r;Ne(s,"argMax");let i=bt(o,s.shape);const a=Cn(i,s.shape.length);let l=s;const u=[];null!=a&&(l=cs({inputs:{x:s},backend:e,attrs:{perm:a}}),u.push(l),i=$n(i.length,l.shape.length)),i=[i[0]],xr("argMax",i,l.shape.length);const[c,d]=dr(l.shape,i),p=kr(G(c),"int32"),f=G(d),g=e.data.get(l.dataId).values;for(let m=0;m<p.length;++m){const y=m*f;let b=g[y],v=0;for(let x=0;x<f;++x){const w=g[y+x];w>b&&(b=w,v=x)}p[m]=v}return u.forEach(m=>e.disposeIntermediateTensorInfo(m)),e.makeTensorInfo(c,"int32",p)}},Wle={kernelName:cg,backendName:"cpu",kernelFunc:function Ule(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o}=r;Ne(s,"argMin");let i=bt(o,s.shape);const a=Cn(i,s.shape.length);let l=s;const u=[];null!=a&&(l=cs({inputs:{x:s},backend:e,attrs:{perm:a}}),u.push(l),i=$n(i.length,l.shape.length)),i=[i[0]],xr("argMin",i,l.shape.length);const[c,d]=dr(l.shape,i),p=kr(G(c),"int32"),f=G(d),g=e.data.get(l.dataId).values;for(let m=0;m<p.length;++m){const y=m*f;let b=g[y],v=0;for(let x=0;x<f;++x){const w=g[y+x];w<b&&(b=w,v=x)}p[m]=v}return u.forEach(m=>e.disposeIntermediateTensorInfo(m)),e.makeTensorInfo(c,"int32",p)}},Gle=qt(dh,t=>Math.asin(t)),Hle={kernelName:dh,backendName:"cpu",kernelFunc:Gle},jle=qt(hh,t=>Math.asinh(t)),qle={kernelName:hh,backendName:"cpu",kernelFunc:jle},Kle=qt(ph,t=>Math.atan(t)),Xle={kernelName:ph,backendName:"cpu",kernelFunc:Kle},Yle=jn((t,n)=>Math.atan2(t,n)),Zle=fr(mh,Yle),Qle={kernelName:mh,backendName:"cpu",kernelFunc:Zle},Jle=qt(fh,t=>Math.atanh(t)),eue={kernelName:fh,backendName:"cpu",kernelFunc:Jle};function UI(t,n,e,r,s,o){const i=s.strideHeight,a=s.strideWidth,l=s.dilationHeight,u=s.dilationWidth,c=s.effectiveFilterHeight,d=s.effectiveFilterWidth,h=s.padInfo.top,p=s.padInfo.left,f="max"===o?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,g=vt(s.outShape,e),m=g.values,y=s.outShape[1]*s.outShape[2]*s.outShape[3],b=s.outShape[2]*s.outShape[3],v=s.outShape[3];for(let x=0;x<s.batchSize;++x){const w=x*y,C=x*r[0];for(let I=0;I<s.inChannels;++I)for(let D=0;D<s.outHeight;++D){const E=D*i-h,N=Math.max(0,E),P=Math.min(s.inHeight,c+E),V=w+D*b;for(let B=0;B<s.outWidth;++B){const z=B*a-p,U=Math.max(0,z),j=Math.min(s.inWidth,d+z);let q=f,W=0,K=0;for(let ae=N;ae<P;ae+=l){const he=C+ae*r[1];for(let le=U;le<j;le+=u){const pe=t[he+le*r[2]+I];"max"===o&&pe>q?q=pe:"avg"===o&&(W+=pe,K++)}if(isNaN(q))break}m[V+B*v+I]="avg"===o?W/K:q}}}return g}function YL(t,n,e,r,s=!1,o=!1){const i=vt(r.outShape,"int32"),a=r.strideHeight,l=r.strideWidth,u=r.dilationHeight,c=r.dilationWidth,d=r.effectiveFilterHeight,h=r.effectiveFilterWidth,p=r.padInfo.top,f=r.padInfo.left,g=vt(n,e,t);for(let m=0;m<r.batchSize;++m)for(let y=0;y<r.inChannels;++y)for(let b=0;b<r.outHeight;++b){const v=b*a-p;let x=v;for(;x<0;)x+=u;const w=Math.min(r.inHeight,d+v);for(let C=0;C<r.outWidth;++C){const I=C*l-f;let D=I;for(;D<0;)D+=c;const E=Math.min(r.inWidth,h+I);let N=Number.NEGATIVE_INFINITY,P=-1;for(let V=x;V<w;V+=u){const B=V-v;for(let z=D;z<E;z+=c){const U=z-I,j=g.get(m,V,z,y);j>N&&(N=j,P=s?o?((m*r.inHeight+V)*r.inWidth+z)*r.inChannels+y:(V*r.inWidth+z)*r.inChannels+y:B*h+U)}}i.set(P,m,b,C,y)}}return i}function ZL(t,n,e,r,s,o){const i=s.strideDepth,a=s.strideHeight,l=s.strideWidth,u=s.dilationDepth,c=s.dilationHeight,d=s.dilationWidth,h=s.effectiveFilterDepth,p=s.effectiveFilterHeight,f=s.effectiveFilterWidth,g=s.padInfo.front,m=s.padInfo.top,y=s.padInfo.left,b="max"===o?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,v=vt(s.outShape,e),x=v.values,w=s.outShape[1]*s.outShape[2]*s.outShape[3]*s.outShape[4],C=s.outShape[2]*s.outShape[3]*s.outShape[4],I=s.outShape[3]*s.outShape[4],D=s.outShape[4];for(let E=0;E<s.batchSize;++E){const N=E*w,P=E*r[0];for(let V=0;V<s.inChannels;++V)for(let B=0;B<s.outDepth;++B){const z=B*i-g;let U=z;for(;U<0;)U+=u;const j=Math.min(s.inDepth,h+z),q=N+B*C;for(let W=0;W<s.outHeight;++W){const K=W*a-m;let ne=K;for(;ne<0;)ne+=c;const ae=Math.min(s.inHeight,p+K),he=q+W*I;for(let le=0;le<s.outWidth;++le){const be=le*l-y;let pe=be;for(;pe<0;)pe+=d;const Se=Math.min(s.inWidth,f+be),$e=he+le*D;let qe=b,ze=0,dt=0;for(let Kt=U;Kt<j;Kt+=u){const an=P+Kt*r[1];for(let En=ne;En<ae;En+=c){const ln=an+En*r[2];for(let Jt=pe;Jt<Se;Jt+=d){const bn=t[ln+Jt*r[3]+V];if("max"===o&&bn>qe?qe=bn:"avg"===o&&(ze+=bn,dt++),isNaN(qe))break}if(isNaN(qe))break}if(isNaN(qe))break}x[$e+V]="avg"===o?ze/Math.max(dt,1):qe}}}}return v}const rue={kernelName:dg,backendName:"cpu",kernelFunc:function nue(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n;Ne(s,"avgPool");const{filterSize:o,strides:i,pad:a,dimRoundingMode:l}=r;_(vr(i,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`);const c=so(s.shape,o,i,1,a,l);let d;if(1===c.filterWidth&&1===c.filterHeight&&Bt(c.inShape,c.outShape))d=mi({inputs:{x:s},backend:e});else{const h=e.data.get(s.dataId).values,p=Pe(s.shape),f=UI(h,0,s.dtype,p,c,"avg");d=e.makeTensorInfo(c.outShape,s.dtype,f.values)}return d}},oue={kernelName:hg,backendName:"cpu",kernelFunc:function sue(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{filterSize:o,strides:i,pad:a,dimRoundingMode:l,dataFormat:u}=r;Ne(s,"avgPool3d");const c=Bi(s.shape,o,i,1,a,l,u),h=ZL(e.data.get(s.dataId).values,0,s.dtype,Pe(s.shape),c,"avg");return e.makeTensorInfo(h.shape,"float32",h.values)}},aue={kernelName:g0,backendName:"cpu",kernelFunc:function iue(t){const{inputs:n,backend:e,attrs:r}=t,{dy:s,input:o}=n,{filterSize:i,strides:a,pad:l,dimRoundingMode:u}=r;Ne([s,o],"avgPool3DGrad");const c=Bi(o.shape,i,a,1,l,u),d=c.strideDepth,h=c.strideHeight,p=c.strideWidth,f=c.filterDepth,g=c.filterHeight,m=c.filterWidth,y=c.dilationDepth,b=c.dilationHeight,v=c.dilationWidth,x=c.effectiveFilterDepth,w=c.effectiveFilterHeight,C=c.effectiveFilterWidth,I=x-1-c.padInfo.front,D=C-1-c.padInfo.left,E=w-1-c.padInfo.top,N=vt(o.shape,"float32"),P=1/(f*g*m),V=e.bufferSync(s);for(let B=0;B<c.batchSize;++B)for(let z=0;z<c.inChannels;++z)for(let U=0;U<c.inDepth;++U)for(let j=0;j<c.inHeight;++j)for(let q=0;q<c.inWidth;++q){const W=U-I,K=j-E,ne=q-D;let ae=0;for(let he=0;he<x;he+=y){const le=(W+he)/d;if(!(le<0||le>=c.outDepth||Math.floor(le)!==le))for(let be=0;be<w;be+=b){const pe=(K+be)/h;if(!(pe<0||pe>=c.outHeight||Math.floor(pe)!==pe))for(let Se=0;Se<C;Se+=v){const $e=(ne+Se)/p;$e<0||$e>=c.outWidth||Math.floor($e)!==$e||(ae+=V.get(B,le,pe,$e,z))}}}N.set(ae*P,B,U,j,q,z)}return e.makeTensorInfo(N.shape,N.dtype,N.values)}},uue={kernelName:m0,backendName:"cpu",kernelFunc:function lue(t){const{inputs:n,backend:e,attrs:r}=t,{dy:s,input:o}=n,i=o;Ne([s,o],"avgPoolGrad");const{filterSize:a,strides:l,pad:u}=r,c=so(i.shape,a,l,1,u),d=c.strideHeight,h=c.strideWidth,p=c.filterHeight,f=c.filterWidth,g=c.dilationHeight,m=c.dilationWidth,y=c.effectiveFilterHeight,b=c.effectiveFilterWidth,v=b-1-c.padInfo.left,x=y-1-c.padInfo.top,w=vt(i.shape,"float32"),C=1/(p*f),I=e.data.get(s.dataId).values,D=vt(s.shape,"float32",I);for(let E=0;E<c.batchSize;++E)for(let N=0;N<c.inChannels;++N)for(let P=0;P<c.inHeight;++P)for(let V=0;V<c.inWidth;++V){const B=P-x,z=V-v;let U=0;for(let j=0;j<y;j+=g){const q=(B+j)/d;if(!(q<0||q>=c.outHeight||Math.floor(q)!==q))for(let W=0;W<b;W+=m){const K=(z+W)/h;K<0||K>=c.outWidth||Math.floor(K)!==K||(U+=D.get(E,q,K,N))}}w.set(U*C,E,P,V,N)}return e.makeTensorInfo(w.shape,w.dtype,w.values)}},due={kernelName:Ig,backendName:"cpu",kernelFunc:function cue(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,scale:o,offset:i,mean:a,variance:l}=n;_(a.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),_(null==i||a.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),_(null==o||a.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),Ne([s,a,l,o,i],"batchNorm");let{varianceEpsilon:u}=r;null==u&&(u=.001);const c=e.data.get(s.dataId).values,d=e.data.get(a.dataId).values,h=e.data.get(l.dataId).values,p=o?e.data.get(o.dataId).values:new Float32Array([1]),f=i?e.data.get(i.dataId).values:new Float32Array([0]),g=new Float32Array(c.length),m=f.length,y=p.length,b=h.length,v=d.length;let x=0,w=0,C=0,I=0;for(let D=0;D<c.length;++D)g[D]=f[x++]+(c[D]-d[w++])*p[C++]/Math.sqrt(h[I++]+u),x>=m&&(x=0),w>=v&&(w=0),C>=y&&(C=0),I>=b&&(I=0);return e.makeTensorInfo(s.shape,s.dtype,g)}};function QL(t,n,e,r,s){const o=O_(r,n,e),i=G(e),a=Pe(r);if(o){const d=$_(n,a);return"string"===s?t.slice(d,d+i):t.subarray(d,d+i)}const u=vt(r,s,"string"===s?ji(t):t),c=vt(e,s);for(let d=0;d<c.size;++d){const h=c.indexToLoc(d),p=h.map((f,g)=>f+n[g]);c.set(u.get(...p),...h)}return"string"===s?xO(c.values):c.values}function Ul(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{begin:o,size:i}=r;Ne(s,"slice");const[a,l]=Iy(s,o,i);M_(s,a,l);const c=QL(e.data.get(s.dataId).values,a,l,s.shape,s.dtype);return e.makeTensorInfo(l,s.dtype,c)}const hue={kernelName:ey,backendName:"cpu",kernelFunc:Ul},fue={kernelName:fg,backendName:"cpu",kernelFunc:function pue(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{blockShape:o,crops:i}=r;Ne([s],"batchToSpaceND");const a=o.reduce((y,b)=>y*b),l=Cp(s.shape,o,a),u=_p(l.length,o.length),c=Sp(s.shape,o,a),d=vS(i,o.length),h=xS(c,i,o.length),p=on({inputs:{x:s},backend:e,attrs:{shape:l}}),f=cs({inputs:{x:p},backend:e,attrs:{perm:u}}),g=on({inputs:{x:f},backend:e,attrs:{shape:c}}),m=Ul({inputs:{x:g},backend:e,attrs:{begin:d,size:h}});return e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(g),m}};function WI(t,n,e,r,s){const o=G(r),i=kr(s,e);for(let a=0;a<t.length;a++){const l=t[a];if(l<0)throw new Error("Input x must be non-negative!");l>=s||(i[l]+=o>0?n[a]:1)}return i}function JL(t,n,e,r=!1){const s=t.shape[0],o=t.shape[1],i=vt([s,e],n.dtype);for(let a=0;a<s;a++)for(let l=0;l<o;l++){const u=t.get(a,l);if(u<0)throw new Error("Input x must be non-negative!");u>=e||i.set(r?1:n.size>0?i.get(a,u)+n.get(a,l):i.get(a,u)+1,a,u)}return i}const gue={kernelName:y0,backendName:"cpu",kernelFunc:function mue(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,weights:o}=n,{size:i}=r,u=WI(e.data.get(s.dataId).values,e.data.get(o.dataId).values,o.dtype,o.shape,i);return e.makeTensorInfo([i],o.dtype,u)}},bue={kernelName:eM,backendName:"cpu",kernelFunc:function yue(t){const{inputs:n,backend:e}=t,{s0:r,s1:s}=n,o=e.data.get(r.dataId).values,i=e.data.get(s.dataId).values,a=st(Array.from(o),Array.from(i));return e.makeTensorInfo([a.length],"int32",Int32Array.from(a))}},eV=fi(t=>Math.ceil(t)),vue=Pa(yh,eV),xue={kernelName:yh,backendName:"cpu",kernelFunc:vue},wue=qt(bh,(t,n)=>t>n.clipValueMax?n.clipValueMax:t<n.clipValueMin?n.clipValueMin:t),Cue={kernelName:bh,backendName:"cpu",kernelFunc:wue},_ue={kernelName:mg,backendName:"cpu",kernelFunc:t=>{const{x:n}=t.inputs,e=t.backend,r=new Float32Array(G(n.shape)),s=e.data.get(n.dataId),i=s.complexTensorInfos.imag,a=e.data.get(s.complexTensorInfos.real.dataId).values,l=e.data.get(i.dataId).values;for(let u=0;u<a.length;u++)r[u]=Math.hypot(a[u],l[u]);return e.makeOutput(r,n.shape,"float32")}};function tV(t,n,e,r){const s=Mn(e,G(n));if(r&&"string"!==e){let o=0;t.forEach(i=>{const a=G(i.shape);s.set(i.vals,o),o+=a})}else{let o=0;t.forEach(i=>{const a="string"===e?ji(i.vals):i.vals;let l=0;for(let u=0;u<i.shape[0];++u){const c=u*n[1]+o;for(let d=0;d<i.shape[1];++d)s[c+d]=a[l++]}o+=i.shape[1]})}return s}function Ic(t){const{inputs:n,backend:e}=t,{input:r}=n,s=e.data.get(r.dataId).complexTensorInfos.imag,o=e.data.get(s.dataId).values;return e.makeTensorInfo(s.shape,s.dtype,o)}const Sue={kernelName:P0,backendName:"cpu",kernelFunc:Ic};function Dc(t){const{inputs:n,backend:e,attrs:r}=t,{axis:s}=r,o=bt(s,n[0].shape)[0];gS(n.map(g=>g.shape),o);let a=ii(n.map(g=>g.shape),o);if(0===G(a))return e.makeTensorInfo(a,n[0].dtype,[]);const l=n.filter(g=>G(g.shape)>0);if(1===l.length)return mi({inputs:{x:l[0]},backend:e});if("complex64"===l[0].dtype){const g=l.map(x=>zl({inputs:{input:x},backend:e})),m=l.map(x=>Ic({inputs:{input:x},backend:e})),y=Dc({inputs:g,backend:e,attrs:{axis:o}}),b=Dc({inputs:m,backend:e,attrs:{axis:o}}),v=xs({inputs:{real:y,imag:b},backend:e});return g.forEach(x=>e.disposeIntermediateTensorInfo(x)),m.forEach(x=>e.disposeIntermediateTensorInfo(x)),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(b),v}const u=l.map(g=>{const y=[-1,G(g.shape.slice(o))];return on({inputs:{x:g},backend:e,attrs:{shape:y}})}),c=u.map(g=>({vals:e.data.get(g.dataId).values,shape:g.shape}));a=ii(u.map(g=>g.shape),1);const h=tV(c,a,n[0].dtype,1===u[0].shape[0]),p=ii(l.map(g=>g.shape),o),f=e.makeTensorInfo(p,n[0].dtype,h);return u.forEach(g=>e.disposeIntermediateTensorInfo(g)),f}const Iue={kernelName:gg,backendName:"cpu",kernelFunc:Dc};function nV(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,filter:o}=n,{strides:i,pad:a,dataFormat:l,dilations:u,dimRoundingMode:c}=r;Ne([s,o],"conv2d");const d=zi(l),h=cr(s.shape,o.shape,i,u,a,c,!1,d),p=h.filterHeight,f=h.filterWidth,g=h.dilationHeight,m=h.dilationWidth,y=h.padInfo.left,b=h.padInfo.top,v="channelsLast"===h.dataFormat,x=new br(h.outShape,s.dtype),w=Pe(s.shape),C=Pe(o.shape),I=w[0],D=v?w[1]:w[2],E=v?w[2]:1,N=v?1:w[1],P=x.strides[0],V=v?x.strides[1]:x.strides[2],B=v?x.strides[2]:1,z=v?1:x.strides[1],U=e.data.get(s.dataId).values,j=e.data.get(o.dataId).values,q=x.values;for(let W=0;W<h.batchSize;++W){const K=W*I,ne=W*P;for(let ae=0;ae<h.outHeight;++ae){const he=ne+ae*V,le=ae*h.strideHeight-b;for(let be=0;be<p;++be){const pe=le+be*g;if(pe<0||pe>=h.inHeight)continue;const Se=be*C[0],$e=K+pe*D;for(let qe=0;qe<h.outWidth;++qe){const ze=he+qe*B,dt=qe*h.strideWidth-y;for(let mt=0;mt<f;++mt){const Kt=dt+mt*m;if(Kt<0||Kt>=h.inWidth)continue;const En=$e+Kt*E;let ln=Se+mt*C[1];for(let Jt=0;Jt<h.inChannels;++Jt){const Sn=U[En+Jt*N];for(let bn=0;bn<h.outChannels;++bn)q[ze+bn*z]+=Sn*j[ln+bn];ln+=h.outChannels}}}}}}return e.makeTensorInfo(x.shape,x.dtype,q)}const Due={kernelName:yg,backendName:"cpu",kernelFunc:nV},Eue={kernelName:v0,backendName:"cpu",kernelFunc:function Tue(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,dy:o}=n,{strides:i,pad:a,dataFormat:l,dimRoundingMode:u,filterShape:c}=r;Ne([s,o],"conv2dBackpropFilter");const d=zi(l),h=cr(s.shape,c,i,1,a,u,!1,d),{strideHeight:p,strideWidth:f,filterHeight:g,filterWidth:m}=h,y="channelsLast"===h.dataFormat,b=new br(h.filterShape,"float32"),v=h.padInfo.left,x=h.padInfo.top,w=e.data.get(s.dataId).values,C=e.data.get(o.dataId).values,I=new br(s.shape,s.dtype,w),D=new br(o.shape,o.dtype,C);for(let E=0;E<g;++E){const N=Math.max(0,Math.ceil((x-E)/p)),P=Math.min(h.outHeight,(h.inHeight+x-E)/p);for(let V=0;V<m;++V){const B=Math.max(0,Math.ceil((v-V)/f)),z=Math.min(h.outWidth,(h.inWidth+v-V)/f);for(let U=0;U<h.inChannels;++U)for(let j=0;j<h.outChannels;++j){let q=0;for(let W=0;W<h.batchSize;++W)for(let K=N;K<P;++K){const ne=E+K*p-x;for(let ae=B;ae<z;++ae){const he=V+ae*f-v;q+=y?I.get(W,ne,he,U)*D.get(W,K,ae,j):I.get(W,U,ne,he)*D.get(W,j,K,ae)}}b.set(q,E,V,U,j)}}}return e.makeTensorInfo(b.shape,b.dtype,b.values)}},kue={kernelName:bg,backendName:"cpu",kernelFunc:function Nue(t){const{inputs:n,backend:e,attrs:r}=t,{dy:s,filter:o}=n,{inputShape:i,strides:a,pad:l,dataFormat:u,dimRoundingMode:c}=r;Ne([s,o],"conv2dBackpropInput");const d=Pe(o.shape),h=Pe(s.shape);let p=zi(u);const f=cr(i,o.shape,a,1,l,c,!1,p),g=new br(f.inShape,"float32"),m=g.values,y=e.data.get(s.dataId).values,b=e.data.get(o.dataId).values,[v,x,w]=d,{batchSize:C,filterHeight:I,filterWidth:D,inChannels:E,inHeight:N,inWidth:P,outChannels:V,outHeight:B,outWidth:z,strideHeight:U,strideWidth:j}=f;p=f.dataFormat;const q=I-1-f.padInfo.top,W=D-1-f.padInfo.left,K="channelsLast"===p,ne=g.strides[0],ae=K?g.strides[1]:g.strides[2],he=K?g.strides[2]:1,le=K?1:g.strides[1],be=h[0],pe=K?h[1]:h[2],Se=K?h[2]:1,$e=K?1:h[1];for(let qe=0;qe<C;++qe)for(let ze=0;ze<E;++ze)for(let dt=0;dt<N;++dt){const mt=dt-q,Kt=Math.max(0,Math.ceil(mt/U)),an=Math.min(B,(I+mt)/U);for(let En=0;En<P;++En){const ln=En-W,Jt=Math.max(0,Math.ceil(ln/j)),Sn=Math.min(z,(D+ln)/j);let bn=0;for(let Cr=Kt;Cr<an;++Cr){const za=Cr*U-mt;for(let Ws=Jt;Ws<Sn;++Ws){const Lo=be*qe+pe*Cr+Se*Ws,Yi=v*(I-1-za)+x*(D-1-(Ws*j-ln))+w*ze;for(let Ua=0;Ua<V;++Ua)bn+=y[Lo+$e*Ua]*b[Yi+Ua]}}m[ne*qe+ae*dt+he*En+le*ze]=bn}}return e.makeTensorInfo(g.shape,g.dtype,g.values)}},Rue={kernelName:vg,backendName:"cpu",kernelFunc:function Aue(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,filter:o}=n,{strides:i,pad:a,dilations:l}=r;Ne([s,o],"conv3d");const u=Ca(s.shape,o.shape,i,l,a),{filterDepth:c,filterHeight:d,filterWidth:h,dilationDepth:p,dilationHeight:f,dilationWidth:g,padInfo:m}=u,y=m.front,b=m.left,v=m.top,x=new br(u.outShape,s.dtype),w=e.data.get(s.dataId).values,C=e.data.get(o.dataId).values,I=x.values,D=Pe(s.shape),E=Pe(o.shape);for(let N=0;N<u.batchSize;++N){const P=N*D[0],V=N*x.strides[0];for(let B=0;B<u.outDepth;++B){const z=V+B*x.strides[1],U=B*u.strideDepth-y;for(let j=0;j<c;++j){const q=U+j*p;if(q<0||q>=u.inDepth)continue;const W=j*E[0],K=P+q*D[1];for(let ne=0;ne<u.outHeight;++ne){const ae=z+ne*x.strides[2],he=ne*u.strideHeight-v;for(let le=0;le<d;++le){const be=he+le*f;if(be<0||be>=u.inHeight)continue;const pe=W+le*E[1],Se=K+be*D[2];for(let $e=0;$e<u.outWidth;++$e){const qe=ae+$e*u.outChannels,ze=$e*u.strideWidth-b;for(let dt=0;dt<h;++dt){const mt=ze+dt*g;if(mt<0||mt>=u.inWidth)continue;const an=Se+mt*u.inChannels;let En=pe+dt*E[2];for(let ln=0;ln<u.inChannels;++ln){const Jt=w[an+ln];for(let Sn=0;Sn<u.outChannels;++Sn)I[qe+Sn]+=Jt*C[En+Sn];En+=u.outChannels}}}}}}}}return e.makeTensorInfo(x.shape,x.dtype,x.values)}},Mue={kernelName:x0,backendName:"cpu",kernelFunc:function Fue(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,dy:o}=n,{strides:i,pad:a,filterShape:l}=r;Ne([s,o],"conv3dBackpropFilterV2");const u=Pe(s.shape),c=Pe(o.shape),d=Ca(s.shape,l,i,1,a),h=d.strideDepth,p=d.strideHeight,f=d.strideWidth,g=d.filterDepth,m=d.filterHeight,y=d.filterWidth,b=new br(d.filterShape,"float32"),v=b.values,[x,w,C,I]=b.strides,D=e.data.get(o.dataId).values,[E,N,P,V]=c,B=e.data.get(s.dataId).values,[z,U,j,q]=u,W=d.padInfo.front,K=d.padInfo.left,ne=d.padInfo.top;for(let ae=0;ae<g;++ae){const he=Math.max(0,Math.ceil((W-ae)/h)),le=Math.min(d.outDepth,(d.inDepth+W-ae)/h),be=ae*x;for(let pe=0;pe<m;++pe){const Se=Math.max(0,Math.ceil((ne-pe)/p)),$e=Math.min(d.outHeight,(d.inHeight+ne-pe)/p),qe=pe*w+be;for(let ze=0;ze<y;++ze){const dt=Math.max(0,Math.ceil((K-ze)/f)),mt=Math.min(d.outWidth,(d.inWidth+K-ze)/f),Kt=ze*C+qe;for(let an=0;an<d.inChannels;++an){const En=an*I+Kt;for(let ln=0;ln<d.outChannels;++ln){let Jt=0;for(let Sn=0;Sn<d.batchSize;++Sn){const bn=Sn*z,Xi=Sn*E;for(let Cr=he;Cr<le;++Cr){const Ws=(ae+Cr*h-W)*U+bn,Xl=Cr*N+Xi;for(let Lo=Se;Lo<$e;++Lo){const Ua=(pe+Lo*p-ne)*j+Ws,Wa=Lo*P+Xl;for(let Ga=dt;Ga<mt;++Ga)Jt+=B[(ze+Ga*f-K)*q+Ua+an]*D[Ga*V+Wa+ln]}}}v[En+ln]=Jt}}}}}return e.makeTensorInfo(b.shape,b.dtype,b.values)}},Oue={kernelName:w0,backendName:"cpu",kernelFunc:function Pue(t){const{inputs:n,backend:e,attrs:r}=t,{dy:s,filter:o}=n,{pad:i,strides:a,inputShape:l}=r;Ne([s],"conv3dBackpropInputV2");const u=Pe(s.shape),c=Pe(o.shape),d=Ca(l,o.shape,a,1,i),h=new br(d.inShape,"float32"),p=h.values,[f,g,m,y]=h.strides,b=e.data.get(s.dataId).values,[v,x,w,C]=u,I=e.data.get(o.dataId).values,[D,E,N,P]=c,{batchSize:V,filterDepth:B,filterHeight:z,filterWidth:U,inChannels:j,inDepth:q,inHeight:W,inWidth:K,outChannels:ne,outDepth:ae,outHeight:he,outWidth:le,strideDepth:be,strideHeight:pe,strideWidth:Se}=d,$e=B-1-d.padInfo.front,qe=z-1-d.padInfo.top,ze=U-1-d.padInfo.left;for(let dt=0;dt<V;++dt)for(let mt=0;mt<j;++mt)for(let Kt=0;Kt<q;++Kt){const an=Kt-$e,En=Math.max(0,Math.ceil(an/be)),ln=Math.min(ae,(B+an)/be);for(let Jt=0;Jt<W;++Jt){const Sn=Jt-qe,bn=Math.max(0,Math.ceil(Sn/pe)),Xi=Math.min(he,(z+Sn)/pe);for(let Cr=0;Cr<K;++Cr){const za=Cr-ze,Ws=Math.max(0,Math.ceil(za/Se)),Xl=Math.min(le,(U+za)/Se);let Lo=0;for(let Yi=En;Yi<ln;++Yi){const Ua=Yi*be-an;for(let Wa=bn;Wa<Xi;++Wa){const Ga=Wa*pe-Sn;for(let Zp=Ws;Zp<Xl;++Zp){const m1=v*dt+x*Yi+w*Wa+C*Zp,PSe=D*(B-1-Ua)+E*(z-1-Ga)+N*(U-1-(Zp*Se-za))+P*mt;for(let qb=0;qb<ne;++qb)Lo+=b[m1+qb]*I[PSe+qb]}}}p[f*dt+g*Kt+m*Jt+y*Cr+mt]=Lo}}}return e.makeTensorInfo(h.shape,h.dtype,h.values)}},$ue=qt(vh,t=>Math.cos(t)),Lue={kernelName:vh,backendName:"cpu",kernelFunc:$ue},Vue=qt(xh,t=>Math.cosh(t)),Bue={kernelName:xh,backendName:"cpu",kernelFunc:Vue},Uue={kernelName:_0,backendName:"cpu",kernelFunc:function zue(t){const{inputs:n,backend:e,attrs:r}=t,{image:s,boxes:o,boxInd:i}=n,{cropSize:a,method:l,extrapolationValue:u}=r,[c,d,h,p]=s.shape,f=o.shape[0],[g,m]=a,y=vt([f,g,m,p],"float32"),b=e.data.get(o.dataId).values,v=e.data.get(i.dataId).values,x=e.data.get(s.dataId).values,w=Pe(s.shape),C=Pe(y.shape);for(let I=0;I<f;I++){const D=4*I,E=b[D],N=b[D+1],P=b[D+2],V=b[D+3],B=v[I];if(B>=c)continue;const z=g>1?(P-E)*(d-1)/(g-1):0,U=m>1?(V-N)*(h-1)/(m-1):0;for(let j=0;j<g;j++){const q=g>1?E*(d-1)+j*z:.5*(E+P)*(d-1);if(q<0||q>d-1)for(let W=0;W<m;W++)for(let K=0;K<p;K++)y.values[K+W*C[2]+j*C[1]+I*C[0]]=u;else if("bilinear"===l){const W=Math.floor(q),K=Math.ceil(q),ne=q-W;for(let ae=0;ae<m;ae++){const he=m>1?N*(h-1)+ae*U:.5*(N+V)*(h-1);if(he<0||he>h-1){for(let Se=0;Se<p;Se++)y.values[Se+ae*C[2]+j*C[1]+I*C[0]]=u;continue}const le=Math.floor(he),be=Math.ceil(he),pe=he-le;for(let Se=0;Se<p;Se++){let $e=Se+le*w[2]+W*w[1]+B*w[0];const qe=x[$e];$e=Se+be*w[2]+W*w[1]+B*w[0];const ze=x[$e];$e=Se+le*w[2]+K*w[1]+B*w[0];const dt=x[$e];$e=Se+be*w[2]+K*w[1]+B*w[0];const mt=x[$e],Kt=qe+(ze-qe)*pe;$e=Se+ae*C[2]+j*C[1]+I*C[0],y.values[$e]=Kt+(dt+(mt-dt)*pe-Kt)*ne}}}else for(let W=0;W<m;++W){const K=m>1?N*(h-1)+W*U:.5*(N+V)*(h-1);if(K<0||K>h-1){for(let he=0;he<p;he++)y.values[he+W*C[2]+j*C[1]+I*C[0]]=u;continue}const ne=Math.round(K),ae=Math.round(q);for(let he=0;he<p;he++)y.values[he+W*C[2]+j*C[1]+I*C[0]]=x[he+ne*w[2]+ae*w[1]+B*w[0]]}}}return e.makeTensorInfo(y.shape,y.dtype,y.values)}},Gue={kernelName:C0,backendName:"cpu",kernelFunc:function Wue(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o,exclusive:i,reverse:a}=r;Ne(s,"cumprod");const l=Cn([o],s.shape.length);let u=s;null!=l&&(u=cs({inputs:{x:s},backend:e,attrs:{perm:l}}));const c=$n(1,s.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const d=ys(u.dtype,"int32"),h=l0(G(u.shape),d),p=e.data.get(u.dataId).values,f=u.shape[u.shape.length-1],g=a?(y,b)=>y+f-b-1:(y,b)=>y+b;for(let y=0;y<p.length;y+=f)for(let b=0;b<f;b++){const v=g(y,b);if(0===b)h[v]=i?1:p[v];else{const x=g(y,b-1);h[v]=i?p[x]*h[x]:p[v]*h[x]}}const m=e.makeTensorInfo(u.shape,d,h);if(null!=l){const b=cs({inputs:{x:m},backend:e,attrs:{perm:Sa(l)}});return e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(u),b}return m}},jue={kernelName:xg,backendName:"cpu",kernelFunc:function Hue(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o,exclusive:i,reverse:a}=r;Ne(s,"cumsum");const l=Cn([o],s.shape.length);let u=s;null!=l&&(u=cs({inputs:{x:s},backend:e,attrs:{perm:l}}));const c=$n(1,s.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const d=ys(u.dtype,"int32"),h=kr(G(u.shape),d),p=e.data.get(u.dataId).values,f=u.shape[u.shape.length-1],g=a?(y,b)=>y+f-b-1:(y,b)=>y+b;for(let y=0;y<p.length;y+=f)for(let b=0;b<f;b++){const v=g(y,b);if(0===b)h[v]=i?0:p[v];else{const x=g(y,b-1);h[v]=i?p[x]+h[x]:p[v]+h[x]}}const m=e.makeTensorInfo(u.shape,d,h);if(null!=l){const b=cs({inputs:{x:m},backend:e,attrs:{perm:Sa(l)}});return e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(u),b}return m}},Kue={kernelName:S0,backendName:"cpu",kernelFunc:function que(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,weights:o}=n,{size:i,binaryOutput:a}=r;if(1===s.shape.length){const c=WI(e.data.get(s.dataId).values,e.data.get(o.dataId).values,o.dtype,o.shape,i);return e.makeTensorInfo([i],o.dtype,c)}if(2===s.shape.length){const c=JL(e.bufferSync(s),e.bufferSync(o),i,a);return e.makeTensorInfo(c.shape,o.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}},Yue={kernelName:I0,backendName:"cpu",kernelFunc:function Xue(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{blockSize:o,dataFormat:i}=r;_("NHWC"===i,()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`);const a=s.shape[0],l=s.shape[1],u=s.shape[2],c=s.shape[3],d=l*o,h=u*o,p=c/(o*o),f=e.data.get(s.dataId).values,g=new Float32Array(a*d*h*p);let m=0;for(let y=0;y<a;++y)for(let b=0;b<d;++b){const v=Math.floor(b/o),x=b%o;for(let w=0;w<h;++w){const C=Math.floor(w/o),D=(x*o+w%o)*p;for(let E=0;E<p;++E)g[m++]=f[E+D+c*(C+u*(v+l*y))]}}return e.makeTensorInfo([a,d,h,p],s.dtype,g)}};function rV(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,filter:o}=n,{strides:i,pad:a,dilations:l,dimRoundingMode:u}=r;Ne([s,o],"depthwiseConv2DNative");const c=Pe(s.shape),d=Pe(o.shape);let h=l;null==h&&(h=[1,1]),_(vr(i,h),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${h}'`);const p=cr(s.shape,o.shape,i,h,a,u,!0),{filterHeight:f,filterWidth:g,dilationHeight:m,dilationWidth:y,padInfo:b}=p,v=b.left,x=b.top,w=p.outChannels/p.inChannels,C=new br(p.outShape,s.dtype),I=e.data.get(s.dataId).values,D=e.data.get(o.dataId).values,E=C.values;for(let N=0;N<p.batchSize;++N){const P=N*c[0],V=N*C.strides[0];for(let B=0;B<p.outHeight;++B){const z=V+B*C.strides[1],U=B*p.strideHeight-x;for(let j=0;j<f;++j){const q=U+j*m;if(q<0||q>=p.inHeight)continue;const W=j*d[0],K=P+q*c[1];for(let ne=0;ne<p.outWidth;++ne){const ae=z+ne*C.strides[2],he=ne*p.strideWidth-v;for(let le=0;le<g;++le){const be=he+le*y;if(be<0||be>=p.inWidth)continue;const Se=K+be*p.inChannels;let $e=ae,qe=W+le*d[1];for(let ze=0;ze<p.inChannels;++ze){const dt=I[Se+ze];for(let mt=0;mt<w;++mt)E[$e+mt]+=dt*D[qe+mt];$e+=w,qe+=w}}}}}}return e.makeTensorInfo(C.shape,C.dtype,C.values)}const Zue={kernelName:wg,backendName:"cpu",kernelFunc:rV},Jue={kernelName:D0,backendName:"cpu",kernelFunc:function Que(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,dy:o}=n,{strides:i,dilations:a,pad:l,dimRoundingMode:u,filterShape:c}=r;Ne([s,o],"depthwiseConv2dNativeBackpropFilter");const d=cr(s.shape,c,i,a,l,u,!0),{strideHeight:h,strideWidth:p,filterHeight:f,filterWidth:g}=d,m=new br(d.filterShape,"float32"),y=d.padInfo.left,b=d.padInfo.top,v=d.outChannels/d.inChannels,x=e.data.get(s.dataId).values,w=new br(s.shape,s.dtype,x),C=e.data.get(o.dataId).values,I=new br(o.shape,o.dtype,C);for(let D=0;D<f;++D){const E=Math.max(0,Math.ceil((b-D)/h)),N=Math.min(d.outHeight,(d.inHeight+b-D)/h);for(let P=0;P<g;++P){const V=Math.max(0,Math.ceil((y-P)/p)),B=Math.min(d.outWidth,(d.inWidth+y-P)/p);for(let z=0;z<d.outChannels;++z){const U=Math.trunc(z/v),j=z%v;let q=0;for(let W=0;W<d.batchSize;++W)for(let K=E;K<N;++K){const ne=D+K*h-b;for(let ae=V;ae<B;++ae)q+=w.get(W,ne,P+ae*p-y,U)*I.get(W,K,ae,z)}m.set(q,D,P,U,j)}}}return e.makeTensorInfo(m.shape,m.dtype,m.values)}},tce={kernelName:T0,backendName:"cpu",kernelFunc:function ece(t){const{inputs:n,backend:e,attrs:r}=t,{dy:s,filter:o}=n,{strides:i,dilations:a,pad:l,dimRoundingMode:u,inputShape:c}=r;Ne([s,o],"depthwiseConv2DNativeBackpropInput");const d=Pe(s.shape),h=Pe(o.shape),p=cr(c,o.shape,i,a,l,u,!0),f=new br(p.inShape,"float32"),g=f.values,[m,y,b]=f.strides,v=e.data.get(s.dataId).values,[x,w,C]=d,I=e.data.get(o.dataId).values,[D,E,N]=h,{batchSize:P,filterHeight:V,filterWidth:B,inChannels:z,inHeight:U,inWidth:j,outChannels:q,outHeight:W,outWidth:K,strideHeight:ne,strideWidth:ae}=p,he=V-1-p.padInfo.top,le=B-1-p.padInfo.left,be=q/z;for(let pe=0;pe<P;++pe)for(let Se=0;Se<z;++Se)for(let $e=0;$e<U;++$e){const qe=$e-he,ze=Math.max(0,Math.ceil(qe/ne)),dt=Math.min(W,(V+qe)/ne);for(let mt=0;mt<j;++mt){const Kt=mt-le,an=Math.max(0,Math.ceil(Kt/ae)),En=Math.min(K,(B+Kt)/ae);let ln=0;for(let Jt=ze;Jt<dt;++Jt){const Sn=Jt*ne-qe;for(let bn=an;bn<En;++bn){const Cr=x*pe+w*Jt+C*bn,za=D*(V-1-Sn)+E*(B-1-(bn*ae-Kt))+N*Se;for(let Ws=0;Ws<be;++Ws)ln+=v[Cr+(Se*be+Ws)]*I[za+Ws]}}g[m*pe+y*$e+b*mt+Se]=ln}}return e.makeTensorInfo(f.shape,f.dtype,f.values)}},rce={kernelName:"Diag",backendName:"cpu",kernelFunc:function nce(t){const{inputs:n,backend:e}=t,{x:r}=n,s=G(r.shape),o=e.data.get(r.dataId).values,i=vt([s,s],r.dtype),a=i.values;for(let u=0;u<o.length;u++)a[u*s+u]=o[u];const l=[...r.shape,...r.shape];return e.makeTensorInfo(l,i.dtype,i.values)}},sce={kernelName:Cg,backendName:"cpu",kernelFunc:({inputs:t,backend:n,attrs:e})=>{const{x:r,filter:s}=t,{strides:o,pad:i,dilations:a}=e,l=n,u=l.data.get(r.dataId).values,c=r.shape.length,d=l.data.get(s.dataId).values,h=s.shape.length,{batchSize:p,inHeight:f,inWidth:g,inChannels:m,outHeight:y,outWidth:b,padInfo:v,strideHeight:x,strideWidth:w,filterHeight:C,filterWidth:I,dilationHeight:D,dilationWidth:E,outShape:N}=pp(r.shape,s.shape,o,i,"NHWC",a),P=G(N),V=N.length,B=Mn(r.dtype,P);for(let U=0;U<p;++U)for(let j=0;j<y;++j){const q=j*x-v.top;for(let W=0;W<b;++W){const K=W*w-v.left;for(let ne=0;ne<m;++ne){let ae=Number.MIN_SAFE_INTEGER;for(let le=0;le<C;++le){const be=q+le*D;if(be>=0&&be<f)for(let pe=0;pe<I;++pe){const Se=K+pe*E;if(Se>=0&&Se<g){const $e=ti([U,be,Se,ne],c,Pe(r.shape)),qe=ti([le,pe,ne],h,Pe(s.shape)),ze=u[$e]+d[qe];ze>ae&&(ae=ze)}}}B[ti([U,j,W,ne],V,Pe(N))]=ae}}}return{dataId:l.write(wl(B,r.dtype),N,r.dtype),shape:N,dtype:r.dtype}}},oce={kernelName:N0,backendName:"cpu",kernelFunc:({inputs:t,backend:n,attrs:e})=>{const{x:r,filter:s,dy:o}=t,{strides:i,pad:a,dilations:l}=e,u=n,c=Do(r.shape,u.data.get(r.dataId).values),d=Do(s.shape,u.data.get(s.dataId).values),{batchSize:h,inHeight:p,inWidth:f,inChannels:g,outHeight:m,outWidth:y,padInfo:b,strideHeight:v,strideWidth:x,filterHeight:w,filterWidth:C,dilationHeight:I,dilationWidth:D,outShape:E}=pp(r.shape,s.shape,i,a,"NHWC",l);_(o.rank===E.length,()=>`Error in ${N0}, dy must have the same rank as output ${E.length}, but got ${o.rank}`);const N=Do(E,u.data.get(o.dataId).values),P=YF(s.shape,s.dtype);for(let B=0;B<h;++B)for(let z=0;z<m;++z){const U=z*v-b.top;for(let j=0;j<y;++j){const q=j*x-b.left;for(let W=0;W<g;++W){let K=Number.MIN_SAFE_INTEGER,ne=0,ae=0;for(let he=0;he<w;++he){const le=U+he*I;if(le>=0&&le<p)for(let be=0;be<C;++be){const pe=q+be*D;if(pe>=0&&pe<f){const Se=c[B][le][pe][W]+d[he][be][W];Se>K&&(K=Se,ne=he,ae=be)}}}P[ne][ae][W]+=N[B][z][j][W]}}}return{dataId:u.write(wl(P,r.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},ice={kernelName:E0,backendName:"cpu",kernelFunc:({inputs:t,backend:n,attrs:e})=>{const{x:r,filter:s,dy:o}=t,{strides:i,pad:a,dilations:l}=e,u=n,c=Do(r.shape,u.data.get(r.dataId).values),d=Do(s.shape,u.data.get(s.dataId).values),{batchSize:h,inHeight:p,inWidth:f,inChannels:g,outHeight:m,outWidth:y,padInfo:b,strideHeight:v,strideWidth:x,filterHeight:w,filterWidth:C,dilationHeight:I,dilationWidth:D,outShape:E}=pp(r.shape,s.shape,i,a,"NHWC",l);_(o.rank===E.length,()=>`Error in ${E0}, dy must have the same rank as output ${E.length}, but got ${o.rank}`);const N=Do(E,u.data.get(o.dataId).values),P=YF(r.shape,r.dtype);for(let B=0;B<h;++B)for(let z=0;z<m;++z){const U=z*v-b.top;for(let j=0;j<y;++j){const q=j*x-b.left;for(let W=0;W<g;++W){let K=Number.MIN_SAFE_INTEGER,ne=U<0?0:U,ae=q<0?0:q;for(let he=0;he<w;++he){const le=U+he*I;if(le>=0&&le<p)for(let be=0;be<C;++be){const pe=q+be*D;if(pe>=0&&pe<f){const Se=c[B][le][pe][W]+d[he][be][W];Se>K&&(K=Se,ne=le,ae=pe)}}}P[B][ne][ae][W]+=N[B][z][j][W]}}}return{dataId:u.write(wl(P,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},GI=jn((t,n)=>t*n),ace=BI((t,n,e,r)=>({real:t*e-n*r,imag:t*r+n*e})),_b=fr(Lh,GI,ace),lce={kernelName:Lh,backendName:"cpu",kernelFunc:_b};function Vp(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o,keepDims:i}=r;let a;Ne(s,"sum"),a="bool"===s.dtype?Oa({inputs:{x:s},backend:e,attrs:{dtype:"int32"}}):mi({inputs:{x:s},backend:e});const l=a.shape.length,u=bt(o,a.shape),c=Cn(u,l);let d=u,h=a;null!=c&&(h=cs({inputs:{x:a},backend:e,attrs:{perm:c}}),d=$n(d.length,l)),xr("sum",d,h.shape.length);const[p,f]=dr(h.shape,d);let m=Cb(e,p,ys(h.dtype,"int32"));const y=G(f),b=e.data.get(m.dataId).values,v=e.data.get(h.dataId).values;for(let x=0;x<b.length;++x){const w=x*y;let C=0;for(let I=0;I<y;++I)C+=v[w+I];b[x]=C}if(i){const w=m;m=on({inputs:{x:m},backend:e,attrs:{shape:On(m.shape,u)}}),e.disposeIntermediateTensorInfo(w)}return e.disposeIntermediateTensorInfo(a),null!=c&&e.disposeIntermediateTensorInfo(h),m}const uce={kernelName:ty,backendName:"cpu",kernelFunc:Vp},dce={kernelName:"Einsum",backendName:"cpu",kernelFunc:function cce(t){const{inputs:n,backend:e,attrs:r}=t,{equation:s}=r,o=n,{allDims:i,summedDims:a,idDims:l}=kS(s,o.length);RS(i.length,l,o);const{path:u,steps:c}=FS(a,l),d=c.length;let h=null,p=i.length;const f=[];for(let g=0;g<d;++g){for(const m of c[g]){const{permutationIndices:y,expandDims:b}=AS(p,l[m]);let v;MS(y)?v=o[m]:(v=cs({inputs:{x:o[m]},backend:e,attrs:{perm:y}}),f.push(v));const x=v.shape.slice();for(let w=0;w<b.length;++w)x.splice(b[w],0,1);Bt(v.shape,x)||(v=on({inputs:{x:v},backend:e,attrs:{shape:x}}),f.push(v)),null===h?h=v:(h=_b({inputs:{a:v,b:h},backend:e}),f.push(h))}g<d-1&&(u[g]>=0&&(h=Vp({inputs:{x:h},backend:e,attrs:{axis:u[g]-(i.length-p),keepDims:!1}}),f.push(h)),p--)}for(const g of f)g!==h&&e.disposeIntermediateTensorInfo(g);return h}},pce={kernelName:k0,backendName:"cpu",kernelFunc:function hce(t){const{inputs:n,backend:e}=t,{dy:r,y:s}=n;Ne([r,s],"eluGrad");const o=new Float32Array(G(s.shape)),i=e.data.get(s.dataId).values,a=e.data.get(r.dataId).values;for(let l=0;l<i.length;++l){const u=i[l];o[l]=u>=0?a[l]:a[l]*(u+1)}return e.makeTensorInfo(s.shape,"float32",o)}},sV=jn((t,n)=>t===n?1:0),oV=fr(_g,sV,null,"bool"),fce={kernelName:_g,backendName:"cpu",kernelFunc:oV},mce=CS,gce=_S,yce=SS,bce=IS,vce=DS,xce=TS,wce=qt(_h,t=>{const n=Math.sign(t),e=Math.abs(t),r=1/(1+mce*e);return n*(1-((((xce*r+vce)*r+bce)*r+yce)*r+gce)*r*Math.exp(-e*e))}),Cce={kernelName:_h,backendName:"cpu",kernelFunc:wce},iV=fi(t=>Math.exp(t)),aV=Pa(Sh,iV,"float32"),_ce={kernelName:Sh,backendName:"cpu",kernelFunc:aV};function Sb(t){const{inputs:n,backend:e,attrs:r}=t,{input:s}=n,{dim:o}=r,i=s.shape.length,a=s.shape.slice();let l=o;return o<0&&(_(-(i+1)<=o,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+o+1),a.splice(l,0,1),on({inputs:{x:s},backend:e,attrs:{shape:a}})}const Sce={kernelName:Sg,backendName:"cpu",kernelFunc:Sb},lV=fi(t=>Math.expm1(t)),Ice=Pa(Ih,lV),Dce={kernelName:Ih,backendName:"cpu",kernelFunc:Ice},Tce=jn((t,n)=>t/n),HI=fr(wh,Tce),jI={kernelName:wh,backendName:"cpu",kernelFunc:HI},uV=jn((t,n)=>t-n),Ece=BI((t,n,e,r)=>({real:t-e,imag:n-r})),qI=fr(Jh,uV,Ece),Nce={kernelName:Jh,backendName:"cpu",kernelFunc:qI};function cV(t,n,e){const r=t.shape,s=r[0],o=r[1],i=e.data.get(t.dataId),a=i.complexTensorInfos.real,l=i.complexTensorInfos.imag,u=[s,o],c=G(u),d=Nr("float32",c),h=Nr("float32",c);for(let m=0;m<s;m++){const y=Ul({inputs:{x:a},backend:e,attrs:{begin:[m,0],size:[1,o]}}),b=Ul({inputs:{x:l},backend:e,attrs:{begin:[m,0],size:[1,o]}}),v=xs({inputs:{real:y,imag:b},backend:e}),{real:x,imag:w}=kce(v,n,e),C=Hi(x,w);for(let I=0;I<o;I++){const D=ES(C,I);d[m*o+I]=D.real,h[m*o+I]=D.imag}e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(b),e.disposeIntermediateTensorInfo(v)}const p=e.makeTensorInfo(u,"float32",d),f=e.makeTensorInfo(u,"float32",h),g=xs({inputs:{real:p,imag:f},backend:e});return e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(f),g}function kce(t,n,e){const r=G(t.shape),s=e.data.get(t.dataId),o=e.data.get(s.complexTensorInfos.real.dataId).values,i=e.data.get(s.complexTensorInfos.imag.dataId).values;if(function Ace(t){return 0==(t&t-1)}(r)){const a=KI(o,i,r,n,e),l=[t.shape[0],t.shape[1]];if(n){const u=e.makeTensorInfo(l,"float32",a.real),c=e.makeTensorInfo(l,"float32",a.imag),d=e.makeTensorInfo([],"float32",ga(r,"float32")),h=mi({inputs:{x:d},backend:e}),p=jI.kernelFunc({inputs:{a:u,b:d},backend:e}),f=jI.kernelFunc({inputs:{a:c,b:h},backend:e}),g=e.data.get(p.dataId).values,m=e.data.get(f.dataId).values;return e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(f),{real:g,imag:m}}return a}{const l=function Rce(t,n,e){const r=new Float32Array(2*n);for(let s=0;s<n;s++){let o=0,i=0;for(let a=0;a<n;a++){const l=sO(s*a,n,e),u=ES(t,a);o+=u.real*l.real-u.imag*l.imag,i+=u.real*l.imag+u.imag*l.real}e&&(o/=n,i/=n),nO(r,o,i,s)}return r}(Hi(o,i),r,n);return JP(l)}}function KI(t,n,e,r,s){if(1===e)return{real:t,imag:n};const o=Hi(t,n),i=e/2,a=eO(o),l=a.real,u=a.imag,c=[l.length],d=s.makeTensorInfo(c,"float32",l),h=s.makeTensorInfo(c,"float32",u),p=xs({inputs:{real:d,imag:h},backend:s}),f=tO(o),g=f.real,m=f.imag,y=[g.length],b=s.makeTensorInfo(y,"float32",g),v=s.makeTensorInfo(y,"float32",m),x=xs({inputs:{real:b,imag:v},backend:s}),w=KI(l,u,i,r,s),C=w.real,I=w.imag,D=[C.length],E=s.makeTensorInfo(D,"float32",C),N=s.makeTensorInfo(D,"float32",I),P=xs({inputs:{real:E,imag:N},backend:s}),V=KI(g,m,i,r,s),B=V.real,z=V.imag,U=[B.length],j=s.makeTensorInfo(U,"float32",B),q=s.makeTensorInfo(U,"float32",z),W=xs({inputs:{real:j,imag:q},backend:s}),K=rO(e,r),ne=[K.real.length],ae=s.makeTensorInfo(ne,"float32",K.real),he=s.makeTensorInfo(ne,"float32",K.imag),le=xs({inputs:{real:ae,imag:he},backend:s}),be=_b({inputs:{a:le,b:W},backend:s}),pe=Sc({inputs:{a:P,b:be},backend:s}),Se=qI({inputs:{a:P,b:be},backend:s}),$e=zl({inputs:{input:pe},backend:s}),qe=zl({inputs:{input:Se},backend:s}),ze=Ic({inputs:{input:pe},backend:s}),dt=Ic({inputs:{input:Se},backend:s}),mt=Dc({inputs:[$e,qe],backend:s,attrs:{axis:0}}),Kt=Dc({inputs:[ze,dt],backend:s,attrs:{axis:0}}),an=s.data.get(mt.dataId).values,En=s.data.get(Kt.dataId).values;return s.disposeIntermediateTensorInfo(d),s.disposeIntermediateTensorInfo(h),s.disposeIntermediateTensorInfo(p),s.disposeIntermediateTensorInfo(b),s.disposeIntermediateTensorInfo(v),s.disposeIntermediateTensorInfo(x),s.disposeIntermediateTensorInfo(E),s.disposeIntermediateTensorInfo(N),s.disposeIntermediateTensorInfo(P),s.disposeIntermediateTensorInfo(j),s.disposeIntermediateTensorInfo(q),s.disposeIntermediateTensorInfo(W),s.disposeIntermediateTensorInfo(ae),s.disposeIntermediateTensorInfo(he),s.disposeIntermediateTensorInfo(le),s.disposeIntermediateTensorInfo(be),s.disposeIntermediateTensorInfo(pe),s.disposeIntermediateTensorInfo(Se),s.disposeIntermediateTensorInfo($e),s.disposeIntermediateTensorInfo(ze),s.disposeIntermediateTensorInfo(qe),s.disposeIntermediateTensorInfo(dt),s.disposeIntermediateTensorInfo(mt),s.disposeIntermediateTensorInfo(Kt),{real:an,imag:En}}const Mce={kernelName:"FFT",backendName:"cpu",kernelFunc:function Fce(t){const{inputs:n,backend:e}=t,{input:r}=n,s=G(r.shape),o=r.shape[r.shape.length-1],a=on({inputs:{x:r},backend:e,attrs:{shape:[s/o,o]}}),l=cV(a,!1,e),u=on({inputs:{x:l},backend:e,attrs:{shape:r.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(l),u}};function XI(t){const{backend:n,attrs:e}=t,{shape:r,value:s,dtype:o}=e,i=o||Ju(s),a=Mn(i,G(r));return function Oce(t,n,e){t.fill(n)}(a,s),n.makeTensorInfo(r,i,a)}const Pce={kernelName:R0,backendName:"cpu",kernelFunc:XI},$ce={kernelName:F0,backendName:"cpu",kernelFunc:({inputs:t,backend:e})=>{const{image:r}=t,s=e,o=Nr(r.dtype,G(r.shape)),[i,a,l,u]=r.shape,c=s.data.get(r.dataId).values;for(let h=0;h<i;h++){const p=h*l*a*u;for(let f=0;f<a;f++){const g=f*(l*u);for(let m=0;m<l;m++){const y=m*u;for(let b=0;b<u;b++){const v=Math.round(l-m-1),x=p+g+y+b;let w=c[x];v>=0&&v<l&&(w=c[p+g+v*u+b]),o[x]=w}}}}return{dataId:s.write(o,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},dV=fi(t=>Math.floor(t)),Lce=Pa(Dh,dV),Vce={kernelName:Dh,backendName:"cpu",kernelFunc:Lce},hV=jn((t,n)=>Math.floor(t/n)),Bce=fr(Th,hV,null,"int32"),zce={kernelName:Th,backendName:"cpu",kernelFunc:Bce},Wce={kernelName:cy,backendName:"cpu",kernelFunc:function Uce(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,filter:o,bias:i,preluActivationWeights:a}=n,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=r;let g=nV({inputs:{x:s,filter:o},backend:e,attrs:{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h}});if(i){const m=g;if("NCHW"===c&&1===i.shape.length&&1!==i.shape[0]){const y=on({inputs:{x:i},backend:e,attrs:{shape:[i.shape[0],1,1]}});g=Sc({inputs:{a:g,b:y},backend:e}),e.disposeIntermediateTensorInfo(y)}else g=Sc({inputs:{a:g,b:i},backend:e});e.disposeIntermediateTensorInfo(m)}if(p){const m=g;if("NCHW"===c&&"prelu"===p&&1===a.shape.length&&1!==a.shape[0]){const y=on({inputs:{x:a},backend:e,attrs:{shape:[a.shape[0],1,1]}});g=wb(e,g,p,y,f),e.disposeIntermediateTensorInfo(y)}else g=wb(e,g,p,a,f);e.disposeIntermediateTensorInfo(m)}return g}},Hce={kernelName:dy,backendName:"cpu",kernelFunc:function Gce(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,filter:o,bias:i,preluActivationWeights:a}=n,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=r;let g=rV({inputs:{x:s,filter:o},backend:e,attrs:{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h}});if(i){const m=g;g=Sc({inputs:{a:g,b:i},backend:e}),e.disposeIntermediateTensorInfo(m)}if(p){const m=g;g=wb(e,g,p,a,f),e.disposeIntermediateTensorInfo(m)}return g}};function pV(t,n,e,r,s,o,i,a,l){const u=vt([r,o],e);for(let c=0;c<r;c++){const d=[];let h=0;for(let p=0;p<s;p++){const f=t[c*s+p];h+=f*i[p],d.push(f)}if(h<0||h>=l/o)throw new Error(`Invalid indices: ${d} does not index into ${a}`);for(let p=0;p<o;p++)u.values[c*o+p]=n.get(...n.indexToLoc(h*o+p))}return u}const qce={kernelName:rM,backendName:"cpu",kernelFunc:function jce(t){const{inputs:n,backend:e}=t,{params:r,indices:s}=n,o=G(r.shape),i=s.shape,a=i[i.length-1],[l,u,c,d]=wS(r,s);if(0===u)return e.makeTensorInfo(l,r.dtype,[]);const f=pV(e.data.get(s.dataId).values,e.bufferSync(r),r.dtype,u,a,c,d,r.shape,o);return e.makeTensorInfo(l,r.dtype,f.values)}};function fV(t,n,e){const r=vt(e,t.dtype);for(let s=0;s<r.size;++s){const i=r.indexToLoc(s).slice(),u=n.locToIndex([i[0],i[2]]);i[2]=n.values[u];const c=t.locToIndex(i);0<=c&&c<t.values.length&&(r.values[s]=t.values[c])}return r}const Xce={kernelName:Dg,backendName:"cpu",kernelFunc:function Kce(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,indices:o}=n,{axis:i,batchDims:a}=r;Ne([s,o],"gatherV2");const l=bt(i,s.shape)[0],u=e.data.get(o.dataId).values,c=s.shape[l];for(let x=0;x<u.length;++x){const w=u[x];_(w<=c-1&&w>=0,()=>`GatherV2: the index value ${w} is not in [0, ${c-1}]`)}let d=a;null==a&&(d=0);const h=G(o.shape),p=$S(s,o,l,d),f=on({inputs:{x:s},backend:e,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),g=on({inputs:{x:o},backend:e,attrs:{shape:[p.batchSize,h/p.batchSize]}}),m=[p.batchSize,p.outerSize,h/p.batchSize,p.sliceSize],y=e.bufferSync(g),v=fV(e.bufferSync(f),y,m);return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(g),e.makeTensorInfo(p.outputShape,v.dtype,v.values)}},mV=jn((t,n)=>t>n?1:0),Yce=fr(Tg,mV,null,"bool"),Zce={kernelName:Tg,backendName:"cpu",kernelFunc:Yce},gV=jn((t,n)=>t>=n?1:0),Qce=fr(Eh,gV,null,"bool"),Jce={kernelName:Eh,backendName:"cpu",kernelFunc:Qce},tde={kernelName:M0,backendName:"cpu",kernelFunc:function ede(t){const{inputs:n,backend:e}=t,{input:r}=n,s=G(r.shape),o=r.shape[r.shape.length-1],a=on({inputs:{x:r},backend:e,attrs:{shape:[s/o,o]}}),l=cV(a,!0,e),u=on({inputs:{x:l},backend:e,attrs:{shape:r.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(l),u}},nde=qt(kh,t=>Number.isFinite(t)?1:0,"bool"),rde={kernelName:kh,backendName:"cpu",kernelFunc:nde},sde=qt(Ah,t=>Math.abs(t)===1/0?1:0,"bool"),ode={kernelName:Ah,backendName:"cpu",kernelFunc:sde},ide=qt(Rh,t=>Number.isNaN(t)?1:0,"bool"),ade={kernelName:Rh,backendName:"cpu",kernelFunc:ide},yV=jn((t,n)=>t<n?1:0),lde=fr(Ng,yV,null,"bool"),ude={kernelName:Ng,backendName:"cpu",kernelFunc:lde},bV=jn((t,n)=>t<=n?1:0),cde=fr(kg,bV,null,"bool"),dde={kernelName:kg,backendName:"cpu",kernelFunc:cde};function vV(t,n,e){const r=(n-t)/(e-1),s=kr(e,"float32");s[0]=t;for(let o=1;o<s.length;o++)s[o]=s[o-1]+r;return s}const pde={kernelName:sM,backendName:"cpu",kernelFunc:function hde(t){const{backend:n,attrs:e}=t,{start:r,stop:s,num:o}=e,i=vV(r,s,o);return n.makeTensorInfo([i.length],"float32",i)}},xV=fi(t=>Math.log(t)),fde=Pa(Fh,xV),mde={kernelName:Fh,backendName:"cpu",kernelFunc:fde},gde=qt(Mh,t=>Math.log1p(t)),yde={kernelName:Mh,backendName:"cpu",kernelFunc:gde},bde=jn((t,n)=>t&&n),vde=fr(Ag,bde,null,"bool"),xde={kernelName:Ag,backendName:"cpu",kernelFunc:vde},wde=qt(Rg,t=>t?0:1,"bool"),Cde={kernelName:Rg,backendName:"cpu",kernelFunc:wde},_de=jn((t,n)=>t||n),Sde=fr(Fg,_de,null,"bool"),Ide={kernelName:Fg,backendName:"cpu",kernelFunc:Sde},Tde={kernelName:Mg,backendName:"cpu",kernelFunc:function Dde(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{depthRadius:o,bias:i,alpha:a,beta:l}=r;Ne(s,"LRN");const u=s.shape[3],c=u-1,d=e.data.get(s.dataId).values,h=G(s.shape),p=new Float32Array(h);function f(g){const m=g%u;let y=g-m+Math.max(0,m-o);const b=g-m+Math.min(m+o,c);let v=0;for(;y<=b;y++){const x=d[y];v+=x*x}return v}for(let g=0;g<h;g++){const m=f(g),y=d[g]*Math.pow(i+a*m,-l);p[g]=y}return e.makeTensorInfo(s.shape,s.dtype,p)}},Nde={kernelName:O0,backendName:"cpu",kernelFunc:function Ede(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,y:o,dy:i}=n,{depthRadius:a,bias:l,alpha:u,beta:c}=r;Ne(i,"LRNGrad");const d=G(i.shape),h=i.shape[3],p=e.data.get(i.dataId).values,f=e.data.get(s.dataId).values,g=e.data.get(o.dataId).values,m=new Float32Array(d),y=d;for(let b=0;b<y;b++){const v=b%h,x=b-v+Math.max(0,v-a),w=b-v+Math.min(h,v+a+1);let C=0;for(let I=x;I<w;I++)C+=Math.pow(f[I],2);C=u*C+l;for(let I=x;I<w;I++){let D=-2*u*c*f[I]*g[b]/C;b===I&&(D+=Math.pow(C,-c)),D*=p[b],m[I]+=D}}return e.makeTensorInfo(i.shape,s.dtype,m)}};function wV(t,n,e,r){const s=Nr(r,G(e));for(let o=0;o<s.length;++o){const i=o*n;let a=t[i];for(let l=0;l<n;++l){const u=t[i+l];(Number.isNaN(u)||u>a)&&(a=u)}s[o]=a}return s}function CV(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{reductionIndices:o,keepDims:i}=r,a=e;let l=s.shape;const u=l.length,c=bt(o,l);let d=c;const h=Cn(d,u);let p=a.data.get(s.dataId).values;if(null!=h){const x=new Array(u);for(let w=0;w<x.length;w++)x[w]=l[h[w]];p=zI(p,l,s.dtype,h,x),d=$n(d.length,u),l=x}Ne(s,"max"),xr("max",d,u);const[f,g]=dr(l,d),y=wV(p,G(g),f,s.dtype),b=a.write(y,f,s.dtype);let v=f;return i&&(v=On(f,c)),{dataId:b,shape:v,dtype:s.dtype}}const kde={kernelName:Pg,backendName:"cpu",kernelFunc:CV},_V=jn((t,n)=>Math.max(t,n)),Ade=fr(Ph,_V),Rde={kernelName:Ph,backendName:"cpu",kernelFunc:Ade},Mde={kernelName:Og,backendName:"cpu",kernelFunc:function Fde(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n;Ne(s,"maxPool");const{filterSize:o,strides:i,pad:a,dimRoundingMode:l}=r;_(vr(i,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`);const c=so(s.shape,o,i,1,a,l);let d;if(1===c.filterWidth&&1===c.filterHeight&&Bt(c.inShape,c.outShape))d=mi({inputs:{x:s},backend:e});else{const h=e.data.get(s.dataId).values,p=Pe(s.shape),f=UI(h,0,s.dtype,p,c,"max");d=e.makeTensorInfo(c.outShape,s.dtype,f.values)}return d}},Ode={kernelName:$g,backendName:"cpu",kernelFunc:function Pde(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{filterSize:o,strides:i,pad:a,dimRoundingMode:l,dataFormat:u}=r;Ne(s,"maxPool3d");const c=Bi(s.shape,o,i,1,a,l,u),h=ZL(e.data.get(s.dataId).values,0,s.dtype,Pe(s.shape),c,"max");return e.makeTensorInfo(h.shape,"float32",h.values)}},Lde={kernelName:L0,backendName:"cpu",kernelFunc:function $de(t){const{inputs:n,backend:e,attrs:r}=t,{dy:s,input:o}=n,{filterSize:i,strides:a,pad:l,dimRoundingMode:u}=r;Ne([s,o],"maxPool3DGrad");const c=Bi(o.shape,i,a,1,l,u),h=function tue(t,n){const e=vt(n.outShape,"int32"),r=n.strideDepth,s=n.strideHeight,o=n.strideWidth,i=n.dilationDepth,a=n.dilationHeight,l=n.dilationWidth,u=n.effectiveFilterDepth,c=n.effectiveFilterHeight,d=n.effectiveFilterWidth,h=n.padInfo.front,p=n.padInfo.top,f=n.padInfo.left;for(let g=0;g<n.batchSize;++g)for(let m=0;m<n.inChannels;++m)for(let y=0;y<n.outDepth;++y){const b=y*r-h;let v=b;for(;v<0;)v+=i;const x=Math.min(n.inDepth,u+b);for(let w=0;w<n.outHeight;++w){const C=w*s-p;let I=C;for(;I<0;)I+=a;const D=Math.min(n.inHeight,c+C);for(let E=0;E<n.outWidth;++E){const N=E*o-f;let P=N;for(;P<0;)P+=l;const V=Math.min(n.inWidth,d+N);let B=Number.NEGATIVE_INFINITY,z=-1;for(let U=v;U<x;U+=i){const j=U-b;for(let q=I;q<D;q+=a){const W=q-C;for(let K=P;K<V;K+=l){const ne=K-N,ae=t.get(g,U,q,K,m);ae>=B&&(B=ae,z=j*c*d+W*c+ne)}}}e.set(z,g,y,w,E,m)}}}return e}(e.bufferSync(o),c),p=c.strideDepth,f=c.strideHeight,g=c.strideWidth,m=c.dilationDepth,y=c.dilationHeight,b=c.dilationWidth,v=c.effectiveFilterDepth,x=c.effectiveFilterHeight,w=c.effectiveFilterWidth,C=v-1-c.padInfo.front,I=w-1-c.padInfo.left,D=x-1-c.padInfo.top,E=vt(o.shape,"float32"),N=e.bufferSync(s);for(let P=0;P<c.batchSize;++P)for(let V=0;V<c.inChannels;++V)for(let B=0;B<c.inDepth;++B)for(let z=0;z<c.inHeight;++z)for(let U=0;U<c.inWidth;++U){const j=B-C,q=z-D,W=U-I;let K=0;for(let ne=0;ne<v;ne+=m){const ae=(j+ne)/p;if(!(ae<0||ae>=c.outDepth||Math.floor(ae)!==ae))for(let he=0;he<x;he+=y){const le=(q+he)/f;if(!(le<0||le>=c.outHeight||Math.floor(le)!==le))for(let be=0;be<w;be+=b){const pe=(W+be)/g;if(pe<0||pe>=c.outWidth||Math.floor(pe)!==pe)continue;const qe=v*x*w-1-h.get(P,ae,le,pe,V)===ne*x*w+he*w+be?1:0;0!==qe&&(K+=N.get(P,ae,le,pe,V)*qe)}}}E.set(K,P,B,z,U,V)}return e.makeTensorInfo(E.shape,E.dtype,E.values)}},Bde={kernelName:$0,backendName:"cpu",kernelFunc:function Vde(t){const{inputs:n,backend:e,attrs:r}=t,{dy:s,input:o,output:i}=n,a=o;Ne([o,i],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:d}=r,h=so(a.shape,l,u,1,c,d),p=e.data.get(a.dataId).values,f=vt(h.outShape,a.dtype,YL(p,a.shape,a.dtype,h).values),g=h.strideHeight,m=h.strideWidth,y=h.dilationHeight,b=h.dilationWidth,v=h.effectiveFilterHeight,x=h.effectiveFilterWidth,w=x-1-h.padInfo.left,C=v-1-h.padInfo.top,I=vt(a.shape,"float32"),D=e.data.get(s.dataId).values,E=vt(s.shape,"float32",D);for(let N=0;N<h.batchSize;++N)for(let P=0;P<h.inChannels;++P)for(let V=0;V<h.inHeight;++V)for(let B=0;B<h.inWidth;++B){const z=V-C,U=B-w;let j=0;for(let q=0;q<v;q+=y){const W=(z+q)/g;if(!(W<0||W>=h.outHeight||Math.floor(W)!==W))for(let K=0;K<x;K+=b){const ne=(U+K)/m;if(ne<0||ne>=h.outWidth||Math.floor(ne)!==ne)continue;const le=v*x-1-f.get(N,W,ne,P)===q*x+K?1:0;0!==le&&(j+=E.get(N,W,ne,P)*le)}}I.set(j,N,V,B,P)}return e.makeTensorInfo(I.shape,I.dtype,I.values)}},Ude={kernelName:oM,backendName:"cpu",kernelFunc:({inputs:t,attrs:n,backend:e})=>{const{x:r}=t,{filterSize:s,strides:o,pad:i,includeBatchInIndex:a}=n,l=e;Ne(r,"MaxPoolWithArgmax");const u=l.data.get(r.dataId).values,c=so(r.shape,s,o,[1,1],i),[d,h]=function zde(t,n,e,r,s){const i=UI(t,0,e,Pe(n),s,"max"),a=YL(t,n,e,s,!0,r);return[i.values,a.values]}(u,r.shape,r.dtype,a,c),p=l.write(d,c.outShape,r.dtype),f=l.write(h,c.outShape,r.dtype);return[{dataId:p,shape:c.outShape,dtype:r.dtype},{dataId:f,shape:c.outShape,dtype:"int32"}]}},Gde={kernelName:Lg,backendName:"cpu",kernelFunc:function Wde(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o,keepDims:i}=r,a=bt(o,s.shape),c=G(dr(s.shape,a)[1]),d=[],h=e.makeTensorInfo([],"float32",new Float32Array([c]));d.push(h);const p=Oa({inputs:{x:s},backend:e,attrs:{dtype:"float32"}});d.push(p);const f=HI({inputs:{a:p,b:h},backend:e});d.push(f);const g=Vp({inputs:{x:f},backend:e,attrs:{axis:o,keepDims:i}});return d.forEach(m=>e.disposeIntermediateTensorInfo(m)),g}},jde={kernelName:Vg,backendName:"cpu",kernelFunc:function Hde(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o,keepDims:i}=r;Ne(s,"min");const a=bt(o,s.shape);let l=a;const u=Cn(l,s.shape.length);let c=s;null!=u&&(c=cs({inputs:{x:s},backend:e,attrs:{perm:u}}),l=$n(l.length,s.shape.length)),xr("min",l,c.shape.length);const[d,h]=dr(c.shape,l),p=G(h),f=kr(G(d),c.dtype),g=e.data.get(c.dataId).values;for(let y=0;y<f.length;++y){const b=y*p;let v=g[b];for(let x=0;x<p;++x){const w=g[b+x];(Number.isNaN(w)||w<v)&&(v=w)}f[y]=v}null!=u&&e.disposeIntermediateTensorInfo(c);const m=e.makeTensorInfo(d,c.dtype,f);if(i){const b=on({inputs:{x:m},backend:e,attrs:{shape:On(d,a)}});return e.disposeIntermediateTensorInfo(m),b}return m}},SV=jn((t,n)=>Math.min(t,n)),qde=fr(Oh,SV),Kde={kernelName:Oh,backendName:"cpu",kernelFunc:qde},Yde={kernelName:Bg,backendName:"cpu",kernelFunc:function Xde(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{paddings:o,mode:i}=r;Ne(s,"mirrorPad");const a=o.map((v,x)=>v[0]+s.shape[x]+v[1]),l=o.map(v=>v[0]),u=o.map((v,x)=>v[0]+s.shape[x]),c="reflect"===i?0:1,d=e.data.get(s.dataId).values,h=s.shape.length,p=Pe(s.shape),f=G(a),g=a.length,m=Pe(a),y=Nr(s.dtype,f);for(let v=0;v<f;v++){let x=ec(v,g,m);for(let C=0;C<g;C++)x[C]<l[C]?x[C]=2*l[C]-x[C]-c:x[C]>=u[C]&&(x[C]=2*(u[C]-1)-x[C]+c);x=x.map((C,I)=>C-l[I]);const w=ti(x,h,p);y[v]=d[w]}return{dataId:e.write(y,a,s.dtype),shape:a,dtype:s.dtype}}},Zde=jn((t,n)=>{const e=t%n;return t<0&&n<0||t>=0&&n>=0?e:(e+n)%n}),Qde=fr($h,Zde),Jde={kernelName:$h,backendName:"cpu",kernelFunc:Qde};function IV(t){const{inputs:n,backend:e,attrs:r}=t,{logits:s}=n,{dim:o}=r,i=s.shape.length;let a=o;if(-1===a&&(a=i-1),a!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${a}`);const l=bt([a],s.shape),u=CV({inputs:{x:s},backend:e,attrs:{reductionIndices:l,keepDims:!1}}),c=On(u.shape,l),d=on({inputs:{x:u},backend:e,attrs:{shape:c}}),h=qI({inputs:{a:s,b:d},backend:e}),p=aV({inputs:{x:h},backend:e}),f=Vp({inputs:{x:p},backend:e,attrs:{axis:l,keepDims:!1}}),g=on({inputs:{x:f},backend:e,attrs:{shape:c}}),m=HI({inputs:{a:p,b:g},backend:e});return e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(g),m}const ehe={kernelName:sy,backendName:"cpu",kernelFunc:IV},nhe={kernelName:iM,backendName:"cpu",kernelFunc:function the(t){const{inputs:n,backend:e,attrs:r}=t,{logits:s}=n,{numSamples:o,seed:i,normalized:a}=r;Ne(s,"multinomial");const l=a?s:IV({inputs:{logits:s},backend:e,attrs:{dim:-1}}),u=l.shape[0],c=l.shape[1],d=e.data.get(l.dataId).values,h=[u,o],p=kr(G(h),"int32");for(let f=0;f<u;++f){const g=f*c,m=new Float32Array(c-1);m[0]=d[g];for(let v=1;v<m.length;++v)m[v]=m[v-1]+d[g+v];const y=Q_.alea(i.toString()),b=f*o;for(let v=0;v<o;++v){const x=y();p[b+v]=m.length;for(let w=0;w<m.length;w++)if(x<m[w]){p[b+v]=w;break}}}return a||e.disposeIntermediateTensorInfo(l),e.makeTensorInfo(h,"int32",p)}};function DV(t,n,e){const r=ga(-1,e);return GI([],n,r,t,e)}const she={kernelName:zg,backendName:"cpu",kernelFunc:function rhe(t){const{inputs:n,backend:e}=t,{x:r}=n;Ne(r,"neg");const s=e.data.get(r.dataId).values,[o,i]=DV(s,r.shape,r.dtype);return e.makeTensorInfo(i,r.dtype,o)}},ohe=uS,ahe={kernelName:V0,backendName:"cpu",kernelFunc:function ihe(t){const{inputs:n,backend:e,attrs:r}=t,{boxes:s,scores:o}=n,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l}=r;Ne(s,"NonMaxSuppression");const u=e.data.get(s.dataId).values,c=e.data.get(o.dataId).values,{selectedIndices:d}=ohe(u,c,i,a,l);return e.makeTensorInfo([d.length],"int32",new Int32Array(d))}},lhe=cS,che={kernelName:B0,backendName:"cpu",kernelFunc:function uhe(t){const{inputs:n,backend:e,attrs:r}=t,{boxes:s,scores:o}=n,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:u}=r;Ne(s,"NonMaxSuppressionPadded");const c=e.data.get(s.dataId).values,d=e.data.get(o.dataId).values,{selectedIndices:h,validOutputs:p}=lhe(c,d,i,a,l,u);return[e.makeTensorInfo([h.length],"int32",new Int32Array(h)),e.makeTensorInfo([],"int32",new Int32Array([p]))]}},dhe=dS,phe={kernelName:z0,backendName:"cpu",kernelFunc:function hhe(t){const{inputs:n,backend:e,attrs:r}=t,{boxes:s,scores:o}=n,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l,softNmsSigma:u}=r;Ne(s,"NonMaxSuppressionWithScore");const c=e.data.get(s.dataId).values,d=e.data.get(o.dataId).values,h=i,p=a,f=l,g=u,{selectedIndices:m,selectedScores:y}=dhe(c,d,h,p,f,g);return[e.makeTensorInfo([m.length],"int32",new Int32Array(m)),e.makeTensorInfo([y.length],"float32",new Float32Array(y))]}},TV=jn((t,n)=>t!==n?1:0),fhe=fr(Ug,TV,null,"bool"),mhe={kernelName:Ug,backendName:"cpu",kernelFunc:fhe},yhe={kernelName:Gg,backendName:"cpu",kernelFunc:function ghe(t){const{inputs:n,backend:e,attrs:r}=t,{indices:s}=n,{dtype:o,depth:i,onValue:a,offValue:l}=r;Ne(s,"oneHot");const u=G(s.shape),c=new Float32Array(u*i);c.fill(l);const d=e.data.get(s.dataId).values;for(let h=0;h<u;++h)d[h]>=0&&d[h]<i&&(c[h*i+d[h]]=a);return e.makeTensorInfo([...s.shape,i],o,c)}};function Ib(t){const{inputs:n,backend:e}=t,{x:r}=n;if("string"===r.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===r.dtype){const s=zl({inputs:{input:r},backend:e}),o=Ib({inputs:{x:s},backend:e}),i=Ic({inputs:{input:r},backend:e}),a=Ib({inputs:{x:i},backend:e}),l=xs({inputs:{real:o,imag:a},backend:e});return e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),l}return XI({backend:e,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}const bhe={kernelName:ly,backendName:"cpu",kernelFunc:Ib},vhe={kernelName:Wg,backendName:"cpu",kernelFunc:function EV(t){const{inputs:n,backend:e}=t,{x:r}=n;if("string"===r.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===r.dtype){const s=zl({inputs:{input:r},backend:e}),o=EV({inputs:{x:s},backend:e}),i=Ic({inputs:{input:r},backend:e}),a=Ib({inputs:{x:i},backend:e}),l=xs({inputs:{real:o,imag:a},backend:e});return e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),l}return XI({backend:e,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}};function NV(t){const{inputs:n,backend:e,attrs:r}=t,{axis:s}=r;if(1===n.length)return Sb({inputs:{input:n[0]},backend:e,attrs:{dim:s}});const o=n[0].shape,i=n[0].dtype;n.forEach(c=>{no(o,c.shape,"All tensors passed to stack must have matching shapes"),_(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],u=Dc({inputs:n.map(c=>{const d=Sb({inputs:{input:c},backend:e,attrs:{dim:s}});return a.push(d),d}),backend:e,attrs:{axis:s}});return a.forEach(c=>e.disposeIntermediateTensorInfo(c)),u}const xhe={kernelName:Hg,backendName:"cpu",kernelFunc:NV},kV={kernelName:jg,backendName:"cpu",kernelFunc:function whe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{paddings:o,constantValue:i}=r;Ne(s,"pad");const a=o.map((b,v)=>b[0]+s.shape[v]+b[1]),l=o.map(b=>b[0]),u=e.data.get(s.dataId).values,c=G(s.shape),d=s.shape.length,h=Pe(s.shape),p=G(a),f=a.length,g=Pe(a),m=Nr(s.dtype,p);0!==i&&m.fill(i);for(let b=0;b<c;b++)m[ti(ec(b,d,h).map((C,I)=>C+l[I]),f,g)]=u[b];return{dataId:e.write(m,a,s.dtype),shape:a,dtype:s.dtype}}},Che=jn((t,n)=>Math.pow(t,n)),_he=fr(Vh,Che),She={kernelName:Vh,backendName:"cpu",kernelFunc:_he};function AV(t,n,e,r){const[s,o]=dr(t,r),i=ys(n,"int32"),a=kr(G(s),i),l=G(o);for(let u=0;u<a.length;++u){const c=u*l;let d=1;for(let h=0;h<l;++h)d*=e[c+h];a[u]=d}return{outVals:a,outShape:s,outDtype:i}}const Dhe={kernelName:Kg,backendName:"cpu",kernelFunc:function Ihe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o,keepDims:i}=r;Ne(s,"prod");const a=s.shape.length,l=bt(o,s.shape),u=Cn(l,a);let c=l,d=s;const h=[];null!=u&&(d=cs({inputs:{x:s},backend:e,attrs:{perm:u}}),h.push(d),c=$n(c.length,a));const p=e.data.get(d.dataId).values,{outVals:f,outShape:g,outDtype:m}=AV(d.shape,d.dtype,p,c);let y=g;return i&&(y=On(g,l)),h.forEach(b=>e.disposeIntermediateTensorInfo(b)),e.makeTensorInfo(y,m,f)}};function RV(t,n){const e=t.slice(0,n);for(;e.length<n;)e.push(1);for(let r=n;r<t.length;r++)e[n-1]*=t[r];return e}function FV(t,n,e,r,s,o,i,a){if(0===t.length)throw new Error("paramsNestedSplits must be non empty");if(0===n[0].length)throw new Error("Split tensors must not be scalars");if(function The(t,n,e){t.forEach((r,s)=>{if(r<0||r>=e){const o=ec(s,n.length,Pe(n)).join(",");throw new Error(`indices[${o}] = ${r} is not in [0, ${e})`)}})}(o,i,n[0][0]-1),0===r.length)throw new Error("params.rank must be nonzero");const u=r[0],{outSplits:c,valueSlices:d,numValues:h}=function Nhe(t,n,e,r){const s=[];let o=0;const a=new Array(n.length-1+e.length).fill(null).map(()=>[0]);!function Ehe(t,n){for(let e=0;e<t.length;++e){const r=t[e],s=e===t.length-1?n:t[e+1].length;if(0===r.length)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>s)throw new Error("Ragged splits must not point past values");for(let o=1;o<r.length;++o)if(r[o-1]>r[o])throw new Error("Ragged splits must be sorted in ascending order")}}(e,r);let l=1;for(let u=0;u<n.length-1;++u){l*=n[u];const c=n[u+1];for(let d=1;d<l+1;++d)a[u].push(d*c)}for(let u=0;u<t.length;++u){let c=t[u],d=t[u]+1;for(let h=0;h<e.length;++h){const p=e[h],f=h+n.length-1;if(f>=0){const g=a[f],m=g[g.length-1]-p[c];for(let y=c;y<d;++y)a[f].push(p[y+1]+m)}c=p[c],d=p[d]}d!==c&&(s.push([c,d]),o+=d-c)}return{outSplits:a,valueSlices:s,numValues:o}}(o,i,t,u),p=function khe(t){const n=[];for(let e=0;e<t.length;++e){const s=Mn("int32",t[e].length);n.push(s),t[e].forEach((o,i)=>s[i]=o)}return n}(c),f=function Rhe(t,n,e,r,s){const o=n.slice();o[0]=s;const i=Mn(e,G(o)),a=t.length;return function Ahe(t,n,e,r,s,o){const i=RV(n,2)[1],a=RV(o,2)[1];let l=0;for(const u of e)for(let c=u[0];c<u[1];++c){for(let d=0;d<r;++d)s[l*a+d]=t[c*i+d];++l}}(t,n,r,0===a?0:a/n[0],i,o),[i,o]}(e,r,s,d,h);return[p,f[0],f[1]]}const Mhe={kernelName:aM,backendName:"cpu",kernelFunc:function Fhe(t){const{inputs:n,backend:e,attrs:r}=t,{paramsNestedSplits:s,paramsDenseValues:o,indices:i}=n,l=s.map(y=>e.data.get(y.dataId).values),u=s.map(y=>y.shape),c=e.data.get(o.dataId).values,d=e.data.get(i.dataId).values,[h,p,f]=FV(l,u,c,o.shape,o.dtype,d,i.shape),g=h.map(y=>e.makeTensorInfo([y.length],"int32",y)),m=e.makeTensorInfo(f,o.dtype,p);return g.concat([m])}},MV=2147483647;function PV(t,n,e,r,s,o,i){if(n.length>1)throw new Error("starts must be a scalar or vector");if(s.length>1)throw new Error("limits must be a scalar or vector");if(i.length>1)throw new Error("deltas must be a scalar or vector");const a=0===n.length,l=0===s.length,u=0===i.length,c=[];a||c.push(n[0]),l||c.push(s[0]),u||c.push(i[0]);for(let m=1;m<c.length;++m)if(c[m]!==c[m-1])throw new Error("starts, limits, and deltas must have the same shape");const d=0===c.length?1:c[0],h=Mn("int32",d+1);h[0]=0;for(let m=0;m<d;++m){const y=a?t[0]:t[m],b=l?r[0]:r[m],v=u?o[0]:o[m];if(0===v)throw new Error("Requires delta != 0");let x;if(v>0&&b<y||v<0&&b>y)x=0;else if(x=Math.ceil(Math.abs((b-y)/v)),x>MV)throw new Error(`Requires ((limit - start) / delta) <= ${MV}`);h[m+1]=h[m]+x}const f=Mn(e,h[d]);let g=0;for(let m=0;m<d;++m){const y=h[m+1]-h[m];let b=a?t[0]:t[m];const v=u?o[0]:o[m];for(let x=0;x<y;++x)f[g++]=b,b+=v}return[h,f]}const Ohe={kernelName:lM,backendName:"cpu",kernelFunc:function Phe(t){const{inputs:n,backend:e}=t,{starts:r,limits:s,deltas:o}=n,i=e.data.get(r.dataId).values,a=e.data.get(s.dataId).values,l=e.data.get(o.dataId).values,[u,c]=PV(i,r.shape,r.dtype,a,s.shape,l,o.shape);return[e.makeTensorInfo([u.length],"int32",u),e.makeTensorInfo([c.length],r.dtype,c)]}};var fo=uo;class Db{constructor(n,e,r,s,o,i,a,l,u,c){this.shape=n,this.shapeShape=e,this.values=r,this.valuesShape=s,this.valuesDType=o,this.defaultValue=i,this.defaultValueShape=a,this.rowPartitionValues=l,this.rowPartitionValuesShapes=u,this.rowPartitionTypes=XP(c),this.raggedRank=YP(this.rowPartitionTypes)}getRowPartitionTypeByDimension(n){return this.rowPartitionTypes[0]===fo.FIRST_DIM_SIZE?this.rowPartitionTypes[n+1]:this.rowPartitionTypes[n]}getRowPartitionTensor(n){return this.rowPartitionTypes[0]===fo.FIRST_DIM_SIZE?this.rowPartitionValues[n+1]:this.rowPartitionValues[n]}getMaxWidth(n){const e=this.getRowPartitionTensor(n-1);switch(this.getRowPartitionTypeByDimension(n-1)){case fo.VALUE_ROWIDS:return Db.getMaxWidthValueRowID(e);case fo.ROW_SPLITS:return Db.getMaxWidthRowSplit(e);default:throw new Error(`Cannot handle partition type ${fo[this.getRowPartitionTypeByDimension(n-1)]}`)}}static getMaxWidthRowSplit(n){const e=n.length;if(0===e||1===e)return 0;let r=0;for(let s=0;s<e-1;++s){const o=n[s+1]-n[s];o>r&&(r=o)}return r}static getMaxWidthValueRowID(n){const e=n.length;if(0===e)return 0;let r=0,s=n[0],o=0;for(let i=1;i<e;++i){const a=n[i];a!==s&&(s=a,o=Math.max(i-r,o),r=i)}return Math.max(e-r,o)}tensorShapeFromTensor(n,e,r=!0){if(0===e.length){if(-1===n[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return $V(n,r)}calculateOutputSize(n){const e=this.valuesShape;ZP(this.defaultValueShape,e);const s=this.tensorShapeFromTensor(this.shape,this.shapeShape),i=KP(this.raggedRank,s,e);i[0]<0&&(i[0]=n);for(let a=1;a<=this.raggedRank;++a)i[a]<0&&(i[a]=this.getMaxWidth(a));return i}calculateFirstParentOutputIndex(n,e,r){const s=Math.min(n,r),o=[];let i=0;for(let a=0;a<s;++a,i+=e)o.push(i);for(let a=s;a<n;++a)o.push(-1);return _(o.length===n,()=>"Final length of result must be equal to firstDimension."),o}calculateOutputIndexRowSplit(n,e,r,s){const o=n.length,i=[];for(let a=0;a<o-1;++a){const l=n[a+1]-n[a];let u=Math.min(s,l),c=e[a];-1===c&&(u=0);for(let d=0;d<u;++d)i.push(c),c+=r;for(let d=0;d<l-u;++d)i.push(-1)}if(o>0&&i.length!==n[o-1])throw new Error("Invalid row split size.");return i}calculateOutputIndexValueRowID(n,e,r,s){const o=n.length,i=[];if(0===o)return[];let a=0,l=n[0];if(l>=e.length)throw new Error(`Got currentValueRowId=${l}, which is not less than ${e.length}`);let u=e[l];i.push(u);for(let c=1;c<o;++c){const d=n[c];if(d===l)u>=0&&(++a,a<s?u+=r:u=-1);else{if(a=0,l=d,d>=e.length)throw new Error(`Got nextValueRowId=${d} which is not less than ${e.length}`);u=e[d]}i.push(u)}if(i.length!==n.length)throw new Error("Invalid row ids.");return i}calculateOutputIndex(n,e,r,s){const o=this.getRowPartitionTensor(n),i=this.getRowPartitionTypeByDimension(n);switch(i){case fo.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(o,e,r,s);case fo.ROW_SPLITS:if(o.length-1>e.length)throw new Error(`Row partition size is greater than output size: ${o.length-1} > ${e.length}`);return this.calculateOutputIndexRowSplit(o,e,r,s);default:throw new Error(`Unsupported partition type: ${fo[i]}`)}}getFirstDimensionSize(){const n=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");const e=this.rowPartitionTypes[0];switch(e){case fo.FIRST_DIM_SIZE:return n[0];case fo.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case fo.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${fo[e]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const e=this.getFirstDimensionSize(),r=this.calculateOutputSize(e),s=new Array(this.raggedRank+1);s[s.length-1]=1;for(let l=s.length-2;l>=0;--l)s[l]=s[l+1]*r[l+1];const o=$V(r,!1),i=Mn(this.valuesDType,G(o));if(s[0]*r[0]>0){let l=this.calculateFirstParentOutputIndex(e,s[0],r[0]);for(let u=1;u<=this.raggedRank;++u)l=this.calculateOutputIndex(u-1,l,s[u],r[u]);this.setOutput(this.raggedRank,l,i,o)}return[o,i]}setOutput(n,e,r,s){if(0===r.length)return;const o=this.values,i=r;let a=s.slice();a=a.slice(n+1);const l=G(a),u=e.length;let c=this.defaultValue;if(c.length!==l&&1!==c.length){const f=this.defaultValueShape;$(()=>{const g=M(c,f);c=gp(g,a).dataSync()})}let d=0,h=0,p=0;for(let f=0;f<=u;++f){let g=f<u?e[f]:-1;if(g!==p){if(h<p){const m=o.subarray(d*l);OV(i.subarray(h*l),m,(p-h)*l)}if(f>=u&&(g=Math.floor(r.length/l)),g>p)if(1===this.defaultValue.length)i.subarray(p*l,g*l).fill(this.defaultValue[0]),p=g;else for(;g>p;)OV(i.slice(p*l),c,l),++p;g<0?(d=f+1,h=p):(d=f,h=p,p=h+1)}else++p}}}function OV(t,n,e){for(let r=0;r<e;r++)t[r]=n[r]}function $V(t,n){const e=[];for(let r of t){if(r<0){if(!n)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}e.push(r)}return e}function LV(t,n,e,r,s,o,i,a,l,u){return new Db(t,n,e,r,s,o,i,a,l,u).compute()}const Lhe={kernelName:uM,backendName:"cpu",kernelFunc:function $he(t){const{inputs:n,backend:e,attrs:r}=t,{shape:s,values:o,defaultValue:i,rowPartitionTensors:a}=n,{rowPartitionTypes:l}=r,u=e.data.get(s.dataId).values,c=e.data.get(o.dataId).values,d=e.data.get(i.dataId).values,h=a.map(m=>e.data.get(m.dataId).values),p=a.map(m=>m.shape),[f,g]=LV(u,s.shape,c,o.shape,o.dtype,d,i.shape,h,p,l);return e.makeTensorInfo(f,o.dtype,g)}};function VV(t,n,e,r){if(t===n||t<n&&e<0||n<t&&e>1)return kr(0,r);const l=kr(Math.abs(Math.ceil((n-t)/e)),r);n<t&&1===e&&(e=-1),l[0]=t;for(let u=1;u<l.length;u++)l[u]=l[u-1]+e;return l}const Bhe={kernelName:U0,backendName:"cpu",kernelFunc:function Vhe(t){const{backend:n,attrs:e}=t,{start:r,stop:s,dtype:o,step:i}=e,a=VV(r,s,i,o);return n.makeTensorInfo([a.length],o,a)}},zhe=qt(Bh,t=>1/t),Uhe={kernelName:Bh,backendName:"cpu",kernelFunc:zhe},Ghe={kernelName:Zg,backendName:"cpu",kernelFunc:function Whe(t){const{inputs:n,backend:e,attrs:r}=t,{images:s}=n,{alignCorners:o,halfPixelCenters:i,size:a}=r;Ne(s,"resizeBilinear");const l=Pe(s.shape),[u,c]=a,[d,h,p,f]=s.shape,g=e.data.get(s.dataId).values,m=new Float32Array(G([d,u,c,f])),y=[o&&u>1?h-1:h,o&&c>1?p-1:p],b=[o&&u>1?u-1:u,o&&c>1?c-1:c];let v=0;const x=y[0]/b[0],w=y[1]/b[1];for(let C=0;C<d;C++)for(let I=0;I<u;I++){let D;D=i?x*(I+.5)-.5:x*I;const E=Math.max(0,Math.floor(D)),N=D-E,P=Math.min(h-1,Math.ceil(D)),V=C*l[0]+E*l[1],B=C*l[0]+P*l[1];for(let z=0;z<c;z++){let U;U=i?w*(z+.5)-.5:w*z;const j=Math.max(0,Math.floor(U)),q=U-j,W=Math.min(p-1,Math.ceil(U)),K=V+j*l[2],ne=B+j*l[2],ae=V+W*l[2],he=B+W*l[2];for(let le=0;le<f;le++){const be=g[K+le],pe=g[ne+le],qe=be+(g[ae+le]-be)*q;m[v++]=qe+(pe+(g[he+le]-pe)*q-qe)*N}}}return e.makeTensorInfo([d,u,c,f],"float32",m)}},jhe={kernelName:H0,backendName:"cpu",kernelFunc:function Hhe(t){const{inputs:n,backend:e,attrs:r}=t,{images:s,dy:o}=n,{alignCorners:i}=r;Ne([o,s],"resizeBilinearGrad");const a=Pe(s.shape),[l,u,c,d]=s.shape,[,h,p]=o.shape,f=new Float32Array(l*u*c*d),g=[i&&h>1?u-1:u,i&&p>1?c-1:c],m=[i&&h>1?h-1:h,i&&p>1?p-1:p],y=g[0]/m[0],b=g[1]/m[1],v=e.data.get(o.dataId).values;let x=0;for(let w=0;w<l;w++){const C=w*a[0];for(let I=0;I<h;I++){const D=I*y,E=Math.floor(D),N=Math.min(Math.ceil(D),u-1),P=C+E*a[1],V=C+N*a[1],B=D-E,z=1-B;for(let U=0;U<p;U++){const j=U*b,q=Math.floor(j),W=Math.min(Math.ceil(j),c-1),K=j-q,ne=1-K,ae=P+q*a[2],he=P+W*a[2],le=V+q*a[2],be=V+W*a[2],pe=z*ne,Se=z*K,$e=B*ne,qe=B*K;for(let ze=0;ze<d;ze++){const dt=v[x++];f[ae+ze]+=dt*pe,f[he+ze]+=dt*Se,f[le+ze]+=dt*$e,f[be+ze]+=dt*qe}}}}return e.makeTensorInfo([l,c,u,d],"float32",f)}},Khe={kernelName:Yg,backendName:"cpu",kernelFunc:function qhe(t){const{inputs:n,backend:e,attrs:r}=t,{images:s}=n,{alignCorners:o,halfPixelCenters:i,size:a}=r;Ne(s,"resizeNearestNeighbor");const l=Pe(s.shape),[u,c]=a,[d,h,p,f]=s.shape,g=e.data.get(s.dataId).values,m=new Float32Array(d*u*c*f),y=[o&&u>1?h-1:h,o&&c>1?p-1:p],b=[o&&u>1?u-1:u,o&&c>1?c-1:c],v=y[0]/b[0],x=y[1]/b[1];let w=0;for(let C=0;C<d;C++){const I=C*l[0];for(let D=0;D<u;D++){const E=i?v*(D+.5):v*D;let N=Math.min(h-1,o?Math.round(E):Math.floor(E));i&&(N=Math.max(0,N));const P=I+N*l[1];for(let V=0;V<c;V++){const B=i?x*(V+.5):x*V;let z=Math.min(p-1,o?Math.round(B):Math.floor(B));i&&(z=Math.max(0,z));const U=P+z*l[2];for(let j=0;j<f;j++)m[w++]=g[U+j]}}}return e.makeTensorInfo([d,u,c,f],s.dtype,m)}},Yhe={kernelName:G0,backendName:"cpu",kernelFunc:function Xhe(t){const{inputs:n,backend:e,attrs:r}=t,{images:s,dy:o}=n,{alignCorners:i}=r;Ne([o,s],"resizeNearestNeighborGrad");const a=Pe(s.shape),l=Pe(o.shape),[u,c,d,h]=s.shape,[,p,f]=o.shape,g=new Float32Array(u*c*d*h),m=e.data.get(o.dataId).values,y=[i&&p>1?c-1:c,i&&f>1?d-1:d],b=[i&&p>1?p-1:p,i&&f>1?f-1:f],v=y[0]/b[0],x=y[1]/b[1],w=1/v,C=1/x,I=2*Math.ceil(w)+2,D=2*Math.ceil(C)+2;for(let E=0;E<u;E++){const N=E*a[0];for(let P=0;P<c;P++){const V=N+P*a[1],B=Math.floor(P*w),z=Math.floor(B-I/2);for(let U=0;U<d;U++){const j=V+U*a[2],q=Math.floor(U*C),W=Math.floor(q-D/2);for(let K=0;K<h;K++){let ne=0;for(let ae=0;ae<I;ae++){const he=ae+z;if(he<0||he>=p)continue;const le=N+he*l[1],be=he*v;if(P===Math.min(c-1,i?Math.round(be):Math.floor(be)))for(let Se=0;Se<D;Se++){const $e=Se+W;if($e<0||$e>=f)continue;const qe=le+$e*l[2],ze=$e*x;U===Math.min(d-1,i?Math.round(ze):Math.floor(ze))&&(ne+=m[qe+K])}}g[j+K]=ne}}}}return e.makeTensorInfo(s.shape,s.dtype,g)}},Qhe={kernelName:Qg,backendName:"cpu",kernelFunc:function Zhe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{dims:o}=r;Ne(s,"reverse");const i=s.shape.length,a=bt(o,s.shape);if(0===i)return mi({inputs:{x:s},backend:e});const l=new br(s.shape,s.dtype),u=e.bufferSync(s);for(let c=0;c<l.size;c++){const d=l.indexToLoc(c),h=d.slice();a.forEach(p=>h[p]=s.shape[p]-1-h[p]),l.set(u.get(...h),...d)}return e.makeTensorInfo(l.shape,l.dtype,l.values)}},Jhe={kernelName:s_,backendName:"cpu",kernelFunc:({inputs:t,attrs:n,backend:e})=>{const{image:r}=t,{radians:s,fillValue:o,center:i}=n,a=e,l=Nr(r.dtype,G(r.shape)),[u,c,d,h]=r.shape,[p,f]=bS(i,c,d),m=Math.sin(s),y=Math.cos(s),b=a.data.get(r.dataId).values;for(let x=0;x<u;x++){const w=x*d*c*h;for(let C=0;C<c;C++){const I=C*(d*h);for(let D=0;D<d;D++){const E=D*h;for(let N=0;N<h;N++){const P=[u,C,D,N],V=P[2],B=P[1];let z=(V-p)*y-(B-f)*m,U=(V-p)*m+(B-f)*y;z=Math.round(z+p),U=Math.round(U+f);let j=o;"number"!=typeof o&&(j=3===N?255:o[N]),z>=0&&z<d&&U>=0&&U<c&&(j=b[w+U*(d*h)+z*h+N]),l[w+I+E+N]=j}}}}return{dataId:a.write(l,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},epe=qt(Wh,t=>{const n=Math.floor(t);return t-n<.5?Math.floor(t):t-n>.5?Math.ceil(t):n%2==0?n:n+1}),tpe={kernelName:Wh,backendName:"cpu",kernelFunc:epe},BV=fi(t=>1/Math.sqrt(t)),npe=Pa(Gh,BV),rpe={kernelName:Gh,backendName:"cpu",kernelFunc:npe};function Wl(t,n,e,r,s,o,i,a,l,u){const c=[r/s,s],d=t.values,h=n.values;if(0===r)return vt(e,n.dtype);const p=l instanceof br?l:vt(c,n.dtype);"string"==typeof l||"number"==typeof l?p.values.fill(l):"boolean"==typeof l&&p.values.fill(+l);for(let f=0;f<o;f++){const g=[];let m=0;for(let y=0;y<i;y++){const b=d[f*i+y];g.push(b),m+=b*a[y]}if(m<0||m>=r/s)throw new Error(`Invalid indices: ${g} does not index into ${e}`);for(let y=0;y<s;y++)u?p.values[m*s+y]+=h[f*s+y]:p.values[m*s+y]=0===n.rank?h[0]:h[f*s+y]}return p}const ope={kernelName:cM,backendName:"cpu",kernelFunc:function spe(t){const{inputs:n,backend:e,attrs:r}=t,{indices:s,updates:o}=n,{shape:i}=r,{sliceRank:a,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=Fl(0,s,i),g=Wl(e.bufferSync(s),e.bufferSync(o),i,d,u,l,a,c,0,!0);return e.makeTensorInfo(i,g.dtype,g.values)}};function ipe(t,n){let e=0,r=t.length,s=0;for(;e<r;)s=Math.floor((e+r)/2),t[s]<n?e=s+1:r=s;return r}function ape(t,n){let e=0,r=t.length,s=0;for(;e<r;)s=Math.floor((e+r)/2),t[s]<=n?e=s+1:r=s;return r}const cpe={kernelName:hM,backendName:"cpu",kernelFunc:function upe(t){const{inputs:n,backend:e,attrs:r}=t,{sortedSequence:s,values:o}=n,{side:i}=r,u=function lpe(t,n,e,r,s,o){const i=Mn("int32",e*s);for(let a=0;a<e;++a){const l=t.slice(a*r,(a+1)*r),u=a*s;for(let c=0;c<s;++c)i[u+c]="left"===o?ipe(l,n[c+u]):ape(l,n[c+u])}return i}(e.data.get(s.dataId).values,e.data.get(o.dataId).values,s.shape[0],s.shape[1],o.shape[1],i);return e.makeTensorInfo(o.shape,"int32",u)}},hpe={kernelName:Jg,backendName:"cpu",kernelFunc:function dpe(t){const{inputs:n,backend:e}=t,{condition:r,t:s,e:o}=n;Ne([r,s,o],"select");const i=r.shape.length,a=e.data.get(r.dataId).values,l=e.data.get(s.dataId).values,u=e.data.get(o.dataId).values,c=ys(s.dtype,o.dtype),d=kr(G(s.shape),c);let h=0;const p=0===i||i>1||1===s.shape.length?1:G(s.shape.slice(1));for(let f=0;f<a.length;f++)for(let g=0;g<p;g++)d[h++]=1===a[f]?l[f]:u[f];return e.makeTensorInfo(s.shape,c,d)}},ppe=Wy,fpe=Gy,mpe=qt(Hh,t=>t>=0?fpe*t:ppe*(Math.exp(t)-1)),gpe={kernelName:Hh,backendName:"cpu",kernelFunc:mpe},ype=qt(Kh,t=>t<0?-1:t>0?1:0),bpe={kernelName:Kh,backendName:"cpu",kernelFunc:ype},vpe=qt(jh,t=>Math.sin(t)),xpe={kernelName:jh,backendName:"cpu",kernelFunc:vpe},wpe=qt(qh,t=>Math.sinh(t)),Cpe={kernelName:qh,backendName:"cpu",kernelFunc:wpe},zV=Math.log(1.1920928955078125e-7)+2,_pe=qt(Yh,t=>{const n=t>-zV,e=t<zV,r=Math.exp(t);let s;return s=e?r:n?t:Math.log(1+r),s}),Spe={kernelName:Yh,backendName:"cpu",kernelFunc:_pe},Dpe={kernelName:ny,backendName:"cpu",kernelFunc:function Ipe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{blockShape:o,paddings:i}=r;Ne([s],"spaceToBatchND");const a=G(o),l=[[0,0]];l.push(...i);for(let C=1+o.length;C<s.shape.length;++C)l.push([0,0]);const u=kV.kernelFunc({inputs:{x:s},backend:e,attrs:{paddings:l,constantValue:0}}),c=Cp(u.shape,o,a,!1),d=_p(c.length,o.length,!1),h=Sp(u.shape,o,a,!1),g=on({inputs:{x:u},backend:e,attrs:{shape:c}}),b=cs({inputs:{x:g},backend:e,attrs:{perm:d}}),w=on({inputs:{x:b},backend:e,attrs:{shape:h}});return e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(b),w}};function UV(t,n,e,r,s,o,i){const a=n[0],l=o[0],u=new Array(l),c=new Array(a),d=n[1];if(0===l){if(0!==a)throw new Error(aO(a));return[Mn(e,0),[0,d],Mn(s,0),u,c]}let h=!0,p=0;const f=new Array(l).fill(0);for(let m=0;m<a;++m){const y=t[m*d];if(y<0)throw new Error(lO(m,y));if(y>=l)throw new Error(uO(m,y,l));++f[y],h=h&&y>=p,p=y}let g=!0;for(let m=0;m<l;++m){const y=0===f[m];u[m]=y,g=g&&!y,f[m]=Math.max(f[m],1),m>0&&(f[m]+=f[m-1])}if(g&&h){const m=t,y=r;for(let b=0;b<a;++b)c[b]=b;return[m,[a,d],y,u,c]}{const m=f[l-1],y=Mn(e,m*d),b=Mn(s,m),v=new Array(l).fill(0);for(let x=0;x<a;++x){const w=t[x*d],I=(0===w?0:f[w-1])+v[w];v[w]++;for(let D=0;D<d;++D)y[I*d+D]=t[x*d+D];b[I]=r[x],c[x]=I}for(let x=0;x<l;++x)if(0===v[x]){const C=0===x?0:f[x-1];y[C*d+0]=x;for(let I=1;I<d;++I)y[C*d+I]=0;b[C]=i}return[y,[m,d],b,u,c]}}const Epe={kernelName:j0,backendName:"cpu",kernelFunc:function Tpe(t){const{inputs:n,backend:e}=t,{indices:r,values:s,denseShape:o,defaultValue:i}=n;if(1!==o.shape.length)throw new Error(`Dense shape must be a vector, saw:\n        ${o.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n        ${r.shape}`);if(1!==s.shape.length)throw new Error(`Values must be a vector, saw:\n        ${s.shape}`);if(0!==i.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`);const a=e.data.get(r.dataId).values,l=e.data.get(s.dataId).values,u=e.data.get(o.dataId).values,c=e.data.get(i.dataId).values[0],[d,h,p,f,g]=UV(a,r.shape,r.dtype,l,s.dtype,u,c);return[e.makeTensorInfo(h,r.dtype,d),e.makeTensorInfo([h[0]],s.dtype,p),e.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(m=>Number(m)))),e.makeTensorInfo([g.length],r.dtype,new Int32Array(g))]}};function WV(t,n,e,r,s){const o=G(r),i=n[0],a=s.length,l=[];let u=1,c=-1;for(let m=0;m<a;++m){const y=s[m];if(-1===y){if(-1!==c)throw new Error(cO(c,m));c=m,l.push(1)}else{if(y<0)throw new Error(dO(m,y));u*=y,l.push(y)}}if(-1!==c){if(u<=0)throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");const m=Math.trunc(o/u);if(u*m!==o)throw new Error(pO(r,l));l[c]=m}if(G(l)!==o)throw new Error(fO(r,l));const h=r.length,p=[];if(h>0){p[h-1]=1;for(let m=h-2;m>=0;--m)p[m]=p[m+1]*r[m+1]}const f=[];if(a>0){f[a-1]=1;for(let m=a-2;m>=0;--m)f[m]=f[m+1]*l[m+1]}const g=Mn(e,i*a);for(let m=0;m<i;++m){let y=0;for(let b=0;b<h;++b)y+=t[m*h+b]*p[b];for(let b=0;b<a;++b)g[m*a+b]=Math.trunc(y/f[b]),y%=f[b]}return[g,[i,a],l]}const kpe={kernelName:q0,backendName:"cpu",kernelFunc:function Npe(t){const{inputs:n,backend:e}=t,{inputIndices:r,inputShape:s,newShape:o}=n;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${r.shape}`);if(1!==s.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${s.shape}`);if(1!==o.shape.length)throw new Error(`Target shape should be a vector but received shape ${o.shape}`);const i=Array.from(e.data.get(s.dataId).values),a=e.data.get(r.dataId).values,l=Array.from(e.data.get(o.dataId).values),[u,c,d]=WV(a,r.shape,r.dtype,i,l);return[e.makeTensorInfo(c,r.dtype,u),e.makeTensorInfo([d.length],o.dtype,new Int32Array(d))]}};function YI(t,n,e,r,s,o=!1,i=0){const a=r.length,l=[n[0],t.length/n[0]],u=l[1],d=a>0?s[a-1]+1:0;if(d<0)throw new Error("segment ids must be >= 0");const h=n.slice();h[0]=d;const f=Mn(e,h.reduce((v,x)=>v*x,1));if(0===a)return d>0&&f.fill(i),[f,h];if(d<=0)throw new Error("segment ids must be >= 0");let g=0,m=1,y=0,b=s[g];for(;;){let v=0;if(m<a){if(v=s[m],b===v){++m;continue}if(b>=v)throw new Error("segment ids are not increasing")}if(b<0||b>=d)throw new Error(gO(b,d));b>y&&f.fill(i,y*u,b*u);for(let x=g;x<m;++x){const w=r[x];if(w<0||w>=l[0])throw new Error(yO(x,r[x],l[0]));for(let C=0;C<u;C++)f[b*u+C]+=t[w*u+C]}if(o)for(let x=0;x<u;x++)f[b*u+x]/=m-g;if(g=m,++m,y=b+1,b=v,m>a)break}return y<d&&f.fill(i,y*u,d*u),[f,h]}const Rpe={kernelName:K0,backendName:"cpu",kernelFunc:function Ape(t){const{inputs:n,backend:e}=t,{data:r,indices:s,segmentIds:o}=n;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n          ${s.shape}`);if(1!==o.shape.length)throw new Error(`Segment ids should be a vector but received shape\n          ${o.shape}`);if(s.shape[0]!==o.shape[0])throw new Error("segmentIds and indices should have same size.");const i=e.data.get(r.dataId).values,a=e.data.get(s.dataId).values,l=e.data.get(o.dataId).values,[u,c]=YI(i,r.shape,r.dtype,a,l,!0);return e.makeTensorInfo(c,r.dtype,u)}},Mpe={kernelName:X0,backendName:"cpu",kernelFunc:function Fpe(t){const{inputs:n,backend:e}=t,{data:r,indices:s,segmentIds:o}=n;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n         ${s.shape}`);if(1!==o.shape.length)throw new Error(`Segment ids should be a vector but received shape\n         ${o.shape}`);if(s.shape[0]!==o.shape[0])throw new Error("segmentIds and indices should have same size.");const i=e.data.get(r.dataId).values,a=e.data.get(s.dataId).values,l=e.data.get(o.dataId).values,[u,c]=YI(i,r.shape,r.dtype,a,l);return e.makeTensorInfo(c,r.dtype,u)}},Ope={kernelName:pM,backendName:"cpu",kernelFunc:function Ppe(t){const{inputs:n,backend:e,attrs:r}=t,{sparseIndices:s,sparseValues:o,defaultValue:i}=n,{outputShape:a}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:d,outputSize:h}=Fl(0,s,a),p=!1,f=e.bufferSync(s);let g;switch(o.dtype){case"bool":g=Wl(f,e.bufferSync(o),a,h,c,u,l,d,Boolean(e.data.get(i.dataId).values[0]),p);break;case"float32":case"int32":g=Wl(f,e.bufferSync(o),a,h,c,u,l,d,e.data.get(i.dataId).values[0],p);break;case"string":g=Wl(f,e.bufferSync(o),a,h,c,u,l,d,ba(e.data.get(i.dataId).values[0]),p);break;default:throw new Error(`Unsupported type ${o.dtype}`)}return e.makeTensorInfo(a,g.dtype,g.values)}},Lpe={kernelName:ry,backendName:"cpu",kernelFunc:function $pe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{numOrSizeSplits:o,axis:i}=r,a=bt(i,s.shape)[0],l=PS(s,o,a),u=new Array(s.shape.length).fill(0),c=s.shape.slice();return l.map(d=>{const h=[...c];h[a]=d;const p=Ul({inputs:{x:s},backend:e,attrs:{begin:u,size:h}});return u[a]+=d,p})}},Vpe=fi(t=>Math.sqrt(t)),Bpe=qt(Zh,t=>Math.sqrt(t)),zpe={kernelName:Zh,backendName:"cpu",kernelFunc:Bpe},Upe={kernelName:Y0,backendName:"cpu",kernelFunc:({inputs:t,backend:n})=>{const{x:e}=t,r=n;Ne(e,"square");const s=r.data.get(e.dataId).values,o=new Float32Array(s.length);for(let a=0;a<s.length;++a){const l=s[a];o[a]=l*l}return{dataId:r.write(o,e.shape,e.dtype),shape:e.shape,dtype:e.dtype}}},GV=jn((t,n)=>{const e=t-n;return e*e}),Wpe=fr(Qh,GV),Gpe={kernelName:Qh,backendName:"cpu",kernelFunc:Wpe},HV=fi((t,n)=>{const{pattern:e,replaceGlobal:r,rewrite:s}=n;return t.replace(new RegExp(e,r?"g":""),s)}),jpe={kernelName:oy,backendName:"cpu",kernelFunc:Pa(oy,HV)},qpe=qt(rp,(t,n)=>{const e=n;return isNaN(t)?NaN:t>0?1:e.alpha}),Kpe={kernelName:rp,backendName:"cpu",kernelFunc:qpe};function jV(t,n,e,r){const s=vt(t,n.dtype);for(let o=0;o<s.size;o++){const i=s.indexToLoc(o),a=new Array(i.length);for(let l=0;l<a.length;l++)a[l]=i[l]*e[l]+r[l];s.set(n.get(...a),...i)}return s}const Ype={kernelName:Z0,backendName:"cpu",kernelFunc:function Xpe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{begin:o,end:i,strides:a,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:h}=r;Ne(s,"stridedSlice");const{finalShapeSparse:p,finalShape:f,isIdentity:g,sliceDim0:m,isSimpleSlice:y,begin:b,end:v,strides:x}=L_(s.shape,o,i,a,l,u,c,d,h);let w;if(g)w=on({inputs:{x:s},backend:e,attrs:{shape:f}});else if(m||y){_(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);const C=P_(b,v,x),I=Ul({inputs:{x:s},backend:e,attrs:{begin:b,size:C}});w=on({inputs:{x:I},backend:e,attrs:{shape:f}}),e.disposeIntermediateTensorInfo(I)}else{const I=jV(p,e.bufferSync(s),x,b);w=e.makeTensorInfo(f,I.dtype,I.values)}return w}};class Zpe{constructor(n,e,r,s,o,i){this.separator=ya(n),this.nGramWidths=e,this.leftPad=ya(r),this.rightPad=ya(s),this.padWidth=o,this.preserveShort=i}getPadWidth(n){return Math.min(this.padWidth<0?n-1:this.padWidth,n-1)}getNumNGrams(n,e){const r=this.getPadWidth(e);return Math.max(0,n+2*r-e+1)}createNGrams(n,e,r,s,o,i){for(let a=0;a<o;++a){const l=this.getPadWidth(i),u=Math.max(0,l-a),c=Math.max(0,l-(o-(a+1))),d=i-(u+c),h=e+(u>0?0:a-l);let p=0;p+=u*this.leftPad.length;for(let b=0;b<d;++b)p+=n[h+b].length;p+=c*this.rightPad.length,p+=(u+c+d-1)*this.separator.length,r[s+a]=new Uint8Array(p);const g=r[s+a];let m=0;const y=b=>b.forEach(v=>g[m++]=v);for(let b=0;b<u;++b)y(this.leftPad),y(this.separator);for(let b=0;b<d-1;++b)y(n[h+b]),y(this.separator);if(d>0){y(n[h+d-1]);for(let b=0;b<c;++b)y(this.separator),y(this.rightPad)}else{for(let b=0;b<c-1;++b)y(this.rightPad),y(this.separator);y(this.rightPad)}}}compute(n,e){const r=n.length,s=e.length;if(s>0){let l=e[0];if(0!==l)throw new Error(`First split value must be 0, got ${l}`);for(let u=1;u<s;++u){let c=e[u]>=l;if(c=c&&e[u]<=r,!c)throw new Error(`Invalid split value ${e[u]}, must be in [${l}, ${r}]`);l=e[u]}if(l!==r)throw new Error(`Last split value must be data size. Expected ${r}, got ${l}`)}const o=s-1,i=Mn("int32",s);if(0===r||0===s){const l=new Array(r);for(let u=0;u<=o;++u)i[u]=0;return[l,i]}i[0]=0;for(let l=1;l<=o;++l){const u=e[l]-e[l-1];let c=0;this.nGramWidths.forEach(d=>{c+=this.getNumNGrams(u,d)}),this.preserveShort&&u>0&&0===c&&(c=1),i[l]=i[l-1]+c}const a=new Array(i[o]);for(let l=0;l<o;++l){const u=e[l];let c=i[l];if(this.nGramWidths.forEach(d=>{const p=this.getNumNGrams(e[l+1]-e[l],d);this.createNGrams(n,u,a,c,p,d),c+=p}),this.preserveShort&&c===i[l]){const d=e[l+1]-e[l];if(0===d)continue;this.createNGrams(n,u,a,c,1,d+2*this.padWidth)}}return[a,i]}}function qV(t,n,e,r,s,o,i,a){return new Zpe(e,r,s,o,i,a).compute(t,n)}const Jpe={kernelName:Q0,backendName:"cpu",kernelFunc:function Qpe(t){const{inputs:n,backend:e,attrs:r}=t,{separator:s,nGramWidths:o,leftPad:i,rightPad:a,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:d}=n,h=e.data.get(c.dataId).values,p=e.data.get(d.dataId).values,[f,g]=qV(h,p,s,o,i,a,l,u);return[e.makeTensorInfo([f.length],"string",f),e.makeTensorInfo(d.shape,"int32",g)]}};function efe(t,n,e,r){if(!t.length)return;if(0===n.length){for(let o=0;o<t.length;++o)r.push(t.subarray(o,o+1));return}if(1===n.length){const o=n[0];let i=t.indexOf(o);for(;-1!==i;){const a=t.subarray(0,i);(!e||0!==a.length)&&r.push(a),i=(t=t.subarray(i+1)).indexOf(o)}return void((!e||0!==t.length)&&r.push(t))}let s=0;for(let o=0;o<t.length+1;o++)if(o===t.length||-1!==n.indexOf(t[o])){const i=t.subarray(s,o);(!e||0!==i.length)&&r.push(i),s=o+1}}function KV(t,n,e){const r=t.length,s=[];let o=0,i=0;const a=new Array(r);for(let h=0;h<r;++h){const p=s.length;efe(t[h],n,e,s);const f=s.length-p;a[h]=f,o+=f,i=Math.max(i,f)}const l=Mn("int32",2*o),u=new Array(o),c=[r,i];let d=0;for(let h=0;h<r;++h)for(let p=0;p<a[h];++p)l[2*d]=h,l[2*d+1]=p,u[d]=s[d],++d;return[l,u,c]}const nfe={kernelName:J0,backendName:"cpu",kernelFunc:function tfe(t){const{inputs:n,backend:e,attrs:r}=t,{skipEmpty:s}=r,{input:o,delimiter:i}=n;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(1!==o.shape.length)throw new Error(`Input must be a vector, got shape: ${o.shape}`);if(0!==i.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const a=e.data.get(o.dataId).values,l=e.data.get(i.dataId).values[0],[u,c,d]=KV(a,l,s),h=c.length;return[e.makeTensorInfo([h,2],"int32",u),e.makeTensorInfo([h],"string",c),e.makeTensorInfo([2],"int32",new Int32Array(d))]}};function XV(t,n){const e=Mn("int32",t.length);for(let r=0;r<t.length;++r)e[r]=NY(t[r]).modulo(n).getLowBitsUnsigned();return e}const sfe={kernelName:e_,backendName:"cpu",kernelFunc:function rfe(t){const{inputs:n,backend:e,attrs:r}=t,{numBuckets:s}=r,{input:o}=n;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const a=XV(e.data.get(o.dataId).values,s);return e.makeTensorInfo(o.shape,"int32",a)}},ofe=qt(ep,t=>Math.tan(t)),ife={kernelName:ep,backendName:"cpu",kernelFunc:ofe},afe=qt(tp,t=>Math.tanh(t));function YV(t,n){const e=new Array(t.rank);for(let s=0;s<e.length;s++)e[s]=t.shape[s]*n[s];const r=vt(e,t.dtype);for(let s=0;s<r.values.length;++s){const o=r.indexToLoc(s),i=new Array(t.rank);for(let l=0;l<i.length;l++)i[l]=o[l]%t.shape[l];const a=t.locToIndex(i);r.values[s]=t.values[a]}return r}const Bp=(t,n)=>{const e=n.value-t.value;return 0===e?t.index-n.index:e};function ZV(t,n,e=0,r=t.length-1){for(;r>e;){if(r-e>600){const a=r-e+1,l=n-e+1,u=Math.log(a),c=.5*Math.exp(2*u/3),d=.5*Math.sqrt(u*c*(a-c)/a)*Math.sign(l-a/2);ZV(t,n,Math.max(e,Math.floor(n-l*c/a+d)),Math.min(r,Math.floor(n+(a-l)*c/a+d)))}const s=t[n];let o=e,i=r;for(pa(t,e,n),Bp(t[r],s)>0&&pa(t,e,r);o<i;){for(pa(t,o,i),o++,i--;Bp(t[o],s)<0;)o+=1;for(;Bp(t[i],s)>0;)i-=1}0===Bp(t[e],s)?pa(t,e,i):(i+=1,pa(t,i,r)),i<=n&&(e=i+1),n<=i&&(r=i-1)}}function QV(t,n,e,r,s){const o=n[n.length-1],[i,a]=[t.length/o,o],l=Nr(e,i*r),u=Nr("int32",i*r);for(let d=0;d<i;d++){const h=d*a,p=t.subarray(h,h+a);let f=new Array(p.length);p.forEach((b,v)=>f[v]={value:b,index:v}),r<f.length&&(ZV(f,r),f=f.slice(0,r)),s&&f.sort(Bp);const g=d*r,m=l.subarray(g,g+r),y=u.subarray(g,g+r);for(let b=0;b<r;b++)m[b]=f[b].value,y[b]=f[b].index}const c=n.slice();return c[c.length-1]=r,[vt(c,e,l),vt(c,"int32",u)]}function JV(t,n,e){switch(e){case"reflect":return function yfe(t,n){let e=t;if(e<0)if(n<=1)e=0;else{const r=2*n;e<r&&(e=r*Math.trunc(-e/r)+e),e=e<-n?e+r:-e-1}else if(e>n-1)if(n<=1)e=0;else{const r=2*n;e-=r*Math.trunc(e/r),e>=n&&(e=r-e-1)}return bl(0,e,n-1)}(t,n);case"wrap":return function bfe(t,n){let e=t;return e<0?n<=1?e=0:e+=n*(Math.trunc(-e/(n-1))+1):e>n-1&&(n<=1?e=0:e-=n*Math.trunc(e/(n-1))),bl(0,e,n-1)}(t,n);case"nearest":return function xfe(t,n){return bl(0,t,n-1)}(t,n);default:return function vfe(t,n){return t}(t)}}function zp(t,n,e,r,s,o,i,a,l,u,c){return 0<=a&&a<n&&0<=l&&l<e?t[i*r+a*s+l*o+u]:c}function wfe(t,n,e,r,s,o,i,a,l,u,c){return zp(t,n,e,r,s,o,i,Math.round(a),Math.round(l),u,c)}function Cfe(t,n,e,r,s,o,i,a,l,u,c){const d=Math.floor(a),h=Math.floor(l),p=d+1,f=h+1;return(p-a)*((f-l)*zp(t,n,e,r,s,o,i,d,h,u,c)+(l-h)*zp(t,n,e,r,s,o,i,d,f,u,c))+(a-d)*((f-l)*zp(t,n,e,r,s,o,i,p,h,u,c)+(l-h)*zp(t,n,e,r,s,o,i,p,f,u,c))}function e3(t,n,e,r){const s=bt(n,e)[0],o=[1,e[0],1];for(let f=0;f<s;f++)o[0]*=e[f];o[1]=e[s];for(let f=s+1;f<e.length;f++)o[2]*=e[f];const i=new Map,a=new Int32Array(e[s]),l=new br(o,r,t),u=[],c=1===o[0]&&1===o[2];for(let f=0;f<e[s];f++){let g;if(c)g=t[f].toString();else{const y=[];for(let b=0;b<o[0];b++)for(let v=0;v<o[2];v++)y.push(l.get(b,f,v));g=y.join(",")}const m=i.get(g);if(null!=m)a[f]=m;else{const y=i.size;i.set(g,y),a[f]=y,u.push(f)}}const d=o.slice();d[1]=i.size;const h=new br(d,r);u.forEach((f,g)=>{for(let m=0;m<o[0];m++)for(let y=0;y<o[2];y++)h.set(l.get(m,f,y),m,g,y)});const p=e.slice();return p[s]=d[1],{outputValues:h.values,outputShape:p,indices:a}}const Nfe=[Tle,Ele,kle,Rle,_le,Mle,$le,Vle,zle,Wle,Hle,qle,Xle,Qle,eue,rue,oue,aue,uue,Ile,due,fue,gue,bue,wle,xue,Cue,vle,_ue,Iue,Due,Eue,kue,Rue,Mue,Oue,Lue,Bue,Uue,Gue,jue,Kue,Yue,Zue,Jue,tce,rce,sce,oce,ice,dce,cle,pce,fce,Cce,_ce,Sce,Dce,Mce,Pce,$ce,Vce,zce,Wce,Hce,qce,Xce,Zce,Jce,dle,tde,Sue,rde,ode,ade,hle,ude,dde,pde,mde,yde,xde,Cde,Ide,Tde,Nde,kde,Rde,Mde,Ode,Lde,Bde,Ude,Gde,jde,Kde,Yde,Jde,nhe,lce,she,ahe,che,phe,mhe,yhe,vhe,xhe,kV,She,fle,Dhe,Mhe,Ohe,Lhe,Bhe,xle,jI,Uhe,mle,gle,Sle,Ghe,jhe,Khe,Yhe,Qhe,Jhe,tpe,rpe,ope,cpe,hpe,gpe,ble,bpe,xpe,Cpe,hue,ehe,Spe,Dpe,Epe,kpe,Rpe,Mpe,Ope,Lpe,zpe,Upe,Gpe,jpe,Kpe,Ype,Jpe,nfe,sfe,Nce,uce,ife,{kernelName:tp,backendName:"cpu",kernelFunc:afe},{kernelName:dM,backendName:"cpu",kernelFunc:function ufe(t){const{inputs:n,backend:e}=t,{tensor:r,indices:s,updates:o}=n,{sliceRank:i,numUpdates:a,sliceSize:l,strides:u,outputSize:c}=Fl(0,s,r.shape),h=e.bufferSync(s),p=e.bufferSync(o),f=e.bufferSync(r),g=Wl(h,p,r.shape,c,l,a,i,u,f,!1);return e.makeTensorInfo(r.shape,g.dtype,g.values)}},{kernelName:np,backendName:"cpu",kernelFunc:function dfe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{reps:o}=r;Ne(s,"tile");const i=YV(e.bufferSync(s),o);return e.makeTensorInfo(i.shape,i.dtype,i.values)}},{kernelName:t_,backendName:"cpu",kernelFunc:function pfe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{k:o,sorted:i}=r;Ne(s,"topk");const a=e.data.get(s.dataId).values,[l,u]=QV(a,s.shape,s.dtype,o,i);return[e.makeTensorInfo(l.shape,l.dtype,l.values),e.makeTensorInfo(u.shape,u.dtype,u.values)]}},{kernelName:n_,backendName:"cpu",kernelFunc:function mfe(t){const{inputs:n,attrs:e,backend:r}=t,{image:s,transforms:o}=n,{interpolation:i,fillMode:a,fillValue:l,outputShape:u}=e,[c,d,h,p]=s.shape,[f,g]=u??[d,h],m=[c,f,g,p],y=Pe(s.shape),b=y[0],v=y[1],x=y[2],w=Pe(m),C=w[0],I=w[1],D=w[2],E=Nr(s.dtype,G(m));E.fill(l);const N=r.data.get(s.dataId).values,P=r.data.get(o.dataId).values;for(let B=0;B<c;++B){const z=1===o.shape[0]?P:P.subarray(8*B,8*B+8);for(let U=0;U<f;++U)for(let j=0;j<g;++j)for(let q=0;q<p;++q){let W;const K=z[6]*j+z[7]*U+1;if(0===K)continue;const ae=(z[3]*j+z[4]*U+z[5])/K,he=JV((z[0]*j+z[1]*U+z[2])/K,h,a),le=JV(ae,d,a);switch(i){case"nearest":W=wfe(N,d,h,b,v,x,B,le,he,q,l);break;case"bilinear":W=Cfe(N,d,h,b,v,x,B,le,he,q,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}E[B*C+U*I+j*D+q]=W}return r.makeTensorInfo(m,s.dtype,E)}return{dataId:r.write(E,m,s.dtype),shape:s.shape,dtype:s.dtype}}},Ple,{kernelName:r_,backendName:"cpu",kernelFunc:function _fe(t){const{inputs:n,attrs:e,backend:r}=t,{axis:s}=e,{x:o}=n;Ne(o,"unique");const i=r.data.get(o.dataId).values,{outputValues:a,outputShape:l,indices:u}=e3(i,s,o.shape,o.dtype);return[r.makeTensorInfo(l,o.dtype,a),r.makeTensorInfo([u.length],"int32",u)]}},{kernelName:iy,backendName:"cpu",kernelFunc:function Ife(t){const{inputs:n,backend:e,attrs:r}=t,{value:s}=n;let{axis:o}=r;o<0&&(o+=s.shape.length);const i=s.shape.length,a=s.shape[o],l=new Array(i-1);let u=0;for(let p=0;p<i;p++)p!==o&&(l[u++]=s.shape[p]);const c=new Array(i).fill(0),d=s.shape.slice();d[o]=1;const h=new Array(a);for(let p=0;p<h.length;p++){c[o]=p;const f=Ul({inputs:{x:s},backend:e,attrs:{begin:c,size:d}});h[p]=on({inputs:{x:f},backend:e,attrs:{shape:l}}),e.disposeIntermediateTensorInfo(f)}return h}},{kernelName:ay,backendName:"cpu",kernelFunc:function Tfe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,segmentIds:o}=n,{numSegments:i}=r;Ne(s,"unsortedSegmentSum");const u=[],c=[],d=s.shape.length-o.shape.length;let h=o;for(let f=0;f<d;++f){const g=Sb({inputs:{input:h},backend:e,attrs:{dim:f+1}});h=g,c.push(g)}for(let f=0;f<i;++f){const g=ga(f,"int32"),m=e.makeTensorInfo([],"int32",g),y=oV({inputs:{a:m,b:h},backend:e}),b=Oa({inputs:{x:y},backend:e,attrs:{dtype:"float32"}}),v=_b({inputs:{a:b,b:s},backend:e}),x=Vp({inputs:{x:v},backend:e,attrs:{axis:0,keepDims:!1}});u.push(x),c.push(m),c.push(y),c.push(b),c.push(v),c.push(x)}const p=NV({inputs:u,backend:e,attrs:{axis:0}});return c.forEach(f=>e.disposeIntermediateTensorInfo(f)),p}},bhe];for(const t of Nfe)i_(t);const $a={},Tb={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function $o(t,n){if(!(t in $a)||null!=n){const r=function Rfe(t,n){if(1!==t&&2!==t)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const e=n??function Afe(t){if(!L().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&2===t)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(t);return e.addEventListener("webglcontextlost",r=>{r.preventDefault(),delete $a[t]},!1),L().getBool("SOFTWARE_WEBGL_ENABLED")&&(Tb.failIfMajorPerformanceCaveat=!1),1===t?e.getContext("webgl",Tb)||e.getContext("experimental-webgl",Tb):e.getContext("webgl2",Tb)}(t,n);if(null===r)return console.log("Could not get context for WebGL version",t),null;$a[t]=r}const e=$a[t];return null==e||e.isContextLost()?(delete $a[t],$o(t)):(e.disable(e.DEPTH_TEST),e.disable(e.STENCIL_TEST),e.disable(e.BLEND),e.disable(e.DITHER),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SAMPLE_COVERAGE),e.enable(e.SCISSOR_TEST),e.enable(e.CULL_FACE),e.cullFace(e.BACK),$a[t])}var Tc=(()=>{return(t=Tc||(Tc={}))[t.DENSE=0]="DENSE",t[t.SHARED_BATCH=1]="SHARED_BATCH",Tc;var t})(),ws=(()=>{return(t=ws||(ws={}))[t.RENDER=0]="RENDER",t[t.UPLOAD=1]="UPLOAD",t[t.PIXELS=2]="PIXELS",t[t.DOWNLOAD=3]="DOWNLOAD",ws;var t})(),mr=(()=>{return(t=mr||(mr={}))[t.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",t[t.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",t[t.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",t[t.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",t[t.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16",mr;var t})();function Up(t,n){return[n,t]}function Eb(t){const n=G(t);return r0(Math.ceil(n/4))}function Ec(t,n){return[Math.max(1,Math.ceil(n/2)),Math.max(1,Math.ceil(t/2))]}function ZI(t,n){const e=t;let r,s,o,i,a,l,u,c,d,h;return 2===L().getNumber("WEBGL_VERSION")?(r=e.R32F,s=e.R16F,o=e.RGBA16F,i=e.RGBA32F,a=e.RED,u=4,c=1,d=e.HALF_FLOAT,h=e.FLOAT,l=e.RGBA8):(r=t.RGBA,s=t.RGBA,o=t.RGBA,i=e.RGBA,a=t.RGBA,u=4,c=4,d=null!=n?n.HALF_FLOAT_OES:null,h=t.FLOAT,l=t.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:s,internalFormatPackedHalfFloat:o,internalFormatPackedFloat:i,textureFormatFloat:a,downloadTextureFormat:l,downloadUnpackNumChannels:u,defaultNumChannels:c,textureTypeHalfFloat:d,textureTypeFloat:h}}function ge(t,n){const e=n();return L().getBool("DEBUG")&&function Pfe(t){const n=t.getError();if(n!==t.NO_ERROR)throw new Error("WebGL Error: "+function Vfe(t,n){switch(n){case t.NO_ERROR:return"NO_ERROR";case t.INVALID_ENUM:return"INVALID_ENUM";case t.INVALID_VALUE:return"INVALID_VALUE";case t.INVALID_OPERATION:return"INVALID_OPERATION";case t.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case t.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case t.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${n}`}}(t,n))}(t),e}const Ofe=5.96e-8,$fe=65504;function Lfe(t){return!!(L().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===t||Ofe<Math.abs(t)&&Math.abs(t)<$fe)}function Nb(t,n){return Ki(t,()=>t.getExtension(n),'Extension "'+n+'" not supported on this browser.')}const Ufe=/ERROR: [0-9]+:([0-9]+):/g;function t3(t,n){const e=Ufe.exec(n);if(null==e)return console.log(`Couldn't parse line number in error: ${n}`),void console.log(t);const r=+e[1],s=t.split("\n"),o=s.length.toString().length+2,i=s.map((d,h)=>Qu((h+1).toString(),o)+d);let a=0;for(let d=0;d<i.length;d++)a=Math.max(i[d].length,a);const l=i.slice(0,r-1),u=i.slice(r-1,r),c=i.slice(r);console.log(l.join("\n")),console.log(n.split("\n")[0]),console.log(`%c ${Qu(u[0],a)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join("\n"))}function QI(t,n){if(ge(t,()=>t.validateProgram(n)),!1===t.getProgramParameter(n,t.VALIDATE_STATUS))throw console.log(t.getProgramInfoLog(n)),new Error("Shader program validation failed.")}function n3(t,n,e,r,s,o,i){const a=t.getAttribLocation(n,e);return-1!==a&&(ge(t,()=>t.bindBuffer(t.ARRAY_BUFFER,r)),ge(t,()=>t.vertexAttribPointer(a,s,t.FLOAT,!1,o,i)),ge(t,()=>t.enableVertexAttribArray(a)),!0)}function Jfe(t,n,e,r){ge(t,()=>function Yfe(t,n,e){(function s3(t,n){const e=t.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=n+t.TEXTURE0;if(r<t.TEXTURE0||r>e)throw new Error(`textureUnit must be in [gl.TEXTURE0, gl.TEXTURE${e}].`)})(t,e),ge(t,()=>t.activeTexture(t.TEXTURE0+e)),ge(t,()=>t.bindTexture(t.TEXTURE_2D,n))}(t,n,r)),ge(t,()=>t.uniform1i(e,r))}function JI(t,n,e){ge(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,e)),ge(t,()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,n,0))}function r3(t,n){ge(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,n)),ge(t,()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,null,0))}function kb(t){const n=t.checkFramebufferStatus(t.FRAMEBUFFER);if(n!==t.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function eme(t,n){switch(n){case t.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case t.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${n}`}}(t,n))}function Ki(t,n,e){const r=ge(t,()=>n());if(null==r)throw new Error(e);return r}function Nc(t,n=2){return G(t.slice(0,t.length-n))}function kc(t){if(0===t.length)throw Error("Cannot get rows and columns of an empty shape array.");return[t.length>1?t[t.length-2]:1,t[t.length-1]]}function Ab(t){let n=[1,1,1];return 0===t.length||1===t.length&&1===t[0]||(n=[Nc(t),...kc(t)]),n}function Rb(t){return t%2==0}function Fb(t,n){if(Bt(t=t.slice(-2),n=n.slice(-2))||!t.length||!n.length||0===t[0]||0===t[1]||0===n[0]||0===n[1])return!0;if(t.length!==n.length){const e=t[t.length-1],r=n[n.length-1];if(e===r||Rb(e)&&Rb(r)&&(1===t[0]||1===n[0]))return!0}return t[1]===n[1]&&Rb(t[0])&&Rb(n[0])}let Mb,Pb;function mo(t,n){return null!=t.getExtension(n)}function o3(t){try{if(null!=$o(t))return!0}catch(n){return console.log("Error when getting WebGL context: ",n),!1}return!1}function e1(t){const n=ZI(t),e=t.createTexture();t.bindTexture(t.TEXTURE_2D,e),t.texImage2D(t.TEXTURE_2D,0,n.internalFormatFloat,1,1,0,n.textureFormatFloat,n.textureTypeFloat,null);const o=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,o),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,e,0);const i=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(e),t.deleteFramebuffer(o),i}function Wp(t,n){Array.isArray(t)||(t=[t]),t.forEach(e=>{null!=e&&_("complex64"!==e.dtype,()=>`${n} does not support complex64 tensors in the WebGL backend.`)})}const Re=L();function Kr(){let t,n,e,r,s,o,i,a,l,u;return 2===L().getNumber("WEBGL_VERSION")?(t="#version 300 es",n="in",e="out",r="in",s="texture",o="outputColor",i="out vec4 outputColor;",a=L().getBool("WEBGL2_ISNAN_CUSTOM")?"\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ":"",l="",u="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(t="",n="attribute",e="varying",r="varying",s="texture2D",o="gl_FragColor",i="",a="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",l="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",u="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:t,attribute:n,varyingVs:e,varyingFs:r,texture2D:s,output:o,defineOutput:i,defineSpecialNaN:a,defineSpecialInf:l,defineRound:u}}function Gl(t,n,e="index"){const r=Pe(n);return r.map((s,o)=>`int ${t[o]} = ${e} / ${s}; ${o===r.length-1?`int ${t[o+1]} = ${e} - ${t[o]} * ${s}`:`index -= ${t[o]} * ${s}`};`).join("")}function Ob(t,n,e="index"){const r=Pe(n);return r.map((s,o)=>`int ${t[o]} = ${e} / outShapeStrides[${o}]; ${o===r.length-1?`int ${t[o+1]} = ${e} - ${t[o]} * outShapeStrides[${o}]`:`index -= ${t[o]} * outShapeStrides[${o}]`};`).join("")}function t1(t){const n=Pe(t).map(e=>e.toString());return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${n[0]} + coords.y * ${n[1]} + coords.z;\n  }\n`}Re.registerFlag("HAS_WEBGL",()=>Re.getNumber("WEBGL_VERSION")>0),Re.registerFlag("WEBGL_VERSION",()=>o3(2)?2:o3(1)?1:0),Re.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1),Re.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>2===Re.get("WEBGL_VERSION")),Re.registerFlag("WEBGL_CPU_FORWARD",()=>!0),Re.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1),Re.registerFlag("WEBGL_PACK",()=>Re.getBool("HAS_WEBGL")),Re.registerFlag("WEBGL_PACK_NORMALIZATION",()=>Re.getBool("WEBGL_PACK")),Re.registerFlag("WEBGL_PACK_CLIP",()=>Re.getBool("WEBGL_PACK")),Re.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>Re.getBool("WEBGL_PACK")),Re.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>Re.getBool("WEBGL_PACK")),Re.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>Re.getBool("WEBGL_PACK")),Re.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>Re.getBool("WEBGL_PACK")),Re.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>Re.getBool("WEBGL_PACK")),Re.registerFlag("WEBGL_PACK_REDUCE",()=>Re.getBool("WEBGL_PACK")),Re.registerFlag("WEBGL_LAZILY_UNPACK",()=>Re.getBool("WEBGL_PACK")),Re.registerFlag("WEBGL_CONV_IM2COL",()=>Re.getBool("WEBGL_PACK")),Re.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>function nme(t){if(null==Mb){const n=$o(t);Mb=n.getParameter(n.MAX_TEXTURE_SIZE)}return Mb}(Re.getNumber("WEBGL_VERSION"))),Re.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>function rme(t){if(null==Pb){const n=$o(t);Pb=n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,Pb)}(Re.getNumber("WEBGL_VERSION"))),Re.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const t=Re.getNumber("WEBGL_VERSION");return 0===t?0:function sme(t){if(0===t)return 0;let n;const e=$o(t);return n=mo(e,"EXT_disjoint_timer_query_webgl2")&&2===t?2:mo(e,"EXT_disjoint_timer_query")?1:0,n}(t)}),Re.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>Re.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!NM()),Re.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>function ome(t){if(0===t)return!1;const n=$o(t);if(1===t){if(!mo(n,"OES_texture_float"))return!1}else if(!mo(n,"EXT_color_buffer_float"))return!1;return e1(n)}(Re.getNumber("WEBGL_VERSION"))),Re.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>!Re.getBool("WEBGL_FORCE_F16_TEXTURES")&&Re.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")),Re.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>function ime(t){if(0===t)return!1;const n=$o(t);if(1!==t){if(mo(n,"EXT_color_buffer_float"))return e1(n);const r="EXT_color_buffer_half_float";if(mo(n,r)){const s=n.getExtension(r);return function ame(t,n){const e=ZI(t,n),r=t.createTexture();t.bindTexture(t.TEXTURE_2D,r),t.texImage2D(t.TEXTURE_2D,0,e.internalFormatHalfFloat,1,1,0,e.textureFormatFloat,e.textureTypeHalfFloat,null);const i=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,i),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,r,0);const a=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(r),t.deleteFramebuffer(i),a}(n,s)}return!1}return!(!mo(n,"OES_texture_float")||!mo(n,"WEBGL_color_buffer_float"))&&e1(n)}(Re.getNumber("WEBGL_VERSION"))),Re.registerFlag("WEBGL_FENCE_API_ENABLED",()=>function lme(t){return 2===t&&null!=$o(t).fenceSync}(Re.getNumber("WEBGL_VERSION"))),Re.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>Re.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0),Re.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,t=>{if(t<0&&-1!==t)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${t}.`)}),Re.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>NM()?1:-1,t=>{if(t<0&&-1!==t)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${t}.`)}),Re.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128),Re.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1),Re.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5),Re.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128),Re.registerFlag("WEBGL_EXP_CONV",()=>!1),Re.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>Re.getBool("IS_TEST")),Re.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0),Re.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1),Re.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1),Re.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);const i3="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:a3}=et;function dme(t,n,e){const r=[];if(t.forEach(p=>{const f=G(p.shapeInfo.logicalShape);if(p.shapeInfo.isUniform?r.push(`uniform float ${p.name}${f>1?`[${f}]`:""};`):(r.push(`uniform sampler2D ${p.name};`),r.push(`uniform int offset${p.name};`)),e.enableShapeUniforms){const{uniformShape:g}=r1(e.packedInputs,p.shapeInfo.logicalShape,p.shapeInfo.texShape);switch(g.length){case 1:r.push(`uniform int ${p.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${p.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${p.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${p.name}Shape;`)}r.push(`uniform ivec2 ${p.name}TexShape;`)}}),e.enableShapeUniforms){switch(n.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;")}r.push("uniform ivec2 outTexShape;")}e.customUniforms&&e.customUniforms.forEach(p=>{r.push(`uniform ${p.type} ${p.name}${p.arrayIndex?`[${p.arrayIndex}]`:""};`)});const s=r.join("\n"),o=t.map(p=>function hme(t,n,e=!1,r){let s="";s+=e?l3(t,r):Ac(t,r);return t.shapeInfo.logicalShape.length<=n.logicalShape.length&&(s+=e?function Hme(t,n){const e=t.name,r=e.charAt(0).toUpperCase()+e.slice(1),s="get"+r+"AtOutCoords",o=t.shapeInfo.logicalShape.length,i=n.logicalShape.length,a=a3(t.shapeInfo.logicalShape,n.logicalShape),l=Qt(i),u=i-o;let c;const d=["x","y","z","w","u","v"];c=0===o?"":i<2&&a.length>=1?"coords = 0;":a.map(b=>`coords.${d[b+u]} = 0;`).join("\n");let h="";h=i<2&&o>0?"coords":t.shapeInfo.logicalShape.map((b,v)=>`coords.${d[v+u]}`).join(", ");let p="return outputValue;";const g=1===G(t.shapeInfo.logicalShape),y=1===G(n.logicalShape);if(1!==o||g||y){if(g&&!y)p=1===i?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(a.length){const b=o-2,v=o-1;a.indexOf(b)>-1&&a.indexOf(v)>-1?p="return vec4(outputValue.x);":a.indexOf(b)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":a.indexOf(v)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}}else p="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${s}() {\n      ${l} coords = getOutputCoords();\n      ${c}\n      vec4 outputValue = get${r}(${h});\n      ${p}\n    }\n  `}(t,n):function jme(t,n){const e=t.name,r=e.charAt(0).toUpperCase()+e.slice(1),s="get"+r+"AtOutCoords",a=t.shapeInfo.logicalShape.length,l=n.logicalShape.length;if(!t.shapeInfo.isUniform&&a===l&&null==t.shapeInfo.flatOffset&&Bt(t.shapeInfo.texShape,n.texShape))return`\n      float ${s}() {\n        return sampleTexture(${e}, resultUV);\n      }\n    `;const u=Qt(l),c=a3(t.shapeInfo.logicalShape,n.logicalShape),d=l-a;let h;const p=["x","y","z","w","u","v"];h=0===a?"":l<2&&c.length>=1?"coords = 0;":c.map(g=>`coords.${p[g+d]} = 0;`).join("\n");let f="";return f=l<2&&a>0?"coords":t.shapeInfo.logicalShape.map((g,m)=>`coords.${p[m+d]}`).join(", "),`\n    float ${s}() {\n      ${u} coords = getOutputCoords();\n      ${h}\n      return get${r}(${f});\n    }\n  `}(t,n)),s}(p,n,e.packedInputs,e.enableShapeUniforms)).join("\n"),i=n.texShape,a=Kr(),l=function mme(t){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${t.texture2D}(textureSampler, uv).r;\n    }\n  `}(a);let u,c,d=function bme(t){return`${t.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${t.varyingFs} vec2 resultUV;\n    ${t.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${t.defineSpecialNaN}\n    ${t.defineSpecialInf}\n    ${t.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${vme}\n    ${xme}\n    ${wme}\n  `}(a);return n.isPacked?(u=function pme(t,n,e){switch(t.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function _me(t,n,e){const r=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)];return 1===r[0]?e?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${r[1]}.0);\n      }\n    `:1===r[1]?e?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${r[0]}.0);\n      }\n    `:e?"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);\n    }\n  `}(0,n,e);case 2:return function Ame(t,n,e){const r=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)];if(Bt(t,n))return e?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));\n      }\n    `;const s=Math.ceil(t[1]/2);return e?"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(t,n,e);case 3:return function Ime(t,n,e){if(e)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const r=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)],s=Math.ceil(t[2]/2),o=s*Math.ceil(t[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      int b = index / ${o};\n      index -= b * ${o};\n\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(t,n,e);default:return function Tme(t,n,e){if(e)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const r=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)],s=Math.ceil(t[t.length-1]/2),o=s*Math.ceil(t[t.length-2]/2);let i=o,a="",l="b, r, c";for(let u=2;u<t.length-1;u++)i*=t[t.length-u-1],a=`\n      int b${u} = index / ${i};\n      index -= b${u} * ${i};\n    `+a,l=`b${u}, `+l;return`\n    ivec${t.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      ${a}\n\n      int b = index / ${o};\n      index -= b * ${o};\n\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec${t.length}(${l});\n    }\n  `}(t,n,e)}}(n.logicalShape,i,e.enableShapeUniforms),c=function yme(t){return`\n    void setOutput(vec4 val) {\n      ${t.output} = val;\n    }\n  `}(a)):(u=function fme(t,n,e){switch(t.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function Sme(t,n,e){return 1===n[0]?e?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.x * ${n[1]}.0);\n      }\n    `:1===n[1]?e?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.y * ${n[0]}.0);\n      }\n    `:e?"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      return resTexRC.x * ${n[1]} + resTexRC.y;\n    }\n  `}(0,n,e);case 2:return function Rme(t,n,e){return Bt(t,n)?e?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${n[0]}, ${n[1]}));\n      }\n    `:1===t[1]?e?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${n[0]}, ${n[1]}));\n        int index = resTexRC.x * ${n[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:1===t[0]?e?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${n[0]}, ${n[1]}));\n        int index = resTexRC.x * ${n[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:e?"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n      int r = index / ${t[1]};\n      int c = index - r * ${t[1]};\n      return ivec2(r, c);\n    }\n  `}(t,n,e);case 3:return function Dme(t,n,e){if(e)return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${Ob(["r","c","d"],t)}\n    return ivec3(r, c, d);\n  }\n`;const r=Gl(["r","c","d"],t);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n      ${r}\n      return ivec3(r, c, d);\n    }\n  `}(t,n,e);case 4:return function Eme(t,n,e){if(e)return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${Ob(["r","c","d","d2"],t)}\n      return ivec4(r, c, d, d2);\n    }\n  `;const r=Gl(["r","c","d","d2"],t);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n      ${r}\n      return ivec4(r, c, d, d2);\n    }\n  `}(t,n,e);case 5:return function Nme(t,n){const e=Gl(["r","c","d","d2","d3"],t);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${n[0]},\n                             ${n[1]}));\n\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      ${e}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(t,n);case 6:return function kme(t,n){const e=Gl(["r","c","d","d2","d3","d4"],t);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      ${e}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(t,n);default:throw new Error(`${t.length}-D output sampling is not yet supported`)}}(n.logicalShape,i,e.enableShapeUniforms),c=function gme(t){return`\n    void setOutput(float val) {\n      ${t.output} = vec4(val, 0, 0, 0);\n    }\n  `}(a)),e.packedInputs&&(d+=Cme),[d,l,c,s,u,o,e.userCode].join("\n")}function Ac(t,n=!1){const e=t.shapeInfo.logicalShape;switch(e.length){case 0:return function Mme(t,n){const e=t.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1);if(t.shapeInfo.isUniform)return`float ${r}() {return ${e};}`;const[s,o]=t.shapeInfo.texShape;if(1===s&&1===o)return`\n      float ${r}() {\n        return sampleTexture(${e}, halfCR);\n      }\n    `;const i=Hl(e);if(n)return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], ${i});\n      return sampleTexture(${e}, uv);\n    }\n  `;const[a,l]=t.shapeInfo.texShape;return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${a}, ${l}, ${i});\n      return sampleTexture(${e}, uv);\n    }\n  `}(t,n);case 1:return function Ome(t,n){const e=t.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1);if(t.shapeInfo.isUniform)return`\n      float ${r}(int index) {\n        ${Rc(t)}\n      }\n    `;const s=t.shapeInfo.texShape,o=s[0],i=s[1];if(1===i&&1===o)return`\n      float ${r}(int index) {\n        return sampleTexture(${e}, halfCR);\n      }\n    `;const a=Hl(e);return 1===i?n?`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / float(${e}TexShape[0]));\n        return sampleTexture(${e}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${o}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `:1===o?n?`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${a}) + 0.5) / float(${e}TexShape[1]), 0.5);\n        return sampleTexture(${e}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${i}.0, 0.5);\n        return sampleTexture(${e}, uv);\n      }\n    `:n?`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], index + ${a});\n      return sampleTexture(${e}, uv);\n    }\n  `:`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${o}, ${i}, index + ${a});\n      return sampleTexture(${e}, uv);\n    }\n  `}(t,n);case 2:return function Lme(t,n){const e=t.shapeInfo.logicalShape,r=t.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=t.shapeInfo.texShape;if(null!=o&&Bt(e,o))return n?`\n      float ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${o[1]}.0, ${o[0]}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;const{newShape:i,keptDims:a}=fa(e);if(i.length<e.length){const p=["row","col"];return`\n      ${Ac(Fc(t,i),n)}\n      float ${s}(int row, int col) {\n        return ${s}(${Mc(p,a)});\n      }\n    `}if(t.shapeInfo.isUniform)return`\n      float ${s}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${e[1]}, 1)));\n        ${Rc(t)}\n      }\n    `;const u=o[0],c=o[1],d=Hl(r);return 1===c?n?`\n      float ${s}(int row, int col) {\n        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col) {\n      float index = dot(vec3(row, col, ${d}), vec3(${e[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `:1===u?n?`\n      float ${s}(int row, int col) {\n        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col) {\n      float index = dot(vec3(row, col, ${d}), vec3(${e[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);\n      return sampleTexture(${r}, uv);\n    }\n  `:n?`\n      float ${s}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${r}Shape[1] + col + ${d};\n        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n  float ${s}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${e[1]} + col + ${d};\n    vec2 uv = uvFromFlat(${u}, ${c}, index);\n    return sampleTexture(${r}, uv);\n  }\n`}(t,n);case 3:return function Bme(t,n){const e=t.shapeInfo.logicalShape,r=t.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=e[1]*e[2],i=e[2],{newShape:a,keptDims:l}=fa(e);if(a.length<e.length){const m=["row","col","depth"];return`\n        ${Ac(Fc(t,a),n)}\n        float ${s}(int row, int col, int depth) {\n          return ${s}(${Mc(m,l)});\n        }\n      `}if(t.shapeInfo.isUniform)return`\n      float ${s}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${o}, ${i}, 1)));\n        ${Rc(t)}\n      }\n    `;const c=t.shapeInfo.texShape,d=c[0],h=c[1],p=t.shapeInfo.flatOffset;if(h===o&&null==p)return n?`\n      float ${s}(int row, int col, int depth) {\n        int stride1 = ${r}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n        float ${s}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${i}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${h}.0, ${d}.0);\n          return sampleTexture(${r}, uv);\n        }\n      `;if(h===i&&null==p)return n?`\n      float ${s}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${e[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${h}.0, ${d}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;const f=Hl(r);return n?`\n    float ${s}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${r}Shape[1] * ${r}Shape[2];\n      int stride1 = ${r}Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ${f};\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n      return sampleTexture(${r}, uv);\n    }\n    `:`\n      float ${s}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${o} + col * ${i} + depth + ${f};\n        vec2 uv = uvFromFlat(${d}, ${h}, index);\n        return sampleTexture(${r}, uv);\n      }\n  `}(t,n);case 4:return function Ume(t,n){const e=t.shapeInfo.logicalShape,r=t.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=e[3],i=e[2]*o,a=e[1]*i,{newShape:l,keptDims:u}=fa(e);if(l.length<e.length){const v=["row","col","depth","depth2"];return`\n      ${Ac(Fc(t,l),n)}\n      float ${s}(int row, int col, int depth, int depth2) {\n        return ${s}(${Mc(v,u)});\n      }\n    `}if(t.shapeInfo.isUniform)return`\n      float ${s}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${a}, ${i}, ${o}, 1)));\n        ${Rc(t)}\n      }\n    `;const c=t.shapeInfo.flatOffset,d=t.shapeInfo.texShape,h=d[0],p=d[1],f=`int stride2 = ${r}Shape[3];`,g=`int stride1 = ${r}Shape[2] * stride2;`,m=`int stride0 = ${r}Shape[1] * stride1;`;if(p===a&&null==c)return n?`\n      float ${s}(int row, int col, int depth, int depth2) {\n        ${f}\n        ${g}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${i}, ${o}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${h}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;if(p===o&&null==c)return n?`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${e[1]*e[2]}, ${e[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${h}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;const y=Hl(r);return n?`\n    float ${s}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${f}\n      ${g}\n      ${m}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${y});\n      return sampleTexture(${r}, uv);\n    }\n  `:`\n    float ${s}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${a} + col * ${i} +\n          depth * ${o} + depth2;\n      vec2 uv = uvFromFlat(${h}, ${p}, index + ${y});\n      return sampleTexture(${r}, uv);\n    }\n  `}(t,n);case 5:return function Wme(t){const n=t.shapeInfo.logicalShape,e=t.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),s=n[4],o=n[3]*s,i=n[2]*o,a=n[1]*i,{newShape:l,keptDims:u}=fa(n);if(l.length<n.length){const m=["row","col","depth","depth2","depth3"];return`\n      ${Ac(Fc(t,l))}\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        return ${r}(${Mc(m,u)});\n      }\n    `}if(t.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${a}, ${i}, ${o}, ${s})) +\n          depth3;\n        ${Rc(t)}\n      }\n    `;const c=t.shapeInfo.flatOffset,d=t.shapeInfo.texShape,h=d[0],p=d[1];if(p===a&&null==c)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${i}, ${o}, ${s}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${h}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;if(p===s&&null==c)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${n[1]*n[2]*n[3]},\n               ${n[2]*n[3]}, ${n[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${h}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;return`\n    float ${r}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${a} + col * ${i} + depth * ${o} +\n          depth2 * ${s} + depth3 + ${Hl(e)};\n      vec2 uv = uvFromFlat(${h}, ${p}, index);\n      return sampleTexture(${e}, uv);\n    }\n  `}(t);case 6:return function Gme(t){const n=t.shapeInfo.logicalShape,e=t.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),{newShape:s,keptDims:o}=fa(n);if(s.length<n.length){const y=["row","col","depth","depth2","depth3","depth4"];return`\n      ${Ac(Fc(t,s))}\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${r}(${Mc(y,o)});\n      }\n    `}const i=n[5],a=n[4]*i,l=n[3]*a,u=n[2]*l,c=n[1]*u;if(t.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${c}, ${u}, ${l}, ${a})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${i}, 1)));\n        ${Rc(t)}\n      }\n    `;const d=t.shapeInfo.flatOffset,h=t.shapeInfo.texShape,p=h[0],f=h[1];if(f===c&&null==d)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${u}, ${l}, ${a}, ${i})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${p}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;if(f===i&&null==d)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${n[1]*n[2]*n[3]*n[4]},\n               ${n[2]*n[3]*n[4]},\n               ${n[3]*n[4]},\n               ${n[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${p}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;return`\n    float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${c} + col * ${u} + depth * ${l} +\n          depth2 * ${a} + depth3 * ${i} + depth4 + ${Hl(e)};\n      vec2 uv = uvFromFlat(${p}, ${f}, index);\n      return sampleTexture(${e}, uv);\n    }\n  `}(t);default:throw new Error(`${e.length}-D input sampling is not yet supported`)}}function l3(t,n){switch(t.shapeInfo.logicalShape.length){case 0:return function Fme(t){const n=t.name;return`\n    vec4 ${"get"+n.charAt(0).toUpperCase()+n.slice(1)}() {\n      return ${Kr().texture2D}(${n}, halfCR);\n    }\n  `}(t);case 1:return function Pme(t,n){const e=t.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),s=t.shapeInfo.texShape,o=Kr();if(n)return`\n    vec4 ${r}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${o.texture2D}(${e}, uv);\n    }\n  `;const i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];return`\n    vec4 ${r}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${i[0]}, ${i[1]}, index);\n      return ${o.texture2D}(${e}, uv);\n    }\n  `}(t,n);case 2:return function $me(t,n){const e=t.shapeInfo.logicalShape,r=t.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=t.shapeInfo.texShape,i=o[0],a=o[1],l=Kr();if(null!=o&&Bt(e,o))return n?`\n      vec4 ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `:`\n      vec4 ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${i}.0);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `;if(n)return`\n    vec4 ${s}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `;const u=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];return`\n    vec4 ${s}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${Math.ceil(e[1]/2)}, ${u[0]}, ${u[1]}, row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `}(t,n);case 3:return function Vme(t,n){const e=t.shapeInfo.logicalShape,r=t.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=t.shapeInfo.texShape,i=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];if(1===e[0]){const p=[1,2],g=["b","row","col"];return`\n        ${l3(Fc(t,e.slice(1)),n)}\n        vec4 ${s}(int b, int row, int col) {\n          return ${s}(${Mc(g,p)});\n        }\n      `}const a=Kr();if(n)return`\n    vec4 ${s}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${a.texture2D}(${r}, uv);\n    }\n  `;const l=i[0],u=i[1],c=Math.ceil(e[2]/2);return`\n    vec4 ${s}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${l}, ${u}, ${c*Math.ceil(e[1]/2)}, ${c}, b, row, col);\n      return ${a.texture2D}(${r}, uv);\n    }\n  `}(t,n);default:return function zme(t,n){const e=t.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),s=Kr();if(n)return`\n    vec4 ${r}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${e}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${e}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${e}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${s.texture2D}(${e}, uv);\n    }\n  `;const o=t.shapeInfo.logicalShape,i=o.length,a=t.shapeInfo.texShape,l=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],u=l[0],c=l[1],d=Math.ceil(o[i-1]/2);let h=d*Math.ceil(o[i-2]/2),p="int b, int row, int col",f=`b * ${h} + (row / 2) * ${d} + (col / 2)`;for(let g=2;g<i-1;g++)p=`int b${g}, `+p,h*=o[i-g-1],f=`b${g} * ${h} + `+f;return`\n    vec4 ${r}(${p}) {\n      int index = ${f};\n      int texR = index / ${c};\n      int texC = index - texR * ${c};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${u});\n      return ${s.texture2D}(${e}, uv);\n    }\n  `}(t,n)}}const vme="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",xme="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",wme="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Cme="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function Hl(t){return`offset${t}`}function Rc(t){const n=t.name,e=G(t.shapeInfo.logicalShape);return e<2?`return ${n};`:`\n    for (int i = 0; i < ${e}; i++) {\n      if (i == index) {\n        return ${n}[i];\n      }\n    }\n  `}function Qt(t){if(t<=1)return"int";if(2===t)return"ivec2";if(3===t)return"ivec3";if(4===t)return"ivec4";if(5===t)return"ivec5";if(6===t)return"ivec6";throw Error(`GPU for rank ${t} is not yet supported`)}function r1(t,n,e){const{newShape:r,keptDims:s}=fa(n),o=n.length,i=t&&3===o&&1===n[0],a=i?n.slice(1):r,l=!t&&o>1&&!Bt(n,e)&&r.length<o||i;return{useSqueezeShape:l,uniformShape:l?a:n,keptDims:s}}function Fc(t,n){const e=JSON.parse(JSON.stringify(t));return e.shapeInfo.logicalShape=n,e}function Mc(t,n){return n.map(e=>t[e]).join(", ")}function c3(t,n,e){const r=[],s=[];let o,i,a,l=null,u=null;u=t.getUniformLocation(e,"NAN",!1),1===L().getNumber("WEBGL_VERSION")&&(l=t.getUniformLocation(e,"INFINITY",!1));const c=!1;for(const d of n.variableNames){const h={name:d,uniform:t.getUniformLocation(e,d,c),offset:t.getUniformLocation(e,`offset${d}`,c)};n.enableShapeUniforms&&(h.shape=t.getUniformLocation(e,`${d}Shape`,c),h.texShape=t.getUniformLocation(e,`${d}TexShape`,c)),r.push(h)}if(n.enableShapeUniforms&&(o=t.getUniformLocation(e,"outShape",c),a=t.getUniformLocation(e,"outShapeStrides",c),i=t.getUniformLocation(e,"outTexShape",c)),n.customUniforms)for(const d of n.customUniforms)s.push(t.getUniformLocation(e,d.name,c));return{variablesLocations:r,customUniformLocations:s,infLoc:l,nanLoc:u,outShapeLocation:o,outShapeStridesLocation:a,outTexShapeLocation:i}}function d3(t,n){if(t.length!==n.length)throw Error(`Binary was compiled with ${t.length} inputs, but was executed with ${n.length} inputs`);t.forEach((e,r)=>{const s=e.logicalShape,o=n[r],i=o.shape;if(!Bt(s,i))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${s} and ${i} must match`);if(e.isUniform&&o.isUniform)return;const a=e.texShape,l=o.isUniform?null:o.texData.texShape;if(!Bt(a,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${l} must match`)})}function Rr(t){return L().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&t<=4}class Yme{constructor(n){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=Tc.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const e=Kr();this.outputShape=n,this.enableShapeUniforms=Rr(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?Ob(["r","c","d"],n):Gl(["r","c","d"],n)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${e.output} = result;\n      }\n    `}}class Zme{constructor(n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=Tc.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const e=Kr();this.outputShape=n,this.enableShapeUniforms=Rr(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?Ob(["r","c","d"],n):Gl(["r","c","d"],n)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${e.output} = result;\n      }\n    `}}class Qme{constructor(n){this.variableNames=["A"],this.outTexUsage=ws.DOWNLOAD;const e=Kr();this.outputShape=n,this.userCode=`\n      ${i3}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${e.output} = encode_float(x);\n      }\n    `}}class Jme{constructor(n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=ws.DOWNLOAD;const e=Kr();this.outputShape=n,this.userCode=`\n      ${i3}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${e.output} = encode_float(x);\n      }\n    `}}const ege={R:0,G:1,B:2,A:3};class h3{constructor(n,e=!1,r="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const s=Kr();this.outputShape=n,this.enableShapeUniforms=Rr(this.outputShape.length);let o="result";e&&(o="floor(result * 255. + 0.5)");let i="";for(let a=0;a<r.length;a++)i+=`\n          if(offset == ${a}) {\n            result = values[${ege[r[a]]}];\n          }`;this.userCode=`\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":t1(n)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int flatIndex = getFlatIndex(coords);\n        float result = 0.;\n        int offset = imod(flatIndex, ${r.length});\n\n        flatIndex = idiv(flatIndex, ${r.length}, 1.);\n\n        int r = flatIndex / texShape[1];\n        if (r < texShape[0]) {\n          int c = imod(flatIndex, texShape[1]);\n          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n          vec4 values = ${s.texture2D}(A, uv);\n          ${i}\n        }\n        ${s.output} = vec4(${o}, 0., 0., 0.);\n      }\n    `}}class tge{constructor(n,e=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=Kr();this.outputShape=n,this.enableShapeUniforms=Rr(this.outputShape.length);let s="",o="result";e&&(o="floor(result * 255. + 0.5)");for(let i=0;i<=1;i++)for(let a=0;a<=1;a++){const l=2*i+a;s+=`\n          localCoords = coords;\n          if(localCoords[2] + ${a} < ${this.enableShapeUniforms?"outShape[2]":`${n[2]}`}) {\n          localCoords[2] += ${a};\n          if (localCoords[1] + ${i} < ${this.enableShapeUniforms?"outShape[1]":`${n[1]}`}) {\n            localCoords[1] += ${i};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${r.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${l}] = values[0];\n            } else if (offset == 1) {\n              result[${l}] = values[1];\n            } else if (offset == 2) {\n              result[${l}] = values[2];\n            } else {\n              result[${l}] = values[3];\n            }\n          }\n        }\n        `}this.userCode=`\n        ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":t1(n)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${s}\n\n          ${r.output} = ${o};\n        }\n    `}}function Gp(t,n,e,r,s,o){!function Kfe(t,n){const e=L().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(t<=0||n<=0)throw new Error(`Requested texture size [${t}x${n}] is invalid.`);if(t>e||n>e)throw new Error(`Requested texture size [${t}x${n}] greater than WebGL maximum on this browser / GPU [${e}x${e}].`)}(n,e);const i=function qfe(t){return Ki(t,()=>t.createTexture(),"Unable to create WebGLTexture.")}(t),a=t.TEXTURE_2D;return ge(t,()=>t.bindTexture(a,i)),ge(t,()=>t.texParameteri(a,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE)),ge(t,()=>t.texParameteri(a,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE)),ge(t,()=>t.texParameteri(a,t.TEXTURE_MIN_FILTER,t.NEAREST)),ge(t,()=>t.texParameteri(a,t.TEXTURE_MAG_FILTER,t.NEAREST)),1===L().getNumber("WEBGL_VERSION")?ge(t,()=>t.texImage2D(a,0,r,n,e,0,s,o,null)):ge(t,()=>t.texStorage2D(a,1,r,n,e)),ge(t,()=>t.bindTexture(t.TEXTURE_2D,null)),{texture:i,texShape:[e,n]}}function p3(t){return t.internalFormatFloat}function f3(t){return t.internalFormatHalfFloat}function m3(t){return t.downloadTextureFormat}function g3(t){return t.internalFormatPackedFloat}function y3(t){return t.internalFormatPackedHalfFloat}class s1{constructor(n){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const e=L().getNumber("WEBGL_VERSION");if(null!=n?(this.gl=n,function kfe(t,n){$a[t]=n}(e,n)):this.gl=$o(e),n=this.gl,2===L().getNumber("WEBGL_VERSION")){const o=n;this.createVertexArray=()=>ge(o,()=>o.createVertexArray()),this.bindVertexArray=i=>ge(o,()=>o.bindVertexArray(i)),this.deleteVertexArray=i=>ge(o,()=>o.deleteVertexArray(i)),this.getVertexArray=()=>ge(o,()=>o.getParameter(o.VERTEX_ARRAY_BINDING))}else if(null!=n){const o=n.getExtension("OES_vertex_array_object");if(null==o)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>ge(n,()=>o.createVertexArrayOES()),this.bindVertexArray=i=>ge(n,()=>o.bindVertexArrayOES(i)),this.deleteVertexArray=i=>ge(n,()=>o.deleteVertexArrayOES(i)),this.getVertexArray=()=>ge(n,()=>n.getParameter(o.VERTEX_ARRAY_BINDING_OES))}let r="WEBGL_color_buffer_float";const s="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===L().getNumber("WEBGL_VERSION")){const i="OES_texture_half_float";if(this.textureFloatExtension=Nb(this.gl,"OES_texture_float"),mo(this.gl,i))this.textureHalfFloatExtension=Nb(this.gl,i);else if(L().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(r),mo(this.gl,s))this.colorBufferHalfFloatExtension=Nb(this.gl,s);else if(L().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(r="EXT_color_buffer_float",mo(this.gl,r))this.colorBufferFloatExtension=this.gl.getExtension(r);else{if(!mo(this.gl,s))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(s)}this.vertexBuffer=function rge(t){return function Hfe(t,n){const e=Ki(t,()=>t.createBuffer(),"Unable to create WebGLBuffer");return ge(t,()=>t.bindBuffer(t.ARRAY_BUFFER,e)),ge(t,()=>t.bufferData(t.ARRAY_BUFFER,n,t.STATIC_DRAW)),e}(t,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}(this.gl),this.indexBuffer=function sge(t){return function jfe(t,n){const e=Ki(t,()=>t.createBuffer(),"Unable to create WebGLBuffer");return ge(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,e)),ge(t,()=>t.bufferData(t.ELEMENT_ARRAY_BUFFER,n,t.STATIC_DRAW)),e}(t,new Uint16Array([0,1,2,2,1,3]))}(this.gl),this.framebuffer=function Xfe(t){return Ki(t,()=>t.createFramebuffer(),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=ZI(this.gl,this.textureHalfFloatExtension)}get debug(){return L().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const n=this.gl;ge(n,()=>n.finish()),ge(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,null)),ge(n,()=>n.deleteFramebuffer(this.framebuffer)),ge(n,()=>n.bindBuffer(n.ARRAY_BUFFER,null)),ge(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,null)),ge(n,()=>n.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(n,e){return this.throwIfDisposed(),function oge(t,n,e,r){const[s,o]=Up(n,e);return Gp(t,s,o,p3(r),r.textureFormatFloat,t.FLOAT)}(this.gl,n,e,this.textureConfig)}createFloat16MatrixTexture(n,e){return this.throwIfDisposed(),function ige(t,n,e,r){const[s,o]=Up(n,e);return Gp(t,s,o,f3(r),r.textureFormatFloat,r.textureTypeHalfFloat)}(this.gl,n,e,this.textureConfig)}createUnsignedBytesMatrixTexture(n,e){return this.throwIfDisposed(),function age(t,n,e,r){const[s,o]=Up(n,e);return Gp(t,s,o,m3(r),t.RGBA,t.UNSIGNED_BYTE)}(this.gl,n,e,this.textureConfig)}uploadPixelDataToTexture(n,e){this.throwIfDisposed(),function hge(t,n,e){ge(t,()=>t.bindTexture(t.TEXTURE_2D,n)),e.data instanceof Uint8Array?2===L().getNumber("WEBGL_VERSION")?ge(t,()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,e.width,e.height,t.RGBA,t.UNSIGNED_BYTE,e.data)):ge(t,()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,e.width,e.height,0,t.RGBA,t.UNSIGNED_BYTE,e.data)):2===L().getNumber("WEBGL_VERSION")?ge(t,()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,t.RGBA,t.UNSIGNED_BYTE,e)):ge(t,()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,e)),ge(t,()=>t.bindTexture(t.TEXTURE_2D,null))}(this.gl,n,e)}uploadDenseMatrixToTexture(n,e,r,s){this.throwIfDisposed(),function dge(t,n,e,r,s,o){let i,a,l;ge(t,()=>t.bindTexture(t.TEXTURE_2D,n)),s instanceof Uint8Array?(i=new Uint8Array(e*r*4),a=t.UNSIGNED_BYTE,l=t.RGBA):(i=new Float32Array(e*r*4),a=t.FLOAT,l=o.internalFormatPackedFloat),i.set(s),2===L().getNumber("WEBGL_VERSION")?ge(t,()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,e,r,t.RGBA,a,i)):ge(t,()=>t.texImage2D(t.TEXTURE_2D,0,l,e,r,0,t.RGBA,a,i)),ge(t,()=>t.bindTexture(t.TEXTURE_2D,null))}(this.gl,n,e,r,s,this.textureConfig)}createFloat16PackedMatrixTexture(n,e){return this.throwIfDisposed(),function uge(t,n,e,r){const[s,o]=Ec(n,e);return Gp(t,s,o,y3(r),t.RGBA,r.textureTypeHalfFloat)}(this.gl,n,e,this.textureConfig)}createPackedMatrixTexture(n,e){return this.throwIfDisposed(),function lge(t,n,e,r){const[s,o]=Ec(n,e);return Gp(t,s,o,g3(r),t.RGBA,t.FLOAT)}(this.gl,n,e,this.textureConfig)}deleteMatrixTexture(n){this.throwIfDisposed(),this.outputTexture===n&&(r3(this.gl,this.framebuffer),this.outputTexture=null),ge(this.gl,()=>this.gl.deleteTexture(n))}downloadByteEncodedFloatMatrixFromOutputTexture(n,e,r){return this.downloadMatrixDriver(n,()=>function mge(t,n,e,r){const[s,o]=Up(n,e),a=new Uint8Array(function Ffe(t,n){return t*n}(n*e,4));return ge(t,()=>t.readPixels(0,0,s,o,r.downloadTextureFormat,t.UNSIGNED_BYTE,a)),new Float32Array(a.buffer)}(this.gl,e,r,this.textureConfig))}downloadPackedMatrixFromBuffer(n,e,r,s,o,i){return function gge(t,n,e,r,s,o,i,a){const l=t,u=new Float32Array(function Mfe(t,n){const[e,r]=Ec(t,n);return e*r*4}(o,i));return l.bindBuffer(l.PIXEL_PACK_BUFFER,n),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,u),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),u}(this.gl,n,0,0,0,o,i)}downloadFloat32MatrixFromBuffer(n,e){return function fge(t,n,e){const r=t,s=new Float32Array(e);return r.bindBuffer(r.PIXEL_PACK_BUFFER,n),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,s),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),s}(this.gl,n,e)}createBufferFromTexture(n,e,r){this.bindTextureToFrameBuffer(n);const s=function pge(t,n,e,r){const s=t.createBuffer();ge(t,()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,s));const a=16*n*e;return ge(t,()=>t.bufferData(t.PIXEL_PACK_BUFFER,a,t.STREAM_READ)),ge(t,()=>t.readPixels(0,0,e,n,t.RGBA,t.FLOAT,0)),ge(t,()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,null)),s}(this.gl,e,r);return this.unbindTextureToFrameBuffer(),s}createAndWaitForFence(){const n=this.createFence(this.gl);return this.pollFence(n)}createFence(n){let e,r;if(L().getBool("WEBGL_FENCE_API_ENABLED")){const s=n,o=s.fenceSync(s.SYNC_GPU_COMMANDS_COMPLETE,0);n.flush(),r=()=>{const i=s.clientWaitSync(o,0,0);return i===s.ALREADY_SIGNALED||i===s.CONDITION_SATISFIED},e=o}else L().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(e=this.beginQuery(),this.endQuery(),r=()=>this.isQueryAvailable(e,L().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):r=()=>!0;return{query:e,isFencePassed:r}}downloadMatrixFromPackedTexture(n,e,r){return this.downloadMatrixDriver(n,()=>function yge(t,n,e){const r=new Float32Array(n*e*4);return ge(t,()=>t.readPixels(0,0,e,n,t.RGBA,t.FLOAT,r)),r}(this.gl,e,r))}createProgram(n){this.throwIfDisposed();const e=this.gl;null==this.vertexShader&&(this.vertexShader=function nge(t){const n=Kr();return function Bfe(t,n){const e=Ki(t,()=>t.createShader(t.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(ge(t,()=>t.shaderSource(e,n)),ge(t,()=>t.compileShader(e)),!1===t.getShaderParameter(e,t.COMPILE_STATUS))throw console.log(t.getShaderInfoLog(e)),new Error("Failed to compile vertex shader.");return e}(t,`${n.version}\n    precision highp float;\n    ${n.attribute} vec3 clipSpacePos;\n    ${n.attribute} vec2 uv;\n    ${n.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}(e));const r=function Wfe(t){return Ki(t,()=>t.createProgram(),"Unable to create WebGLProgram.")}(e);let s;return ge(e,()=>e.attachShader(r,this.vertexShader)),ge(e,()=>e.attachShader(r,n)),function Gfe(t,n){if(ge(t,()=>t.linkProgram(n)),!L().get("ENGINE_COMPILE_ONLY")&&!1===t.getProgramParameter(n,t.LINK_STATUS))throw console.log(t.getProgramInfoLog(n)),new Error("Failed to link vertex and fragment shaders.")}(e,r),s=Object.assign(r,{vao:this.createVertexArray()}),this.bindVertexArray(s.vao),ge(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),console.assert(function cge(t,n,e){return ge(t,()=>t.bindBuffer(t.ARRAY_BUFFER,e)),n3(t,n,"clipSpacePos",e,3,20,0)&&n3(t,n,"uv",e,2,20,12)}(e,s,this.vertexBuffer),"gpgpu_util.bindVertexProgramAttributeStreams not fully successful."),this.debug&&QI(e,s),this.setProgram(s),s}deleteProgram(n){this.throwIfDisposed(),n===this.program&&(this.program=null),null!=n&&(ge(this.gl,()=>this.gl.deleteProgram(n)),this.deleteVertexArray(n.vao))}setProgram(n){this.throwIfDisposed(),this.program=n,null!=this.program&&(this.bindVertexArray(this.program.vao),this.debug&&QI(this.gl,this.program)),ge(this.gl,()=>this.gl.useProgram(n))}getUniformLocation(n,e,r=!0){return this.throwIfDisposed(),r?function Zfe(t,n,e){return Ki(t,()=>t.getUniformLocation(n,e),'uniform "'+e+'" not present in program.')}(this.gl,n,e):function Qfe(t,n,e){return t.getUniformLocation(n,e)}(this.gl,n,e)}getAttributeLocation(n,e){return this.throwIfDisposed(),ge(this.gl,()=>this.gl.getAttribLocation(n,e))}getUniformLocationNoThrow(n,e){return this.throwIfDisposed(),this.gl.getUniformLocation(n,e)}setInputMatrixTexture(n,e,r){this.throwIfDisposed(),this.throwIfNoProgram(),Jfe(this.gl,n,e,r)}setOutputMatrixTexture(n,e,r){this.setOutputMatrixTextureDriver(n,r,e)}setOutputPackedMatrixTexture(n,e,r){this.throwIfDisposed();const[s,o]=Ec(e,r);this.setOutputMatrixTextureDriver(n,s,o)}setOutputMatrixWriteRegion(n,e,r,s){this.setOutputMatrixWriteRegionDriver(r,n,s,e)}setOutputPackedMatrixWriteRegion(n,e,r,s){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&QI(this.gl,this.program),kb(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const n=this.gl;if(this.debug){const e=this.getVertexArray();console.assert(e===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}ge(n,()=>n.drawElements(n.TRIANGLES,6,n.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),ge(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=Nb(this.gl,2===L().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===L().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const r=this.gl,s=this.getQueryTimerExtensionWebGL2(),o=r.createQuery();return r.beginQuery(s.TIME_ELAPSED_EXT,o),o}const n=this.getQueryTimerExtensionWebGL1(),e=n.createQueryEXT();return n.beginQueryEXT(n.TIME_ELAPSED_EXT,e),e}endQuery(){if(2===L().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,r=this.getQueryTimerExtensionWebGL2();return void e.endQuery(r.TIME_ELAPSED_EXT)}const n=this.getQueryTimerExtensionWebGL1();n.endQueryEXT(n.TIME_ELAPSED_EXT)}waitForQueryAndGetTime(n){var e=this;return J(function*(){return yield jF(()=>e.disposed||e.isQueryAvailable(n,L().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),e.getQueryTime(n,L().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))})()}getQueryTime(n,e){if(0===e)return null;if(2===e){const r=this.gl;return r.getQueryParameter(n,r.QUERY_RESULT)/1e6}{const r=this.getQueryTimerExtensionWebGL1();return r.getQueryObjectEXT(n,r.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(n,e){if(0===e)return!0;if(2===e){const r=this.gl,s=this.getQueryTimerExtensionWebGL2(),o=r.getQueryParameter(n,r.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),o&&!this.disjoint}{const r=this.getQueryTimerExtensionWebGL1(),s=r.getQueryObjectEXT(n,r.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),s&&!this.disjoint}}pollFence(n){return new Promise(e=>{this.addItemToPoll(()=>n.isFencePassed(),()=>e())})}pollItems(){const n=function bge(t){let n=0;for(;n<t.length&&t[n]();++n);return n-1}(this.itemsToPoll.map(e=>e.isDoneFn));for(let e=0;e<=n;++e){const{resolveFn:r}=this.itemsToPoll[e];r()}this.itemsToPoll=this.itemsToPoll.slice(n+1)}addItemToPoll(n,e){if(this.itemsToPoll.push({isDoneFn:n,resolveFn:e}),this.itemsToPoll.length>1)return;let r;"setTimeoutCustom"in L().platform&&(r=L().platform.setTimeoutCustom.bind(L().platform)),jF(()=>(this.pollItems(),0===this.itemsToPoll.length),()=>0,null,r)}bindTextureToFrameBuffer(n){this.throwIfDisposed(),JI(this.gl,n,this.framebuffer),this.debug&&kb(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(JI(this.gl,this.outputTexture,this.framebuffer),this.debug&&kb(this.gl)):r3(this.gl,this.framebuffer)}downloadMatrixDriver(n,e){this.bindTextureToFrameBuffer(n);const r=e();return this.unbindTextureToFrameBuffer(),r}setOutputMatrixTextureDriver(n,e,r){this.throwIfDisposed();const s=this.gl;JI(s,n,this.framebuffer),this.debug&&kb(s),this.outputTexture=n,ge(s,()=>s.viewport(0,0,e,r)),ge(s,()=>s.scissor(0,0,e,r))}setOutputMatrixWriteRegionDriver(n,e,r,s){this.throwIfDisposed(),ge(this.gl,()=>this.gl.scissor(n,e,r,s))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}const{addImpl:vge,bincountImpl:b3,bincountReduceImpl:xge,castImpl:wge,ceilImpl:Cge,concatImpl:_ge,equalImpl:Sge,expImpl:Ige,expm1Impl:Dge,floorImpl:Tge,gatherNdImpl:Ege,gatherV2Impl:Nge,greaterImpl:kge,greaterEqualImpl:Age,lessImpl:Rge,lessEqualImpl:Fge,linSpaceImpl:Mge,logImpl:Pge,maxImpl:Oge,maximumImpl:$ge,minimumImpl:Lge,multiplyImpl:Vge,negImpl:Bge,notEqualImpl:zge,prodImpl:Uge,raggedGatherImpl:Wge,raggedRangeImpl:Gge,raggedTensorToTensorImpl:Hge,rangeImpl:jge,rsqrtImpl:qge,scatterImpl:Kge,sigmoidImpl:Xge,simpleAbsImpl:v3,sliceImpl:Yge,sparseFillEmptyRowsImpl:Zge,sparseReshapeImpl:Qge,sparseSegmentReductionImpl:x3,sqrtImpl:Jge,staticRegexReplaceImpl:eye,stridedSliceImpl:tye,stringNGramsImpl:nye,stringSplitImpl:rye,stringToHashBucketFastImpl:sye,subImpl:oye,tileImpl:iye,topKImpl:aye,transposeImpl:o1,uniqueImpl:lye}=hn;function w3(t,n){return["x","y","z","w","u","v"].slice(0,n).map(e=>`${t}.${e}`)}function Xr(t,n){return 1===n?[t]:w3(t,n)}class cye{constructor(n){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=n,this.rank=n.length,this.enableShapeUniforms=Rr(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const e=Xr("rc",this.rank),r=Qt(this.rank),s=this.getOutOfBoundsCondition(e),o=this.getSetup(e),i=this.getOutput(e);this.userCode=`\n        void main() {\n          ${r} rc = getOutputCoords();\n\n          if(${s}) {\n            setOutput(vec4(0));\n          } else {\n            ${o}\n\n            setOutput(vec4(${i}));\n          }\n        }\n      `}}getSourceCoordsArr(n){const e=[];for(let r=0;r<=1;r++)for(let s=0;s<=1;s++){let o=`${0===r?"r":"rp1"}, ${0===s?"c":"cp1"}`;for(let i=2;i<this.rank;i++)o=`${n[n.length-1-i]},`+o;e.push(o)}return e}getOutOfBoundsCondition(n){if(1===this.rank)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let e="";for(let r=this.rank-2;r<this.rank;r++)e+=`${n[r]} >= ${this.enableShapeUniforms?`outShape[${r}]`:this.outputShape[r]}`,r<this.rank-1&&(e+="||");return e}getSetup(n){if(1===this.rank)return"";const e=n.slice(-2);return`\n      int r = ${e[0]};\n      int c = ${e[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1]};\n      bool rEdge = rp1 >= ${this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2]};\n    `}getOutput(n){const e=this.getSourceCoordsArr(n);return 1===this.rank?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${e[0]}),\n            cEdge ? 0. : getA(${e[1]}),\n            rEdge ? 0. : getA(${e[2]}),\n            rEdge || cEdge ? 0. : getA(${e[3]})`}}class C3{constructor(n,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=n,this.enableShapeUniforms=Rr(this.outputShape.length);let r="";for(let s=0;s<4;s++){let o="thisRC = rc;";s%2==1&&(o+="thisRC.z += 1;"),s>1&&(o+="thisRC.y += 1;"),r+=`\n        ${o}\n        ${s>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${s}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${s>0?"}":""}\n      `}this.userCode=`\n      ${function dye(t,n){return`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${n?function cme(t,n,e="index"){const s=function ume(t,n){const e=t.length,r=t.map(o=>`${n}[${o}]`),s=new Array(e-1);s[e-2]=r[e-1];for(let o=e-3;o>=0;--o)s[o]=`(${s[o+1]} * ${r[o+1]})`;return s}(t.map((o,i)=>i),n);return s.map((o,i)=>`int ${t[i]} = ${e} / ${s[i]}; ${i===s.length-1?`int ${t[i+1]} = ${e} - ${t[i]} * ${s[i]}`:`index -= ${t[i]} * ${s[i]}`};`).join("")}(["r","c","d"],"inputShape"):Gl(["r","c","d"],t)}\n      return ivec3(r, c, d);\n    }\n  `}(e,this.enableShapeUniforms)}\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":t1(n)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms?"outShape[1]":n[1]};\n        int cols = ${this.enableShapeUniforms?"outShape[2]":n[2]};\n\n        ${r}\n\n        setOutput(result);\n      }\n    `}}class hye{constructor(n){this.gpgpu=n,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(n,e,r){const s=S3(e,r),o=I3(n,s,r);o in this.freeTextures||(this.freeTextures[o]=[]),o in this.usedTextures||(this.usedTextures[o]=[]);const i=_3(n,s,this.gpgpu.gl,this.gpgpu.textureConfig,r);if(this.freeTextures[o].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=i,this.log();const l=this.freeTextures[o].pop();return this.usedTextures[o].push(l),l}let a;return s===mr.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(n[0],n[1]):s===mr.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(n[0],n[1]):s===mr.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(n[0],n[1]):s===mr.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(n[0],n[1]):s===mr.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(n[0],n[1])),this.usedTextures[o].push(a),this.numUsedTextures++,this._numBytesAllocated+=i,this.log(),a}releaseTexture(n,e,r,s){if(null==this.freeTextures)return;const o=S3(r,s),i=I3(e,o,s);i in this.freeTextures||(this.freeTextures[i]=[]);const a=_3(e,o,this.gpgpu.gl,this.gpgpu.textureConfig,s),l=L().get("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==l&&this._numBytesAllocated>l?(this.gpgpu.deleteMatrixTexture(n.texture),this._numBytesAllocated-=a):(this.freeTextures[i].push(n),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;const u=this.usedTextures[i],c=u&&u.indexOf(n);if(null==c||c<0)throw new Error("Cannot release a texture that was never provided by this texture manager");u[c]=u[u.length-1],u.pop(),this.log()}log(){if(!this.logEnabled)return;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${this.numFreeTextures+this.numUsedTextures})`);const e=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*e)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const n in this.freeTextures)this.freeTextures[n].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});for(const n in this.usedTextures)this.usedTextures[n].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function _3(t,n,e,r,s){const o=function fye(t,n){switch(t){case mr.PACKED_2X2_FLOAT32:return g3(n);case mr.PACKED_2X2_FLOAT16:return y3(n);case mr.UNPACKED_FLOAT32:return p3(n);case mr.UNPACKED_FLOAT16:return f3(n);case mr.PACKED_4X1_UNSIGNED_BYTE:return m3(n);default:throw new Error(`Unknown physical texture type ${t}`)}}(n,r);let i;if(s){const[l,u]=Ec(t[0],t[1]);i=l*u}else{const[l,u]=Up(t[0],t[1]);i=l*u}const a=function pye(t,n){if(n===t.R32F)return 4;if(n===t.R16F)return 2;if(n===t.RGBA32F)return 16;if(n===t.RGBA)return 16;if(n===t.RGBA16F)return 8;if(n===t.RGBA8)return 4;throw new Error(`Unknown internal format ${n}`)}(e,o);return i*a}function S3(t,n){if(t===ws.UPLOAD)return mr.PACKED_2X2_FLOAT32;if(t===ws.RENDER||null==t)return function mye(t){return L().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?t?mr.PACKED_2X2_FLOAT32:mr.UNPACKED_FLOAT32:t?mr.PACKED_2X2_FLOAT16:mr.UNPACKED_FLOAT16}(n);if(t===ws.DOWNLOAD||t===ws.PIXELS)return mr.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${t}`)}function I3(t,n,e){return`${t[0]}_${t[1]}_${n}_${e}`}class gi{constructor(n,e){this.variableNames=["A"],this.outputShape=n,this.enableShapeUniforms=Rr(this.outputShape.length),this.userCode=`\n      float unaryOperation(float x) {\n        ${e}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const Us="if (isnan(x)) return x;",gye="return x;",D3="return abs(x);",yye="return (x >= 0.0) ? x : (exp(x) - 1.0);",bye=Us+"\n  return (x < 0.0) ? 0.0 : x;\n",vye=Us+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",La="return x;",xye="return 1.0 / (1.0 + exp(-1.0 * x));",wye="return x;",Cye="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",_ye="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",Sye="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",Iye="return 1.0 / (1.0 + exp(-1.0 * x));";class Va{constructor(n,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=Rr(this.outputShape.length),this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${e}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}class Dye{constructor(n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=n,this.enableShapeUniforms=Rr(this.outputShape.length);const e=n.length,r=Xr("rc",e),s=Qt(e),o=function uye(t,n){if(1===t)return"rc";let e="";for(let r=0;r<t;r++)e+=n[r],r<t-1&&(e+=",");return e}(e,r),i=r.slice(-2),a=e<=1?"rc":`vec2(${i.join(",")})`;this.userCode=`\n      void main() {\n        ${s} rc = getOutputCoords();\n        vec4 packedInput = getA(${o});\n\n        setOutput(getChannel(packedInput, ${a}));\n      }\n    `}}const Tye=wO,Lb={},Aye=L().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");let Mye=(()=>{class t extends e0{nextDataId(){return t.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!L().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let r;if(null!=e){if(e instanceof s1)r=e;else{const s=$o(L().getNumber("WEBGL_VERSION"),e);r=new s1(s)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const s=$o(L().getNumber("WEBGL_VERSION"));r=new s1(s),this.binaryCache=function kye(t){return t in Lb||(Lb[t]={}),Lb[t]}(L().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=r,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new hye(this.gpgpu),this.numMBBeforeWarning=function Fye(){return null==L().global.screen?1024:L().global.screen.height*L().global.screen.width*window.devicePixelRatio*600/1024/1024}(),this.texData=new GF(this,ri())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,r,s,o,i,a){const l=this.makeTensorInfo(r,s),u=this.texData.get(l.dataId);u.isPacked=!1,u.texture={texture:e,texShape:[o,i]},u.texShape=[o,i];const c=Ab(r),d=new h3(c,!1,a),h=this.runWebGLProgram(d,[l],s,[[o,i]]);return h.shape=r,u.texture=null,this.disposeIntermediateTensorInfo(l),h.dataId}write(e,r,s){if((L().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||L().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===s&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const o={id:this.nextDataId()};return this.texData.set(o,{shape:r,dtype:s,values:e,usage:ws.UPLOAD,refCount:1}),o}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){this.texData.get(e).refCount++}decRef(e){this.texData.has(e)&&this.texData.get(e).refCount--}move(e,r,s,o,i){if(L().getBool("DEBUG")&&this.checkNumericalProblems(r),"complex64"===o)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:s,dtype:o,values:r,usage:ws.UPLOAD,refCount:i})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const r=this.texData.get(e),{values:s,dtype:o,complexTensorInfos:i,slice:a,shape:l,isPacked:u}=r;if(null!=a){let p;p=u?new Va(l,La):new gi(l,La);const f=this.runWebGLProgram(p,[{dataId:e,shape:l,dtype:o}],o),g=this.readSync(f.dataId);return this.disposeIntermediateTensorInfo(f),g}if(null!=s)return this.convertAndCacheOnCPU(e);if("string"===o)return s;const c=null!=this.activeTimers;let d,h;return c&&(d=is()),h="complex64"===o?Hi(this.readSync(i.real.dataId),this.readSync(i.imag.dataId)):this.getValuesFromTexture(e),c&&(this.downloadWaitMs+=is()-d),this.convertAndCacheOnCPU(e,h)}read(e){var r=this;return J(function*(){if(r.pendingRead.has(e)){const m=r.pendingRead.get(e);return new Promise(y=>m.push(y))}const s=r.texData.get(e),{values:o,shape:i,slice:a,dtype:l,complexTensorInfos:u,isPacked:c}=s;if(null!=a){let m;m=c?new Va(i,La):new gi(i,La);const y=r.runWebGLProgram(m,[{dataId:e,shape:i,dtype:l}],l),b=r.read(y.dataId);return r.disposeIntermediateTensorInfo(y),b}if(null!=o)return r.convertAndCacheOnCPU(e);if(L().getBool("DEBUG")&&!L().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===L().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let h,p,d=null;if("complex64"!==l&&L().get("WEBGL_BUFFER_SUPPORTED")){h=r.decode(e);const m=r.texData.get(h.dataId);d=r.gpgpu.createBufferFromTexture(m.texture.texture,...Eb(i))}if(r.pendingRead.set(e,[]),"complex64"!==l&&(yield r.gpgpu.createAndWaitForFence()),"complex64"===l){const m=yield Promise.all([r.read(u.real.dataId),r.read(u.imag.dataId)]);p=Hi(m[0],m[1])}else if(null==d)p=r.getValuesFromTexture(e);else{const m=G(i);p=r.gpgpu.downloadFloat32MatrixFromBuffer(d,m)}if(null!=h&&r.disposeIntermediateTensorInfo(h),null!=d){const m=r.gpgpu.gl;ge(m,()=>m.deleteBuffer(d))}const f=r.convertAndCacheOnCPU(e,p),g=r.pendingRead.get(e);return r.pendingRead.delete(e),g.forEach(m=>m(f)),r.pendingDisposal.has(e)&&(r.pendingDisposal.delete(e),r.disposeData(e)&&ri().removeDataId(e,r),r.pendingDeletes--),f})()}readToGPU(e,r={}){const s=this.texData.get(e),{values:o,shape:i,slice:a,dtype:l,isPacked:u,texture:c}=s;if("complex64"===l)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=a){let f;f=u?new Va(i,La):new gi(i,La);const g=this.runWebGLProgram(f,[{dataId:e,shape:i,dtype:l}],l),m=this.readToGPU(g,r);return this.disposeIntermediateTensorInfo(g),m}if(null==c)throw null!=o?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const d=this.decode(e,r.customTexShape),h=ri().makeTensorFromTensorInfo(d),p=this.texData.get(d.dataId);return Object.assign({tensorRef:h},p.texture)}bufferSync(e){const r=this.readSync(e.dataId);if("string"===e.dtype)try{const s=r.map(o=>ba(o));return vt(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return vt(e.shape,e.dtype,r)}checkNumericalProblems(e){if(null!=e)for(let r=0;r<e.length;r++){const s=e[r];if(!Lfe(s))throw L().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${s} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${s} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:r,dtype:s,isPacked:o}=this.texData.get(e),i=G(r);if(L().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const p=this.decode(e),f=this.texData.get(p.dataId),g=this.gpgpu.downloadMatrixFromPackedTexture(f.texture.texture,...Eb(r)).subarray(0,i);return this.disposeIntermediateTensorInfo(p),g}const a=L().getBool("WEBGL_PACK")&&!0===o,l=a?Ab(r):r,u=a?new Jme(l):new Qme(l),c=this.runWebGLProgram(u,[{shape:l,dtype:s,dataId:e}],"float32"),d=this.texData.get(c.dataId),h=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(d.texture.texture,d.texShape[0],d.texShape[1]).subarray(0,i);return this.disposeIntermediateTensorInfo(c),h}timerAvailable(){return L().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){var r=this;const s=this.activeTimers,o=[];let i=!1;null==this.programTimersStack?(this.programTimersStack=o,i=!0):this.activeTimers.push(o),this.activeTimers=o,e();const a=Cl(this.activeTimers.map(c=>c.query)).filter(c=>null!=c),l=Cl(this.activeTimers.map(c=>c.name)).filter(c=>null!=c);this.activeTimers=s,i&&(this.programTimersStack=null);const u={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return J(function*(){if(L().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const c=yield Promise.all(a);u.kernelMs=function aY(t){let n=0;for(let e=0;e<t.length;e++)n+=t[e];return n}(c),u.getExtraProfileInfo=()=>c.map((d,h)=>({name:l[h],ms:d})).map(d=>`${d.name}: ${d.ms}`).join(", ")}else u.kernelMs={error:"WebGL query timers are not supported in this environment."};return r.uploadWaitMs=0,r.downloadWaitMs=0,u})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return L().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:is(),endMs:null}}endTimer(e){return L().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=is(),e)}getQueryTime(e){var r=this;return J(function*(){return L().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?r.gpgpu.waitForQueryAndGetTime(e):e.endMs-e.startMs})()}disposeData(e,r=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(r?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!r&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:s}=this.texData.get(e);return null!=s&&(this.disposeData(s.real.dataId,r),this.disposeData(s.imag.dataId,r)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:r,dtype:s,texShape:o,usage:i,isPacked:a,slice:l}=this.texData.get(e),u=l&&l.origDataId||e,c=this.dataRefCount.get(u);c>1?this.dataRefCount.set(u,c-1):(this.dataRefCount.delete(u),null!=r&&(this.numBytesInGPU-=this.computeBytes(o,s),this.textureManager.releaseTexture(r,o,i,a)));const d=this.texData.get(e);d.texture=null,d.texShape=null,d.isPacked=!1,d.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,r=Aye){return L().getBool("WEBGL_CPU_FORWARD")&&e.every(s=>null==this.texData.get(s.dataId).texture&&G(s.shape)<r)}getGPGPUContext(){return this.gpgpu}where(e){Ps("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const r=e.dataSync();return Tye(e.shape,r)}packedUnaryOp(e,r,s){const o=new Va(e.shape,r),i=this.compileAndRun(o,[e],s);return ri().makeTensorFromTensorInfo(i)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){const o=v3(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,o)}if(L().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,D3,e.dtype);const r=new gi(e.shape,D3),s=this.compileAndRun(r,[e]);return ri().makeTensorFromTensorInfo(s)}makeTensorInfo(e,r,s){let o;if("string"===r&&null!=s&&s.length>0&&lh(s[0])){const i=s.map(a=>ya(a));o=this.write(i,e,r)}else o=this.write(s,e,r);return this.texData.get(o).usage=null,{dataId:o,shape:e,dtype:r}}makeOutput(e,r,s){return ri().makeTensorFromTensorInfo(this.makeTensorInfo(e,r,s),this)}unpackTensor(e){const r=new Dye(e.shape);return this.runWebGLProgram(r,[e],e.dtype)}packTensor(e){const r=new cye(e.shape);return this.runWebGLProgram(r,[e],e.dtype,null,!0)}packedReshape(e,r){const s=[Nc(e.shape),...kc(e.shape)],o={dtype:e.dtype,shape:s,dataId:e.dataId},i=[Nc(r),...kc(r)],a=new C3(i,s),c=this.runWebGLProgram(a,[o],e.dtype,[s],!0);return{dataId:c.dataId,shape:r,dtype:c.dtype}}decode(e,r){const s=this.texData.get(e),{isPacked:o,shape:i,dtype:a}=s;null!=r&&_(G(i)<=r[0]*r[1]*4,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.");const l=Ab(i);let u;u=o?new Zme(l):new Yme(l);const d=[r??Eb(l)];return{dtype:a,shape:i,dataId:this.runWebGLProgram(u,[{shape:l,dtype:a,dataId:e}],a,d,!0,r).dataId}}runWebGLProgram(e,r,s,o,i=!1,a){const l=this.makeTensorInfo(e.outputShape,s),u=this.texData.get(l.dataId);if(e.packedOutput&&(u.isPacked=!0),e.outPackingScheme===Tc.DENSE){const b=a??Eb(e.outputShape);u.texShape=b.map(v=>2*v)}if(null!=e.outTexUsage&&(u.usage=e.outTexUsage),0===G(l.shape))return u.values=Nr(l.dtype,0),l;const c=[],d=r.map(b=>{if("complex64"===b.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let v=this.texData.get(b.dataId);if(null==v.texture){if(!e.packedInputs&&G(b.shape)<=L().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:b.shape,texData:null,isUniform:!0,uniformValues:v.values};e.packedInputs&&(v.isPacked=!0,v.shape=b.shape)}if(this.uploadToGPU(b.dataId),!!v.isPacked!=!!e.packedInputs)b=v.isPacked?this.unpackTensor(b):this.packTensor(b),c.push(b),v=this.texData.get(b.dataId);else if(v.isPacked&&!Fb(v.shape,b.shape)){const x=b,w=b.shape;b.shape=v.shape,b=this.packedReshape(b,w),c.push(b),v=this.texData.get(b.dataId),x.shape=w}return{shape:b.shape,texData:v,isUniform:!1}});this.uploadToGPU(l.dataId);const h={shape:l.shape,texData:u,isUniform:!1},p=function Xme(t,n,e){let r="";n.concat(e).forEach(i=>{const a=null!=i.texData&&null!=i.texData.slice&&i.texData.slice.flatOffset>0;if(t.enableShapeUniforms&&!i.isUniform){const l=i.texData.texShape,{useSqueezeShape:u,uniformShape:c,keptDims:d}=r1(t.packedInputs,i.shape,l);let h="",p="",f="";if(1===c.length&&t.packedInputs){const w=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];h=`${w[0]>1}_${w[1]>1}`}else if(2!==c.length||t.packedInputs){if(c.length>2&&!t.packedInputs){const w=Pe(c);f=`${w[0]===l[1]}_${w[w.length-1]===l[1]}`}}else p=`${c[0]>1}_${c[1]>1}`;const g=i.shape.length,m=2===c.length&&Bt(i.shape,l),y=1===G(i.shape),b=dc(i.shape,e.shape),v=!t.packedInputs&&g===e.shape.length&&Bt(l,e.texData.texShape);r+=`${g}_${v}_${u?d:""}_${c.length}_${y}_${b}_${m}_${h}_${p}_${f}_${t.packedInputs||c.length>2?"":`${l[0]>1}_${l[1]>1}`}_${a}`}else r+=`${i.shape}_${i.isUniform?"uniform":i.texData.texShape}_${a}`});let o=t.constructor.name;return o+="_"+r+"_"+t.userCode+`${L().getNumber("WEBGL_VERSION")}`,o}(e,d,h),f=this.getAndSaveBinary(p,()=>function qme(t,n,e,r){const s=e.map((c,d)=>{const h={logicalShape:c.shape,texShape:c.isUniform?null:c.texData.texShape,isUniform:c.isUniform,isPacked:!c.isUniform&&c.texData.isPacked,flatOffset:null};return null!=c.texData&&null!=c.texData.slice&&c.texData.slice.flatOffset>0&&(h.flatOffset=c.texData.slice.flatOffset),{name:n.variableNames[d],shapeInfo:h}}),o=s.map(c=>c.shapeInfo),i={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},a=dme(s,i,n),l=function zfe(t,n){const e=Ki(t,()=>t.createShader(t.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(ge(t,()=>t.shaderSource(e,n)),ge(t,()=>t.compileShader(e)),L().get("ENGINE_COMPILE_ONLY"))return e;if(!1===t.getShaderParameter(e,t.COMPILE_STATUS))throw t3(n,t.getShaderInfoLog(e)),new Error("Failed to compile fragment shader.");return e}(t.gl,a),u=t.createProgram(l);return L().get("ENGINE_COMPILE_ONLY")?{program:n,fragmentShader:l,source:a,webGLProgram:u,inShapeInfos:o,outShapeInfo:i,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:Object.assign({program:n,fragmentShader:l,source:a,webGLProgram:u,inShapeInfos:o,outShapeInfo:i},c3(t,n,u))}(this.gpgpu,e,d,h)),g=null!=this.activeTimers;let m;g&&(m=this.startTimer()),L().get("ENGINE_COMPILE_ONLY")||function Kme(t,n,e,r,s){n.program.enableShapeUniforms||(d3(n.inShapeInfos,e),d3([n.outShapeInfo],[r]));const o=r.texData.texture,i=r.texData.texShape;r.texData.isPacked?t.setOutputPackedMatrixTexture(o.texture,i[0],i[1]):t.setOutputMatrixTexture(o.texture,i[0],i[1]),t.setProgram(n.webGLProgram),1===L().getNumber("WEBGL_VERSION")&&null!==n.infLoc&&t.gl.uniform1f(n.infLoc,1/0),null!==n.nanLoc&&t.gl.uniform1f(n.nanLoc,NaN);for(let l=0;l<e.length;++l){const u=e[l],{uniform:c,offset:d,shape:h,texShape:p}=n.variablesLocations[l];if(h){const{uniformShape:f}=r1(n.program.packedInputs,u.shape,u.texData.texShape);switch(f.length){case 1:t.gl.uniform1iv(h,new Int32Array(f));break;case 2:t.gl.uniform2iv(h,new Int32Array(f));break;case 3:t.gl.uniform3iv(h,new Int32Array(f));break;case 4:t.gl.uniform4iv(h,new Int32Array(f))}}if(p&&t.gl.uniform2i(p,u.texData.texShape[0],u.texData.texShape[1]),null!=c){if(u.isUniform){if(G(u.shape)<2)t.gl.uniform1f(c,u.uniformValues[0]);else{let f=u.uniformValues;f instanceof Float32Array||(f=new Float32Array(f)),t.gl.uniform1fv(c,f)}continue}null!=u.texData.slice&&null!=d&&t.gl.uniform1i(d,u.texData.slice.flatOffset),t.setInputMatrixTexture(u.texData.texture.texture,c,l)}}const a=n.outShapeLocation;if(a)switch(r.shape.length){case 1:t.gl.uniform1iv(a,new Int32Array(r.shape));break;case 2:t.gl.uniform2iv(a,new Int32Array(r.shape));break;case 3:t.gl.uniform3iv(a,new Int32Array(r.shape));break;case 4:t.gl.uniform4iv(a,new Int32Array(r.shape))}if(n.outShapeStridesLocation){const l=Pe(r.shape);switch(r.shape.length){case 2:t.gl.uniform1iv(n.outShapeStridesLocation,new Int32Array(l));break;case 3:t.gl.uniform2iv(n.outShapeStridesLocation,new Int32Array(l));break;case 4:t.gl.uniform3iv(n.outShapeStridesLocation,new Int32Array(l))}}if(n.outTexShapeLocation&&t.gl.uniform2i(n.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),n.program.customUniforms&&s)for(let l=0;l<n.program.customUniforms.length;++l){const u=n.program.customUniforms[l],c=n.customUniformLocations[l],d=s[l];if("float"===u.type)t.gl.uniform1fv(c,d);else if("vec2"===u.type)t.gl.uniform2fv(c,d);else if("vec3"===u.type)t.gl.uniform3fv(c,d);else if("vec4"===u.type)t.gl.uniform4fv(c,d);else if("int"===u.type)t.gl.uniform1iv(c,d);else if("ivec2"===u.type)t.gl.uniform2iv(c,d);else if("ivec3"===u.type)t.gl.uniform3iv(c,d);else{if("ivec4"!==u.type)throw Error(`uniform type ${u.type} is not supported yet.`);t.gl.uniform4iv(c,d)}}t.executeProgram()}(this.gpgpu,f,d,h,o),c.forEach(b=>this.disposeIntermediateTensorInfo(b)),g&&(m=this.endTimer(m),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(m)}));const y=L().get("WEBGL_FLUSH_THRESHOLD");if(y>0){const b=is();b-this.lastGlFlushTime>y&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=b)}if(!L().getBool("WEBGL_LAZILY_UNPACK")&&u.isPacked&&!1===i){const b=this.unpackTensor(l);return this.disposeIntermediateTensorInfo(l),b}return l}compileAndRun(e,r,s,o,i=!1){return this.runWebGLProgram(e,r,s=s||r[0].dtype,o,i)}getAndSaveBinary(e,r){return e in this.binaryCache||(this.binaryCache[e]=r()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(L().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(r=>{this.gpgpu.deleteProgram(this.binaryCache[r].webGLProgram),delete this.binaryCache[r]}),this.textureManager.dispose(),null!=this.canvas&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=$(()=>{if(!L().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=L().getBool("DEBUG");L().set("DEBUG",!1);const r=this.abs(rt(1e-8)).dataSync()[0];if(L().set("DEBUG",e),r>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){const r=this.texData.get(e),{shape:s,dtype:o,values:i,texture:a,usage:l,isPacked:u}=r;if(null!=a)return;const c=null!=this.activeTimers;let d;c&&(d=is());let h=r.texShape;if(null==h&&(h=function tme(t,n=!1){let e=L().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=L().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");r===1/0&&L().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=e/2),n&&(e*=2,r*=2,1===(t=t.map((a,l)=>l>=t.length-2?t0(t[l]):t[l])).length&&(t=[2,t[0]])),2!==t.length&&(t=fa(t).newShape);let s=G(t),o=null;t.length<=1&&s<=e?o=[1,s]:2===t.length&&t[0]<=e&&t[1]<=e?o=t:3===t.length&&t[0]*t[1]<=e&&t[2]<=e?o=[t[0]*t[1],t[2]]:3===t.length&&t[0]<=e&&t[1]*t[2]<=e?o=[t[0],t[1]*t[2]]:4===t.length&&t[0]*t[1]*t[2]<=e&&t[3]<=e?o=[t[0]*t[1]*t[2],t[3]]:4===t.length&&t[0]<=e&&t[1]*t[2]*t[3]<=e&&(o=[t[0],t[1]*t[2]*t[3]]);const i=null!=o&&Math.max(...o)>r&&Math.min(...o)<=(n?2:1)&&Math.min(...o)>0;if(null==o||i)if(n){const a=Nc(t);let l=2,u=2;t.length&&([l,u]=kc(t)),s=a*(l/2)*(u/2),o=r0(s).map(c=>2*c)}else o=r0(s);return o}(s,u),r.texShape=h),null!=i){const p=Ab(s);let f,g=h[1],m=h[0];const y=i instanceof Uint8Array||i instanceof Uint8ClampedArray;(u||!y)&&([g,m]=Ec(h[0],h[1])),f=u?new tge(p,y):new h3(p,y);const b=y?[m,g]:h,v=this.makeTensorInfo(b,o),x=this.texData.get(v.dataId);x.usage=y?ws.PIXELS:ws.UPLOAD,x.texShape=b,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(v.dataId),g,m,i);const I=this.runWebGLProgram(f,[v],o,[[m,g]],!0),D=this.texData.get(I.dataId);r.texShape=D.texShape,r.isPacked=D.isPacked,r.usage=D.usage,L().get("ENGINE_COMPILE_ONLY")?this.disposeData(I.dataId):(r.texture=D.texture,r.values=null,this.texData.delete(I.dataId)),this.disposeIntermediateTensorInfo(v),c&&(this.uploadWaitMs+=is()-d)}else{const p=this.acquireTexture(h,l,o,u);r.texture=p}}convertAndCacheOnCPU(e,r){const s=this.texData.get(e),{dtype:o}=s;return null!=r&&(s.values=function Pye(t,n){if("float32"===n||"complex64"===n)return t;if("int32"===n||"bool"===n){const e="int32"===n?new Int32Array(t.length):new Uint8Array(t.length);for(let r=0;r<e.length;++r)e[r]=Math.round(t[r]);return e}throw new Error(`Unknown dtype ${n}`)}(r,o)),s.values}acquireTexture(e,r,s,o){if(this.numBytesInGPU+=this.computeBytes(e,s),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const i=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${i} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,r,o)}computeBytes(e,r){return e[0]*e[1]*ag(r)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}checkCompileCompletionAsync(){var e=this;return J(function*(){const r=[];if(e.gpgpu.parallelCompilationExtension){for(const[,s]of Object.entries(e.binaryCache))r.push(e.checkCompletionAsync_(s));return Promise.all(r)}for(const[,s]of Object.entries(e.binaryCache)){const o=new Promise(i=>{try{e.checkCompletion_(s),i(!0)}catch(a){throw a}});r.push(o)}return Promise.all(r)})()}checkCompletionAsync_(e){var r=this;return J(function*(){return r.gpgpu.gl.getProgramParameter(e.webGLProgram,r.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?r.checkCompletion_(e):(yield qP(),r.checkCompletionAsync_(e))})()}checkCompletion_(e){if(!1===this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS))throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)?(t3(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){const{variablesLocations:r,customUniformLocations:s,infLoc:o,nanLoc:i,outShapeLocation:a,outShapeStridesLocation:l,outTexShapeLocation:u}=c3(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=r,e.customUniformLocations=s,e.infLoc=o,e.nanLoc=i,e.outShapeLocation=a,e.outShapeStridesLocation=l,e.outTexShapeLocation=u}}createTensorFromGPUData(e,r,s){e.channels=e.channels||"RGBA";const{texture:o,height:i,width:a,channels:l}=e,u=ri().backend;if(!u.gpgpu.gl.isTexture(o))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const c=u.writeTexture(o,r,s,i,a,l);return ri().makeTensorFromDataId(c,r,s,u)}}return t.nextDataId=0,t})();kM()&&qM("webgl",()=>new Mye,2);const i1="\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n";class Pc{constructor(n,e,r){this.variableNames=["A","B"],this.outputShape=st(e,r),this.enableShapeUniforms=Rr(this.outputShape.length),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${n}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}const jl="\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n";class Hp{constructor(n,e,r,s=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=st(e,r);const o=this.outputShape.length;this.enableShapeUniforms=Rr(o);let i="";if(s)if(0===o||1===G(this.outputShape))i="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(i=`\n          ${Qt(o)} coords = getOutputCoords();\n        `,1===o)i+=this.enableShapeUniforms?"\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const l=Xr("coords",o);i+=this.enableShapeUniforms?`\n            bool nextRowOutOfBounds =\n              (${l[o-2]} + 1) >= outShape[${o} - 2];\n            bool nextColOutOfBounds =\n              (${l[o-1]} + 1) >= outShape[${o} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `:`\n            bool nextRowOutOfBounds =\n              (${l[o-2]} + 1) >= ${this.outputShape[o-2]};\n            bool nextColOutOfBounds =\n              (${l[o-1]} + 1) >= ${this.outputShape[o-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${n}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${i}\n\n        setOutput(result);\n      }\n    `}}function Cs(t){const{inputs:n,backend:e}=t,{x:r}=n;return e.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const Lye={kernelName:Nh,backendName:"webgl",kernelFunc:Cs};function Ba(t){const{inputs:n,backend:e}=t,{real:r,imag:s}=n,o=e.makeTensorInfo(r.shape,"complex64"),i=e.texData.get(o.dataId),a=Cs({inputs:{x:r},backend:e}),l=Cs({inputs:{x:s},backend:e});return i.complexTensorInfos={real:a,imag:l},o}const Vye={kernelName:b0,backendName:"webgl",kernelFunc:Ba},T3="return (a < 0.) ? b * a : a;",E3="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",zye={kernelName:Eg,backendName:"webgl",kernelFunc:function Bye(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{alpha:o}=r,i=e.makeTensorInfo([],"float32",ga(o,"float32")),a=L().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Hp(E3,s.shape,i.shape):new Pc(T3,s.shape,i.shape),l=e.runWebGLProgram(a,[s,i],"float32");return e.disposeIntermediateTensorInfo(i),l}},N3="return (a < 0.) ? b * a : a;",k3="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",Wye={kernelName:qg,backendName:"webgl",kernelFunc:function Uye(t){const{inputs:n,backend:e}=t,{x:r,alpha:s}=n,o=L().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Hp(k3,r.shape,s.shape):new Pc(N3,r.shape,s.shape);return e.runWebGLProgram(o,[r,s],"float32")}},Oc="if (isnan(x)) return x;";function Ft({opSnippet:t,packedOpSnippet:n,cpuKernelImpl:e,dtype:r}){return({inputs:s,backend:o})=>{const{x:i}=s,a=o,l=r||i.dtype;if(a.shouldExecuteOnCPU([i])&&null!=e){const d=a.texData.get(i.dataId),h=e(d.values,l);return a.makeTensorInfo(i.shape,l,h)}let c;return c=L().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=n?new Va(i.shape,n):new gi(i.shape,t),a.runWebGLProgram(c,[i],l)}}function wr({opSnippet:t,packedOpSnippet:n,checkOutOfBounds:e=!1,supportsComplex:r=!1,cpuKernelImpl:s,dtype:o}){return({inputs:i,backend:a})=>{const{a:l,b:u}=i,c=a;if(r&&"complex64"===l.dtype){const f=c.texData.get(l.dataId),g=c.texData.get(u.dataId),[m,y]=[[f.complexTensorInfos.real,g.complexTensorInfos.real],[f.complexTensorInfos.imag,g.complexTensorInfos.imag]].map(v=>{const[x,w]=v,C={dataId:x.dataId,dtype:x.dtype,shape:l.shape},I={dataId:w.dataId,dtype:w.dtype,shape:u.shape},D=new Pc(t,l.shape,u.shape);return c.runWebGLProgram(D,[C,I],ys(x.dtype,w.dtype))}),b=Ba({inputs:{real:m,imag:y},backend:c});return c.disposeIntermediateTensorInfo(m),c.disposeIntermediateTensorInfo(y),b}const d=o||ys(l.dtype,u.dtype);if(("string"===l.dtype||"string"===u.dtype||c.shouldExecuteOnCPU([l,u]))&&null!=s){const f=c.texData.get(l.dataId).values,g=c.texData.get(u.dataId).values,m="string"===l.dtype?ji(f):f,y="string"===l.dtype?ji(g):g,[b,v]=s(l.shape,u.shape,m,y,d),x=c.makeTensorInfo(v,d);return c.texData.get(x.dataId).values=b,x}let p;return p=L().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=n?new Hp(n,l.shape,u.shape,e):new Pc(t,l.shape,u.shape),c.runWebGLProgram(p,[l,u],d)}}function jp(t,n=!1){if("linear"===t)return n?wye:gye;if("relu"===t)return n?_ye:bye;if("elu"===t)return n?Cye:yye;if("relu6"===t)return n?Sye:vye;if("prelu"===t)return n?k3:N3;if("leakyrelu"===t)return n?E3:T3;if("sigmoid"===t)return n?Iye:xye;throw new Error(`Activation ${t} has not been implemented for the WebGL backend.`)}class A3{constructor(n,e,r,s=!1,o=!1,i=!1,a=null,l=!1,u=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=r,this.enableShapeUniforms=Rr(this.outputShape.length);const d=Math.ceil((s?n[1]:n[2])/2),h=s?"i * 2, rc.y":"rc.y, i * 2",p=o?"rc.z, i * 2":"i * 2, rc.z",f=s?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],g=o?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let m="",y="";a&&(m=l?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${a}\n        }`:u?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${a}\n        }`:`vec4 activation(vec4 x) {\n          ${a}\n        }`,y="result = activation(result);");const b=i?"result += getBiasAtOutCoords();":"";i&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),u&&this.variableNames.push("leakyreluAlpha");let v="rc.x",x="rc.x";n[0]<e[0]?v=`imod(rc.x, ${n[0]})`:e[0]<n[0]&&(x=`imod(rc.x, ${e[0]})`),this.userCode=`\n      ${m}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${d}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        int batchA = ${v};\n        int batchB = ${x};\n        for (int i = 0; i < ${d}; i++) {\n          vec4 a = getMatrixA(batchA, ${h});\n          vec4 b = getMatrixB(batchB, ${p});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${f[0]} * ${g[0]});\n          result += (${f[1]} * ${g[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${b}\n\n        ${y}\n\n        setOutput(result);\n      }\n    `}}const R3={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class F3{constructor(n,e,r){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=st(e,r),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${n}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}const M3="return a * b;";function a1(t){const{inputs:n,backend:e}=t,{a:r,b:s}=n,o=ys(r.dtype,s.dtype);if("complex64"===r.dtype){const a=e.texData.get(r.dataId),l=e.texData.get(s.dataId),u=new F3(R3.REAL,r.shape,s.shape),c=new F3(R3.IMAG,r.shape,s.shape),d=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:r.shape},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:s.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:s.shape}],h=e.runWebGLProgram(u,d,"float32"),p=e.runWebGLProgram(c,d,"float32"),f=Ba({inputs:{real:h,imag:p},backend:e});return e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(p),f}if(e.shouldExecuteOnCPU([r,s])){const a=e.texData.get(r.dataId),l=e.texData.get(s.dataId),[u,c]=Vge(r.shape,s.shape,a.values,l.values,o),d=e.makeTensorInfo(c,o);return e.texData.get(d.dataId).values=u,d}let i;return i=L().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Hp(M3,r.shape,s.shape):new Pc(M3,r.shape,s.shape),e.runWebGLProgram(i,[r,s],o)}const Gye={kernelName:Lh,backendName:"webgl",kernelFunc:a1};function fe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{shape:o}=r,i=e,a=G(s.shape),l=qF(o,a),u=G(l);_(a===u,()=>`The new shape (${l}) has ${u} elements and the old shape (${s.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`);const c=i.texData.get(s.dataId);return!c.isPacked||Fb(s.shape,l)||null!==c.texture&&Fb(c.shape,l)?(i.incRef(s.dataId),{dataId:s.dataId,shape:l,dtype:s.dtype}):function Hye(t,n,e){const r=[Nc(t.shape),...kc(t.shape)],s={dtype:t.dtype,shape:r,dataId:t.dataId},o=[Nc(n),...kc(n)],i=new C3(o,r),u=e.runWebGLProgram(i,[s],t.dtype,[r],!0);return{dataId:u.dataId,shape:n,dtype:u.dtype}}(s,l,i)}const jye={kernelName:Xg,backendName:"webgl",kernelFunc:fe};class P3{constructor(n,e){this.variableNames=["x"];const{windowSize:r,batchSize:s,inSize:o,outSize:i}=n;this.outputShape=[s,i];const a=4*Math.floor(r/4),l=r%4;let u="sumValue += dot(values, ones);";if(null!=e){const d=1/e;u=`sumValue += dot(values * ${Zu(d)?d.toPrecision(2):d}, ones);`}let c="";o%r>0&&(c=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${c}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${a}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${u}\n        }\n\n        int inIdx = inOffset + ${a};\n        if (${1===l}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${u}\n        } else if (${2===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${u}\n        } else if (${3===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${u}\n        }\n        setOutput(sumValue);\n      }\n    `}}class qye{constructor(n,e){this.variableNames=["x"];const{windowSize:r,batchSize:s,inSize:o,outSize:i}=n;this.outputShape=[s,i];let a="0.0",l="";"prod"===e?a="1.0":"min"===e?(a="1.0 / 1e-20",l="min"):"max"===e&&(a="-1.0 / 1e-20",l="max");let u=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===e?u="sumValue":"prod"===e?u="prodValue":"all"===e?u="allValue":"any"===e&&(u="anyValue");const c=4*Math.floor(r/4),d=r%4;let h=`\n      if (${"sum"===e}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===e}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${l}(values, minMaxValue);\n        if (${"min"===e} || ${"max"===e}) {\n          minMaxValue = ${l}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,p="vec4";"all"===e?(a="1.0",h="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",p="bvec4"):"any"===e&&(a="0.0",h="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",p="bvec4");let f="";o%r>0&&(f=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${a};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${f}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        vec4 minMaxValue = vec4(${a});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${c}; i += 4) {\n          int inIdx = inOffset + i;\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${h}\n        }\n\n        int inIdx = inOffset + ${c};\n        if (${1===d}) {\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${2===d}) {\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${3===d}) {\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${h}\n        }\n        setOutput(${u});\n      }\n    `}}function ql(t,n,e,r){const s=function Kye(t){const n=[];for(;0===n.length||1!==n[n.length-1].outSize;){const e=n.length?n[n.length-1].outSize:t[1],r=Uy(e);n.push({inSize:e,windowSize:r,outSize:Math.ceil(e/r)})}return n}(t.shape);let o=t;for(let i=0;i<s.length;i++){const{inSize:a,windowSize:l,outSize:u}=s[i];let c,d;c="mean"===e?0===i?new P3({windowSize:l,inSize:a,batchSize:t.shape[0],outSize:u},a):new P3({windowSize:l,inSize:a,batchSize:t.shape[0],outSize:u}):new qye({windowSize:l,inSize:a,batchSize:t.shape[0],outSize:u},e),d=o,o=r.runWebGLProgram(c,[o],n),d.dataId!==t.dataId&&r.disposeIntermediateTensorInfo(d)}return o}class Xye{constructor(n,e){this.variableNames=["A"];const r=new Array(n.length);for(let i=0;i<r.length;i++)r[i]=n[e[i]];this.outputShape=r,this.rank=r.length;const s=Qt(this.rank),o=function Yye(t){const n=t.length;if(n>6)throw Error(`Transpose for rank ${n} is not yet supported`);const e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(n);for(let s=0;s<t.length;s++)r[t[s]]=e[s];return r.join()}(e);this.userCode=`\n    void main() {\n      ${s} resRC = getOutputCoords();\n      setOutput(getA(${o}));\n    }\n    `}}class Zye{constructor(n,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const r=new Array(n.length);for(let c=0;c<r.length;c++)r[c]=n[e[c]];if(this.outputShape=r,this.rank=r.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const s=Qt(this.rank),o=w3("rc",this.rank),i=new Array(this.rank);for(let c=0;c<e.length;c++)i[e[c]]=o[c];const a=`vec2(${i.slice(-2).join()})`,l=`++${o[this.rank-1]} < ${r[this.rank-1]}`,u=`getChannel(getA(${i.join()}), ${a})`;this.userCode=`\n    void main() {\n      ${s} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${u};\n      if(${l}) {\n        result[1] = ${u};\n      }\n      --${o[this.rank-1]};\n      if(++${o[this.rank-2]} < ${r[this.rank-2]}) {\n        result[2] = ${u};\n        if(${l}) {\n          result[3] = ${u};\n        }\n      }\n      setOutput(result);\n    }\n    `}}function Vb(t,n,e){const r=L().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Zye(t.shape,n):new Xye(t.shape,n);return e.runWebGLProgram(r,[t],t.dtype)}function Bb(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o,keepDims:i}=r;return function Qye(t,n,e,r){const o=t.shape.length,i=bt(n,t.shape);let a=i;const l=Cn(a,o),u=null!=l;let c=t;u&&(c=Vb(t,l,r),a=$n(a.length,o)),xr("sum",a,o);const[d,h]=dr(c.shape,a);let p=d;e&&(p=On(d,i));const f=G(h),y=fe({inputs:{x:c},attrs:{shape:[G(t.shape)/f,f]},backend:r}),v=ql(y,c_(t.dtype),"sum",r),x=fe({inputs:{x:v},attrs:{shape:p},backend:r});return r.disposeIntermediateTensorInfo(y),r.disposeIntermediateTensorInfo(v),u&&r.disposeIntermediateTensorInfo(c),x}(s,o,i,e)}const Jye={kernelName:ty,backendName:"webgl",kernelFunc:Bb};function Yr(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{perm:o}=r,i=e,l=new Array(s.shape.length);for(let c=0;c<l.length;c++)l[c]=s.shape[o[c]];let u;if(i.shouldExecuteOnCPU([s])){const d=i.texData.get(s.dataId).values,h=o1(d,s.shape,s.dtype,o,l);u=i.makeTensorInfo(l,s.dtype),i.texData.get(u.dataId).values=h}else u=Vb(s,o,i);return u}const ebe={kernelName:nc,backendName:"webgl",kernelFunc:Yr},O3=1e3;function zb({a:t,b:n,transposeA:e,transposeB:r,backend:s,bias:o=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:l=null}){const u=t.shape.length,c=n.shape.length,d=e?t.shape[u-2]:t.shape[u-1],h=r?n.shape[c-1]:n.shape[c-2],p=e?t.shape[u-1]:t.shape[u-2],f=r?n.shape[c-2]:n.shape[c-1],g=t.shape.slice(0,-2),m=n.shape.slice(0,-2),y=G(g),b=G(m),x=st(t.shape.slice(0,-2),n.shape.slice(0,-2)).concat([p,f]);_(d===h,()=>`Error in matMul: inner shapes (${d}) and (${h}) of Tensors with shapes ${t.shape} and ${n.shape} and transposeA=${e} and transposeB=${r} must match.`);const w=e?[y,d,p]:[y,p,d],C=r?[b,f,h]:[b,h,f],I=fe({inputs:{x:t},backend:s,attrs:{shape:w}}),D=fe({inputs:{x:n},backend:s,attrs:{shape:C}}),E=[I,D],N=Math.max(y,b),P=e?I.shape[1]:I.shape[2],V=null!=o,B=null!=i,z="leakyrelu"===l,U=null!=l?jp(l,!0):null;let q;if((1===p||1===f)&&P>O3&&!1===(V||B||z||null!=U)){let K=I,ne=D;e&&(K=Yr({inputs:{x:I},backend:s,attrs:{perm:[0,2,1]}}),E.push(K)),r&&(ne=Yr({inputs:{x:D},backend:s,attrs:{perm:[0,2,1]}}),E.push(ne));const he=1===f;let le=K;1!==f&&(le=fe({inputs:{x:K},backend:s,attrs:{shape:[N,P,1]}}),E.push(le));const be=1===f?2:1;let pe=ne;he&&(pe=fe({inputs:{x:ne},backend:s,attrs:{shape:[N,1,P]}}),E.push(pe));const Se=a1({inputs:{a:le,b:pe},backend:s});q=Bb({inputs:{x:Se},backend:s,attrs:{axis:be,keepDims:!0}}),E.push(Se)}else{const K=ys(t.dtype,n.dtype),ne=new A3(w,C,[N,p,f],e,r,V,U,B,z),ae=[I,D];if(null!=o&&ae.push(o),B&&ae.push(i),z){const he=s.makeTensorInfo([],"float32",ga(a,"float32"));ae.push(he),E.push(he)}q=s.runWebGLProgram(ne,ae,K)}const W=fe({inputs:{x:q},backend:s,attrs:{shape:x}});E.push(q);for(const K of E)s.disposeIntermediateTensorInfo(K);return W}const nbe={kernelName:uy,backendName:"webgl",kernelFunc:function tbe(t){const{inputs:n,backend:e,attrs:r}=t,{a:s,b:o,bias:i,preluActivationWeights:a}=n,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:d}=r;return zb({a:s,b:o,transposeA:l,transposeB:u,backend:e,bias:i,preluActivationWeights:a,leakyreluAlpha:d,activation:c})}},$3="return abs(x);",sbe={kernelName:lg,backendName:"webgl",kernelFunc:function rbe(t){const{inputs:n,backend:e}=t,{x:r}=n;if(e.shouldExecuteOnCPU([r])&&"complex64"!==r.dtype){const o=e.texData.get(r.dataId),i=v3(o.values);return e.makeTensorInfo(r.shape,r.dtype,i)}let s;return s=L().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new Va(r.shape,$3):new gi(r.shape,$3),e.runWebGLProgram(s,[r],r.dtype)}},ibe=Ft({opSnippet:Us+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),abe={kernelName:uh,backendName:"webgl",kernelFunc:ibe},ube=Ft({opSnippet:Us+"\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),cbe={kernelName:ch,backendName:"webgl",kernelFunc:ube},L3="return a + b;",dbe=wr({opSnippet:L3,packedOpSnippet:L3,supportsComplex:!0,cpuKernelImpl:vge}),hbe={kernelName:tc,backendName:"webgl",kernelFunc:dbe};class pbe{constructor(n,e){this.outputShape=[],this.outputShape=n,this.variableNames=e.map((o,i)=>`T${i}`);const r=[];this.variableNames.forEach(o=>{r.push(`float v${o} = get${o}AtOutCoords();`)});const s=this.variableNames.map(o=>`v${o}`).join(" + ");this.userCode=`\n      void main() {\n        ${r.join("\n        ")}\n\n        float result = ${s};\n        setOutput(result);\n      }\n    `}}class fbe{constructor(n,e){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.variableNames=e.map((o,i)=>`T${i}`);const r=[];this.variableNames.forEach(o=>{r.push(`vec4 v${o} = get${o}AtOutCoords();`)});const s=this.variableNames.map(o=>`v${o}`).join(" + ");this.userCode=`\n      void main() {\n        ${r.join("\n        ")}\n\n        vec4 result = ${s};\n        setOutput(result);\n      }\n    `}}const mbe={kernelName:h0,backendName:"webgl",kernelFunc:function Ub(t){const{inputs:n,backend:e}=t,r=n;if(1===r.length)return Cs({inputs:{x:r[0]},backend:e});if(r.length>L().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const l=Math.floor(r.length/2),u=Ub({inputs:r.slice(0,l),backend:e}),c=Ub({inputs:r.slice(l),backend:e});return Ub({inputs:[u,c],backend:e})}const s=r.map(l=>l.dtype).reduce((l,u)=>ys(l,u)),o=r.map(l=>l.shape),a=L().getBool("WEBGL_PACK")?new fbe(r[0].shape,o):new pbe(r[0].shape,o);return e.runWebGLProgram(a,r,s)}},ybe={kernelName:"All",backendName:"webgl",kernelFunc:function gbe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o,keepDims:i}=r,a=s.shape.length,l=bt(o,s.shape);let u=l;const c=Cn(u,a);let d=s;null!=c&&(d=Yr({inputs:{x:s},backend:e,attrs:{perm:c}}),u=$n(u.length,a)),xr("all",u,a);const[h,p]=dr(d.shape,u),g=fe({inputs:{x:d},backend:e,attrs:{shape:[-1,G(p)]}}),m=ql(g,g.dtype,"all",e);let y;return y=fe(i?{inputs:{x:m},backend:e,attrs:{shape:On(h,l)}}:{inputs:{x:m},backend:e,attrs:{shape:h}}),e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(m),null!=c&&e.disposeIntermediateTensorInfo(d),y}},vbe={kernelName:"Any",backendName:"webgl",kernelFunc:function bbe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o,keepDims:i}=r,a=s.shape.length,l=bt(o,s.shape);let u=l;const c=Cn(u,a);let d=s;null!=c&&(d=Yr({inputs:{x:s},backend:e,attrs:{perm:c}}),u=$n(u.length,a)),xr("any",u,a);const[h,p]=dr(d.shape,u),g=fe({inputs:{x:d},backend:e,attrs:{shape:[-1,G(p)]}}),m=ql(g,g.dtype,"any",e);let y;return y=fe(i?{inputs:{x:m},backend:e,attrs:{shape:On(h,l)}}:{inputs:{x:m},backend:e,attrs:{shape:h}}),e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(m),null!=c&&e.disposeIntermediateTensorInfo(d),y}};class xbe{constructor(n,e,r){this.variableNames=["A"];const{windowSize:s,batchSize:o,outSize:i}=n;r||this.variableNames.push("bestIndicesA"),this.outputShape=[o,i],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${s};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${s}; i++) {\n          int inIdx = ${r?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));"};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${"max"===e?">":"<"} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}class wbe{constructor(n,e,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,_(n.length>2,()=>`Packed arg${r.charAt(0).toUpperCase()+r.slice(1)} supports only inputs with rank above 2.`);const i=Math.ceil(n[n.length-1]/e);this.outputShape=n.slice(0,-1),i>1&&this.outputShape.push(i),s||this.variableNames.push("bestIndicesA");const a=this.outputShape,l=a.length,u=Qt(l),c=Xr("coords",l);let d,h;if(1===i){h=l+1;const D=Qt(h);d=`\n        ${D} sourceLocR = ${D}(${c.join()}, 0);\n        ++${c[l-1]};\n        ${D} sourceLocG = ${D}(${c.join()}, 0);\n        ++${c[l-2]};\n        ${D} sourceLocA = ${D}(${c.join()}, 0);\n        --${c[l-1]};\n        ${D} sourceLocB = ${D}(${c.join()}, 0);\n        --${c[l-2]};`}else h=l,d=`\n        ${u} sourceLocR = coords;\n        ++${c[l-1]};\n        ${u} sourceLocG = coords;\n        ++${c[l-2]};\n        ${u} sourceLocA = coords;\n        --${c[l-1]};\n        ${u} sourceLocB = coords;\n        --${c[l-2]};`;const p=["x","y","z","w","u","v"].slice(0,h),f="."+p[h-1],g=p.map(D=>"int "+D),m=Xr("sourceLocR",h-1).concat("inIdx.r"),y=Xr("sourceLocG",h-1).concat("inIdx.g"),b=Xr("sourceLocB",h-1).concat("inIdx.b"),v=Xr("sourceLocA",h-1).concat("inIdx.a"),x="max"===r?"greaterThan":"lessThan",w=s?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${m.join()}),\n                             getBestIndicesAChannel(${y.join()}),\n                             getBestIndicesAChannel(${b.join()}),\n                             getBestIndicesAChannel(${v.join()})));`,C=`vec4(\n            getAChannel(${m.join()}),\n            hasNextCol ? getAChannel(${y.join()}) : 0.,\n            hasNextRow ? getAChannel(${b.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${v.join()}) : 0.)`,I=s?"":`\n      float getBestIndicesAChannel(${g.join()}) {\n        return getChannel(getBestIndicesA(${p.join()}),\n                                          vec2(${p.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${g.join()}) {\n        return getChannel(getA(${p.join()}),\n                               vec2(${p.slice(-2).join()}));\n      }\n      ${I}\n      void main() {\n        ${u} coords = getOutputCoords();\n        bool hasNextCol = ${c[l-1]} < ${a[l-1]-1};\n        bool hasNextRow = ${c[l-2]} < ${a[l-2]-1};\n        ${d}\n        ivec4 srcIdx = ivec4(sourceLocR${f}, sourceLocG${f},\n          sourceLocB${f}, sourceLocA${f}) * ${e};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${C};\n\n        for (int i = 0; i < ${e}; i++) {\n          inIdx = srcIdx;\n          ${w}\n          vec4 candidate = ${C};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${x}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}function V3(t,n,e,r=null){let s=n.shape[0],o=n.shape[1];null!=r&&(s=r.shape[0],o=r.shape[1]);const i=Uy(o),a={windowSize:i,inSize:o,batchSize:s,outSize:Math.ceil(o/i)},l=new xbe(a,e,null==r),u=[n];null!=r&&u.push(r);const c=t.runWebGLProgram(l,u,"int32");if(1===c.shape[1])return c;const d=V3(t,n,e,c);return t.disposeIntermediateTensorInfo(c),d}function B3(t,n,e,r=null){const s=null!=r?r.shape:n.shape,i=Uy(s[s.length-1]),a=new wbe(s,i,e,null==r),u=t.runWebGLProgram(a,null==r?[n]:[n,r],"int32");if(u.shape.length===n.shape.length){const c=B3(t,n,e,u);return t.disposeIntermediateTensorInfo(u),c}return u}function z3(t,n,e,r){const s=[e];if(xr("arg"+r.charAt(0).toUpperCase()+r.slice(1),s,n.shape.length),!L().getBool("WEBGL_PACK_REDUCE")||n.shape.length<=2){const o=[],i=t.texData.get(n.dataId);let l=n;null!==i&&i.isPacked&&(l=t.unpackTensor(n),o.push(l));const[u,c]=dr(l.shape,s),d=G(c),h=fe({inputs:{x:l},backend:t,attrs:{shape:[-1,d]}});o.push(h);const p=V3(t,h,r);o.push(p);const f=fe({inputs:{x:p},backend:t,attrs:{shape:u}});return o.forEach(g=>t.disposeIntermediateTensorInfo(g)),f}return B3(t,n,r)}const _be={kernelName:ug,backendName:"webgl",kernelFunc:function Cbe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o}=r;let i=bt(o,s.shape);const a=Cn(i,s.shape.length);let l=s;const u=[];null!=a&&(l=Yr({inputs:{x:s},backend:e,attrs:{perm:a}}),u.push(l),i=$n(i.length,l.shape.length)),xr("argMax",[i[0]],l.shape.length);const c=z3(e,l,i[0],"max");return u.forEach(d=>e.disposeIntermediateTensorInfo(d)),c}},Ibe={kernelName:cg,backendName:"webgl",kernelFunc:function Sbe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o}=r;let i=bt(o,s.shape);const a=Cn(i,s.shape.length);let l=s;const u=[];null!=a&&(l=Yr({inputs:{x:s},backend:e,attrs:{perm:a}}),u.push(l),i=$n(i.length,l.shape.length)),xr("argMin",[i[0]],l.shape.length);const c=z3(e,l,i[0],"min");return u.forEach(d=>e.disposeIntermediateTensorInfo(d)),c}},Tbe=Ft({opSnippet:Us+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),Ebe={kernelName:dh,backendName:"webgl",kernelFunc:Tbe},kbe=Ft({opSnippet:Us+"return log(x + sqrt(x * x + 1.0));"}),Abe={kernelName:hh,backendName:"webgl",kernelFunc:kbe},Fbe=Ft({opSnippet:Us+"\n  return atan(x);\n"}),Mbe={kernelName:ph,backendName:"webgl",kernelFunc:Fbe},$be=wr({opSnippet:i1+"\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+jl+"\n  return result;\n"}),Lbe={kernelName:mh,backendName:"webgl",kernelFunc:$be},Bbe=Ft({opSnippet:Us+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),zbe={kernelName:fh,backendName:"webgl",kernelFunc:Bbe};class qp{constructor(n,e,r,s=!1,o=!1){if(this.variableNames=["x"],"avg"===e&&r)throw new Error("Cannot compute positions for average pool.");const i=n.filterWidth,a=n.strideHeight,l=n.strideWidth,u=n.dilationHeight,c=n.dilationWidth,d=n.effectiveFilterHeight,h=n.effectiveFilterWidth,p=n.padInfo.top,f=n.padInfo.left;this.outputShape=n.outShape;const g="avg"===e;let b="0.0";if(g||(b="-1.0 / 1e-20"),r)return void(this.userCode=`\n        const ivec2 strides = ivec2(${a}, ${l});\n        const ivec2 pads = ivec2(${p}, ${f});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${d};\n              wR += ${u}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${n.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${h};\n                wC += ${c}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${n.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value >= currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${s?o?`((batch  * ${n.inHeight} + xR) * ${n.inWidth} + xC) * ${n.inChannels} + d`:`(xR * ${n.inWidth} + xC) * ${n.inChannels} + d`:`wR * ${h} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let x=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===e&&(x="avgValue / max(count, 1.0)");const w=4*Math.floor(i/4),C=i%4,I=`\n      if (${g}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${a}, ${l});\n      const ivec2 pads = ivec2(${p}, ${f});\n      const float initializationValue = ${b};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${n.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${b});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${d};\n            wR += ${u}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${n.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${w}; wC += 4) {\n            int xC = xCCorner + wC * ${c};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${c}, d),\n              getValue(batch, xR, xC + 2 * ${c}, d),\n              getValue(batch, xR, xC + 3 * ${c}, d)\n            );\n\n            ${I}\n          }\n\n          int xC = xCCorner + ${w};\n          if (${1===C}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${I}\n          } else if (${2===C}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${c}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${I}\n          } else if (${3===C}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${c}, d),\n              getValue(batch, xR, xC + 2 * ${c}, d),\n              initializationValue\n            );\n\n            ${I}\n          }\n        }\n        setOutput(${x});\n      }\n    `}}class l1{constructor(n,e,r,s=!1,o=!1){if(this.variableNames=["x"],"avg"===e&&r)throw new Error("Cannot compute positions for average pool.");const i=n.filterWidth,a=n.strideDepth,l=n.strideHeight,u=n.strideWidth,c=n.dilationDepth,d=n.dilationHeight,h=n.dilationWidth,p=n.effectiveFilterDepth,f=n.effectiveFilterHeight,g=n.effectiveFilterWidth,m=n.padInfo.front,y=n.padInfo.top,b=n.padInfo.left;this.outputShape=n.outShape;const v="avg"===e;let x="0.0";if(v||(x="-1.0 / 1e-20"),r)return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${a}, ${l}, ${u});\n        const ivec3 pads = ivec3(${m}, ${y}, ${b});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${p};\n              wD += ${c}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${n.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${f};\n                wR += ${d}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${n.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${g};\n                  wC += ${h}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${n.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value >= currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${s?o?`(((batch * ${n.inDepth} + xD) * ${n.inHeight} + xR) * ${n.inWidth} + xC) * ${n.inChannels} + ch`:`((xD * ${n.inHeight} + xR) * ${n.inWidth} + xC) * ${n.inChannels} + ch`:`wD * ${f} * ${g} +\n                      wR * ${g} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let C=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===e&&(C="avgValue / max(count, 1.0)");const I=4*Math.floor(i/4),D=i%4,E=`\n      if (${v}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${a}, ${l}, ${u});\n      const ivec3 pads = ivec3(${m}, ${y}, ${b});\n      const float initializationValue = ${x};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${n.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${x});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${p};\n            wD += ${c}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${n.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${f};\n            wR += ${d}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${n.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${I}; wC += 4) {\n              int xC = xCCorner + wC * ${h};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${h}, ch)\n              );\n\n              ${E}\n            }\n\n            int xC = xCCorner + ${I};\n            if (${1===D}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${E}\n            } else if (${2===D}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${E}\n            } else if (${3===D}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                initializationValue\n              );\n\n              ${E}\n            }\n          }\n        }\n        setOutput(${C});\n      }\n    `}}const Wbe={kernelName:dg,backendName:"webgl",kernelFunc:function Ube(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n;Wp(s,"avgPool");const{filterSize:o,strides:i,pad:a,dimRoundingMode:l}=r;_(vr(i,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`);const c=so(s.shape,o,i,1,a,l);if(1===c.filterWidth&&1===c.filterHeight&&Bt(c.inShape,c.outShape))return Cs({inputs:{x:s},backend:e});const d=new qp(c,"avg",!1);return e.runWebGLProgram(d,[s],"float32")}},Hbe={kernelName:hg,backendName:"webgl",kernelFunc:function Gbe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{filterSize:o,strides:i,pad:a,dimRoundingMode:l,dataFormat:u}=r,d=Bi(s.shape,o,i,[1,1,1],a,l,u),h=new l1(d,"avg",!1);return e.runWebGLProgram(h,[s],"float32")}};class jbe{constructor(n){this.variableNames=["dy"],this.outputShape=n.inShape;const l=n.effectiveFilterHeight,u=n.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${l-1-n.padInfo.top}, ${u-1-n.padInfo.left});\n      const float avgMultiplier = float(${1/(n.filterHeight*n.filterWidth)});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${l};\n            wR += ${n.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${n.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${n.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${u};\n            wC+= ${n.dilationWidth}) {\n            float dyC = float(dyCCorner + wC) / ${n.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class qbe{constructor(n){this.variableNames=["dy"],this.outputShape=n.inShape;const d=n.effectiveFilterDepth,h=n.effectiveFilterHeight,p=n.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${d-1-n.padInfo.front}, ${h-1-n.padInfo.top}, ${p-1-n.padInfo.left});\n      const float avgMultiplier = float(${1/(n.filterDepth*n.filterHeight*n.filterWidth)});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${d};\n            wD += ${n.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${n.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${n.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${h};\n              wR += ${n.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${n.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${n.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${p};\n                wC += ${n.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${n.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const Xbe={kernelName:g0,backendName:"webgl",kernelFunc:function Kbe(t){const{inputs:n,backend:e,attrs:r}=t,{dy:s,input:o}=n,i=o,{filterSize:a,strides:l,pad:u,dimRoundingMode:c}=r,h=Bi(i.shape,a,l,[1,1,1],u,c),p=new qbe(h);return e.runWebGLProgram(p,[s],i.dtype)}},Zbe={kernelName:m0,backendName:"webgl",kernelFunc:function Ybe(t){const{inputs:n,backend:e,attrs:r}=t,{dy:s,input:o}=n,i=o;Wp([s,o],"avgPoolGrad");const{filterSize:a,strides:l,pad:u}=r,c=so(i.shape,a,l,1,u),d=new jbe(c);return e.runWebGLProgram(d,[s],i.dtype)}},Jbe={kernelName:pg,backendName:"webgl",kernelFunc:function Qbe(t){const{inputs:n,backend:e,attrs:r}=t,{a:s,b:o}=n,{transposeA:i,transposeB:a}=r;return zb({a:s,b:o,transposeA:i,transposeB:a,backend:e})}};class eve{constructor(n,e,r,s,o,i){this.outputShape=[],this.variableNames=["x","mean","variance"],st(n,e),st(n,r);let a="0.0";null!=s&&(st(n,s),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="1.0";null!=o&&(st(n,o),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=n,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${a};\n        float scale = ${l};\n        float inv = scale * inversesqrt(variance + float(${i}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}class tve{constructor(n,e,r,s,o,i){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],st(n,e),st(n,r);let a="vec4(0.0)";null!=s&&(st(n,s),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="vec4(1.0)";null!=o&&(st(n,o),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=n,this.userCode=`\n      void main() {\n        vec4 offset = ${a};\n        vec4 scale = ${l};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${i}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}const nve={kernelName:Ig,backendName:"webgl",kernelFunc:({inputs:t,backend:n,attrs:e})=>{const{x:r,mean:s,variance:o,offset:i,scale:a}=t;_(s.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),_(null==i||s.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),_(null==a||s.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=e;null==l&&(l=.001);const u=[r,s,o];let c=null;null!=i&&(c=i.shape,u.push(i));let d=null;null!=a&&(d=a.shape,u.push(a));const h=L().getBool("WEBGL_PACK_NORMALIZATION")?new tve(r.shape,s.shape,o.shape,c,d,l):new eve(r.shape,s.shape,o.shape,c,d,l);return n.runWebGLProgram(h,u,u[0].dtype)}};class rve{constructor(n){this.variableNames=["source"],this.outputShape=n,this.rank=n.length;const e=Qt(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const r=function sve(t){if(1===t)return"sourceLoc";if(t<=6)return u1.slice(0,t).map(n=>"sourceLoc."+n).join(",");throw Error(`Slicing for rank ${t} is not yet supported`)}(this.rank);let s;s=`\n        ${e} sourceLoc;\n        ${e} coords = getOutputCoords();\n        ${n.map((i,a)=>`sourceLoc.${u1[a]} = start[${a}] + coords.${u1[a]};`).join("\n")}\n      `,this.userCode=`\n      void main() {\n        ${s}\n        setOutput(getSource(${r}));\n      }\n    `}}const u1=["x","y","z","w","u","v"];class ove{constructor(n){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.rank=n.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const e=Qt(this.rank),r=Xr("coords",this.rank),s=Xr("sourceLoc",this.rank),o=1===this.rank?"sourceLoc":`vec2(${s.slice(-2).join()})`,i=`getChannel(getSource(${s.join()}), ${o})`,a=`\n      result.x = ${i};\n      if (++${r[this.rank-1]} < ${n[this.rank-1]}) {\n        ++${s[this.rank-1]};\n        result.y = ${i};\n        --${s[this.rank-1]};\n      }\n    `,l=1===this.rank?"":`\n      --${r[this.rank-1]};\n      if (++${r[this.rank-2]} < ${n[this.rank-2]}) {\n        ++${s[this.rank-2]};\n        result.z = ${i};\n        if (++${r[this.rank-1]} < ${n[this.rank-1]}) {\n          ++${s[this.rank-1]};\n          result.w = ${i};\n        }\n      }\n    `,u=this.rank<=4?`sourceLoc = coords +\n            ${e}(${n.map((c,d)=>`start[${d}]`).join()});`:n.map((c,d)=>`${s[d]} = ${r[d]} + start[${d}];`).join("\n");this.userCode=`\n      void main() {\n        ${e} coords = getOutputCoords();\n        ${e} sourceLoc;\n        ${u}\n        vec4 result = vec4(0.);\n        ${a}\n        ${l}\n        setOutput(result);\n      }\n    `}}function $c(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{begin:o,size:i}=r,[a,l]=Iy(s,o,i);if(M_(s,a,l),0===G(l))return e.makeTensorInfo(l,s.dtype,[]);if(e.shouldExecuteOnCPU([s])||"string"===s.dtype){const d=e.texData.get(s.dataId),h=Yge(d.values,a,l,s.shape,s.dtype);return e.makeTensorInfo(l,s.dtype,h)}const{isPacked:u}=e.texData.get(s.dataId),c=O_(s.shape,a,l);if(u||!c){const d=L().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new ove(l):new rve(l);return e.runWebGLProgram(d,[s],s.dtype,[a])}return e.uploadToGPU(s.dataId),function ive(t,n,e,r){const s=r.texData.get(t.dataId),o=r.makeTensorInfo(e,t.dtype),i=r.texData.get(o.dataId);Object.assign(i,s),i.refCount=1,i.shape=e,i.dtype=t.dtype;let a=$_(n,Pe(t.shape));s.slice&&(a+=s.slice.flatOffset),i.slice={flatOffset:a,origDataId:s.slice&&s.slice.origDataId||t.dataId};const l=r.dataRefCount.get(i.slice.origDataId)||1;return r.dataRefCount.set(i.slice.origDataId,l+1),o}(s,a,l,e)}const ave={kernelName:ey,backendName:"webgl",kernelFunc:$c},lve={kernelName:fg,backendName:"webgl",kernelFunc:t=>{const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{blockShape:o,crops:i}=r;_(s.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const a=o.reduce((b,v)=>b*v),l=Cp(s.shape,o,a),u=_p(l.length,o.length),c=Sp(s.shape,o,a),d=vS(i,o.length),h=xS(c,i,o.length),p=[],f=fe({inputs:{x:s},backend:e,attrs:{shape:l}}),g=Yr({inputs:{x:f},backend:e,attrs:{perm:u}}),m=fe({inputs:{x:g},backend:e,attrs:{shape:c}}),y=$c({inputs:{x:m},backend:e,attrs:{begin:d,size:h}});return p.push(f),p.push(g),p.push(m),p.forEach(b=>e.disposeIntermediateTensorInfo(b)),y}},cve={kernelName:y0,backendName:"webgl",kernelFunc:function uve(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,weights:o}=n,{size:i}=r,a=e.readSync(s.dataId),l=e.readSync(o.dataId),u=b3(a,l,o.dtype,o.shape,i);return e.makeTensorInfo([i],o.dtype,u)}},hve={kernelName:eM,backendName:"webgl",kernelFunc:function dve(t){const{inputs:n,backend:e}=t,{s0:r,s1:s}=n,o=e.readSync(r.dataId),i=e.readSync(s.dataId),a=st(Array.from(o),Array.from(i));return e.makeTensorInfo([a.length],"int32",Int32Array.from(a))}},U3=wr({opSnippet:"return float(a != b);",cpuKernelImpl:zge,dtype:"bool"}),pve={kernelName:Ug,backendName:"webgl",kernelFunc:U3};function Kp(t){const{inputs:n,backend:e}=t,{input:r}=n;return Cs({inputs:{x:e.texData.get(r.dataId).complexTensorInfos.real},backend:e})}const fve={kernelName:W0,backendName:"webgl",kernelFunc:Kp},yve={kernelName:gh,backendName:"webgl",kernelFunc:function c1(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{dtype:o}=r;if("complex64"===o){if("complex64"===s.dtype)return Cs({inputs:{x:s},backend:e});const i=hr(s.shape),a=c1({inputs:{x:s},backend:e,attrs:{dtype:"float32"}}),l=Ba({inputs:{real:a,imag:i},backend:e});return i.dispose(),e.disposeIntermediateTensorInfo(a),l}if("complex64"===s.dtype){const i=Kp({inputs:{input:s},backend:e}),a=c1({inputs:{x:i},backend:e,attrs:{dtype:o}});return e.disposeIntermediateTensorInfo(i),a}if(!KF(s.dtype,o)){const i=Cs({inputs:{x:s},backend:e});return{dataId:i.dataId,shape:i.shape,dtype:o}}if(e.shouldExecuteOnCPU([s])){const i=e.texData.get(s.dataId).values,[a,l,u]=wge(i,s.shape,s.dtype,o);return e.makeTensorInfo(a,l,u)}if("int32"===o)return function gve(t,n){const e=new gi(t.shape,"return float(int(x));"),r=n.runWebGLProgram(e,[t],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}(s,e);if("bool"===o){const i=e.makeTensorInfo([],"bool",Nr("bool",1)),l=U3({inputs:{a:s,b:i},backend:e});return e.disposeIntermediateTensorInfo(i),l}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${o}`)}},W3="return ceil(x);",bve=Ft({opSnippet:W3,packedOpSnippet:W3,cpuKernelImpl:Cge}),vve={kernelName:yh,backendName:"webgl",kernelFunc:bve};class xve{constructor(n){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=n,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}}class wve{constructor(n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=n,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}}const _ve={kernelName:bh,backendName:"webgl",kernelFunc:function Cve(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{clipValueMin:o,clipValueMax:i}=r;let a;return a=L().getBool("WEBGL_PACK_CLIP")?new wve(s.shape):new xve(s.shape),e.runWebGLProgram(a,[s],s.dtype,[[o],[i]])}};class Sve{constructor(n){this.variableNames=["real","imag"],this.outputShape=n,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function G3(t,n){return{dataId:n.dataId,dtype:n.dtype,shape:t.shape}}const Dve={kernelName:mg,backendName:"webgl",kernelFunc:function Ive(t){const{inputs:n,backend:e}=t,{x:r}=n,s=e.texData.get(r.dataId),o=new Sve(r.shape),i=[G3(r,s.complexTensorInfos.real),G3(r,s.complexTensorInfos.imag)];return e.runWebGLProgram(o,i,i[0].dtype)}};class Tve{constructor(n){this.outputShape=[],this.outputShape=ii(n,1),this.variableNames=n.map((i,a)=>`T${a}`);const e=new Array(n.length-1);e[0]=n[0][1];for(let i=1;i<e.length;i++)e[i]=e[i-1]+n[i][1];const r=[`if (yC < ${e[0]}) setOutput(getT0(yR, yC));`];for(let i=1;i<e.length;i++)r.push(`else if (yC < ${e[i]}) setOutput(getT${i}(yR, yC-${e[i-1]}));`);r.push(`else setOutput(getT${e.length}(yR, yC-${e[e.length-1]}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${r.join("\n        ")}\n      }\n    `}}class Eve{constructor(n,e){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=ii(n,e);const r=this.outputShape,s=r.length,o=Qt(s),i=Xr("coords",s),a=["x","y","z","w","u","v"].slice(0,s);this.variableNames=n.map((g,m)=>`T${m}`);const l=new Array(n.length-1);l[0]=n[0][e];for(let g=1;g<l.length;g++)l[g]=l[g-1]+n[g][e];const u=a[e],c=a.slice(-2),d=a.join();let h=`if (${u} < ${l[0]}) {\n        return getChannel(\n            getT0(${d}), vec2(${c.join()}));\n        }`;for(let g=1;g<l.length;g++){const m=l[g-1];h+=`\n        if (${u} < ${l[g]}  && ${u} >= ${l[g-1]}) {\n          return getChannel(\n            getT${g}(${Wb(a,u,m)}),\n            vec2(${Wb(c,u,m)}));\n        }`}const f=l[l.length-1];h+=`\n        return getChannel(\n          getT${l.length}(${Wb(a,u,f)}),\n          vec2(${Wb(c,u,f)}));`,this.userCode=`\n      float getValue(${a.map(g=>"int "+g)}) {\n        ${h}\n      }\n\n      void main() {\n        ${o} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${i}), 0., 0., 0.);\n\n        ${i[s-1]} = ${i[s-1]} + 1;\n        if (${i[s-1]} < ${r[s-1]}) {\n          result.g = getValue(${i});\n        }\n\n        ${i[s-2]} = ${i[s-2]} + 1;\n        if (${i[s-2]} < ${r[s-2]}) {\n          result.a = getValue(${i});\n        }\n\n        ${i[s-1]} = ${i[s-1]} - 1;\n        if (${i[s-2]} < ${r[s-2]} &&\n            ${i[s-1]} < ${r[s-1]}) {\n          result.b = getValue(${i});\n        }\n        setOutput(result);\n      }\n    `}}function Wb(t,n,e){const r=t.indexOf(n);return t.map((o,i)=>i===r?`${o} - ${e}`:o).join()}function Gb(t){const{inputs:n,backend:e}=t,{input:r}=n;return Cs({inputs:{x:e.texData.get(r.dataId).complexTensorInfos.imag},backend:e})}const Nve={kernelName:P0,backendName:"webgl",kernelFunc:Gb};function Xp(t,n,e){const r=t[0].dtype;if("complex64"===r){const p=t.map(b=>Kp({inputs:{input:b},backend:e})),f=t.map(b=>Gb({inputs:{input:b},backend:e})),g=Xp(p,n,e),m=Xp(f,n,e),y=Ba({inputs:{real:g,imag:m},backend:e});return p.forEach(b=>e.disposeIntermediateTensorInfo(b)),f.forEach(b=>e.disposeIntermediateTensorInfo(b)),e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(m),y}let s=e.shouldExecuteOnCPU(t);if("string"===r&&(s=!0),s){const p=t.map(x=>{const C=[-1,G(x.shape.slice(n))];return fe({inputs:{x},backend:e,attrs:{shape:C}})}),f=p.map(x=>({vals:e.readSync(x.dataId),shape:x.shape})),g=ii(p.map(x=>x.shape),1),y=_ge(f,g,r,1===p[0].shape[0]),b=ii(t.map(x=>x.shape),n),v=e.makeTensorInfo(b,r,y);return p.forEach(x=>e.disposeIntermediateTensorInfo(x)),v}const o=t.filter(p=>G(p.shape)>0),i=L().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&o[0].shape.length>1;if(1===o.length){const p=i?new gi(t[0].shape,La):new Va(t[0].shape,La);return e.runWebGLProgram(p,t,r)}const a=L().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(o.length>a){const p=[];for(let g=0;g<o.length;g+=a){const m=o.slice(g,g+a);p.push(Xp(m,n,e))}const f=Xp(p,n,e);for(const g of p)e.disposeIntermediateTensorInfo(g);return f}if(i){const p=new Eve(o.map(f=>f.shape),n);return e.runWebGLProgram(p,o,r)}const{tensors2D:l,outShape:u}=function kve(t,n,e){const r=ii(t.map(o=>o.shape),n);return{tensors2D:t.map(o=>fe({inputs:{x:o},attrs:{shape:[-1,G(o.shape.slice(n))]},backend:e})),outShape:r}}(o,n,e),c=new Tve(l.map(p=>p.shape)),d=e.runWebGLProgram(c,l,r);l.forEach(p=>e.disposeIntermediateTensorInfo(p));const h=fe({inputs:{x:d},attrs:{shape:u},backend:e});return e.disposeIntermediateTensorInfo(d),h}function H3(t){const{inputs:n,backend:e,attrs:r}=t,{axis:s}=r,o=bt(s,n[0].shape)[0];gS(n.map(u=>u.shape),o);const a=ii(n.map(u=>u.shape),o);if(0===G(a))return e.makeTensorInfo(a,n[0].dtype,[]);const l=n.filter(u=>G(u.shape)>0);return 1===l.length?Cs({inputs:{x:l[0]},backend:e}):Xp(l,o,e)}const Ave={kernelName:gg,backendName:"webgl",kernelFunc:H3};class j3{constructor(n,e=!1,r=null,s=!1,o=!1){this.variableNames=["x","W"],this.outputShape=n.outShape;const i=n.padInfo.top,a=n.padInfo.left,l=n.strideHeight,u=n.strideWidth,c=n.dilationHeight,d=n.dilationWidth,h=n.filterHeight,p=n.filterWidth,f=4*Math.floor(n.inChannels/4),g=n.inChannels%4,m="channelsLast"===n.dataFormat,y=m?1:2,b=m?2:3,v=m?3:1;let x="",w="";r&&(x=s?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${r}\n        }`:o?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${r}\n        }`:`\n          float activation(float x) {\n            ${r}\n          }\n        `,w="result = activation(result);");const C=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${x}\n\n      const ivec2 strides = ivec2(${l}, ${u});\n      const ivec2 pads = ivec2(${i}, ${a});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${v}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${y}], coords[${b}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${h}; wR++) {\n          int xR = xRCorner + wR * ${c};\n\n          if (xR < 0 || xR >= ${n.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${p}; wC++) {\n            int xC = xCCorner + wC * ${d};\n\n            if (xC < 0 || xC >= ${n.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${f}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${m}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===g}) {\n\n              if (${m}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${f}) *\n                    getW(wR, wC, ${f}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${f}, xR, xC) *\n                    getW(wR, wC, ${f}, d2);\n              }\n\n            } else if (${2===g}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${f}, d2),\n                getW(wR, wC, ${f} + 1, d2)\n              );\n\n              if (${m}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${f}),\n                  getX(batch, xR, xC, ${f} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${f}, xR, xC),\n                  getX(batch, ${f} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===g}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${f}, d2),\n                getW(wR, wC, ${f} + 1, d2),\n                getW(wR, wC, ${f} + 2, d2)\n              );\n\n              if (${m}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${f}),\n                  getX(batch, xR, xC, ${f} + 1),\n                  getX(batch, xR, xC, ${f} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${f}, xR, xC),\n                  getX(batch, ${f} + 1, xR, xC),\n                  getX(batch, ${f} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${C}\n        ${w}\n        setOutput(result);\n      }\n    `}}class Rve{constructor(n){this.variableNames=["x","W"],this.outputShape=n.outShape;const e=n.padInfo.front,r=n.padInfo.top,s=n.padInfo.left,o=n.strideDepth,i=n.strideHeight,a=n.strideWidth,l=n.dilationDepth,u=n.dilationHeight,c=n.dilationWidth,d=n.filterDepth,h=n.filterHeight,p=n.filterWidth,f=4*Math.floor(n.inChannels/4),g=n.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${o}, ${i}, ${a});\n      const ivec3 pads = ivec3(${e}, ${r}, ${s});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${d}; wF++) {\n          int xF = xFCorner + wF * ${l};\n\n          if (xF < 0 || xF >= ${n.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${h}; wR++) {\n            int xR = xRCorner + wR * ${u};\n\n            if (xR < 0 || xR >= ${n.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${p}; wC++) {\n              int xC = xCCorner + wC * ${c};\n\n              if (xC < 0 || xC >= ${n.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${f}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===g}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${f}) *\n                  getW(wF, wR, wC, ${f}, d2);\n              } else if (${2===g}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${f}),\n                  getX(batch, xF, xR, xC, ${f} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${f}, d2),\n                  getW(wF, wR, wC, ${f} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===g}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${f}),\n                  getX(batch, xF, xR, xC, ${f} + 1),\n                  getX(batch, xF, xR, xC, ${f} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${f}, d2),\n                  getW(wF, wR, wC, ${f} + 1, d2),\n                  getW(wF, wR, wC, ${f} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class q3{constructor(n,e=!1,r=null,s=!1,o=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=n.outShape,this.enableShapeUniforms=Rr(this.outputShape.length);const i=n.padInfo.left,a=n.strideWidth,l=n.dilationWidth,u=n.filterHeight,c=n.filterWidth,d=c;let h="\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;";for(let m=0;m<c;m++)h+=`\n           vec4 xTexelC${2*m};\n           int xTexelC${2*m}Ready;\n           vec4 xTexelC${2*m+1};\n           int xTexelC${2*m+1}Ready;\n           vec4 xC${m};`;h+=`\n     for (int r = 0; r < ${u}; r++) {\n      for (int d1 = 0; d1 < ${n.inChannels}; d1 += 2) {\n       `;for(let m=0;m<c;m++)h+=`\n           xTexelC${2*m} = vec4(0.0);\n           xTexelC${2*m}Ready = 0;\n           xTexelC${2*m+1} = vec4(0.0);\n           xTexelC${2*m+1}Ready = 0;\n           xC${m} = vec4(0.0);`;h+="\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";for(let m=0;m<(d+1)/2;m++){const y=2*m;if(h+=`\n           xC = xCCorner + ${y*l};\n           `,1===a){if(y<c&&(i%2==1?(h+=`\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {\n                   xTexelC${y} = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${y}.zw = vec2(0.0);\n                   }\n                   xTexelC${y}Ready = 1;\n                 }\n               `,h+=1===l&&y>0?`\n                 xC${y} = vec4(xTexelC${y-2}.zw, xTexelC${y}.xy);\n                 `:`\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC${y} = vec4(previous.zw, xTexelC${y}.xy);\n                   } else {\n                     xC${y} = vec4(0.0, 0.0, xTexelC${y}.xy);\n                   }\n                   `):h+=`\n                 if (xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {\n                   xTexelC${y} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${y}.zw = vec2(0.0);\n                   }\n                   xTexelC${y}Ready = 1;\n                 }\n\n                 xC${y} = xTexelC${y};\n                 `,y+1<c)){const b=i%2==0?t0(l):l;l%2==0&&i%2==1||l%2!=0&&i%2!=1?(h+=`\n                   xCOffset = xC + imod(pads[1], 2) + ${b};\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {\n                     xTexelC${y+1} = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC${y+1}.zw = vec2(0.0);\n                     }\n                     xTexelC${y+1}Ready = 1;\n                   }\n                   `,h+=l>1?`\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC${y+1} = vec4(previous.zw, xTexelC${y+1}.xy);\n                     } else {\n                      xC${y+1} = vec4(0.0, 0.0, xTexelC${y+1}.xy);\n                     }\n                     `:`\n                     xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.xy);\n                     `):h+=1===b?`\n                     xC${y+1} = xTexelC${y};\n                     `:`\n                     xCOffset = xC + ${b};\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {\n                       xTexelC${y+1} = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC${y+1}.zw = vec2(0.0);\n                       }\n                       xTexelC${y+1}Ready = 1;\n                     }\n\n                     xC${y+1} = xTexelC${y+1};\n                     `}}else y<c&&(i%2==1?(h+=`\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {\n                   xTexelC${y} = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${y}.zw = vec2(0.0);\n                   }\n                   xTexelC${y}Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${y+1}Ready == 0) {\n                   xTexelC${y+1} = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC${y+1}.zw = vec2(0.0);\n                   }\n                   xTexelC${y+1}Ready = 1;\n                 }\n\n                 xC${y} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);\n               `,y+1<c&&(h+=`\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC${y+1} = vec4(xTexelC${y+1}.xy, final.xy);\n                 `)):(h+=`\n                 if(xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {\n                   xTexelC${y} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${y}.zw = vec2(0.0);\n                   }\n                   xTexelC${y}Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {\n                   xTexelC${y+1} = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${y+1}.zw = vec2(0.);\n                   }\n                   xTexelC${y+1}Ready = 1;\n                 }\n\n                 xC${y} = vec4(\n                   xTexelC${y}.xy, xTexelC${y+1}.xy);\n               `,y+1<c&&(h+=`\n                   xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);\n                 `)));y<c&&(h+=`\n             wTexel = getW(r, ${y}, d1, d2);\n             dotProd += xC${y}.xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ${n.inChannels}) {\n               dotProd += xC${y}.yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           `,y+1<c&&(h+=`\n               wTexel = getW(r, ${y+1}, d1, d2);\n               dotProd += xC${y+1}.xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ${n.inChannels}) {\n                 dotProd += xC${y+1}.yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             `))}h+="\n     }\n   ",h+="\n     }\n   ",h+="\n     }\n   ";let p="",f="";r&&(p=s?`vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ${r}\n         }`:o?`vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ${r}\n         }`:`vec4 activation(vec4 x) {\n           ${r}\n         }`,f="result = activation(result);");const g=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n       ${p}\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ${h}\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ${g}\n         ${f}\n         setOutput(result);\n       }\n     `}}class Fve{constructor(n,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=n,this.enableShapeUniforms=Rr(this.outputShape.length);const{dataFormat:r}=e,s=Kr(),o="channelsLast"===r,i=o?1:2,a=o?2:3,l=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${n[2]} && pos < ${n[1]}) {`;let u="";for(let c=0;c<=1;c++)for(let d=0;d<=1;d++)u+=`\n          blockIndex = rc.z + ${d};\n          pos = rc.y + ${c};\n\n          ${l}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${i}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${a}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${o}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*c+d}] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*c+d}] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${u}\n\n        ${s.output} = result;\n      }\n    `}}function Hb(t,n){const e=t.length;return e>=3?n?[...t.slice(0,-3),t[e-3]*t[e-2],t[e-1]]:[...t.slice(0,-3),t[e-3],t[e-2]*t[e-1]]:!n&&1===e&&t[0]>1?[t[0],1]:null}function K3({x:t,filter:n,convInfo:e,backend:r,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:a=null}){const l=t.shape,u=r.texData.get(t.dataId),c=e.inChannels,d=l[0]*l[1]*l[2],h=e.outChannels,p="channelsLast"===e.dataFormat;let m;const y=[];if(null!=o){const x=Hb(o.shape,p);null!=x&&(o=fe({inputs:{x:o},backend:r,attrs:{shape:x}}),y.push(o))}if(null!=s){const x=Hb(s.shape,p);null!=x&&(s=fe({inputs:{x:s},backend:r,attrs:{shape:x}}),y.push(s))}if((1!==d&&1!==h||!(c>O3))&&u.isPacked&&p&&null!=u.texture&&l[2]%2!=0&&Bt(u.shape.slice(-3),l.slice(-3))){const w={dataId:t.dataId,shape:[1,l[0]*l[1]*(l[2]+1),e.inChannels],dtype:t.dtype},C=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,_(Fb(u.shape,w.shape),()=>`packed reshape ${u.shape} to ${w.shape} isn't free`);const I=fe({inputs:{x:n},backend:r,attrs:{shape:[1,e.inChannels,e.outChannels]}});y.push(I);const D=zb({a:w,b:I,backend:r,transposeA:!1,transposeB:!1,bias:s,activation:a,preluActivationWeights:o,leakyreluAlpha:i}),E=r.texData.get(D.dataId);_(E.isPacked,()=>"batchMatMul result is expected to be packed"),u.shape=C,E.shape=e.outShape,m=Cs({inputs:{x:D},backend:r}),m.shape=e.outShape,y.push(D)}else{const x=e.outHeight*e.outWidth,w=fe({inputs:{x:t},backend:r,attrs:{shape:p?[e.batchSize,x,e.inChannels]:[e.batchSize,e.inChannels,x]}}),C=fe({inputs:{x:n},backend:r,attrs:{shape:[1,e.inChannels,e.outChannels]}}),I=zb({a:p?w:C,b:p?C:w,transposeA:!p,transposeB:!1,backend:r,bias:s,activation:a,preluActivationWeights:o,leakyreluAlpha:i});m=fe({inputs:{x:I},backend:r,attrs:{shape:e.outShape}}),y.push(w),y.push(C),y.push(I)}for(const x of y)r.disposeIntermediateTensorInfo(x);return m}function X3({x:t,filter:n,convInfo:e,backend:r,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:a=null}){const{filterWidth:l,filterHeight:u,inChannels:c,outWidth:d,outHeight:h,dataFormat:p}=e,f="channelsLast"===p,g=l*u*c,m=h*d,y=[e.batchSize,g,m],x=[];if(null!=o){const W=Hb(o.shape,f);null!=W&&(o=fe({inputs:{x:o},backend:r,attrs:{shape:W}}),x.push(o))}if(null!=s){const W=Hb(s.shape,f);null!=W&&(s=fe({inputs:{x:s},backend:r,attrs:{shape:W}}),x.push(s))}const w=fe({inputs:{x:n},backend:r,attrs:{shape:[1,g,G(n.shape)/g]}});x.push(w);const C=new Fve(y,e),D=r.runWebGLProgram(C,[t],"float32",[t.shape,[e.padInfo.top,e.padInfo.left],[e.strideHeight,e.strideWidth],[e.dilationHeight,e.dilationWidth],[e.inChannels],[e.filterWidth*e.inChannels],[e.outWidth]]),E=fe({inputs:{x:D},backend:r,attrs:{shape:y}});x.push(D),x.push(E);const N=null!=s,P=null!=o,V="leakyrelu"===a,B=a?jp(a,!0):null,z=new A3(f?E.shape:w.shape,f?w.shape:E.shape,f?[e.batchSize,m,e.outChannels]:[e.batchSize,e.outChannels,m],!0,!1,N,B,P,V),U=f?[E,w]:[w,E];if(s&&U.push(s),P&&U.push(o),V){const W=r.makeTensorInfo([],"float32",ga(i,"float32"));U.push(W),x.push(W)}const j=r.runWebGLProgram(z,U,"float32"),q=fe({inputs:{x:j},backend:r,attrs:{shape:e.outShape}});x.push(j);for(const W of x)r.disposeIntermediateTensorInfo(W);return q}const Pve={kernelName:yg,backendName:"webgl",kernelFunc:function Mve(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,filter:o}=n,{strides:i,pad:a,dataFormat:l,dilations:u,dimRoundingMode:c}=r,d=zi(l),h=cr(s.shape,o.shape,i,u,a,c,!1,d);let p;if(1!==h.filterHeight||1!==h.filterWidth||1!==h.dilationHeight||1!==h.dilationWidth||1!==h.strideHeight||1!==h.strideWidth||"SAME"!==h.padInfo.type&&"VALID"!==h.padInfo.type)if(h.strideWidth<=2&&"channelsLast"===d&&L().getBool("WEBGL_EXP_CONV")){const g=new q3(h);p=e.runWebGLProgram(g,[s,o],"float32",[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]])}else if(L().getBool("WEBGL_CONV_IM2COL"))p=X3({x:s,filter:o,convInfo:h,backend:e});else{const g=new j3(h);p=e.runWebGLProgram(g,[s,o],"float32")}else p=K3({x:s,filter:o,convInfo:h,backend:e});const f=fe({inputs:{x:p},backend:e,attrs:{shape:h.outShape}});return e.disposeIntermediateTensorInfo(p),f}};class Ove{constructor(n){this.variableNames=["x","dy"],this.outputShape=n.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${n.batchSize}; b++) {\n          for (int yR = 0; yR < ${n.outHeight}; yR++) {\n            int xR = wR + yR * ${n.strideHeight} - ${n.padInfo.top};\n\n            if (xR < 0 || xR >= ${n.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${n.outWidth}; yC++) {\n              int xC = wC + yC * ${n.strideWidth} - ${n.padInfo.left};\n\n              if (xC < 0 || xC >= ${n.inWidth}) {\n                continue;\n              }\n\n              ${"channelsLast"===n.dataFormat?"float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);":"float dyValue = getDy(b, d2, yR, yC);\n              float xValue = getX(b, d1, xR, xC);\n              dotProd += (xValue * dyValue);"}\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class $ve{constructor(n){this.variableNames=["dy","W"],this.outputShape=n.inShape;const e=n.filterHeight,r=n.filterWidth,i="channelsLast"===n.dataFormat;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-n.padInfo.top}, ${r-1-n.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${i?3:1}];\n\n        ivec2 dyCorner = ivec2(coords[${i?1:2}], coords[${i?2:3}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${n.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${n.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${r}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${n.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${r} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${n.outChannels}; d2++) {\n\n              if (${i}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Lve{constructor(n){this.variableNames=["x","dy"],this.outputShape=n.filterShape,this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${n.batchSize}; b++) {\n          for (int yF = 0; yF < ${n.outDepth}; yF++) {\n            int xF = wF + yF * ${n.strideDepth} - ${n.padInfo.front};\n\n            if (xF < 0 || xF >= ${n.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${n.outHeight}; yR++) {\n              int xR = wR + yR * ${n.strideHeight} - ${n.padInfo.top};\n\n              if (xR < 0 || xR >= ${n.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${n.outWidth}; yC++) {\n                int xC = wC + yC * ${n.strideWidth} - ${n.padInfo.left};\n\n                if (xC < 0 || xC >= ${n.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Vve{constructor(n){this.variableNames=["dy","W"],this.outputShape=n.inShape;const e=n.filterDepth,r=n.filterHeight,s=n.filterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${e-1-n.padInfo.front}, ${r-1-n.padInfo.top}, ${s-1-n.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${e}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${n.strideDepth}.0;\n\n          if (dyF < 0.0 || dyF >= ${n.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${e} - 1 - wF;\n\n          for (int wR = 0; wR < ${r}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${n.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${n.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${r} - 1 - wR;\n\n            for (int wC = 0; wC < ${s}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${n.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${s} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${n.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const zve={kernelName:v0,backendName:"webgl",kernelFunc:function Bve(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,dy:o}=n,{strides:i,pad:a,dataFormat:l,dimRoundingMode:u,filterShape:c}=r,d=zi(l),h=cr(s.shape,c,i,1,a,u,!1,d),p=new Ove(h);return e.runWebGLProgram(p,[s,o],"float32")}};class Uve{constructor(n){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=n.inShape,this.enableShapeUniforms=Rr(this.outputShape.length);const e=n.filterHeight,r=n.filterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-n.padInfo.top}, ${r-1-n.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        vec4 result = vec4(0.);\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / strides[0];\n          if (dyR < 0.0 || dyR >= ${n.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${r}; wC++) {\n            int wCPerm = ${r} - 1 - wC;\n\n            float dyC = float(dyCCorner + wC) / strides[1];\n            bool idyCVal = (dyC >= 0.0) && (dyC < ${n.outWidth}.0)\n              && (fract(dyC) == 0.0);\n            int idyC = int(dyC);\n\n            float dyC2 = float(dyCCorner + wC + 1) / strides[1];\n            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${n.outWidth}.0)\n              && (fract(dyC2) == 0.0);\n            int idyC2 = int(dyC2);\n\n            if (idyCVal && idyCVal2) {\n              for (int d2 = 0; d2 < ${n.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?\n                  dySample : getDy(batch, idyR, idyC2, d2);\n\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n\n                dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample2.xy : dySample2.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal) {\n              for (int d2 = 0; d2 < ${n.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal2) {\n              for (int d2 = 0; d2 < ${n.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC2, d2);\n                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            }\n          }\n        }\n        setOutput(result);\n      }\n    `}}const Gve={kernelName:bg,backendName:"webgl",kernelFunc:function Wve(t){const{inputs:n,backend:e,attrs:r}=t,{dy:s,filter:o}=n,{inputShape:i,strides:a,pad:l,dataFormat:u,dimRoundingMode:c}=r,d=zi(u),h=cr(i,o.shape,a,1,l,c,!1,d);if(L().getBool("WEBGL_PACK")&&"channelsLast"===d){const p=[[h.strideHeight,h.strideWidth]],f=new Uve(h);return e.runWebGLProgram(f,[s,o],"float32",p)}{const p=new $ve(h);return e.runWebGLProgram(p,[s,o],"float32")}}},jve={kernelName:vg,backendName:"webgl",kernelFunc:function Hve(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,filter:o}=n,{strides:i,pad:a,dilations:l}=r,u=Ca(s.shape,o.shape,i,l,a),c=new Rve(u);return e.runWebGLProgram(c,[s,o],"float32")}},Kve={kernelName:x0,backendName:"webgl",kernelFunc:function qve(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,dy:o}=n,{strides:i,pad:a,filterShape:l}=r,u=Ca(s.shape,l,i,1,a),c=new Lve(u);return e.runWebGLProgram(c,[s,o],"float32")}},Yve={kernelName:w0,backendName:"webgl",kernelFunc:function Xve(t){const{inputs:n,backend:e,attrs:r}=t,{dy:s,filter:o}=n,{pad:i,strides:a,inputShape:l}=r,u=Ca(l,o.shape,a,1,i),c=new Vve(u);return e.runWebGLProgram(c,[s,o],"float32")}},Jve=Ft({opSnippet:Oc+"\n  return cos(x);\n",packedOpSnippet:`\n  vec4 result = cos(x);\n  bvec4 isNaN = isnan(x);\n  ${jl}\n  return result;\n`}),exe={kernelName:vh,backendName:"webgl",kernelFunc:Jve},txe=Ft({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),nxe={kernelName:xh,backendName:"webgl",kernelFunc:txe};class rxe{constructor(n,e,r,s,o){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[i,a,l,u]=n,[c]=e,[d,h]=r;this.outputShape=[c,d,h,u];const p="bilinear"===s?1:0,[f,g]=[a-1+".0",l-1+".0"],[m,y,b]=d>1?[""+(a-1)/(d-1),"(y2-y1) * height_ratio",`y1*${f} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${f}`],[v,x,w]=h>1?[""+(l-1)/(h-1),"(x2-x1) * width_ratio",`x1*${g} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${g}`];this.userCode=`\n      const float height_ratio = float(${m});\n      const float width_ratio = float(${v});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${i}) {\n          return;\n        }\n\n        float height_scale = ${y};\n        float width_scale = ${x};\n\n        float in_y = ${b};\n        if( in_y < 0.0 || in_y > ${f} ) {\n          setOutput(float(${o}));\n          return;\n        }\n        float in_x = ${w};\n        if( in_x < 0.0 || in_x > ${g} ) {\n          setOutput(float(${o}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${p} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}const sxe={kernelName:_0,backendName:"webgl",kernelFunc:t=>{const{inputs:n,backend:e,attrs:r}=t,{image:s,boxes:o,boxInd:i}=n,{cropSize:a,method:l,extrapolationValue:u}=r,c=new rxe(s.shape,o.shape,a,l,u);return e.runWebGLProgram(c,[s,o,i],"float32")}};var Lc=(()=>{return(t=Lc||(Lc={})).Prod="*",t.Sum="+",Lc;var t})();class Y3{constructor(n,e,r,s){this.op=n,this.outputShape=e,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const o=this.outputShape.length,a=r?this.op===Lc.Prod?"1.0":"0.0":`getX(${Z3(o,"coords",this.op)})`,l=this.outputShape[this.outputShape.length-1];let u="",c="";r?(u=s?"end != "+(l-1):"end != 0",c=s?"end + 1":"end - 1"):(u=s?`end + pow2 < ${l}`:"end >= pow2",c=s?"end + pow2":"end - pow2"),this.userCode=`\n      void main() {\n        ${Qt(o)} coords = getOutputCoords();\n        int end = ${Q3(o,"coords",this.op)};\n        float val = ${a};\n        int pow2 = int(pow(2.0, index));\n        if (${u}) {\n          int idx = ${c};\n          ${Q3(o,"coords",this.op)} = idx;\n          val ${this.op}= getX(${Z3(o,"coords",this.op)});\n        }\n        setOutput(val);\n      }\n    `}}function Z3(t,n,e){if(1===t)return`${n}`;if(2===t)return`${n}.x, ${n}.y`;if(3===t)return`${n}.x, ${n}.y, ${n}.z`;if(4===t)return`${n}.x, ${n}.y, ${n}.z, ${n}.w`;throw new Error(`Cumulative ${e} for rank ${t} is not yet supported`)}function Q3(t,n,e){if(1===t)return`${n}`;if(2===t)return`${n}.y`;if(3===t)return`${n}.z`;if(4===t)return`${n}.w`;throw new Error(`Cumulative ${e} for rank ${t} is not yet supported`)}function J3(t,n,e,r,s,o){const i=n.shape.length,a=Cn([r],i);let l=n;null!=a&&(l=Yr({inputs:{x:n},backend:e,attrs:{perm:a}}));const u=$n(1,i)[0];if(u!==i-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${n.shape.length-1} but got axis=${r}`);const c=l.shape[u];let d=Cs({inputs:{x:l},backend:e});for(let h=0;h<=Math.ceil(Math.log2(c))-1;h++){const p=new Y3(t,l.shape,!1,o),g=d;d=e.runWebGLProgram(p,[d],d.dtype,[[h]]),e.disposeIntermediateTensorInfo(g)}if(s){const h=new Y3(t,l.shape,s,o),p=d;d=e.runWebGLProgram(h,[d],d.dtype),e.disposeIntermediateTensorInfo(p)}if(null!=a){const p=Yr({inputs:{x:d},backend:e,attrs:{perm:Sa(a)}});return e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(l),p}return d}const ixe={kernelName:C0,backendName:"webgl",kernelFunc:function oxe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o,exclusive:i,reverse:a}=r;return J3(Lc.Prod,s,e,o,i,a)}},lxe={kernelName:xg,backendName:"webgl",kernelFunc:function axe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o,exclusive:i,reverse:a}=r;return J3(Lc.Sum,s,e,o,i,a)}},cxe={kernelName:S0,backendName:"webgl",kernelFunc:function uxe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,weights:o}=n,{size:i,binaryOutput:a}=r;if(1===s.shape.length){const l=e.readSync(s.dataId),u=e.readSync(o.dataId),c=b3(l,u,o.dtype,o.shape,i);return e.makeTensorInfo([i],o.dtype,c)}if(2===s.shape.length){const l=e.bufferSync(s),u=e.bufferSync(o),c=xge(l,u,i,a);return e.makeTensorInfo(c.shape,o.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}};class dxe{constructor(n,e,r){this.variableNames=["x"],this.outputShape=[],this.outputShape=n,this.blockSize=e,this.dataFormat=r,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${e};\n      int offset_h = imod(h, ${e});\n      int in_w = w / ${e};\n      int offset_w = imod(w, ${e});\n      int offset_d = (offset_h * ${e} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const pxe={kernelName:I0,backendName:"webgl",kernelFunc:function hxe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{blockSize:o,dataFormat:i}=r,a=s.shape[0],d=("NHWC"===i?s.shape[1]:s.shape[2])*o,h=("NHWC"===i?s.shape[2]:s.shape[3])*o,p=("NHWC"===i?s.shape[3]:s.shape[1])/(o*o),g=new dxe("NHWC"===i?[a,d,h,p]:[a,p,d,h],o,i);return e.runWebGLProgram(g,[s],s.dtype)}};class eB{constructor(n,e=!1,r=null,s=!1,o=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=n.outShape,this.enableShapeUniforms=Rr(this.outputShape.length);const i=n.filterHeight,a=n.filterWidth,l=n.outChannels/n.inChannels;let u="",c="";r&&(u=s?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${r}\n        }`:o?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${r}\n        }`:`\n          float activation(float x) {\n            ${r}\n          }\n        `,c="result = activation(result);");const d=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${u}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${l};\n        int q = d2 - d1 * ${l};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${i}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${a}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${d}\n        ${c}\n        setOutput(result);\n      }\n    `}}class tB{constructor(n,e=!1,r=null,s=!1,o=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=n.outShape,this.enableShapeUniforms=Rr(this.outputShape.length);const i=n.outChannels/n.inChannels,a=n.padInfo.left,l=n.strideWidth,u=n.dilationWidth,c=n.filterHeight,d=n.filterWidth,h=d;let p="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let y=0;y<d;y++)p+=`\n          vec4 xTexelC${2*y};\n          int xTexelC${2*y}Ready;\n          vec4 xTexelC${2*y+1};\n          int xTexelC${2*y+1}Ready;\n          vec4 xC${y};`;p+=`\n    for (int r = 0; r < ${c}; r++) {\n      `;for(let y=0;y<d;y++)p+=`\n          xTexelC${2*y} = vec4(0.0);\n          xTexelC${2*y}Ready = 0;\n          xTexelC${2*y+1} = vec4(0.0);\n          xTexelC${2*y+1}Ready = 0;\n          xC${y} = vec4(0.0);`;p+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let y=0;y<(h+1)/2;y++){const b=2*y;if(p+=`\n          xC = xCCorner + ${b*u};\n          `,1===l){if(b<d&&(a%2==1?(p+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {\n                  xTexelC${b} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${b}.zw = vec2(0.0);\n                  }\n                  xTexelC${b}Ready = 1;\n                }\n              `,p+=1===u&&b>0?`\n                xC${b} = vec4(xTexelC${b-2}.zw, xTexelC${b}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${b} = vec4(previous.zw, xTexelC${b}.xy);\n                  } else {\n                    xC${b} = vec4(0.0, 0.0, xTexelC${b}.xy);\n                  }\n                  `):p+=`\n                if (xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {\n                  xTexelC${b} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${b}.zw = vec2(0.0);\n                  }\n                  xTexelC${b}Ready = 1;\n                }\n\n                xC${b} = xTexelC${b};\n                `,b+1<d)){const v=a%2==0?t0(u):u;u%2==0&&a%2==1||u%2!=0&&a%2!=1?(p+=`\n                  xCOffset = xC + imod(pads[1], 2) + ${v};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {\n                    xTexelC${b+1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${b+1}.zw = vec2(0.0);\n                    }\n                    xTexelC${b+1}Ready = 1;\n                  }\n                  `,p+=u>1?`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC${b+1} = vec4(previous.zw, xTexelC${b+1}.xy);\n                    } else {\n                     xC${b+1} = vec4(0.0, 0.0, xTexelC${b+1}.xy);\n                    }\n                    `:`\n                    xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.xy);\n                    `):p+=1===v?`\n                    xC${b+1} = xTexelC${b};\n                    `:`\n                    xCOffset = xC + ${v};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {\n                      xTexelC${b+1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${b+1}.zw = vec2(0.0);\n                      }\n                      xTexelC${b+1}Ready = 1;\n                    }\n\n                    xC${b+1} = xTexelC${b+1};\n                    `}}else b<d&&(a%2==1?(p+=`\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {\n                  xTexelC${b} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${b}.zw = vec2(0.0);\n                  }\n                  xTexelC${b}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${b+1}Ready == 0) {\n                  xTexelC${b+1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${b+1}.zw = vec2(0.0);\n                  }\n                  xTexelC${b+1}Ready = 1;\n                }\n\n                xC${b} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);\n              `,b+1<d&&(p+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${b+1} = vec4(xTexelC${b+1}.xy, final.xy);\n                `)):(p+=`\n                if(xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {\n                  xTexelC${b} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${b}.zw = vec2(0.0);\n                  }\n                  xTexelC${b}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {\n                  xTexelC${b+1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${b+1}.zw = vec2(0.);\n                  }\n                  xTexelC${b+1}Ready = 1;\n                }\n\n                xC${b} = vec4(\n                  xTexelC${b}.xy, xTexelC${b+1}.xy);\n              `,b+1<d&&(p+=`\n                  xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);\n                `)));b<d&&(p+=`\n            wTexel = getW(r, ${b}, d1, q);\n            dotProd += xC${b} * vec4(wTexel.xz, wTexel.xz);\n          `,b+1<d&&(p+=`\n              wTexel = getW(r, ${b+1}, d1, q);\n              dotProd += xC${b+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}p+="\n    }\n  ",p+="\n      }\n    ";let f="",g="";r&&(f=s?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${r}\n        }`:o?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${r}\n        }`:`vec4 activation(vec4 x) {\n          ${r}\n        }`,g="result = activation(result);");const m=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${f}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${i};\n        int q = d2 - d1 * ${i};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${p}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${m}\n        ${g}\n        setOutput(result);\n      }\n    `}}const mxe={kernelName:wg,backendName:"webgl",kernelFunc:function fxe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,filter:o}=n,{strides:i,pad:a,dilations:l,dimRoundingMode:u}=r;let c=l;null==c&&(c=[1,1]),_(vr(i,c),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);const d=cr(s.shape,o.shape,i,c,a,u,!0);let h;return h=L().getBool("WEBGL_PACK_DEPTHWISECONV")&&d.strideWidth<=2&&d.outChannels/d.inChannels==1?new tB(d):new eB(d),e.runWebGLProgram(h,[s,o],"float32",[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]])}};class gxe{constructor(n){this.variableNames=["x","dy"],this.outputShape=n.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${n.outChannels/n.inChannels} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${n.batchSize}; b++) {\n          for (int yR = 0; yR < ${n.outHeight}; yR++) {\n            int xR = wR + yR * ${n.strideHeight} - ${n.padInfo.top};\n\n            if (xR < 0 || xR >= ${n.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${n.outWidth}; yC++) {\n              int xC = wC + yC * ${n.strideWidth} - ${n.padInfo.left};\n\n              if (xC < 0 || xC >= ${n.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class yxe{constructor(n){this.variableNames=["dy","W"],this.outputShape=n.inShape;const e=n.filterHeight,r=n.filterWidth,l=n.outChannels/n.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-n.padInfo.top}, ${r-1-n.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${n.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${n.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${r}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${n.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${r} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${l}; dm++) {\n              int d2 = d1 * ${l} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const vxe={kernelName:D0,backendName:"webgl",kernelFunc:function bxe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,dy:o}=n,{strides:i,dilations:a,pad:l,dimRoundingMode:u,filterShape:c}=r,d=cr(s.shape,c,i,a,l,u,!0),h=new gxe(d);return e.runWebGLProgram(h,[s,o],"float32")}},wxe={kernelName:T0,backendName:"webgl",kernelFunc:function xxe(t){const{inputs:n,backend:e,attrs:r}=t,{dy:s,filter:o}=n,{strides:i,dilations:a,pad:l,dimRoundingMode:u,inputShape:c}=r,d=cr(c,o.shape,i,a,l,u,!0),h=new yxe(d);return e.runWebGLProgram(h,[s,o],"float32")}};class Cxe{constructor(n){this.variableNames=["X"],this.outputShape=[n,n],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const Sxe={kernelName:"Diag",backendName:"webgl",kernelFunc:function _xe(t){const{inputs:n,backend:e}=t,{x:r}=n,s=[...r.shape,...r.shape],o=G(r.shape),i=fe({inputs:{x:r},backend:e,attrs:{shape:[o]}}),a=new Cxe(o),l=e.runWebGLProgram(a,[i],i.dtype),u=fe({inputs:{x:l},backend:e,attrs:{shape:s}});return e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(l),u}};class Ixe{constructor(n){this.variableNames=["x","W"],this.outputShape=n.outShape;const{inHeight:e,inWidth:r,padInfo:s,strideHeight:o,strideWidth:i,filterHeight:a,filterWidth:l,dilationHeight:u,dilationWidth:c}=n,{top:d,left:h}=s;this.userCode=`\n      const ivec2 strides = ivec2(${o}, ${i});\n      const ivec2 pads = ivec2(${d}, ${h});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${a}; h++) {\n          int hIn = hBeg + h * ${u};\n\n          if (hIn >= 0 && hIn < ${e}) {\n            for (int w = 0; w < ${l}; w++) {\n              int wIn = wBeg + w * ${c};\n\n              if (wIn >= 0 && wIn < ${r}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}const Txe={kernelName:Cg,backendName:"webgl",kernelFunc:function Dxe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,filter:o}=n,{strides:i,pad:a,dilations:l}=r,u=pp(s.shape,o.shape,i,a,"NHWC",l);let c;const d=new Ixe(u);c=e.runWebGLProgram(d,[s,o],"float32");const h=fe({inputs:{x:c},backend:e,attrs:{shape:u.outShape}});return e.disposeIntermediateTensorInfo(c),h}},Nxe={kernelName:"Einsum",backendName:"webgl",kernelFunc:function Exe(t){const{inputs:n,backend:e,attrs:r}=t,{equation:s}=r,o=n,{allDims:i,summedDims:a,idDims:l}=kS(s,o.length);RS(i.length,l,o);const{path:u,steps:c}=FS(a,l),d=c.length;let h=null,p=i.length;const f=[];for(let g=0;g<d;++g){for(const m of c[g]){const{permutationIndices:y,expandDims:b}=AS(p,l[m]);let v;MS(y)?v=o[m]:(v=Yr({inputs:{x:o[m]},backend:e,attrs:{perm:y}}),f.push(v));const x=v.shape.slice();for(let w=0;w<b.length;++w)x.splice(b[w],0,1);Bt(v.shape,x)||(v=fe({inputs:{x:v},backend:e,attrs:{shape:x}}),f.push(v)),null===h?h=v:(h=a1({inputs:{a:v,b:h},backend:e}),f.push(h))}g<d-1&&(u[g]>=0&&(h=Bb({inputs:{x:h},backend:e,attrs:{axis:u[g]-(i.length-p),keepDims:!1}}),f.push(h)),p--)}for(const g of f)g!==h&&e.disposeIntermediateTensorInfo(g);return h}},kxe=Ft({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),Axe={kernelName:Ch,backendName:"webgl",kernelFunc:kxe},Mxe={kernelName:k0,backendName:"webgl",kernelFunc:t=>{const{inputs:n,backend:e}=t,{dy:r,y:s}=n,o=L().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Hp("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",r.shape,s.shape):new Pc("return (b >= 0.0) ? a : a * (b + 1.0);",r.shape,s.shape);return e.runWebGLProgram(o,[r,s],r.dtype)}},Pxe=wr({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:Sge}),Oxe={kernelName:_g,backendName:"webgl",kernelFunc:Pxe},Lxe=Ft({opSnippet:`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${CS};\n  float a1 = ${_S};\n  float a2 = ${SS};\n  float a3 = ${IS};\n  float a4 = ${DS};\n  float a5 = ${TS};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`}),Vxe={kernelName:_h,backendName:"webgl",kernelFunc:Lxe},nB=Ft({opSnippet:Oc+"\n  return exp(x);\n",packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:Ige,dtype:"float32"}),zxe={kernelName:Sh,backendName:"webgl",kernelFunc:nB};function d1(t){const{inputs:n,attrs:e,backend:r}=t,{dim:s}=e,{input:o}=n,i=o.shape.length,a=o.shape.slice();let l=s;return s<0&&(_(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+s+1),a.splice(l,0,1),fe({inputs:{x:o},backend:r,attrs:{shape:a}})}const Uxe={kernelName:Sg,backendName:"webgl",kernelFunc:d1},rB="return exp(x) - 1.0;",Wxe=Ft({opSnippet:rB,packedOpSnippet:rB,cpuKernelImpl:Dge}),Gxe={kernelName:Ih,backendName:"webgl",kernelFunc:Wxe};class sB{constructor(n,e,r){this.variableNames=["real","imag"];const s=e[1];this.outputShape=e;const o=r?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,i=r?`${s}.0`:"1.0";let a;if("real"===n)a="return real * expR - imag * expI;";else{if("imag"!==n)throw new Error(`FFT component must be either "real" or "imag", got ${n}.`);a="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${o};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${a}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${s});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${s}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${i};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}function oB(t,n,e){const r=e.texData.get(t.dataId),s=G(t.shape),o=t.shape[t.shape.length-1],a=fe({inputs:{x:t},backend:e,attrs:{shape:[s/o,o]}}),l=a.shape,u=new sB("real",l,n),c=new sB("imag",l,n),d=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:l},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:l}],h=e.runWebGLProgram(u,d,"float32"),p=e.runWebGLProgram(c,d,"float32"),f=Ba({inputs:{real:h,imag:p},backend:e});e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(p);const g=fe({inputs:{x:f},backend:e,attrs:{shape:t.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(f),g}const jxe={kernelName:"FFT",backendName:"webgl",kernelFunc:function Hxe(t){const{inputs:n,backend:e}=t,{input:r}=n;return oB(r,!1,e)}};class qxe{constructor(n,e){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=n,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}}function Yp(t){const{backend:n,attrs:e}=t,{shape:r,value:s}=e;let{dtype:o}=e;if(o=o||Ju(s),"string"===o){const i=Mn(o,G(r));return i.fill(s),n.makeTensorInfo(r,o,i)}{const i=new qxe(r,s);return n.runWebGLProgram(i,[],o,[[s]])}}const Kxe={kernelName:R0,backendName:"webgl",kernelFunc:Yp};class Xxe{constructor(n){this.variableNames=["Image"],this.outputShape=[];const e=n[2];this.outputShape=n,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${e} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${e}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const Yxe={kernelName:F0,backendName:"webgl",kernelFunc:({inputs:t,backend:n})=>{const{image:e}=t,r=n,s=new Xxe(e.shape);return r.runWebGLProgram(s,[e],e.dtype)}},iB="return floor(x);",Zxe=Ft({opSnippet:iB,packedOpSnippet:iB,cpuKernelImpl:Tge}),Qxe={kernelName:Dh,backendName:"webgl",kernelFunc:Zxe},Jxe=wr({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),ewe={kernelName:Th,backendName:"webgl",kernelFunc:Jxe};class twe{constructor(n){this.variableNames=["A"];const e=Kr(),[r,s]=n;this.outputShape=n,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}.0, ${r}.0);\n\n        vec4 values = ${e.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}class nwe{constructor(n){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const e=Kr(),[r,s]=n;this.outputShape=n,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${s}.0, ${r}.0);\n            vec4 values = ${e.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${e.output} = result;\n      }\n    `}}const rwe={kernelName:"FromPixels",backendName:"webgl",kernelFunc:function swe(t){const{inputs:n,backend:e,attrs:r}=t;let{pixels:s}=n;const{numChannels:o}=r,i=typeof HTMLVideoElement<"u"&&s instanceof HTMLVideoElement,a=typeof HTMLImageElement<"u"&&s instanceof HTMLImageElement,[l,u]=i?[s.videoWidth,s.videoHeight]:[s.width,s.height],c=[u,l],d=[u,l,o];if(a||i){const g=L().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(null==Vc||g!==h1)&&(h1=g,Vc=document.createElement("canvas").getContext("2d",{willReadFrequently:h1})),Vc.canvas.width=l,Vc.canvas.height=u,Vc.drawImage(s,0,0,l,u),s=Vc.canvas}const h=e.makeTensorInfo(c,"int32");e.texData.get(h.dataId).usage=ws.PIXELS,e.gpgpu.uploadPixelDataToTexture(e.getTexture(h.dataId),s);const p=L().getBool("WEBGL_PACK")?new nwe(d):new twe(d),f=e.runWebGLProgram(p,[h],"int32");return e.disposeData(h.dataId),f}};let Vc,h1=L().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");const iwe={kernelName:cy,backendName:"webgl",kernelFunc:function owe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,filter:o,bias:i,preluActivationWeights:a}=n,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=r,g=zi(c),m=cr(s.shape,o.shape,l,d,u,h,!1,g);let y;const b=[],v=null!=i,x=null!=a,w="leakyrelu"===p,C=()=>{const D=[s,o],E=(N,P)=>{if("NCHW"===P&&1===N.shape.length&&1!==N.shape[0]){const V=fe({inputs:{x:N},backend:e,attrs:{shape:[N.shape[0],1,1]}});return b.push(V),V}return N};if(v&&D.push(E(i,c)),x&&D.push(E(a,c)),w){const N=e.makeTensorInfo([],"float32",ga(f,"float32"));D.push(N),b.push(N)}return D};if(1!==m.filterHeight||1!==m.filterWidth||1!==m.dilationHeight||1!==m.dilationWidth||1!==m.strideHeight||1!==m.strideWidth||"SAME"!==m.padInfo.type&&"VALID"!==m.padInfo.type)if(m.strideWidth<=2&&"channelsLast"===g&&L().getBool("WEBGL_EXP_CONV")){const D=p?jp(p,!0):null,E=new q3(m,v,D,x,w),N=[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]],P=C();y=e.runWebGLProgram(E,P,"float32",N)}else if(L().getBool("WEBGL_CONV_IM2COL"))y=X3({x:s,filter:o,convInfo:m,backend:e,bias:i,activation:p,preluActivationWeights:a,leakyreluAlpha:f});else{const D=p?jp(p,!1):null,E=new j3(m,v,D,x,w),N=C();y=e.runWebGLProgram(E,N,"float32")}else y=K3({x:s,filter:o,convInfo:m,backend:e,bias:i,activation:p,preluActivationWeights:a,leakyreluAlpha:f});const I=fe({inputs:{x:y},backend:e,attrs:{shape:m.outShape}});return b.push(y),b.forEach(D=>e.disposeIntermediateTensorInfo(D)),I}},lwe={kernelName:dy,backendName:"webgl",kernelFunc:function awe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,filter:o,bias:i,preluActivationWeights:a}=n,{strides:l,pad:u,dilations:c,dimRoundingMode:d,activation:h,leakyreluAlpha:p}=r,f=[];let g=c;null==g&&(g=[1,1]),_(vr(l,g),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${g}'`);const m=cr(s.shape,o.shape,l,g,u,d,!0),y=L().getBool("WEBGL_PACK_DEPTHWISECONV")&&m.strideWidth<=2&&m.outChannels/m.inChannels==1,b=h?jp(h,y):null,v=[s,o],x=null!=i,w=null!=a,C="leakyrelu"===h;if(x&&v.push(i),w&&v.push(a),C){const N=e.makeTensorInfo([],"float32",ga(p,"float32"));v.push(N),f.push(N)}let I;I=y?new tB(m,x,b,w,C):new eB(m,x,b,w,C);const E=e.runWebGLProgram(I,v,"float32",[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]]);return f.forEach(N=>e.disposeIntermediateTensorInfo(N)),E}};class uwe{constructor(n,e,r,s){this.sliceDim=n,this.strides=e,this.paramsShape=s,this.variableNames=["x","indices"],this.outputShape=r;const o=Qt(r.length);let i="\n    int index;";for(let a=0;a<this.sliceDim;a++)i+=`\n          index = round(getIndices(coords[0], ${a}));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[a]};\n          flattenIndex += index * ${this.strides[a]};`;this.userCode=`\n         void main() {\n          ${o} coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ${i}\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      `}}const dwe={kernelName:rM,backendName:"webgl",kernelFunc:function cwe(t){const{inputs:n,backend:e}=t,{params:r,indices:s}=n,o=s.shape,i=o[o.length-1],a=G(r.shape),[l,u,c,d]=wS(r,s),h=fe({inputs:{x:s},backend:e,attrs:{shape:[u,i]}}),p=fe({inputs:{x:r},backend:e,attrs:{shape:[G(r.shape)/c,c]}});if(e.shouldExecuteOnCPU([r,s])||"string"===r.dtype){const y=e.readSync(s.dataId),b=e.bufferSync(r),v=Ege(y,b,r.dtype,u,i,c,d,r.shape,a);return e.makeTensorInfo(l,r.dtype,v.values)}const f=new uwe(i,d,[u,c],r.shape),g=e.runWebGLProgram(f,[p,h],p.dtype),m=fe({inputs:{x:g},backend:e,attrs:{shape:l}});return e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(g),m}};class hwe{constructor(n,e){this.variableNames=["A","indices"],this.outputShape=e,this.rank=e.length;const r=Qt(this.rank),s=function pwe(t,n){const e=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let s=0;s<t.length;s++)r.push(2===s?"index":`${e[s]}`);return r.join()}(n);this.userCode=`\n      void main() {\n        ${r} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${n[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${s}));\n      }\n    `}}function aB(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,indices:o}=n,{axis:i,batchDims:a}=r,l=bt(i,s.shape)[0];if(L().get("DEBUG")){const b=e.readSync(o.dataId),v=s.shape[l];for(let x=0;x<b.length;++x){const w=b[x];_(w<=v-1&&w>=0,()=>`GatherV2: the index value ${w} is not in [0, ${v-1}]`)}}const u=$S(s,o,l,a),c=G(o.shape),d=[],h=fe({inputs:{x:s},backend:e,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),p=fe({inputs:{x:o},backend:e,attrs:{shape:[u.batchSize,c/u.batchSize]}});d.push(h),d.push(p);const f=[u.batchSize,u.outerSize,c/u.batchSize,u.sliceSize];if(e.shouldExecuteOnCPU([s,o])||"string"===s.dtype){const b=e.bufferSync(p),v=e.bufferSync(h),x=Nge(v,b,f);return d.forEach(w=>e.disposeIntermediateTensorInfo(w)),e.makeTensorInfo(u.outputShape,x.dtype,x.values)}const g=new hwe(h.shape,f),m=e.runWebGLProgram(g,[h,p],h.dtype);d.push(m);const y=fe({inputs:{x:m},backend:e,attrs:{shape:u.outputShape}});return d.forEach(b=>e.disposeIntermediateTensorInfo(b)),y}const fwe={kernelName:Dg,backendName:"webgl",kernelFunc:aB},mwe=wr({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:kge,dtype:"bool"}),gwe={kernelName:Tg,backendName:"webgl",kernelFunc:mwe},ywe=wr({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:Age}),bwe={kernelName:Eh,backendName:"webgl",kernelFunc:ywe},xwe={kernelName:M0,backendName:"webgl",kernelFunc:function vwe(t){const{inputs:n,backend:e}=t,{input:r}=n;return oB(r,!0,e)}},wwe=Ft({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),Cwe={kernelName:kh,backendName:"webgl",kernelFunc:wwe},_we=Ft({opSnippet:"return float(isinf(x));",dtype:"bool"}),Swe={kernelName:Ah,backendName:"webgl",kernelFunc:_we},Iwe=Ft({opSnippet:"return float(isnan(x));",dtype:"bool"}),Dwe={kernelName:Rh,backendName:"webgl",kernelFunc:Iwe},Twe=wr({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:Rge,dtype:"bool"}),Ewe={kernelName:Ng,backendName:"webgl",kernelFunc:Twe},Nwe=wr({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:Fge,dtype:"bool"}),kwe={kernelName:kg,backendName:"webgl",kernelFunc:Nwe},Rwe={kernelName:sM,backendName:"webgl",kernelFunc:function Awe(t){const{backend:n,attrs:e}=t,{start:r,stop:s,num:o}=e,i=Mge(r,s,o);return n.makeTensorInfo([i.length],"float32",i)}},Mwe=Ft({opSnippet:Oc+"\n  return x < 0.0 ? 0./0. : log(x);\n",packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:Pge}),Pwe={kernelName:Fh,backendName:"webgl",kernelFunc:Mwe},$we=Ft({opSnippet:Oc+"\n  return log(1.0 + x);\n"}),Lwe={kernelName:Mh,backendName:"webgl",kernelFunc:$we},Vwe=wr({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),Bwe={kernelName:Ag,backendName:"webgl",kernelFunc:Vwe},zwe=Ft({opSnippet:"return float(!(x >= 1.0));"}),Uwe={kernelName:Rg,backendName:"webgl",kernelFunc:zwe},Wwe=wr({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),Gwe={kernelName:Fg,backendName:"webgl",kernelFunc:Wwe};class Hwe{constructor(n,e,r,s,o){this.variableNames=["x"],this.outputShape=[];const i=e,a=n[3]-1;let l;this.outputShape=n;const u=`float(${r}) + float(${s}) * sum`;l=.5===o?`inversesqrt(${u})`:1===o?`1.0/(${u})`:`exp(log(${u}) * float(-${o}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${i}; j <= ${i}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${a}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${l};\n        setOutput(val);\n      }\n    `}}class jwe{constructor(n,e,r,s,o){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const i=e,a=n[3]-1;let l;this.outputShape=n;const u=`float(${r}) + float(${s}) * sum`;l=.5===o?`inversesqrt(${u})`:1===o?`1.0/(${u})`:`exp(log(${u}) * float(-${o}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${i};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${i}; j <= ${i}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${l};\n        setOutput(result);\n      }\n    `}}const qwe={kernelName:Mg,backendName:"webgl",kernelFunc:t=>{const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{depthRadius:o,bias:i,alpha:a,beta:l}=r,u=L().getBool("WEBGL_PACK_NORMALIZATION")?new jwe(s.shape,o,i,a,l):new Hwe(s.shape,o,i,a,l);return e.runWebGLProgram(u,[s],s.dtype)}};class Kwe{constructor(n,e,r,s,o){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=n,this.depth=n[3],this.depthRadius=e,this.bias=r,this.alpha=s,this.beta=o,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${e})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${e} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${s}) * norm + float(${r});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${s})\n                * float(${o})\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${o});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}const Xwe={kernelName:O0,backendName:"webgl",kernelFunc:t=>{const{inputs:n,backend:e,attrs:r}=t,{x:s,y:o,dy:i}=n,{depthRadius:a,bias:l,alpha:u,beta:c}=r,d=new Kwe(s.shape,a,l,u,c);return e.runWebGLProgram(d,[s,o,i],s.dtype)}};function lB(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{reductionIndices:o,keepDims:i}=r,a=s.shape.length,l=bt(o,s.shape);let u=l;const c=Cn(u,a),d=null!=c,h=e.shouldExecuteOnCPU([s]);let p=s;if(d){if(h){const v=e.texData.get(p.dataId).values,x=new Array(a);for(let I=0;I<x.length;I++)x[I]=s.shape[c[I]];const w=o1(v,s.shape,s.dtype,c,x);p=e.makeTensorInfo(x,s.dtype),e.texData.get(p.dataId).values=w}else p=Vb(s,c,e);u=$n(u.length,a)}xr("max",u,a);const[f,g]=dr(p.shape,u);let y,m=f;if(i&&(m=On(f,l)),h){const v=e.texData.get(p.dataId).values,x=Oge(v,G(g),m,s.dtype);y=e.makeTensorInfo(m,s.dtype),e.texData.get(y.dataId).values=x}else y=function Ywe(t,n,e,r){const s=G(n),a=fe({inputs:{x:t},attrs:{shape:[G(t.shape)/s,s]},backend:r}),l=ql(a,t.dtype,"max",r),u=fe({inputs:{x:l},attrs:{shape:e},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(l),u}(p,g,m,e);return d&&e.disposeIntermediateTensorInfo(p),y}const Zwe={kernelName:Pg,backendName:"webgl",kernelFunc:lB},eCe=wr({opSnippet:i1+"\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+jl+"\n  return result;\n",cpuKernelImpl:$ge}),tCe={kernelName:Ph,backendName:"webgl",kernelFunc:eCe},rCe={kernelName:Og,backendName:"webgl",kernelFunc:function nCe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n;Wp(s,"maxPool");const{filterSize:o,strides:i,pad:a,dimRoundingMode:l}=r;_(vr(i,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`);const c=so(s.shape,o,i,1,a,l);if(1===c.filterWidth&&1===c.filterHeight&&Bt(c.inShape,c.outShape))return Cs({inputs:{x:s},backend:e});const d=new qp(c,"max",!1);return e.runWebGLProgram(d,[s],s.dtype)}},oCe={kernelName:$g,backendName:"webgl",kernelFunc:function sCe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{filterSize:o,strides:i,pad:a,dataFormat:l,dimRoundingMode:u}=r,d=Bi(s.shape,o,i,[1,1,1],a,u,l),h=new l1(d,"max",!1);return e.runWebGLProgram(h,[s],s.dtype)}};class iCe{constructor(n){this.variableNames=["dy","maxPos"],this.outputShape=n.inShape;const o=n.effectiveFilterHeight,i=n.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${o-1-n.padInfo.top}, ${i-1-n.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${o};\n          wR += ${n.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${n.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${n.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${i}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${n.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${o*i-1} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${i} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class aCe{constructor(n){this.variableNames=["dy","maxPos"],this.outputShape=n.inShape;const l=n.effectiveFilterDepth,u=n.effectiveFilterHeight,c=n.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${l-1-n.padInfo.front}, ${u-1-n.padInfo.top}, ${c-1-n.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${l};\n           wD += ${n.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${n.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${n.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${u};\n              wR += ${n.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${n.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${n.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${c};\n                wC += ${n.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${n.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${l*u*c-1} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${u} * ${c} +\n                  wR * ${c} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const uCe={kernelName:L0,backendName:"webgl",kernelFunc:function lCe(t){const{inputs:n,backend:e,attrs:r}=t,{dy:s,input:o}=n,i=o,{filterSize:a,strides:l,pad:u,dimRoundingMode:c}=r,h=Bi(i.shape,a,l,[1,1,1],u,c),p=new l1(h,"max",!0),f=e.runWebGLProgram(p,[i],i.dtype),g=new aCe(h),m=e.runWebGLProgram(g,[s,f],i.dtype);return e.disposeIntermediateTensorInfo(f),m}},dCe={kernelName:$0,backendName:"webgl",kernelFunc:function cCe(t){const{inputs:n,backend:e,attrs:r}=t,{dy:s,input:o,output:i}=n,a=o;Wp([o,i],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:d}=r,h=so(a.shape,l,u,1,c,d),f=new qp(h,"max",!0),g=e.runWebGLProgram(f,[a],a.dtype),m=new iCe(h),y=e.runWebGLProgram(m,[s,g],a.dtype);return e.disposeIntermediateTensorInfo(g),y}},pCe={kernelName:oM,backendName:"webgl",kernelFunc:({inputs:t,attrs:n,backend:e})=>{const{x:r}=t,{filterSize:s,strides:o,pad:i,includeBatchInIndex:a}=n,l=e;_(4===r.shape.length,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);const u=[1,1];_(vr(o,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${u}'`);const c=so(r.shape,s,o,u,i),[d,h]=function hCe(t,n,e,r){let s=new qp(e,"max",!1);const o=r.runWebGLProgram(s,[t],"float32");return s=new qp(e,"max",!0,!0,n),[o,r.runWebGLProgram(s,[t],"float32")]}(r,a,c,l);return[d,h]}},mCe={kernelName:Lg,backendName:"webgl",kernelFunc:({inputs:t,attrs:n,backend:e})=>{const{x:r}=t,{keepDims:s,axis:o}=n,i=e,a=r.shape.length,l=bt(o,r.shape);let u=l;const c=Cn(u,a),d=null!=c,h=i.shouldExecuteOnCPU([r]),p=[];let f=r;if(d){if(h){const x=i.texData.get(f.dataId).values,w=new Array(a);for(let D=0;D<w.length;D++)w[D]=r.shape[c[D]];const C=o1(x,r.shape,r.dtype,c,w);f=i.makeTensorInfo(w,r.dtype),i.texData.get(f.dataId).values=C}else f=Vb(r,c,i);p.push(f),u=$n(u.length,a)}xr("sum",u,a);const[g,m]=dr(f.shape,u);let y=g;s&&(y=On(g,l));const b=function fCe(t,n,e,r){const s=G(n),a=fe({inputs:{x:t},attrs:{shape:[G(t.shape)/s,s]},backend:r}),l=ql(a,"float32","mean",r),u=fe({inputs:{x:l},attrs:{shape:e},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(l),u}(f,m,y,i);for(const v of p)i.disposeIntermediateTensorInfo(v);return b}},yCe={kernelName:Vg,backendName:"webgl",kernelFunc:function gCe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o,keepDims:i}=r,a=s.shape.length,l=bt(o,s.shape);let u=l;const c=Cn(u,a);let d=s;null!=c&&(d=Yr({inputs:{x:s},backend:e,attrs:{perm:c}}),u=$n(u.length,s.shape.length)),xr("min",u,a);const[h,p]=dr(d.shape,u),g=fe({inputs:{x:d},backend:e,attrs:{shape:[-1,G(p)]}}),m=ql(g,g.dtype,"min",e);let y;return y=fe(i?{inputs:{x:m},backend:e,attrs:{shape:On(h,l)}}:{inputs:{x:m},backend:e,attrs:{shape:h}}),e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(m),null!=c&&e.disposeIntermediateTensorInfo(d),y}},xCe=wr({opSnippet:i1+"\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+jl+"\n  return result;\n",cpuKernelImpl:Lge}),wCe={kernelName:Oh,backendName:"webgl",kernelFunc:xCe};class CCe{constructor(n,e,r){this.variableNames=["x"],this.outputShape=e.map((c,d)=>c[0]+n[d]+c[1]);const s=n.length,o=Qt(s),i=e.map(c=>c[0]).join(","),a=e.map((c,d)=>c[0]+n[d]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s),u="reflect"===r?0:1;this.userCode=1!==s?`\n      ${o} start = ${o}(${i});\n      ${o} end = ${o}(${a});\n\n      void main() {\n        ${o} outC = getOutputCoords();\n        for (int i = 0; i < ${s}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${u};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${u};\n          }\n        }\n        ${o} coords = outC - start;\n        setOutput(getX(${l}));\n      }\n    `:`\n        int start = ${i};\n        int end = ${a};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${u};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${u};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}}class _Ce{constructor(n,e,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map((f,g)=>f[0]+n[g]+f[1]);const s=n.length,o=Qt(s),i=e.map(f=>f[0]).join(","),a=e.map((f,g)=>f[0]+n[g]).join(","),l=Xr("rc",s),u=Xr("source",s),c=`${l[s-1]} < ${this.outputShape[s-1]}`,d=1===s?"source":`vec2(${u.slice(-2).join()})`,h="reflect"===r?0:1;let p="";if(1===s){const f=`\n        ${o} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${h};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${h};\n        }\n        source -= start;\n      `;p=`\n        ${o} rc = outputLoc;\n        ${f}\n        result[0] = getChannel(getX(${u.join()}), ${d});\n        ${l[s-1]} += 1;\n        if(${c}) {\n          ${f}\n          result[1] = getChannel(getX(${u.join()}), ${d});\n        }\n      `}else{const f=`\n        ${o} source = rc;\n        ${o} lt = ${o}(lessThan(source, start));\n        ${o} gte = ${o}(greaterThanEqual(source, end));\n        ${o} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${h}) +\n                gte * ((end - 1) * 2 - source + ${h});\n        source -= start;\n      `;p=`\n        ${o} rc = outputLoc;\n        ${f}\n        result[0] = getChannel(getX(${u.join()}), ${d});\n        ${l[s-1]} += 1;\n        if(${c}) {\n          ${f}\n          result[1] = getChannel(getX(${u.join()}), ${d});\n        }\n        rc = outputLoc;\n        ${l[s-2]} += 1;\n        if(${l[s-2]} < ${this.outputShape[s-2]}) {\n          ${f}\n          result[2] = getChannel(getX(${u.join()}), ${d});\n          ${l[s-1]} += 1;\n          if(${c}) {\n            ${f}\n            result[3] = getChannel(getX(${u.join()}), ${d});\n          }\n        }\n      `}this.userCode=`\n      const ${o} start = ${o}(${i});\n      const ${o} end = ${o}(${a});\n\n      void main() {\n        ${o} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${p}\n        setOutput(result);\n      }\n    `}}const SCe={kernelName:Bg,backendName:"webgl",kernelFunc:({inputs:t,backend:n,attrs:e})=>{const{x:r}=t,{paddings:s,mode:o}=e,i=L().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new _Ce(r.shape,s,o):new CCe(r.shape,s,o);return n.runWebGLProgram(i,[r],r.dtype)}},TCe=wr({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  "+jl+"\n  return result;\n"}),ECe={kernelName:$h,backendName:"webgl",kernelFunc:TCe};class NCe{constructor(n,e,r){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[n,r],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${e-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${e-1}));\n      }\n    `}}const uB=wr({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),kCe={kernelName:wh,backendName:"webgl",kernelFunc:uB},cB="return a - b;",dB=wr({opSnippet:cB,packedOpSnippet:cB,supportsComplex:!0,cpuKernelImpl:oye}),ACe={kernelName:Jh,backendName:"webgl",kernelFunc:dB};function hB(t){const{inputs:n,backend:e,attrs:r}=t,{logits:s}=n,{dim:o}=r,i=bt([o],s.shape),a=lB({inputs:{x:s},backend:e,attrs:{reductionIndices:i,keepDims:!1}}),l=On(a.shape,i),u=fe({inputs:{x:a},backend:e,attrs:{shape:l}}),c=dB({inputs:{a:s,b:u},backend:e}),d=nB({inputs:{x:c},backend:e}),h=Bb({inputs:{x:d},backend:e,attrs:{axis:i,keepDims:!1}}),p=fe({inputs:{x:h},backend:e,attrs:{shape:l}}),f=uB({inputs:{a:d,b:p},backend:e});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(p),f}const RCe={kernelName:sy,backendName:"webgl",kernelFunc:hB},MCe={kernelName:iM,backendName:"webgl",kernelFunc:function FCe(t){const{inputs:n,backend:e,attrs:r}=t,{logits:s}=n,{numSamples:o,seed:i,normalized:a}=r,l=a?s:hB({inputs:{logits:s},backend:e,attrs:{dim:s.shape.length-1}}),d=new NCe(l.shape[0],l.shape[1],o),p=e.runWebGLProgram(d,[l],"int32",[[i]]);return a||e.disposeIntermediateTensorInfo(l),p}},PCe=Us+"\n  return -x;\n",LCe={kernelName:zg,backendName:"webgl",kernelFunc:function $Ce(t){const{inputs:n,backend:e}=t,{x:r}=n;if(e.shouldExecuteOnCPU([r])){const o=e.texData.get(r.dataId),[i,a]=Bge(o.values,r.shape,r.dtype);return e.makeTensorInfo(a,r.dtype,i)}let s;return s=L().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new Va(r.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new gi(r.shape,PCe),e.runWebGLProgram(s,[r],r.dtype)}},VCe=uS,zCe={kernelName:V0,backendName:"webgl",kernelFunc:function BCe(t){Ps("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:n,backend:e,attrs:r}=t,{boxes:s,scores:o}=n,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l}=r,u=e.readSync(s.dataId),c=e.readSync(o.dataId),{selectedIndices:d}=VCe(u,c,i,a,l);return e.makeTensorInfo([d.length],"int32",new Int32Array(d))}},UCe=cS,GCe={kernelName:B0,backendName:"webgl",kernelFunc:function WCe(t){Ps("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:n,backend:e,attrs:r}=t,{boxes:s,scores:o}=n,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:u}=r,c=e.readSync(s.dataId),d=e.readSync(o.dataId),{selectedIndices:h,validOutputs:p}=UCe(c,d,i,a,l,u);return[e.makeTensorInfo([h.length],"int32",new Int32Array(h)),e.makeTensorInfo([],"int32",new Int32Array([p]))]}},HCe=dS,qCe={kernelName:z0,backendName:"webgl",kernelFunc:function jCe(t){Ps("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:n,backend:e,attrs:r}=t,{boxes:s,scores:o}=n,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l,softNmsSigma:u}=r,c=e.readSync(s.dataId),d=e.readSync(o.dataId),h=i,p=a,f=l,g=u,{selectedIndices:m,selectedScores:y}=HCe(c,d,h,p,f,g);return[e.makeTensorInfo([m.length],"int32",new Int32Array(m)),e.makeTensorInfo([y.length],"float32",new Float32Array(y))]}};class KCe{constructor(n,e,r,s){this.variableNames=["indices"],this.outputShape=[n,e],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${s}), float(${r}),\n                      float(index == coords.y)));\n      }\n    `}}const XCe={kernelName:Gg,backendName:"webgl",kernelFunc:t=>{const{inputs:n,backend:e,attrs:r}=t,{indices:s}=n,{dtype:o,depth:i,onValue:a,offValue:l}=r,u=G(s.shape),c=new KCe(u,i,a,l),d=fe({inputs:{x:s},backend:e,attrs:{shape:[u]}}),h=e.runWebGLProgram(c,[d],o);e.disposeIntermediateTensorInfo(d);const f=fe({inputs:{x:h},backend:e,attrs:{shape:[...s.shape,i]}});return e.disposeIntermediateTensorInfo(h),f}};function jb(t){const{inputs:n,backend:e}=t,{x:r}=n;if("complex64"===r.dtype){const s=Kp({inputs:{input:r},backend:e}),o=jb({inputs:{x:s},backend:e}),i=Gb({inputs:{input:r},backend:e}),a=jb({inputs:{x:i},backend:e}),l=Ba({inputs:{real:o,imag:a},backend:e});return e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),l}return Yp({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:e})}const YCe={kernelName:ly,backendName:"webgl",kernelFunc:jb},ZCe={kernelName:Wg,backendName:"webgl",kernelFunc:function pB(t){const{inputs:n,backend:e}=t,{x:r}=n;if("string"===r.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===r.dtype){const s=Kp({inputs:{input:r},backend:e}),o=pB({inputs:{x:s},backend:e}),i=Gb({inputs:{input:r},backend:e}),a=jb({inputs:{x:i},backend:e}),l=Ba({inputs:{real:o,imag:a},backend:e});return e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),l}return Yp({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:e})}},JCe={kernelName:Hg,backendName:"webgl",kernelFunc:function QCe(t){const{inputs:n,backend:e,attrs:r}=t,{axis:s}=r;if(1===n.length)return d1({inputs:{input:n[0]},backend:e,attrs:{dim:s}});const o=n[0].shape,i=n[0].dtype;n.forEach(c=>{no(o,c.shape,"All tensors passed to stack must have matching shapes"),_(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],u=H3({inputs:n.map(c=>{const d=d1({inputs:{input:c},backend:e,attrs:{dim:s}});return a.push(d),d}),backend:e,attrs:{axis:s}});return a.forEach(c=>e.disposeIntermediateTensorInfo(c)),u}};class e0e{constructor(n,e,r){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((u,c)=>u[0]+n[c]+u[1]);const s=n.length,o=Qt(s),i=e.map(u=>u[0]).join(","),a=e.map((u,c)=>u[0]+n[c]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s);this.userCode=1!==s?`\n      ${o} start = ${o}(${i});\n      ${o} end = ${o}(${a});\n\n      void main() {\n        ${o} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${o} coords = outC - start;\n          setOutput(getX(${l}));\n        }\n      }\n    `:`\n        int start = ${i};\n        int end = ${a};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}}class t0e{constructor(n,e,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((g,m)=>g[0]+n[m]+g[1]);const s=n.length,o=Qt(s),i=e.map(g=>g[0]).join(","),a=e.map((g,m)=>g[0]+n[m]).join(","),l=Xr("rc",s),u=Xr("source",s),c=`${l[s-1]} < ${this.outputShape[s-1]}`,d=1===s?"source":`vec2(${u.slice(-2).join()})`,h=[`${o} rc = outputLoc;`,`${l[s-1]} += 1;\n       if(${c}) {\n      `,1===s?"":`}\n       rc = outputLoc;\n       ${l[s-2]} += 1;\n       if(${l[s-2]} < ${this.outputShape[s-2]}) {`,1===s?"":`  ${l[s-1]} += 1;\n         if(${c}) {`],p=1===s?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let f="";for(let g=0,m=1===s?2:4;g<m;g++)f+=`\n        ${h[g]}\n        if (${p}) {\n          result[${g}] = float(value);\n        } else {\n          ${o} source = rc - start;\n          result[${g}] = getChannel(getX(${u.join()}), ${d});\n        }\n      `;f+=1===s?"} ":"}}",this.userCode=`\n      const ${o} start = ${o}(${i});\n      const ${o} end = ${o}(${a});\n\n      void main() {\n        ${o} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${f}\n        setOutput(result);\n      }\n    `}}const fB=t=>{const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{paddings:o,constantValue:i}=r;if(0===G(s.shape))return Yp({backend:e,attrs:{shape:o.map((c,d)=>c[0]+s.shape[d]+c[1]),value:i,dtype:s.dtype}});const a=L().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new t0e(s.shape,o,i):new e0e(s.shape,o,i);return e.runWebGLProgram(a,[s],s.dtype,[[i]])},n0e={kernelName:jg,backendName:"webgl",kernelFunc:fB},o0e=wr({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  "+jl+"\n  return result;\n"}),i0e={kernelName:Vh,backendName:"webgl",kernelFunc:o0e},l0e={kernelName:Kg,backendName:"webgl",kernelFunc:function a0e(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o,keepDims:i}=r,a=s.shape.length,l=[],u=bt(o,s.shape);let c=u;const d=Cn(c,a);let p,h=s;if(null!=d&&(h=Yr({inputs:{x:s},backend:e,attrs:{perm:d}}),c=$n(c.length,a),l.push(h)),xr("prod",c,a),e.shouldExecuteOnCPU([h])){const f=e.texData.get(h.dataId).values,{outVals:g,outShape:m,outDtype:y}=Uge(h.shape,h.dtype,f,c);p=e.makeTensorInfo(m,y,g)}else{const[f,g]=dr(h.shape,c),m=G(g),y=fe({inputs:{x:h},backend:e,attrs:{shape:[-1,m]}}),v=ql(y,c_(s.dtype),"prod",e);p=fe({inputs:{x:v},backend:e,attrs:{shape:f}}),l.push(y),l.push(v)}if(i){l.push(p);const f=On(p.shape,u);p=fe({inputs:{x:p},backend:e,attrs:{shape:f}})}return l.forEach(f=>e.disposeIntermediateTensorInfo(f)),p}},c0e={kernelName:aM,backendName:"webgl",kernelFunc:function u0e(t){const{inputs:n,backend:e,attrs:r}=t,{paramsNestedSplits:s,paramsDenseValues:o,indices:i}=n,{outputRaggedRank:a}=r,l=s.map(y=>e.readSync(y.dataId)),u=s.map(y=>y.shape),c=e.readSync(o.dataId),d=e.readSync(i.dataId),[h,p,f]=Wge(l,u,c,o.shape,o.dtype,d,i.shape,a),g=h.map(y=>e.makeTensorInfo([y.length],"int32",y)),m=e.makeTensorInfo(f,o.dtype,p);return g.concat([m])}},h0e={kernelName:lM,backendName:"webgl",kernelFunc:function d0e(t){const{inputs:n,backend:e}=t,{starts:r,limits:s,deltas:o}=n,i=e.readSync(r.dataId),a=e.readSync(s.dataId),l=e.readSync(o.dataId),[u,c]=Gge(i,r.shape,r.dtype,a,s.shape,l,o.shape);return[e.makeTensorInfo([u.length],"int32",u),e.makeTensorInfo([c.length],r.dtype,c)]}},f0e={kernelName:uM,backendName:"webgl",kernelFunc:function p0e(t){const{inputs:n,backend:e,attrs:r}=t,{shape:s,values:o,defaultValue:i,rowPartitionTensors:a}=n,{rowPartitionTypes:l}=r,u=e.readSync(s.dataId),c=e.readSync(o.dataId),d=e.readSync(i.dataId),h=a.map(m=>e.readSync(m.dataId)),p=a.map(m=>m.shape),[f,g]=Hge(u,s.shape,c,o.shape,o.dtype,d,i.shape,h,p,l);return e.makeTensorInfo(f,o.dtype,g)}},mB=t=>{const{backend:n,attrs:e}=t,{start:r,stop:s,step:o,dtype:i}=e,a=jge(r,s,o,i);return n.makeTensorInfo([a.length],i,a)},m0e={kernelName:U0,backendName:"webgl",kernelFunc:mB},g0e=Ft({opSnippet:"return 1.0 / x;"}),y0e={kernelName:Bh,backendName:"webgl",kernelFunc:g0e},v0e=Ft({opSnippet:Us+"\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),x0e={kernelName:zh,backendName:"webgl",kernelFunc:v0e},C0e=Ft({opSnippet:Us+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),_0e={kernelName:Uh,backendName:"webgl",kernelFunc:C0e};class S0e{constructor(n,e,r,s,o){this.variableNames=["A"],this.outputShape=[];const[i,a,l,u]=n;this.outputShape=[i,e,r,u];const c=[s&&e>1?a-1:a,s&&r>1?l-1:l],d=[s&&e>1?e-1:e,s&&r>1?r-1:r];let h;h=o?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${c[0]/d[0]},\n          ${c[1]/d[1]});\n      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}class I0e{constructor(n,e,r,s,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[i,a,l,u]=n;this.outputShape=[i,e,r,u];const c=[s&&e>1?a-1:a,s&&r>1?l-1:l],d=[s&&e>1?e-1:e,s&&r>1?r-1:r];let h;h=o?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${c[0]/d[0]},\n          ${c[1]/d[1]},\n          ${c[1]/d[1]});\n      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,\n                                     ${l}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${u-1};\n        bool hasNextRow = coords.z < ${r-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}const T0e={kernelName:Zg,backendName:"webgl",kernelFunc:function D0e(t){const{inputs:n,backend:e,attrs:r}=t,{images:s}=n,{alignCorners:o,halfPixelCenters:i,size:a}=r,[l,u]=a,c=L().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new I0e(s.shape,l,u,o,i):new S0e(s.shape,l,u,o,i);return e.runWebGLProgram(c,[s],"float32")}};class E0e{constructor(n,e,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,s,o]=e,[,i,a]=n,l=[r&&i>1?s-1:s,r&&a>1?o-1:o],u=[r&&i>1?i-1:i,r&&a>1?a-1:a],c=l[0]/u[0],d=l[1]/u[1],h=1/c,p=1/d,f=2*Math.ceil(h)+2,g=2*Math.ceil(p)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${c});\n        const float widthScale = float(${d});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${p});\n\n        const int winHeight = int(${f});\n        const int winWidth = int(${g});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${i}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${a}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${s-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${o-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const k0e={kernelName:H0,backendName:"webgl",kernelFunc:function N0e(t){const{inputs:n,backend:e,attrs:r}=t,{images:s,dy:o}=n,{alignCorners:i}=r,a=new E0e(o.shape,s.shape,i);return e.runWebGLProgram(a,[o],o.dtype)}};class A0e{constructor(n,e,r,s,o){this.variableNames=["A"],this.outputShape=[];const[i,a,l,u]=n;this.outputShape=[i,e,r,u];const c=[s&&e>1?a-1:a,s&&r>1?l-1:l],d=[s&&e>1?e-1:e,s&&r>1?r-1:r];let p;p=o?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${c[0]/d[0]},\n          ${c[1]/d[1]});\n      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${p};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${s?"0.5":"0.0"})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}class R0e{constructor(n,e,r,s,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[i,a,l,u]=n;this.outputShape=[i,e,r,u];const c=[s&&e>1?a-1:a,s&&r>1?l-1:l],d=[s&&e>1?e-1:e,s&&r>1?r-1:r];let p;p=o?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${c[0]/d[0]},\n          ${c[1]/d[1]},\n          ${c[1]/d[1]});\n      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,\n                                     ${l}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${p};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${s?"0.5":"0.0"})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${u-1};\n        bool hasNextRow = coords.z < ${r-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}}const M0e={kernelName:Yg,backendName:"webgl",kernelFunc:function F0e(t){const{inputs:n,backend:e,attrs:r}=t,{images:s}=n,{alignCorners:o,halfPixelCenters:i,size:a}=r,[l,u]=a,c=L().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new R0e(s.shape,l,u,o,i):new A0e(s.shape,l,u,o,i);return e.runWebGLProgram(c,[s],s.dtype)}};class P0e{constructor(n,e,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,s,o]=e,[,i,a]=n,l=[r&&i>1?s-1:s,r&&a>1?o-1:o],u=[r&&i>1?i-1:i,r&&a>1?a-1:a],c=l[0]/u[0],d=l[1]/u[1],h=1/c,p=1/d,f=2*Math.ceil(h)+2,g=2*Math.ceil(p)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${c});\n        const float widthScale = float(${d});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${p});\n\n        const int winHeight = int(${f});\n        const int winWidth = int(${g});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${i}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${a}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${l[0]}) *\n                (float(dyR) / float(${u[0]}));\n\n            float sourceFracCol =\n                float(${l[1]}) *\n                  (float(dyC) / float(${u[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${s}) - 1),\n                ${r} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${o}) - 1),\n                ${r} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const $0e={kernelName:G0,backendName:"webgl",kernelFunc:function O0e(t){const{inputs:n,backend:e,attrs:r}=t,{images:s,dy:o}=n,{alignCorners:i}=r,a=new P0e(o.shape,s.shape,i);return e.runWebGLProgram(a,[o],o.dtype)}};class L0e{constructor(n,e){this.variableNames=["x"];const r=n.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);if(this.outputShape=n,1===r)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${n[0]} - coord - 1));\n        }\n      `);const o=n.map((a,l)=>(a=>-1!==e.indexOf(a)&&1!==n[a]?`${n[a]} - coords[${a}] - 1`:`coords[${a}]`)(l)).join(","),i=Qt(r);this.userCode=`\n      void main() {\n        ${i} coords = getOutputCoords();\n        setOutput(getX(${o}));\n      }\n    `}}class V0e{constructor(n,e){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const r=n.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);this.outputShape=n;const s=Xr("rc",r),o=`${s[r-1]} + 1 < ${this.outputShape[r-1]}`,i=`${s[r-2]} + 1 < ${this.outputShape[r-2]}`,a=Qt(r);function h(f){const g=n.map((b,v)=>function p(f,g){return-1!==e.indexOf(f)&&1!==n[f]?`${n[f]} - ${g[f]} - 1`:`${g[f]}`}(v,f));return`getChannel(getX(${g.join(",")}), vec2(${g.slice(-2).join(",")}))`}this.userCode=1===r?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${n[0]} - rc - 1),\n            ${n[0]} - rc - 1);\n          if(${o}){\n              result.g = getChannel(getX(${n[0]} - (rc  + 1) - 1),\n                ${n[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${a} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function l(f){return h(f)}(s.slice())};\n          if(${o}){\n            result.g = ${function u(f){return f[r-1]="("+f[r-1]+" + 1)",h(f)}(s.slice())};\n          }\n          if(${i}) {\n            result.b = ${function c(f){return f[r-2]="("+f[r-2]+" + 1)",h(f)}(s.slice())};\n            if(${o}) {\n              result.a = ${function d(f){return f[r-1]="("+f[r-1]+" + 1)",f[r-2]="("+f[r-2]+" + 1)",h(f)}(s.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}const z0e={kernelName:Qg,backendName:"webgl",kernelFunc:function B0e(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{dims:o}=r,i=s.shape.length,a=bt(o,s.shape);if(0===i)return Cs({inputs:{x:s},backend:e});const l=L().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new V0e(s.shape,a):new L0e(s.shape,a);return e.runWebGLProgram(l,[s],s.dtype)}};class U0e{constructor(n,e){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const r=n[1],s=n[2];this.outputShape=n;let o="";o="number"==typeof e?`float outputValue = ${e.toFixed(2)};`:`\n        vec3 fill = vec3(${e.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${o}\n          if(coordX >= 0 && coordX < ${s} && coordY >= 0 && coordY < ${r}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const W0e={kernelName:s_,backendName:"webgl",kernelFunc:({inputs:t,attrs:n,backend:e})=>{const{image:r}=t,{radians:s,fillValue:o,center:i}=n,a=e,l=new U0e(r.shape,o),[u,c]=bS(i,r.shape[1],r.shape[2]),d=[[u,c,Math.sin(s),Math.cos(s)]];return a.runWebGLProgram(l,[r],r.dtype,d)}},G0e=Ft({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),H0e={kernelName:Wh,backendName:"webgl",kernelFunc:G0e},j0e=Ft({opSnippet:"return inversesqrt(x);",cpuKernelImpl:qge}),q0e={kernelName:Gh,backendName:"webgl",kernelFunc:j0e};class p1{constructor(n,e,r,s,o,i,a=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=i;const u=Qt(o.length),c=Qt(i.length);let d="";1===r?d="i":2===r&&(d="i, j");let p="";1===s?p="i":2===s&&(p="i, coords[1]");let g="";l&&(g="coords[0], coords[1]"),this.userCode=`\n        ${u} strides = ${u}(${o});\n\n        void main() {\n          ${c} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${n}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${e}; j++) {\n              int index = round(getIndices(${d}));\n              flattenedIndex += index * ${e>1?"strides[j]":"strides"};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += getUpdates(${p});\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(${g}), sum, float(found)));\n        }\n      `}}class K0e{constructor(n,e,r,s,o,i,a=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=i;const u=Qt(o.length),c=Qt(i.length);let d="";1===r?d="i":2===r&&(d="i, j");let p="";1===s?p="i":2===s&&(p="i, coords[1]");let g="";l&&(g="coords[0], coords[1]"),this.userCode=`\n        ${u} strides = ${u}(${o});\n\n        void main() {\n          ${c} coords = getOutputCoords();\n          vec4 sum = vec4(0.);\n          vec4 found = vec4(0.);\n          for (int i = 0; i < ${n}; i+=2) {\n            ivec2 flattenedIndex = ivec2(0);\n            for (int j = 0; j < ${e}; j+=2) {\n              ivec4 index = round(getIndices(${d}));\n              flattenedIndex += index.xz * ${e>1?"strides[j]":"strides"};\n              if (j + 1 < ${e}) {\n                flattenedIndex += index.yw * ${e>1?"strides[j + 1]":"strides"};\n              }\n            }\n            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||\n                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {\n              vec4 updVals = getUpdates(${p});\n              if (flattenedIndex[0] == coords[0]) {\n                sum.xy += updVals.xy;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[0] == coords[0] + 1) {\n                sum.zw += updVals.xy;\n                found.zw = vec2(1.);\n              }\n              if (flattenedIndex[1] == coords[0]) {\n                sum.xy += updVals.zw;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[1] == coords[0] + 1) {\n                sum.zw += updVals.zw;\n                found.zw = vec2(1.);\n              }\n            }\n          }\n          setOutput(mix(getDefaultValue(${g}), sum, found));\n        }\n      `}}const Y0e={kernelName:cM,backendName:"webgl",kernelFunc:function X0e(t){const{inputs:n,backend:e,attrs:r}=t,{indices:s,updates:o}=n,{shape:i}=r,{sliceRank:a,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=Fl(0,s,i),h=[d/u,u];if(0===d)return e.makeTensorInfo(i,s.dtype);const p=fe({inputs:{x:s},backend:e,attrs:{shape:[l,a]}}),f=fe({inputs:{x:o},backend:e,attrs:{shape:[l,u]}}),g=e.makeTensorInfo([],"float32",new Float32Array([0]));let m;m=L().getBool("WEBGL_PACK")?new K0e(l,a,p.shape.length,f.shape.length,c,h):new p1(l,a,p.shape.length,f.shape.length,c,h);const y=e.runWebGLProgram(m,[f,p,g],f.dtype),b=fe({inputs:{x:y},backend:e,attrs:{shape:i}});return e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(g),b}};class Z0e{constructor(n,e,r,s){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[n,r];const i=`for (int i = 0; i < ${Math.ceil(Math.log2(e+1))}; ++i) { if (left >= right) break;`,a=2===L().getNumber("WEBGL_VERSION")?"while (left < right) {":i;this.userCode=`\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ${a}\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ${"left"===s?"<":"<="} value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     `}}const J0e={kernelName:hM,backendName:"webgl",kernelFunc:function Q0e(t){const{inputs:n,backend:e,attrs:r}=t,{sortedSequence:s,values:o}=n,{side:i}=r,a=new Z0e(s.shape[0],s.shape[1],o.shape[1],i);return e.runWebGLProgram(a,[s,o],"int32",[[s.shape[1]]])}};class e_e{constructor(n,e,r){let s,o;if(this.variableNames=["c","a","b"],this.outputShape=e,r>4)throw Error(`Where for rank ${r} is not yet supported`);if(1===r)o="resRC",s="resRC";else{const a=["resRC.x","resRC.y","resRC.z","resRC.w"],l=[],u=[];for(let c=0;c<e.length;c++)u.push(`${a[c]}`),c<n&&l.push(`${a[c]}`);s=l.join(),o=u.join()}const i=Qt(r);this.userCode=`\n      void main() {\n        ${i} resRC = getOutputCoords();\n        float cVal = getC(${s});\n        if (cVal >= 1.0) {\n          setOutput(getA(${o}));\n        } else {\n          setOutput(getB(${o}));\n        }\n      }\n    `}}const n_e={kernelName:Jg,backendName:"webgl",kernelFunc:function t_e(t){const{inputs:n,backend:e}=t,{condition:r,t:s,e:o}=n,i=new e_e(r.shape.length,s.shape,s.shape.length);return e.runWebGLProgram(i,[r,s,o],ys(s.dtype,o.dtype))}},s_e=Ft({opSnippet:`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${Wy};\n  float scale = ${Gy};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`}),o_e={kernelName:Hh,backendName:"webgl",kernelFunc:s_e},a_e=Ft({opSnippet:Oc+"\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:Xge}),l_e={kernelName:Xh,backendName:"webgl",kernelFunc:a_e},u_e=Ft({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),c_e={kernelName:Kh,backendName:"webgl",kernelFunc:u_e},p_e=Ft({opSnippet:Oc+"\n  return sin(x);\n",packedOpSnippet:`\n  vec4 result = sin(x);\n  bvec4 isNaN = isnan(x);\n  ${jl}\n  return result;\n`}),f_e={kernelName:jh,backendName:"webgl",kernelFunc:p_e},m_e=Ft({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),g_e={kernelName:qh,backendName:"webgl",kernelFunc:m_e},y_e=Ft({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),b_e={kernelName:Yh,backendName:"webgl",kernelFunc:y_e},v_e={kernelName:ny,backendName:"webgl",kernelFunc:t=>{const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{blockShape:o,paddings:i}=r;_(s.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const a=o.reduce((y,b)=>y*b),l=[[0,0]];l.push(...i);for(let y=1+o.length;y<s.shape.length;++y)l.push([0,0]);const u=[],c=fB({inputs:{x:s},backend:e,attrs:{paddings:l,constantValue:0}}),d=Cp(c.shape,o,a,!1),h=_p(d.length,o.length,!1),p=Sp(c.shape,o,a,!1),f=fe({inputs:{x:c},backend:e,attrs:{shape:d}}),g=Yr({inputs:{x:f},backend:e,attrs:{perm:h}}),m=fe({inputs:{x:g},backend:e,attrs:{shape:p}});return u.push(c),u.push(f),u.push(g),u.forEach(y=>e.disposeIntermediateTensorInfo(y)),m}},w_e={kernelName:j0,backendName:"webgl",kernelFunc:function x_e(t){const{inputs:n,backend:e}=t,{indices:r,values:s,denseShape:o,defaultValue:i}=n;if(1!==o.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${o.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${r.shape}`);if(1!==s.shape.length)throw new Error(`Values must be a vector, saw:\n         ${s.shape}`);if(0!==i.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`);const a=e.readSync(r.dataId),l=e.readSync(s.dataId),u=e.readSync(o.dataId),c=e.readSync(i.dataId)[0],[d,h,p,f,g]=Zge(a,r.shape,r.dtype,l,s.dtype,u,c);return[e.makeTensorInfo(h,r.dtype,d),e.makeTensorInfo([h[0]],s.dtype,p),e.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(m=>Number(m)))),e.makeTensorInfo([g.length],r.dtype,new Int32Array(g))]}},__e={kernelName:q0,backendName:"webgl",kernelFunc:function C_e(t){const{inputs:n,backend:e}=t,{inputIndices:r,inputShape:s,newShape:o}=n;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(1!==s.shape.length)throw new Error(`Input shape should be a vector but received shape ${s.shape}`);if(1!==o.shape.length)throw new Error(`Target shape should be a vector but received shape ${o.shape}`);const i=Array.from(e.readSync(s.dataId)),a=e.readSync(r.dataId),l=Array.from(e.readSync(o.dataId)),[u,c,d]=Qge(a,r.shape,r.dtype,i,l);return[e.makeTensorInfo(c,r.dtype,u),e.makeTensorInfo([d.length],o.dtype,new Int32Array(d))]}},I_e={kernelName:K0,backendName:"webgl",kernelFunc:function S_e(t){const{inputs:n,backend:e}=t,{data:r,indices:s,segmentIds:o}=n;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n              ${s.shape}`);if(1!==o.shape.length)throw new Error(`Segment ids should be a vector but received shape\n              ${o.shape}`);const i=e.readSync(r.dataId),a=e.readSync(s.dataId),l=e.readSync(o.dataId),[u,c]=x3(i,r.shape,r.dtype,a,l,!0);return e.makeTensorInfo(c,r.dtype,u)}},T_e={kernelName:X0,backendName:"webgl",kernelFunc:function D_e(t){const{inputs:n,backend:e}=t,{data:r,indices:s,segmentIds:o}=n;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n             ${s.shape}`);if(1!==o.shape.length)throw new Error(`Segment ids should be a vector but received shape\n             ${o.shape}`);const i=e.readSync(r.dataId),a=e.readSync(s.dataId),l=e.readSync(o.dataId),[u,c]=x3(i,r.shape,r.dtype,a,l);return e.makeTensorInfo(c,r.dtype,u)}},N_e={kernelName:pM,backendName:"webgl",kernelFunc:function E_e(t){const{inputs:n,backend:e,attrs:r}=t,{sparseIndices:s,sparseValues:o,defaultValue:i}=n,{outputShape:a}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:d,outputSize:h}=Fl(0,s,a);if("string"===o.dtype){const y=e.bufferSync(s),b=e.bufferSync(o),v=ba(e.readSync(i.dataId)[0]),x=Kge(y,b,a,h,c,u,l,d,v,!1);return e.makeTensorInfo(a,x.dtype,x.values)}const f=new p1(u,l,s.shape.length,o.shape.length,d,[h,1],!1),g=e.runWebGLProgram(f,[o,s,i],o.dtype),m=fe({inputs:{x:g},backend:e,attrs:{shape:a}});return e.disposeIntermediateTensorInfo(g),m}},A_e={kernelName:ry,backendName:"webgl",kernelFunc:function k_e(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{numOrSizeSplits:o,axis:i}=r,a=bt(i,s.shape)[0],l=PS(s,o,a),c=new Array(s.shape.length).fill(0),d=s.shape.slice();return l.map(h=>{const p=[...d];p[a]=h;const f=$c({inputs:{x:s},backend:e,attrs:{begin:c,size:p}});return c[a]+=h,f})}},gB="return sqrt(x);",R_e=Ft({opSnippet:gB,packedOpSnippet:gB,cpuKernelImpl:Jge}),F_e={kernelName:Zh,backendName:"webgl",kernelFunc:R_e},P_e={kernelName:Y0,backendName:"webgl",kernelFunc:Ft({opSnippet:"return x * x;"})},yB="return (a - b) * (a - b);",O_e=wr({opSnippet:yB,packedOpSnippet:yB}),$_e={kernelName:Qh,backendName:"webgl",kernelFunc:O_e},V_e={kernelName:oy,backendName:"webgl",kernelFunc:function L_e(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n;if("string"!==s.dtype)throw new Error("Input must be of datatype string");const i=ji(e.readSync(s.dataId)),a=eye(i,"string",r);return e.makeTensorInfo(s.shape,"string",a)}},z_e={kernelName:rp,backendName:"webgl",kernelFunc:function B_e({inputs:t,attrs:n,backend:e}){const{x:r}=t,o=new gi(r.shape,Us+`\n    return x > 0.0 ? 1.0 : float(${n.alpha});\n  `);return e.runWebGLProgram(o,[r],r.dtype)}};class U_e{constructor(n,e,r){this.variableNames=["x"],this.outputShape=r;const s=r.length,o=Qt(r.length),i=Qt(r.length);let a="";if(1===s)a="coords * strides + begin";else{let l=0;a=r.map((u,c)=>(l++,1===r.length?`coords * strides[${c}] + begin[${c}]`:`coords[${l-1}] * strides[${c}] + begin[${c}]`)).join(",")}this.userCode=`\n      ${o} begin = ${o}(${n});\n      ${o} strides = ${o}(${e});\n\n      void main() {\n        ${i} coords = getOutputCoords();\n        setOutput(getX(${a}));\n      }\n    `}}const G_e={kernelName:Z0,backendName:"webgl",kernelFunc:function W_e(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{begin:o,end:i,strides:a,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:h}=r,{finalShapeSparse:p,finalShape:f,isIdentity:g,sliceDim0:m,isSimpleSlice:y,begin:b,end:v,strides:x}=L_(s.shape,o,i,a,l,u,c,d,h);let w;if(g)w=fe({inputs:{x:s},backend:e,attrs:{shape:f}});else if(m||y){_(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);const I=P_(b,v,x),D=$c({inputs:{x:s},backend:e,attrs:{begin:b,size:I}});w=fe({inputs:{x:D},backend:e,attrs:{shape:f}}),e.disposeIntermediateTensorInfo(D)}else if(e.shouldExecuteOnCPU([s])){const D=e.readSync(s.dataId),E=vt(s.shape,s.dtype,D),N=tye(p,E,x,b);w=e.makeTensorInfo(f,s.dtype,N.values)}else{const D=new U_e(b,x,p);w=e.runWebGLProgram(D,[s],s.dtype)}const C=fe({inputs:{x:w},backend:e,attrs:{shape:f}});return e.disposeIntermediateTensorInfo(w),C}},j_e={kernelName:Q0,backendName:"webgl",kernelFunc:function H_e(t){const{inputs:n,backend:e,attrs:r}=t,{separator:s,nGramWidths:o,leftPad:i,rightPad:a,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:d}=n,h=e.readSync(c.dataId),p=e.readSync(d.dataId),[f,g]=nye(h,p,s,o,i,a,l,u);return[e.makeTensorInfo([f.length],"string",f),e.makeTensorInfo(d.shape,"int32",g)]}},K_e={kernelName:J0,backendName:"webgl",kernelFunc:function q_e(t){const{inputs:n,backend:e,attrs:r}=t,{skipEmpty:s}=r,{input:o,delimiter:i}=n;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(1!==o.shape.length)throw new Error(`Input must be a vector, got shape: ${o.shape}`);if(0!==i.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const a=e.readSync(o.dataId),l=e.readSync(i.dataId)[0],[u,c,d]=rye(a,l,s),h=c.length;return[e.makeTensorInfo([h,2],"int32",u),e.makeTensorInfo([h],"string",c),e.makeTensorInfo([2],"int32",new Int32Array(d))]}},Y_e={kernelName:e_,backendName:"webgl",kernelFunc:function X_e(t){const{inputs:n,backend:e,attrs:r}=t,{numBuckets:s}=r,{input:o}=n;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const i=e.readSync(o.dataId),a=sye(i,s);return e.makeTensorInfo(o.shape,"int32",a)}},Z_e=Ft({opSnippet:"return tan(x);"}),Q_e={kernelName:ep,backendName:"webgl",kernelFunc:Z_e},J_e=Ft({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),eSe={kernelName:tp,backendName:"webgl",kernelFunc:J_e},nSe={kernelName:dM,backendName:"webgl",kernelFunc:function tSe(t){const{inputs:n,backend:e}=t,{tensor:s,indices:o,updates:i}=n,{sliceRank:a,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=Fl(0,o,s.shape),h=[d/u,u];if(0===d)return e.makeTensorInfo(s.shape,o.dtype);const p=fe({inputs:{x:o},backend:e,attrs:{shape:[l,a]}}),f=fe({inputs:{x:i},backend:e,attrs:{shape:[l,u]}}),g=fe({inputs:{x:s},backend:e,attrs:{shape:h}}),m=new p1(l,a,p.shape.length,f.shape.length,c,h,!1,!0),y=e.runWebGLProgram(m,[f,p,g],g.dtype),b=fe({inputs:{x:y},backend:e,attrs:{shape:s.shape}});return e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(y),b}};class rSe{constructor(n,e){this.variableNames=["A"];const r=new Array(n.length);for(let i=0;i<r.length;i++)r[i]=n[i]*e[i];this.outputShape=r,this.rank=r.length;const s=Qt(this.rank),o=function sSe(t){const n=t.length;if(n>5)throw Error(`Tile for rank ${n} is not yet supported`);if(1===n)return`imod(resRC, ${t[0]})`;const e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let s=0;s<t.length;s++)r.push(`imod(${e[s]}, ${t[s]})`);return r.join()}(n);this.userCode=`\n      void main() {\n        ${s} resRC = getOutputCoords();\n        setOutput(getA(${o}));\n      }\n    `}}function bB(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{reps:o}=r;if("string"===s.dtype||s.shape.length>5){const l=e.readSync(s.dataId),u="string"===s.dtype?l.map(h=>ba(h)):l,c=vt(s.shape,s.dtype,u),d=iye(c,o);return e.makeTensorInfo(d.shape,d.dtype,d.values)}const i=new rSe(s.shape,o);return e.runWebGLProgram(i,[s],s.dtype)}const oSe={kernelName:np,backendName:"webgl",kernelFunc:bB};class iSe{constructor(n){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=n,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}class aSe{constructor(n){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=n,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}}function Kl(t,n){null!==n&&t.disposeIntermediateTensorInfo(n)}function vB(t){let n=1;for(;n<t;)n*=2;return n}const uSe={kernelName:t_,backendName:"webgl",kernelFunc:function lSe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{k:o,sorted:i}=r,a=L().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=L().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),u=s.shape,c=u[u.length-1];if(e.shouldExecuteOnCPU([s])||c<a||o>l){const N=e.readSync(s.dataId),[P,V]=aye(N,u,s.dtype,o,i);return[e.makeTensorInfo(P.shape,P.dtype,P.values),e.makeTensorInfo(V.shape,V.dtype,V.values)]}if(0===o)return u[u.length-1]=0,[e.makeTensorInfo(u,s.dtype,[]),e.makeTensorInfo(u,"int32",[])];if(1===c)return[s,Yp({attrs:{shape:u,dtype:"int32",value:0},backend:e})];const d=e.texData.get(s.dataId),h=null!==d&&d.isPacked,p=h?e.unpackTensor(s):s,g=G(u)/c,m=fe({inputs:{x:p},attrs:{shape:[g,c]},backend:e});h&&Kl(e,p);const y=vB(o),b=vB(c);let v=null;const x=()=>null===v?[m,m]:[m,v],w=(N,P,V)=>{const B=x(),z=new iSe(V),q=v;v=e.runWebGLProgram(z,B,"int32",[[c],[null===v?1:0],[Number.NEGATIVE_INFINITY],[N],[P]]),Kl(e,q)};for(let N=1;N<y;N*=2){const P=2*N;for(let V=N;V>=1;V/=2)w(P,V,[g,b])}for(let N=b;N>y;N/=2){const P=x(),V=new aSe([g,N/2]),U=v;v=e.runWebGLProgram(V,P,"int32",[[c],[null===v?1:0],[y]]),Kl(e,U);const j=y/2,q=2*j;for(let W=j;W>=1;W/=2)w(q,W,v.shape)}let C=v;v=$c({inputs:{x:v},backend:e,attrs:{begin:0,size:[g,o]}}),Kl(e,C);let I=aB({inputs:{x:m,indices:v},backend:e,attrs:{axis:1,batchDims:1}});Kl(e,m);const D=u.slice(0,-1);D.push(o),C=v,v=fe({inputs:{x:v},attrs:{shape:D},backend:e}),Kl(e,C);const E=I;return I=fe({inputs:{x:I},attrs:{shape:D},backend:e}),Kl(e,E),[I,v]}};class cSe{constructor(n,e,r,s,o,i){this.variableNames=["Image","Transforms"],this.outputShape=i;const a="nearest"===r?1:2;let l;switch(s){case"constant":default:l=1;break;case"reflect":l=2;break;case"wrap":l=3;break;case"nearest":l=4}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${l} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${l} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${l} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${n} && 0 <= coordX && coordX < ${e}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${o});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${o});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${e}));\n                float mapY = mapCoord(inY, float(${n}));\n\n                if (${a} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}const hSe={kernelName:n_,backendName:"webgl",kernelFunc:function dSe(t){const{inputs:n,backend:e,attrs:r}=t,{image:s,transforms:o}=n,{interpolation:i,fillMode:a,fillValue:l,outputShape:u}=r,[c,d,h,p]=s.shape,[f,g]=u??[d,h],y=new cSe(d,h,i,a,l,[c,f,g,p]);return e.runWebGLProgram(y,[s,o],"float32")}},fSe={kernelName:r_,backendName:"webgl",kernelFunc:function pSe(t){const{inputs:n,attrs:e,backend:r}=t,{axis:s}=e,{x:o}=n;Wp(o,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const i=r.readSync(o.dataId),{outputValues:a,outputShape:l,indices:u}=lye(i,s,o.shape,o.dtype);return[r.makeTensorInfo(l,o.dtype,a),r.makeTensorInfo([u.length],"int32",u)]}},gSe={kernelName:iy,backendName:"webgl",kernelFunc:function mSe(t){const{inputs:n,backend:e,attrs:r}=t,{value:s}=n;let{axis:o}=r;o<0&&(o+=s.shape.length);const i=s,a=i.shape.length,l=s.shape[o],u=new Array(a-1);let c=0;for(let g=0;g<a;g++)g!==o&&(u[c++]=i.shape[g]);const d=[],h=new Array(a).fill(0),p=i.shape.slice();p[o]=1;const f=new Array(l);for(let g=0;g<f.length;g++){h[o]=g;const m=$c({inputs:{x:i},backend:e,attrs:{begin:h,size:p}}),y=fe({inputs:{x:m},backend:e,attrs:{shape:u}});f[g]=y,d.push(m)}return d.forEach(g=>e.disposeIntermediateTensorInfo(g)),f}};class ySe{constructor(n,e){this.variableNames=["x","segmentIds"];const r=n.windowSize,s=n.batchSize,o=n.inSize,i=n.numSegments,a=i*Math.ceil(o/r);this.outputShape=[s,a];const c=4*Math.floor(r/4),d=r%4,h="\n        sumValue += dot(values, segFilter);\n    ";let p="";o%r>0&&(p=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return initializationValue;\n        }\n      `);let f="";o%r>0&&(f=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${p}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${f}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${i})) * float(${r}));\n        int currentSeg = int(mod(float(outIdx), float(${i})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${c}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${h}\n        }\n\n        int inIdx = inOffset + ${c};\n        if (${1===d}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${h}\n        } else if (${2===d}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${h}\n        } else if (${3===d}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${h}\n        }\n        setOutput(sumValue);\n      }\n    `}}const xSe=[nbe,sbe,abe,cbe,hbe,mbe,ybe,vbe,_be,Ibe,Ebe,Abe,Mbe,Lbe,zbe,Wbe,Hbe,Xbe,Zbe,Jbe,nve,lve,cve,hve,yve,vve,_ve,Vye,Dve,Ave,Pve,zve,Gve,jve,Kve,Yve,exe,nxe,sxe,ixe,lxe,cxe,pxe,mxe,vxe,wxe,Sxe,Txe,Nxe,Axe,Mxe,Oxe,Vxe,zxe,Uxe,Gxe,jxe,Kxe,Yxe,Qxe,ewe,rwe,iwe,lwe,dwe,fwe,gwe,bwe,Lye,xwe,Nve,Cwe,Swe,Dwe,zye,Ewe,kwe,Rwe,Pwe,Lwe,Bwe,Uwe,Gwe,qwe,Xwe,Zwe,tCe,rCe,oCe,uCe,dCe,pCe,mCe,yCe,wCe,SCe,ECe,MCe,Gye,LCe,zCe,GCe,qCe,pve,XCe,ZCe,JCe,n0e,i0e,Wye,l0e,c0e,h0e,f0e,m0e,fve,kCe,y0e,x0e,_0e,jye,T0e,k0e,M0e,$0e,z0e,W0e,H0e,q0e,Y0e,J0e,n_e,o_e,l_e,c_e,f_e,g_e,ave,RCe,b_e,v_e,w_e,__e,I_e,T_e,N_e,A_e,F_e,P_e,$_e,V_e,z_e,G_e,j_e,K_e,Y_e,ACe,Jye,Q_e,eSe,nSe,oSe,uSe,hSe,ebe,fSe,gSe,{kernelName:ay,backendName:"webgl",kernelFunc:function bSe(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,segmentIds:o}=n,{numSegments:i}=r,a=s.shape.length,l=[];let u=0;const c=Cn([u],a);let d=s;null!=c&&(d=Yr({inputs:{x:s},backend:e,attrs:{perm:c}}),l.push(d),u=$n(1,a)[0]);const h=vO(d.shape,u,i),p=G([d.shape[u]]),f=fe({inputs:{x:d},backend:e,attrs:{shape:[-1,p]}});l.push(f);const g=c_(s.dtype),m=(x,w,C,I,D)=>{const E=x.shape[0],N=x.shape[1],P=bO(N,D),B=new ySe({windowSize:P,inSize:N,batchSize:E,numSegments:D},w),z=e.compileAndRun(B,[x,C],I);if(l.push(z),z.shape[1]===D)return z;const U=mB({backend:e,attrs:{start:0,stop:D,step:1,dtype:"float32"}}),j=bB({inputs:{x:U},backend:e,attrs:{reps:[N/P]}});return l.push(U),l.push(j),m(z,w,j,I,D)},b=fe({inputs:{x:m(f,"unsortedSegmentSum",o,g,i)},backend:e,attrs:{shape:h}});let v=b;if(null!=c){l.push(b);const x=Sa(c);v=Yr({inputs:{x:v},backend:e,attrs:{perm:x}})}return l.forEach(x=>e.disposeIntermediateTensorInfo(x)),v}},YCe];for(const t of xSe)i_(t);const CSe=function(t,n,e,r){return{"text-align":t,"background-color":n,color:e,"font-family":r}},xB=function(t,n){return{color:t,"font-family":n}},_Se=function(t){return{"text-align":t}},SSe=function(t){return{"max-width":t,display:"none"}};let ISe=(()=>{class t{constructor(){this.width=400,this.height=400,this.modelo=null,this.facingMode="user",this.respuesta="Cargando...",this.resultado=0}ngOnInit(){this.video=document.getElementById("video"),this.canvas=document.getElementById("canvas"),this.ctx=this.canvas.getContext("2d",{willReadFrequently:!0}),this.loadModel()}loadModel(){var e=this;return J(function*(){console.log("Cargando modelo..."),e.modelo=yield function nae(t,n){return gI.apply(this,arguments)}(e.configuration.modelURL),console.log("Modelo cargado.")})()}onLoad(){this.mostrarCamara()}mostrarCamara(){navigator.mediaDevices.getUserMedia?navigator.mediaDevices.getUserMedia({audio:!1,video:{facingMode:"user",width:this.width,height:this.height}}).then(r=>{this.currentStream=r,this.video.srcObject=r,this.video.onloadedmetadata=()=>{this.video.play()},this.procesarCamara(),this.predecir()}).catch(function(r){alert("No se ha podido utilizar la c\xe1mara."),console.log(r),alert(r)}):alert("No existe la funcion getUserMedia.")}cambiarCamara(){this.currentStream&&this.currentStream.getTracks().forEach(r=>{r.stop()}),this.facingMode="user"==this.facingMode?"environment":"user",navigator.mediaDevices.getUserMedia({audio:!1,video:{facingMode:this.facingMode,width:this.width,height:this.height}}).then(r=>{this.currentStream=r,this.video.srcObject=r}).catch(function(r){console.log("No se ha podido cambiar la c\xe1mara.",r)})}procesarCamara(){this.ctx.drawImage(this.video,0,0,this.width,this.height,0,0,this.width,this.height),setTimeout(this.procesarCamara.bind(this),20)}predecir(){if(null!=this.modelo){let r=document.getElementById("canvasAux").getContext("2d",{willReadFrequently:!0});r.drawImage(this.video,0,0,this.width,this.height,0,0,this.configuration.width,this.configuration.height);let s=r.getImageData(0,0,this.configuration.width,this.configuration.height),o=[],i=[];for(let u=0;u<s.data.length;u+=4)i.push([(s.data[u]/255+s.data[u+1]/255+s.data[u+2]/255)/3]),100==i.length&&(o.push(i),i=[]);o=[o];let a=function WJ(t,n,e){if(n0(t),null!=n&&4!==n.length)throw new Error("tensor4d() requires shape to have four numbers");const r=lp(t,e);if(4!==r.length&&1!==r.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===r.length&&null==n)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return up(t,n,r,e)}(o),l=this.modelo.predict(a).dataSync();this.resultado=l;for(const u of this.configuration.categories)this.resultado>=u.minValue&&this.resultado<u.maxValue&&(this.respuesta=u.name)}setTimeout(this.predecir.bind(this),100)}getTextAlign(){return ha[this.configuration.style.textAlign]}getCamAlign(){return ha[this.configuration.style.camAlign]}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275cmp=ja({type:t,selectors:[["app-preview"]],hostBindings:function(e,r){1&e&&Ee("load",function(){return r.onLoad()},0,UT)},inputs:{configuration:"configuration"},decls:14,vars:26,consts:[[2,"padding","10px",3,"ngStyle"],[3,"ngStyle"],["id","video","autoplay","","loop","","muted","","playsinline","","hidden",""],["id","canvas","width","400","height","400",2,"max-width","100%"],["id","canvasAux","hidden","",3,"width","height","ngStyle"],["id","cambiarCamara","aria-label","Rotar c\xe1mara",1,"btn","btn-light",3,"click"],[1,"bi","bi-arrow-repeat"],["color","primary",3,"ngStyle"]],template:function(e,r){1&e&&(te(0,"div",0)(1,"h1",1),Be(2),Q(),te(3,"p"),Be(4),Q(),te(5,"div",1),Vt(6,"video",2)(7,"canvas",3)(8,"canvas",4),te(9,"button",5),Ee("click",function(){return r.cambiarCamara()}),Vt(10,"i",6),Q()(),te(11,"h1",7),Be(12),Q(),Be(13),Q()),2&e&&(_e("ngStyle",hk(11,CSe,r.getTextAlign(),r.configuration.style.backgroundColor,r.configuration.style.contentColor,r.configuration.style.fontFamily)),me(1),_e("ngStyle",tm(16,xB,r.configuration.style.titleColor,r.configuration.style.fontFamily)),me(1),Zs("",r.configuration.title," "),me(2),sl(r.configuration.description),me(1),_e("ngStyle",_d(19,_Se,r.getCamAlign())),me(3),qf("width",r.configuration.width),qf("height",r.configuration.height),_e("ngStyle",_d(21,SSe,r.configuration.width)),me(3),_e("ngStyle",tm(23,xB,r.configuration.style.titleColor,r.configuration.style.fontFamily)),me(1),Zs(" Resultado: ",r.respuesta,""),me(1),Zs(" ",r.resultado,"\n"))},dependencies:[BA],styles:["i.bi[_ngcontent-%COMP%]{font-size:25px}#cambiarCamara[_ngcontent-%COMP%]{position:absolute;margin-top:10px;margin-left:-50px;border-radius:100%;padding:1px 7px 0}"]}),t})();const DSe=["description"],TSe=["title"],ESe=function(t,n){return{"alert-danger":t,"alert-success":n}};function NSe(t,n){if(1&t){const e=zn();te(0,"div",30),Be(1),te(2,"button",31),Ee("click",function(){return Qe(e),Je(we().closeMessage())}),te(3,"span"),Be(4,"\xd7"),Q()()()}if(2&t){const e=we();_e("ngClass",tm(2,ESe,!1===e.success,!0===e.success)),me(1),Zs("",e.message," ")}}const wB=function(t){return{"is-invalid":t}};let CB=(()=>{class t{constructor(e,r){this.fb=e,this.appsService=r,this.Align=ha,this.message="",this.success=!0}ngOnInit(){this.form=this.fb.group({title:[this.configuration.title,Jd.compose([Jd.required,Jd.maxLength(30)])],description:[this.configuration.description,Jd.compose([Jd.maxLength(200)])]})}setTextAlign(e){this.configuration.style.textAlign=e}setCamAlign(e){this.configuration.style.camAlign=e}setTitle(e){this.form.controls.title.errors||(this.configuration.title=e)}setDescription(e){this.form.controls.description.errors||(this.configuration.description=e)}onFileSelected(e){const r=e.target.files,o=[];let i;for(let a=0;a<r.length;a++){const l=r[a],u=l.name.split(".").pop();"json"==u&&(i=l),"bin"==u&&o.push(l)}this.configuration.modelURL=i.webkitRelativePath}download(){const i=new Blob(["<div id='main'>\n<h1>"+this.configuration.title+"</h1>\n<p>"+this.configuration.description+"</p>\n</div>\n","<style>body {background-color:"+this.configuration.style.backgroundColor+"; color: "+this.configuration.style.contentColor+"}\nh1 {color: "+this.configuration.style.titleColor+"}</style>","<script><\/script>"],{type:"text/html"}),a=window.URL.createObjectURL(i),l=document.createElement("a");l.href=a,l.download="index.html",document.body.appendChild(l),l.click(),document.body.removeChild(l)}addConfig(){this.appsService.addConfig(this.configuration)?(this.message="Se ha a\xf1adido correctamente la configuraci\xf3n actual a la lista.",this.success=!0):(this.message="La configuraci\xf3n actual no puede a\xf1adirse a la lista, ya existe otra configuraci\xf3n con el mismo t\xedtulo.",this.success=!1)}closeMessage(){this.message=""}}return t.\u0275fac=function(e){return new(e||t)(Y(p9),Y(QC))},t.\u0275cmp=ja({type:t,selectors:[["app-config"]],viewQuery:function(e,r){if(1&e&&(Ou(DSe,5),Ou(TSe,5)),2&e){let s;il(s=al())&&(r.description=s.first),il(s=al())&&(r.title=s.first)}},inputs:{configuration:"configuration"},decls:77,vars:25,consts:[["id","config"],[3,"configuration"],["tabindex","-1","id","offcanvasBottom","aria-labelledby","offcanvasBottomLabel",1,"offcanvas","offcanvas-bottom"],[1,"offcanvas-header"],["id","offcanvasBottomLabel",1,"offcanvas-title"],["type","button","data-bs-dismiss","offcanvas","aria-label","Close",1,"btn-close","text-reset"],[1,"offcanvas-body","small"],[3,"formGroup"],[1,"row"],["type","file","accept",".json,.bin","webkitdirectory","","directory","","multiple","",1,"form-control-file",3,"change"],[1,"row","g-2"],[1,"col-md"],["type","text","formControlName","title","placeholder","T\xedtulo de la aplicaci\xf3n",1,"form-control",3,"ngClass","ngModelChange"],["title",""],["type","text","formControlName","description","placeholder","Descripci\xf3n de la aplicaci\xf3n",1,"form-control",3,"ngClass","ngModelChange"],["description",""],[1,"align-buttons"],[1,"btn","btn-outline-dark",3,"click"],[1,"bi","bi-text-left"],[1,"bi","bi-text-center"],[1,"bi","bi-text-right"],[1,"bi","bi-justify"],[1,"row","g-3"],[1,"colorPicker",3,"cpToggle","colorPicker","cpPosition","colorPickerChange"],[1,"colorPicker",3,"colorPicker","cpPosition","colorPickerChange"],[1,"buttons"],["type","button","data-bs-toggle","offcanvas","data-bs-target","#offcanvasBottom","aria-controls","offcanvasBottom",1,"btn","btn-primary"],["type","button","id","downloadBtn",1,"btn","btn-secondary",3,"click"],["type","button",1,"btn","btn-warning",3,"click"],["class","alert","role","alert",3,"ngClass",4,"ngIf"],["role","alert",1,"alert",3,"ngClass"],["type","button","data-dismiss","alert","aria-label","Close",1,"close",3,"click"]],template:function(e,r){if(1&e){const s=zn();te(0,"div",0),Be(1," Vista previa de la aplicaci\xf3n: "),Vt(2,"app-preview",1),te(3,"div",2)(4,"div",3)(5,"h5",4),Be(6,"Configuraci\xf3n de la vista de la aplicaci\xf3n"),Q(),Vt(7,"button",5),Q(),te(8,"div",6)(9,"form",7)(10,"div",8)(11,"label"),Be(12,"Selecciona un nuevo modelo:"),Vt(13,"br"),Q(),te(14,"input",9),Ee("change",function(i){return r.onFileSelected(i)}),Q(),te(15,"label"),Be(16,"Debes seleccionar un directorio que contenga el archivo model.json y los .bin correspondientes."),Q()(),Vt(17,"br"),te(18,"div",10)(19,"div",11)(20,"label"),Be(21,"T\xedtulo de la aplicaci\xf3n"),Q(),te(22,"input",12,13),Ee("ngModelChange",function(){Qe(s);const i=Fx(23);return Je(r.setTitle(i.value))}),Q()(),te(24,"div",11)(25,"label"),Be(26,"Descripci\xf3n de la aplicaci\xf3n"),Q(),te(27,"textarea",14,15),Ee("ngModelChange",function(){Qe(s);const i=Fx(28);return Je(r.setDescription(i.value))}),Q()()()(),Vt(29,"br"),te(30,"div",10)(31,"div",11)(32,"label"),Be(33,"Selecciona la alineaci\xf3n de la c\xe1mara:"),Q(),te(34,"div",16)(35,"button",17),Ee("click",function(){return r.setCamAlign(r.Align.left)}),Vt(36,"i",18),Q(),te(37,"button",17),Ee("click",function(){return r.setCamAlign(r.Align.center)}),Vt(38,"i",19),Q(),te(39,"button",17),Ee("click",function(){return r.setCamAlign(r.Align.right)}),Vt(40,"i",20),Q(),te(41,"button",17),Ee("click",function(){return r.setCamAlign(r.Align.justify)}),Vt(42,"i",21),Q()()(),te(43,"div",11)(44,"label"),Be(45,"Selecciona la alineaci\xf3n del texto:"),Q(),te(46,"div",16)(47,"button",17),Ee("click",function(){return r.setTextAlign(r.Align.left)}),Vt(48,"i",18),Q(),te(49,"button",17),Ee("click",function(){return r.setTextAlign(r.Align.center)}),Vt(50,"i",19),Q(),te(51,"button",17),Ee("click",function(){return r.setTextAlign(r.Align.right)}),Vt(52,"i",20),Q(),te(53,"button",17),Ee("click",function(){return r.setTextAlign(r.Align.justify)}),Vt(54,"i",21),Q()()(),te(55,"div",22)(56,"div",11),Be(57," Color de fondo: "),te(58,"div",23),Ee("colorPickerChange",function(i){return r.configuration.style.backgroundColor=i}),Be(59),Q()(),te(60,"div",11),Be(61," Color del texto: "),te(62,"div",24),Ee("colorPickerChange",function(i){return r.configuration.style.contentColor=i}),Be(63),Q()(),te(64,"div",11),Be(65," Color de los t\xedtulos: "),te(66,"div",24),Ee("colorPickerChange",function(i){return r.configuration.style.titleColor=i}),Be(67),Q()()(),Vt(68,"br"),Q()()(),te(69,"div",25)(70,"button",26),Be(71,"Configuraci\xf3n de la vista"),Q(),te(72,"button",27),Ee("click",function(){return r.download()}),Be(73,"Descargar app actual"),Q(),te(74,"button",28),Ee("click",function(){return r.addConfig()}),Be(75,"A\xf1adir a la lista"),Q()(),Ot(76,NSe,5,5,"div",29),Q()}2&e&&(me(2),_e("configuration",r.configuration),me(7),_e("formGroup",r.form),me(13),_e("ngClass",_d(21,wB,r.form.controls.title.errors)),me(5),_e("ngClass",_d(23,wB,r.form.controls.description.errors)),me(31),Un("background",r.configuration.style.backgroundColor),_e("cpToggle",!0)("colorPicker",r.configuration.style.backgroundColor)("cpPosition","top-right"),me(1),Zs(" ",r.configuration.style.backgroundColor," "),me(3),Un("background",r.configuration.style.contentColor),_e("colorPicker",r.configuration.style.contentColor)("cpPosition","top-right"),me(1),Zs(" ",r.configuration.style.contentColor," "),me(3),Un("background",r.configuration.style.titleColor),_e("colorPicker",r.configuration.style.titleColor)("cpPosition","top-right"),me(1),Zs(" ",r.configuration.style.titleColor,""),me(9),_e("ngIf",""!=r.message))},dependencies:[MA,Bw,bF,Km,rF,sF,og,KC,rY,ISe],styles:["#config[_ngcontent-%COMP%]{margin:10px}.buttons[_ngcontent-%COMP%]   button[_ngcontent-%COMP%], .buttons[_ngcontent-%COMP%]   .alert[_ngcontent-%COMP%]{margin-top:10px;margin-right:10px}.buttons[_ngcontent-%COMP%]   .alert[_ngcontent-%COMP%]{display:inlne-block;padding:5px}#offcanvasBottom[_ngcontent-%COMP%]{--bs-offcanvas-height: 55vh}.align-buttons[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{margin-right:5px}.colorPicker[_ngcontent-%COMP%]{border:2px solid black;display:inline-block;padding:0 5px;margin:0 5px;color:#6a6a6a}.color-picker[_ngcontent-%COMP%]{position:relative}div.alert[_ngcontent-%COMP%]{display:inline-block;padding-top:5px;padding-bottom:5px;margin-top:10px;margin-bottom:0}.alert[_ngcontent-%COMP%]   button.close[_ngcontent-%COMP%]{color:inherit;background-color:transparent;border:0;-webkit-appearance:none;float:right;font-size:1.5rem;font-weight:700;text-shadow:0 1px 0 #fff;opacity:.5;line-height:1;margin-top:-2.5px;margin-right:-10px;margin-left:10px}.alert[_ngcontent-%COMP%]   button.close[_ngcontent-%COMP%]:hover{color:#000}"]}),t})();const kSe=[{path:"",component:CB},{path:"help",component:(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275cmp=ja({type:t,selectors:[["app-help"]],decls:2,vars:0,template:function(e,r){1&e&&(te(0,"p"),Be(1,"Ayuda"),Q())}}),t})()}];let ASe=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=qs({type:t}),t.\u0275inj=Is({imports:[k2.forRoot(kSe),k2]}),t})();function RSe(t,n){if(1&t){const e=zn();te(0,"a",18),Ee("click",function(){const o=Qe(e).$implicit;return Je(we().onSelect(o))}),Be(1),Q()}if(2&t){const e=n.$implicit,r=we();nl("active",e.title===r.getSelected().title),me(1),Zs(" ",e.title," ")}}let FSe=(()=>{class t{constructor(e){this.appsService=e,this.title="meta-app-models",this.configurations=[],this.selectedConfig=structuredClone(this.appsService.configs[0])}ngOnInit(){this.configurations=this.appsService.configs}onSelect(e){this.selectedConfig=structuredClone(e)}getSelected(){return this.selectedConfig}}return t.\u0275fac=function(e){return new(e||t)(Y(QC))},t.\u0275cmp=ja({type:t,selectors:[["app-root"]],decls:26,vars:2,consts:[[1,"navbar","navbar-dark","bg-dark"],["href","#",1,"navbar-brand"],[1,"bi","bi-boxes"],["type","button","data-bs-toggle","offcanvas","data-bs-target","#offcanvasRight","aria-controls","offcanvasRight","aria-expanded","false","aria-label","Toggle navigation",1,"navbar-toggler","navbar-toggler-right"],[1,"navbar-toggler-icon"],[3,"configuration"],["tabindex","-1","id","offcanvasRight","aria-labelledby","offcanvasRightLabel",1,"offcanvas","offcanvas-end"],[1,"offcanvas-header"],["id","offcanvasRightLabel"],["type","button","data-bs-dismiss","offcanvas","aria-label","Close",1,"btn-close","text-reset"],[1,"offcanvas-body"],[1,"list-group"],["class","list-group-item list-group-item-action",3,"active","click",4,"ngFor","ngForOf"],[1,"d-flex","flex-wrap","justify-content-center","align-items-center","py-3","my-4","border-top"],[1,"nav","justify-content-center"],[1,"nav-item"],["href","#",1,"nav-link","px-2","link-dark"],["href","help",1,"nav-link","px-2","link-dark"],[1,"list-group-item","list-group-item-action",3,"click"]],template:function(e,r){1&e&&(te(0,"nav",0)(1,"a",1),Vt(2,"i",2),Be(3," Incrustado de modelos "),Q(),te(4,"button",3),Vt(5,"span",4),Q()(),Vt(6,"app-config",5),te(7,"div",6)(8,"div",7)(9,"h5",8),Be(10,"Modelos cargados"),Q(),Vt(11,"button",9),Q(),te(12,"div",10)(13,"div",11),Ot(14,RSe,2,3,"a",12),Q()()(),te(15,"footer",13)(16,"ul",14)(17,"li",15)(18,"a",16),Be(19,"Home"),Q()(),te(20,"li",15)(21,"a",17),Be(22,"Help"),Q()(),te(23,"li",15)(24,"a",16),Be(25,"About"),Q()()()()),2&e&&(me(6),_e("configuration",r.selectedConfig),me(8),_e("ngForOf",r.configurations))},dependencies:[Vw,CB],styles:[".navbar[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{margin-right:10px}.navbar-dark[_ngcontent-%COMP%]   .navbar-toggler-icon[_ngcontent-%COMP%]{background-image:url(\"data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 30 30'%3e%3cpath stroke='rgba%28255, 255, 255, 0.95%29' stroke-linecap='round' stroke-miterlimit='10' stroke-width='2' d='M4 7h22M4 15h22M4 23h22'/%3e%3c/svg%3e\")}div#offcanvasRight[_ngcontent-%COMP%]{width:250px}.navbar-brand[_ngcontent-%COMP%]{margin-left:12px}nav[_ngcontent-%COMP%]   i.bi.bi-boxes[_ngcontent-%COMP%]{margin-right:5px}"]}),t})(),MSe=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=qs({type:t,bootstrap:[FSe]}),t.\u0275inj=Is({providers:[QC],imports:[T8,ASe,f9,m9,sY]}),t})();D8().bootstrapModule(MSe).catch(t=>console.error(t))},658:Et=>{Et.exports=de;var It=null;try{It=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function de(X,T,ve){this.low=0|X,this.high=0|T,this.unsigned=!!ve}function Ke(X){return!0===(X&&X.__isLong__)}Object.defineProperty(de.prototype,"__isLong__",{value:!0}),de.isLong=Ke;var qn={},et={};function hn(X,T){var ve,Ue,Dt;return T?(Dt=0<=(X>>>=0)&&X<256)&&(Ue=et[X])?Ue:(ve=Ve(X,(0|X)<0?-1:0,!0),Dt&&(et[X]=ve),ve):(Dt=-128<=(X|=0)&&X<128)&&(Ue=qn[X])?Ue:(ve=Ve(X,X<0?-1:0,!1),Dt&&(qn[X]=ve),ve)}function Fe(X,T){if(isNaN(X))return T?gr:Xt;if(T){if(X<0)return gr;if(X>=oe)return Mt}else{if(X<=-Te)return Ut;if(X+1>=Te)return gt}return X<0?Fe(-X,T).neg():Ve(X%Z|0,X/Z|0,T)}function Ve(X,T,ve){return new de(X,T,ve)}de.fromInt=hn,de.fromNumber=Fe,de.fromBits=Ve;var ct=Math.pow;function Ie(X,T,ve){if(0===X.length)throw Error("empty string");if("NaN"===X||"Infinity"===X||"+Infinity"===X||"-Infinity"===X)return Xt;if("number"==typeof T?(ve=T,T=!1):T=!!T,(ve=ve||10)<2||36<ve)throw RangeError("radix");var Ue;if((Ue=X.indexOf("-"))>0)throw Error("interior hyphen");if(0===Ue)return Ie(X.substring(1),T,ve).neg();for(var Dt=Fe(ct(ve,8)),Ct=Xt,Lt=0;Lt<X.length;Lt+=8){var Vn=Math.min(8,X.length-Lt),Nn=parseInt(X.substring(Lt,Lt+Vn),ve);if(Vn<8){var vn=Fe(ct(ve,Vn));Ct=Ct.mul(vn).add(Fe(Nn))}else Ct=(Ct=Ct.mul(Dt)).add(Fe(Nn))}return Ct.unsigned=T,Ct}function O(X,T){return"number"==typeof X?Fe(X,T):"string"==typeof X?Ie(X,T):Ve(X.low,X.high,"boolean"==typeof T?T:X.unsigned)}de.fromString=Ie,de.fromValue=O;var Z=4294967296,oe=Z*Z,Te=oe/2,Me=hn(1<<24),Xt=hn(0);de.ZERO=Xt;var gr=hn(0,!0);de.UZERO=gr;var rr=hn(1);de.ONE=rr;var Vo=hn(1,!0);de.UONE=Vo;var _s=hn(-1);de.NEG_ONE=_s;var gt=Ve(-1,2147483647,!1);de.MAX_VALUE=gt;var Mt=Ve(-1,-1,!0);de.MAX_UNSIGNED_VALUE=Mt;var Ut=Ve(0,-2147483648,!1);de.MIN_VALUE=Ut;var re=de.prototype;re.toInt=function(){return this.unsigned?this.low>>>0:this.low},re.toNumber=function(){return this.unsigned?(this.high>>>0)*Z+(this.low>>>0):this.high*Z+(this.low>>>0)},re.toString=function(T){if((T=T||10)<2||36<T)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(Ut)){var ve=Fe(T),Ue=this.div(ve),Dt=Ue.mul(ve).sub(this);return Ue.toString(T)+Dt.toInt().toString(T)}return"-"+this.neg().toString(T)}for(var Ct=Fe(ct(T,6),this.unsigned),Lt=this,Vn="";;){var Nn=Lt.div(Ct),kn=(Lt.sub(Nn.mul(Ct)).toInt()>>>0).toString(T);if((Lt=Nn).isZero())return kn+Vn;for(;kn.length<6;)kn="0"+kn;Vn=""+kn+Vn}},re.getHighBits=function(){return this.high},re.getHighBitsUnsigned=function(){return this.high>>>0},re.getLowBits=function(){return this.low},re.getLowBitsUnsigned=function(){return this.low>>>0},re.getNumBitsAbs=function(){if(this.isNegative())return this.eq(Ut)?64:this.neg().getNumBitsAbs();for(var T=0!=this.high?this.high:this.low,ve=31;ve>0&&!(T&1<<ve);ve--);return 0!=this.high?ve+33:ve+1},re.isZero=function(){return 0===this.high&&0===this.low},re.eqz=re.isZero,re.isNegative=function(){return!this.unsigned&&this.high<0},re.isPositive=function(){return this.unsigned||this.high>=0},re.isOdd=function(){return 1==(1&this.low)},re.isEven=function(){return 0==(1&this.low)},re.equals=function(T){return Ke(T)||(T=O(T)),(this.unsigned===T.unsigned||this.high>>>31!=1||T.high>>>31!=1)&&this.high===T.high&&this.low===T.low},re.eq=re.equals,re.notEquals=function(T){return!this.eq(T)},re.neq=re.notEquals,re.ne=re.notEquals,re.lessThan=function(T){return this.comp(T)<0},re.lt=re.lessThan,re.lessThanOrEqual=function(T){return this.comp(T)<=0},re.lte=re.lessThanOrEqual,re.le=re.lessThanOrEqual,re.greaterThan=function(T){return this.comp(T)>0},re.gt=re.greaterThan,re.greaterThanOrEqual=function(T){return this.comp(T)>=0},re.gte=re.greaterThanOrEqual,re.ge=re.greaterThanOrEqual,re.compare=function(T){if(Ke(T)||(T=O(T)),this.eq(T))return 0;var ve=this.isNegative(),Ue=T.isNegative();return ve&&!Ue?-1:!ve&&Ue?1:this.unsigned?T.high>>>0>this.high>>>0||T.high===this.high&&T.low>>>0>this.low>>>0?-1:1:this.sub(T).isNegative()?-1:1},re.comp=re.compare,re.negate=function(){return!this.unsigned&&this.eq(Ut)?Ut:this.not().add(rr)},re.neg=re.negate,re.add=function(T){Ke(T)||(T=O(T));var kn=0,Zr=0,xt=0,Fr=0;return xt+=(Fr+=(65535&this.low)+(65535&T.low))>>>16,Zr+=(xt+=(this.low>>>16)+(T.low>>>16))>>>16,kn+=(Zr+=(65535&this.high)+(65535&T.high))>>>16,kn+=(this.high>>>16)+(T.high>>>16),Ve((xt&=65535)<<16|(Fr&=65535),(kn&=65535)<<16|(Zr&=65535),this.unsigned)},re.subtract=function(T){return Ke(T)||(T=O(T)),this.add(T.neg())},re.sub=re.subtract,re.multiply=function(T){if(this.isZero())return Xt;if(Ke(T)||(T=O(T)),It)return Ve(It.mul(this.low,this.high,T.low,T.high),It.get_high(),this.unsigned);if(T.isZero())return Xt;if(this.eq(Ut))return T.isOdd()?Ut:Xt;if(T.eq(Ut))return this.isOdd()?Ut:Xt;if(this.isNegative())return T.isNegative()?this.neg().mul(T.neg()):this.neg().mul(T).neg();if(T.isNegative())return this.mul(T.neg()).neg();if(this.lt(Me)&&T.lt(Me))return Fe(this.toNumber()*T.toNumber(),this.unsigned);var Dt=65535&this.high,Ct=this.low>>>16,Lt=65535&this.low,Nn=65535&T.high,vn=T.low>>>16,kn=65535&T.low,Zr=0,xt=0,Fr=0,Yl=0;return Fr+=(Yl+=Lt*kn)>>>16,xt+=(Fr+=Ct*kn)>>>16,Fr&=65535,xt+=(Fr+=Lt*vn)>>>16,Zr+=(xt+=Dt*kn)>>>16,xt&=65535,Zr+=(xt+=Ct*vn)>>>16,xt&=65535,Zr+=(xt+=Lt*Nn)>>>16,Zr+=(this.high>>>16)*kn+Dt*vn+Ct*Nn+Lt*(T.high>>>16),Ve((Fr&=65535)<<16|(Yl&=65535),(Zr&=65535)<<16|(xt&=65535),this.unsigned)},re.mul=re.multiply,re.divide=function(T){if(Ke(T)||(T=O(T)),T.isZero())throw Error("division by zero");var Ue,Dt,Ct;if(It)return this.unsigned||-2147483648!==this.high||-1!==T.low||-1!==T.high?Ve((this.unsigned?It.div_u:It.div_s)(this.low,this.high,T.low,T.high),It.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?gr:Xt;if(this.unsigned){if(T.unsigned||(T=T.toUnsigned()),T.gt(this))return gr;if(T.gt(this.shru(1)))return Vo;Ct=gr}else{if(this.eq(Ut))return T.eq(rr)||T.eq(_s)?Ut:T.eq(Ut)?rr:(Ue=this.shr(1).div(T).shl(1)).eq(Xt)?T.isNegative()?rr:_s:(Dt=this.sub(T.mul(Ue)),Ct=Ue.add(Dt.div(T)));if(T.eq(Ut))return this.unsigned?gr:Xt;if(this.isNegative())return T.isNegative()?this.neg().div(T.neg()):this.neg().div(T).neg();if(T.isNegative())return this.div(T.neg()).neg();Ct=Xt}for(Dt=this;Dt.gte(T);){Ue=Math.max(1,Math.floor(Dt.toNumber()/T.toNumber()));for(var Vn=Math.ceil(Math.log(Ue)/Math.LN2),Nn=Vn<=48?1:ct(2,Vn-48),vn=Fe(Ue),kn=vn.mul(T);kn.isNegative()||kn.gt(Dt);)kn=(vn=Fe(Ue-=Nn,this.unsigned)).mul(T);vn.isZero()&&(vn=rr),Ct=Ct.add(vn),Dt=Dt.sub(kn)}return Ct},re.div=re.divide,re.modulo=function(T){return Ke(T)||(T=O(T)),It?Ve((this.unsigned?It.rem_u:It.rem_s)(this.low,this.high,T.low,T.high),It.get_high(),this.unsigned):this.sub(this.div(T).mul(T))},re.mod=re.modulo,re.rem=re.modulo,re.not=function(){return Ve(~this.low,~this.high,this.unsigned)},re.and=function(T){return Ke(T)||(T=O(T)),Ve(this.low&T.low,this.high&T.high,this.unsigned)},re.or=function(T){return Ke(T)||(T=O(T)),Ve(this.low|T.low,this.high|T.high,this.unsigned)},re.xor=function(T){return Ke(T)||(T=O(T)),Ve(this.low^T.low,this.high^T.high,this.unsigned)},re.shiftLeft=function(T){return Ke(T)&&(T=T.toInt()),0==(T&=63)?this:T<32?Ve(this.low<<T,this.high<<T|this.low>>>32-T,this.unsigned):Ve(0,this.low<<T-32,this.unsigned)},re.shl=re.shiftLeft,re.shiftRight=function(T){return Ke(T)&&(T=T.toInt()),0==(T&=63)?this:T<32?Ve(this.low>>>T|this.high<<32-T,this.high>>T,this.unsigned):Ve(this.high>>T-32,this.high>=0?0:-1,this.unsigned)},re.shr=re.shiftRight,re.shiftRightUnsigned=function(T){if(Ke(T)&&(T=T.toInt()),0==(T&=63))return this;var ve=this.high;return T<32?Ve(this.low>>>T|ve<<32-T,ve>>>T,this.unsigned):Ve(32===T?ve:ve>>>T-32,0,this.unsigned)},re.shru=re.shiftRightUnsigned,re.shr_u=re.shiftRightUnsigned,re.toSigned=function(){return this.unsigned?Ve(this.low,this.high,!1):this},re.toUnsigned=function(){return this.unsigned?this:Ve(this.low,this.high,!0)},re.toBytes=function(T){return T?this.toBytesLE():this.toBytesBE()},re.toBytesLE=function(){var T=this.high,ve=this.low;return[255&ve,ve>>>8&255,ve>>>16&255,ve>>>24,255&T,T>>>8&255,T>>>16&255,T>>>24]},re.toBytesBE=function(){var T=this.high,ve=this.low;return[T>>>24,T>>>16&255,T>>>8&255,255&T,ve>>>24,ve>>>16&255,ve>>>8&255,255&ve]},de.fromBytes=function(T,ve,Ue){return Ue?de.fromBytesLE(T,ve):de.fromBytesBE(T,ve)},de.fromBytesLE=function(T,ve){return new de(T[0]|T[1]<<8|T[2]<<16|T[3]<<24,T[4]|T[5]<<8|T[6]<<16|T[7]<<24,ve)},de.fromBytesBE=function(T,ve){return new de(T[4]<<24|T[5]<<16|T[6]<<8|T[7],T[0]<<24|T[1]<<16|T[2]<<8|T[3],ve)}},340:(Et,It,de)=>{var Ke=de(471),qn=de(992),et=de(657),hn=de(583),Fe=de(929),Ve=de(83),ct=de(818);ct.alea=Ke,ct.xor128=qn,ct.xorwow=et,ct.xorshift7=hn,ct.xor4096=Fe,ct.tychei=Ve,Et.exports=ct},471:function(Et,It,de){var Ke;!function(qn,et,hn){function Fe(O){var ue=this,ye=function Ie(){var O=4022871197;return function(ye){ye=String(ye);for(var Z=0;Z<ye.length;Z++){var oe=.02519603282416938*(O+=ye.charCodeAt(Z));oe-=O=oe>>>0,O=(oe*=O)>>>0,O+=4294967296*(oe-=O)}return 2.3283064365386963e-10*(O>>>0)}}();ue.next=function(){var Z=2091639*ue.s0+2.3283064365386963e-10*ue.c;return ue.s0=ue.s1,ue.s1=ue.s2,ue.s2=Z-(ue.c=0|Z)},ue.c=1,ue.s0=ye(" "),ue.s1=ye(" "),ue.s2=ye(" "),ue.s0-=ye(O),ue.s0<0&&(ue.s0+=1),ue.s1-=ye(O),ue.s1<0&&(ue.s1+=1),ue.s2-=ye(O),ue.s2<0&&(ue.s2+=1),ye=null}function Ve(O,ue){return ue.c=O.c,ue.s0=O.s0,ue.s1=O.s1,ue.s2=O.s2,ue}function ct(O,ue){var ye=new Fe(O),Z=ue&&ue.state,oe=ye.next;return oe.int32=function(){return 4294967296*ye.next()|0},oe.double=function(){return oe()+11102230246251565e-32*(2097152*oe()|0)},oe.quick=oe,Z&&("object"==typeof Z&&Ve(Z,ye),oe.state=function(){return Ve(ye,{})}),oe}et&&et.exports?et.exports=ct:de.amdD&&de.amdO?void 0!==(Ke=function(){return ct}.call(It,de,It,et))&&(et.exports=Ke):this.alea=ct}(0,Et=de.nmd(Et))},83:function(Et,It,de){var Ke;!function(qn,et,hn){function Fe(Ie){var O=this,ue="";O.next=function(){var Z=O.b,oe=O.c,Te=O.d,Me=O.a;return Z=Z<<25^Z>>>7^oe,oe=oe-Te|0,Te=Te<<24^Te>>>8^Me,Me=Me-Z|0,O.b=Z=Z<<20^Z>>>12^oe,O.c=oe=oe-Te|0,O.d=Te<<16^oe>>>16^Me,O.a=Me-Z|0},O.a=0,O.b=0,O.c=-1640531527,O.d=1367130551,Ie===Math.floor(Ie)?(O.a=Ie/4294967296|0,O.b=0|Ie):ue+=Ie;for(var ye=0;ye<ue.length+20;ye++)O.b^=0|ue.charCodeAt(ye),O.next()}function Ve(Ie,O){return O.a=Ie.a,O.b=Ie.b,O.c=Ie.c,O.d=Ie.d,O}function ct(Ie,O){var ue=new Fe(Ie),ye=O&&O.state,Z=function(){return(ue.next()>>>0)/4294967296};return Z.double=function(){do{var Me=((ue.next()>>>11)+(ue.next()>>>0)/4294967296)/(1<<21)}while(0===Me);return Me},Z.int32=ue.next,Z.quick=Z,ye&&("object"==typeof ye&&Ve(ye,ue),Z.state=function(){return Ve(ue,{})}),Z}et&&et.exports?et.exports=ct:de.amdD&&de.amdO?void 0!==(Ke=function(){return ct}.call(It,de,It,et))&&(et.exports=Ke):this.tychei=ct}(0,Et=de.nmd(Et))},992:function(Et,It,de){var Ke;!function(qn,et,hn){function Fe(Ie){var O=this,ue="";O.x=0,O.y=0,O.z=0,O.w=0,O.next=function(){var Z=O.x^O.x<<11;return O.x=O.y,O.y=O.z,O.z=O.w,O.w^=O.w>>>19^Z^Z>>>8},Ie===(0|Ie)?O.x=Ie:ue+=Ie;for(var ye=0;ye<ue.length+64;ye++)O.x^=0|ue.charCodeAt(ye),O.next()}function Ve(Ie,O){return O.x=Ie.x,O.y=Ie.y,O.z=Ie.z,O.w=Ie.w,O}function ct(Ie,O){var ue=new Fe(Ie),ye=O&&O.state,Z=function(){return(ue.next()>>>0)/4294967296};return Z.double=function(){do{var Me=((ue.next()>>>11)+(ue.next()>>>0)/4294967296)/(1<<21)}while(0===Me);return Me},Z.int32=ue.next,Z.quick=Z,ye&&("object"==typeof ye&&Ve(ye,ue),Z.state=function(){return Ve(ue,{})}),Z}et&&et.exports?et.exports=ct:de.amdD&&de.amdO?void 0!==(Ke=function(){return ct}.call(It,de,It,et))&&(et.exports=Ke):this.xor128=ct}(0,Et=de.nmd(Et))},929:function(Et,It,de){var Ke;!function(qn,et,hn){function Fe(Ie){var O=this;O.next=function(){var Te,Me,ye=O.w,Z=O.X,oe=O.i;return O.w=ye=ye+1640531527|0,Me=Z[oe+34&127],Te=Z[oe=oe+1&127],Me^=Me<<13,Te^=Te<<17,Me=Z[oe]=(Me^=Me>>>15)^(Te^=Te>>>12),O.i=oe,Me+(ye^ye>>>16)|0},function ue(ye,Z){var oe,Te,Me,Xt,gr,rr=[],Vo=128;for(Z===(0|Z)?(Te=Z,Z=null):(Z+="\0",Te=0,Vo=Math.max(Vo,Z.length)),Me=0,Xt=-32;Xt<Vo;++Xt)Z&&(Te^=Z.charCodeAt((Xt+32)%Z.length)),0===Xt&&(gr=Te),Te^=Te<<10,Te^=Te>>>15,Te^=Te<<4,Te^=Te>>>13,Xt>=0&&(Me=0==(oe=rr[127&Xt]^=Te+(gr=gr+1640531527|0))?Me+1:0);for(Me>=128&&(rr[127&(Z&&Z.length||0)]=-1),Me=127,Xt=512;Xt>0;--Xt)Te=rr[Me+34&127],oe=rr[Me=Me+1&127],Te^=Te<<13,oe^=oe<<17,rr[Me]=(Te^=Te>>>15)^(oe^=oe>>>12);ye.w=gr,ye.X=rr,ye.i=Me}(O,Ie)}function Ve(Ie,O){return O.i=Ie.i,O.w=Ie.w,O.X=Ie.X.slice(),O}function ct(Ie,O){null==Ie&&(Ie=+new Date);var ue=new Fe(Ie),ye=O&&O.state,Z=function(){return(ue.next()>>>0)/4294967296};return Z.double=function(){do{var Me=((ue.next()>>>11)+(ue.next()>>>0)/4294967296)/(1<<21)}while(0===Me);return Me},Z.int32=ue.next,Z.quick=Z,ye&&(ye.X&&Ve(ye,ue),Z.state=function(){return Ve(ue,{})}),Z}et&&et.exports?et.exports=ct:de.amdD&&de.amdO?void 0!==(Ke=function(){return ct}.call(It,de,It,et))&&(et.exports=Ke):this.xor4096=ct}(0,Et=de.nmd(Et))},583:function(Et,It,de){var Ke;!function(qn,et,hn){function Fe(Ie){var O=this;O.next=function(){var oe,Te,ye=O.x,Z=O.i;return oe=ye[Z],Te=(oe^=oe>>>7)^oe<<24,Te^=(oe=ye[Z+1&7])^oe>>>10,Te^=(oe=ye[Z+3&7])^oe>>>3,Te^=(oe=ye[Z+4&7])^oe<<7,oe=ye[Z+7&7],ye[Z]=Te^=(oe^=oe<<13)^oe<<9,O.i=Z+1&7,Te},function ue(ye,Z){var oe,Me=[];if(Z===(0|Z))Me[0]=Z;else for(Z=""+Z,oe=0;oe<Z.length;++oe)Me[7&oe]=Me[7&oe]<<15^Z.charCodeAt(oe)+Me[oe+1&7]<<13;for(;Me.length<8;)Me.push(0);for(oe=0;oe<8&&0===Me[oe];++oe);for(8==oe&&(Me[7]=-1),ye.x=Me,ye.i=0,oe=256;oe>0;--oe)ye.next()}(O,Ie)}function Ve(Ie,O){return O.x=Ie.x.slice(),O.i=Ie.i,O}function ct(Ie,O){null==Ie&&(Ie=+new Date);var ue=new Fe(Ie),ye=O&&O.state,Z=function(){return(ue.next()>>>0)/4294967296};return Z.double=function(){do{var Me=((ue.next()>>>11)+(ue.next()>>>0)/4294967296)/(1<<21)}while(0===Me);return Me},Z.int32=ue.next,Z.quick=Z,ye&&(ye.x&&Ve(ye,ue),Z.state=function(){return Ve(ue,{})}),Z}et&&et.exports?et.exports=ct:de.amdD&&de.amdO?void 0!==(Ke=function(){return ct}.call(It,de,It,et))&&(et.exports=Ke):this.xorshift7=ct}(0,Et=de.nmd(Et))},657:function(Et,It,de){var Ke;!function(qn,et,hn){function Fe(Ie){var O=this,ue="";O.next=function(){var Z=O.x^O.x>>>2;return O.x=O.y,O.y=O.z,O.z=O.w,O.w=O.v,(O.d=O.d+362437|0)+(O.v=O.v^O.v<<4^Z^Z<<1)|0},O.x=0,O.y=0,O.z=0,O.w=0,O.v=0,Ie===(0|Ie)?O.x=Ie:ue+=Ie;for(var ye=0;ye<ue.length+64;ye++)O.x^=0|ue.charCodeAt(ye),ye==ue.length&&(O.d=O.x<<10^O.x>>>4),O.next()}function Ve(Ie,O){return O.x=Ie.x,O.y=Ie.y,O.z=Ie.z,O.w=Ie.w,O.v=Ie.v,O.d=Ie.d,O}function ct(Ie,O){var ue=new Fe(Ie),ye=O&&O.state,Z=function(){return(ue.next()>>>0)/4294967296};return Z.double=function(){do{var Me=((ue.next()>>>11)+(ue.next()>>>0)/4294967296)/(1<<21)}while(0===Me);return Me},Z.int32=ue.next,Z.quick=Z,ye&&("object"==typeof ye&&Ve(ye,ue),Z.state=function(){return Ve(ue,{})}),Z}et&&et.exports?et.exports=ct:de.amdD&&de.amdO?void 0!==(Ke=function(){return ct}.call(It,de,It,et))&&(et.exports=Ke):this.xorwow=ct}(0,Et=de.nmd(Et))},818:function(Et,It,de){var Ke;!function(qn,et,hn){var oe,Fe=256,Ve=6,Ie="random",O=hn.pow(Fe,Ve),ue=hn.pow(2,52),ye=2*ue,Z=Fe-1;function Te(gt,Mt,Ut){var re=[],X=rr(gr((Mt=1==Mt?{entropy:!0}:Mt||{}).entropy?[gt,_s(et)]:gt??function Vo(){try{var gt;return oe&&(gt=oe.randomBytes)?gt=gt(Fe):(gt=new Uint8Array(Fe),(qn.crypto||qn.msCrypto).getRandomValues(gt)),_s(gt)}catch{var Mt=qn.navigator,Ut=Mt&&Mt.plugins;return[+new Date,qn,Ut,qn.screen,_s(et)]}}(),3),re),T=new Me(re),ve=function(){for(var Ue=T.g(Ve),Dt=O,Ct=0;Ue<ue;)Ue=(Ue+Ct)*Fe,Dt*=Fe,Ct=T.g(1);for(;Ue>=ye;)Ue/=2,Dt/=2,Ct>>>=1;return(Ue+Ct)/Dt};return ve.int32=function(){return 0|T.g(4)},ve.quick=function(){return T.g(4)/4294967296},ve.double=ve,rr(_s(T.S),et),(Mt.pass||Ut||function(Ue,Dt,Ct,Lt){return Lt&&(Lt.S&&Xt(Lt,T),Ue.state=function(){return Xt(T,{})}),Ct?(hn[Ie]=Ue,Dt):Ue})(ve,X,"global"in Mt?Mt.global:this==hn,Mt.state)}function Me(gt){var Mt,Ut=gt.length,re=this,X=0,T=re.i=re.j=0,ve=re.S=[];for(Ut||(gt=[Ut++]);X<Fe;)ve[X]=X++;for(X=0;X<Fe;X++)ve[X]=ve[T=Z&T+gt[X%Ut]+(Mt=ve[X])],ve[T]=Mt;(re.g=function(Ue){for(var Dt,Ct=0,Lt=re.i,Vn=re.j,Nn=re.S;Ue--;)Dt=Nn[Lt=Z&Lt+1],Ct=Ct*Fe+Nn[Z&(Nn[Lt]=Nn[Vn=Z&Vn+Dt])+(Nn[Vn]=Dt)];return re.i=Lt,re.j=Vn,Ct})(Fe)}function Xt(gt,Mt){return Mt.i=gt.i,Mt.j=gt.j,Mt.S=gt.S.slice(),Mt}function gr(gt,Mt){var X,Ut=[],re=typeof gt;if(Mt&&"object"==re)for(X in gt)try{Ut.push(gr(gt[X],Mt-1))}catch{}return Ut.length?Ut:"string"==re?gt:gt+"\0"}function rr(gt,Mt){for(var re,Ut=gt+"",X=0;X<Ut.length;)Mt[Z&X]=Z&(re^=19*Mt[Z&X])+Ut.charCodeAt(X++);return _s(Mt)}function _s(gt){return String.fromCharCode.apply(0,gt)}if(rr(hn.random(),et),Et.exports){Et.exports=Te;try{oe=de(42)}catch{}}else void 0!==(Ke=function(){return Te}.call(It,de,It,Et))&&(Et.exports=Ke)}(typeof self<"u"?self:this,[],Math)},410:()=>{},628:()=>{},601:()=>{},792:()=>{},977:()=>{},42:()=>{}},Et=>{Et(Et.s=240)}]);